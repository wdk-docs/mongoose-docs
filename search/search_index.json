{
    "docs": [
        {
            "location": "/", 
            "text": "mongoose\n\n\n\u4e3anode.js\u4f18\u96c5\u7684mongodb\u5bf9\u8c61\u5efa\u6a21\n\n\n\u9605\u8bfb\u6587\u6863\n\n\n\u53d1\u73b0\u63d2\u4ef6\n\n\nVersion 5.0.1\n\n\n\u9762\u5bf9\u73b0\u5b9e\u5427,\n\u7f16\u5199MongoDB\u9a8c\u8bc1\uff0c\u94f8\u9020\u548c\u4e1a\u52a1\u903b\u8f91\u6837\u677f\u662f\u4e00\u4e2a\u62d6\u7d2f\n. \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u5199\u4e86mongoose.\n\n\nconst\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/test\n);\n\n\n\nconst\n \nCat\n \n=\n \nmongoose\n.\nmodel\n(\nCat\n,\n \n{\n \nname\n:\n \nString\n \n});\n\n\n\nconst\n \nkitty\n \n=\n \nnew\n \nCat\n({\n \nname\n:\n \nZildjian\n \n});\n\n\nkitty\n.\nsave\n().\nthen\n(()\n \n=\n \nconsole\n.\nlog\n(\nmeow\n));\n\n\n\n\n\nMongoose\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\uff0c\u57fa\u4e8e\u6a21\u5f0f\u7684\u89e3\u51b3\u65b9\u6848\u6765\u5efa\u6a21\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6570\u636e\u3002\u5b83\u5305\u62ec\u5185\u7f6e\u7684\u7c7b\u578b\u8f6c\u6362\uff0c\u9a8c\u8bc1\uff0c\u67e5\u8be2\u6784\u5efa\uff0c\u4e1a\u52a1\u903b\u8f91\u94a9\u5b50\u7b49\u7b49\u3002\n\n\n\u5165\u95e8\n\n\n\u5feb\u901f\u5165\u95e8\u6307\u5357\n\n\n\u652f\u6301\n\n\n\n\n\u5806\u6808\u6ea2\u51fa\n\n\nGitHub\u95ee\u9898\n\n\n\u683c\u5b50\u804a\u5929\n\n\nMongoDB\u652f\u6301\n\n\n\n\n\u65b0\u95fb\n\n\n\u63a8\u7279\n\n\n\u66f4\u65b0\u65e5\u5fd7\n\n\n\u66f4\u65b0\u65e5\u5fd7\n\n\n\u8d5e\u52a9\u5546\n\n\n\n\n\u5728OpenCollective\u4e0a\u8d5e\u52a9Mongoose\u4ee5\u83b7\u5f97\u60a8\u516c\u53f8\u7684\u6807\u8bc6\uff01", 
            "title": "\u524d\u8a00"
        }, 
        {
            "location": "/#mongoose", 
            "text": "\u4e3anode.js\u4f18\u96c5\u7684mongodb\u5bf9\u8c61\u5efa\u6a21  \u9605\u8bfb\u6587\u6863  \u53d1\u73b0\u63d2\u4ef6  Version 5.0.1  \u9762\u5bf9\u73b0\u5b9e\u5427, \u7f16\u5199MongoDB\u9a8c\u8bc1\uff0c\u94f8\u9020\u548c\u4e1a\u52a1\u903b\u8f91\u6837\u677f\u662f\u4e00\u4e2a\u62d6\u7d2f . \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u5199\u4e86mongoose.  const   mongoose   =   require ( mongoose );  mongoose . connect ( mongodb://localhost/test );  const   Cat   =   mongoose . model ( Cat ,   {   name :   String   });  const   kitty   =   new   Cat ({   name :   Zildjian   });  kitty . save (). then (()   =   console . log ( meow ));   Mongoose\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\uff0c\u57fa\u4e8e\u6a21\u5f0f\u7684\u89e3\u51b3\u65b9\u6848\u6765\u5efa\u6a21\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6570\u636e\u3002\u5b83\u5305\u62ec\u5185\u7f6e\u7684\u7c7b\u578b\u8f6c\u6362\uff0c\u9a8c\u8bc1\uff0c\u67e5\u8be2\u6784\u5efa\uff0c\u4e1a\u52a1\u903b\u8f91\u94a9\u5b50\u7b49\u7b49\u3002", 
            "title": "mongoose"
        }, 
        {
            "location": "/#_1", 
            "text": "\u5feb\u901f\u5165\u95e8\u6307\u5357", 
            "title": "\u5165\u95e8"
        }, 
        {
            "location": "/#_2", 
            "text": "\u5806\u6808\u6ea2\u51fa  GitHub\u95ee\u9898  \u683c\u5b50\u804a\u5929  MongoDB\u652f\u6301", 
            "title": "\u652f\u6301"
        }, 
        {
            "location": "/#_3", 
            "text": "\u63a8\u7279", 
            "title": "\u65b0\u95fb"
        }, 
        {
            "location": "/#_4", 
            "text": "\u66f4\u65b0\u65e5\u5fd7", 
            "title": "\u66f4\u65b0\u65e5\u5fd7"
        }, 
        {
            "location": "/#_5", 
            "text": "\u5728OpenCollective\u4e0a\u8d5e\u52a9Mongoose\u4ee5\u83b7\u5f97\u60a8\u516c\u53f8\u7684\u6807\u8bc6\uff01", 
            "title": "\u8d5e\u52a9\u5546"
        }, 
        {
            "location": "/QuickStart/", 
            "text": "\u5165\u95e8\n\n\n\u5165\u95e8\u4f7f\u7528\n\n\n\u6e90\n\n\n\u9996\u5148\u5b89\u88c5\nMongoDB\n\u548c\nNode.js\n\u3002\n\n\n\u63a5\u4e0b\u6765\u4f7f\u7528\nnpm\n\u5b89\u88c5Mongoose\uff1a\n\n\n    $ npm install mongoose\n\n\n\n\n\u505a\u4e2a\u5c0f\u732b\u6a21\u578b\uff0c\u5148\u8fde\u63a5\u672c\u5730\u6570\u636e\u5e93\ntest\n.\n\n\nvar\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/test\n);\n\n\n\n\n\n\u6dfb\u52a0\u9519\u8bef\u901a\u77e5\uff0c\u4ee5\u53ca\u8fde\u63a5\u6210\u529f\u65b9\u6cd5:\n\n\n    \nvar\n \ndb\n \n=\n \nmongoose\n.\nconnection\n;\n\n    \ndb\n.\non\n(\nerror\n,\n \nconsole\n.\nerror\n.\nbind\n(\nconsole\n,\n \nconnection error:\n));\n\n    \ndb\n.\nonce\n(\nopen\n,\n \nfunction\n()\n \n{\n\n\n    \n});\n\n\n\n\n\n\u4e00\u65e6\u6211\u4eec\u7684\u8fde\u63a5\u6253\u5f00\uff0c\u6211\u4eec\u7684\u56de\u8c03\u5c06\u88ab\u8c03\u7528\uff0c\u4e3a\u7b80\u6d01\u8d77\u89c1\uff0c\u6211\u4eec\u5047\u8bbe\u4ee5\u4e0b\u6240\u6709\u4ee3\u7801\u90fd\u4f4d\u4e8e\u6b64\u56de\u8c03\u4e2d\u3002\n\n\n\u5b9a\u4e49\u5c0f\u732b\n\u6a21\u5f0f\n.\n\n\n    \nvar\n \nkittySchema\n \n=\n \nmongoose\n.\nSchema\n({\n\n        \nname\n:\n \nString\n\n    \n});\n\n\n\n\n\n\u6211\u4eec\u6709\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027 \nname\n, \u7c7b\u578b \nString\n. \u4e0b\u4e00\u6b65\u662f\u5c06\u6211\u4eec\u7684\u6a21\u5f0f\u7f16\u8bd1\u6210\u4e00\u4e2a\n\u6a21\u578b\n.\n\n\n    \nvar\n \nKitten\n \n=\n \nmongoose\n.\nmodel\n(\nKitten\n,\n \nkittySchema\n);\n\n\n\n\n\n\u6a21\u578b\u662f\u6211\u4eec\u6784\u9020\u6587\u6863\u7684\u7c7b\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c \u6bcf\u4e2a\u6587\u6863\u5c06\u6210\u4e3a\u4e00\u4e2a\u5c0f\u732b\uff0c\u5176\u7279\u6027\u548c\u884c\u4e3a\u5728\u6211\u4eec\u7684\u6a21\u5f0f\u4e2d\u58f0\u660e\u3002 \u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u5c0f\u732b\u6587\u6863\uff0c\u4ee3\u8868\u6211\u4eec\u521a\u521a\u5728\u5916\u9762\u7684\u4eba\u884c\u9053\u4e0a\u9047\u5230\u7684\u5c0f\u5bb6\u4f19\uff1a\n\n\n    \nvar\n \nsilence\n \n=\n \nnew\n \nKitten\n({\n \nname\n:\n \nSilence\n \n});\n\n    \nconsole\n.\nlog\n(\nsilence\n.\nname\n);\n\n\n\n\n\n\u5c0f\u732b\u53ef\u4ee5\u55b5\u55b5\u53eb\uff0c\u90a3\u4e48\u8ba9\u6211\u4eec\u6765\u770b\u770b\u5982\u4f55\u5728\u6211\u4eec\u7684\u6587\u6863\u4e2d\u6dfb\u52a0\u201cspeak\u201d\u529f\u80fd\uff1a\n\n\n    \nkittySchema\n.\nmethods\n.\nspeak\n \n=\n \nfunction\n \n()\n \n{\n\n      \nvar\n \ngreeting\n \n=\n \nthis\n.\nname\n\n        \n?\n \nMeow name is \n \n+\n \nthis\n.\nname\n\n        \n:\n \nI don\nt have a name\n;\n\n      \nconsole\n.\nlog\n(\ngreeting\n);\n\n    \n}\n\n    \nvar\n \nKitten\n \n=\n \nmongoose\n.\nmodel\n(\nKitten\n,\n \nkittySchema\n);\n\n\n\n\n\n\u6dfb\u52a0\u5230\u6a21\u5f0f\u7684\u201c\u65b9\u6cd5\u201d\u5c5e\u6027\u7684\u51fd\u6570\u88ab\u7f16\u8bd1\u5230\u201c\u6a21\u578b\u201d\u539f\u578b\u4e2d\uff0c\u5e76\u663e\u793a\u5728\u6bcf\u4e2a\u6587\u6863\u5b9e\u4f8b\u4e0a\uff1a\n\n\n    \nvar\n \nfluffy\n \n=\n \nnew\n \nKitten\n({\n \nname\n:\n \nfluffy\n \n});\n\n    \nfluffy\n.\nspeak\n();\n\n\n\n\n\n\u6211\u4eec\u6709\u8bf4\u8bdd\u7684\u5c0f\u732b\uff01\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4fdd\u5b58\u4efb\u4f55\u4e1c\u897f\u7ed9MongoDB\u3002 \u6bcf\u4e2a\u6587\u6863\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528\nsave\n\u65b9\u6cd5\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\u3002 \u56de\u8c03\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c06\u662f\u4e00\u4e2a\u9519\u8bef\uff0c\u5982\u679c\u6709\u9519\u8bef\u5c06\u663e\u793a\u51fa\u6765\u3002\n\n\n    \nfluffy\n.\nsave\n(\nfunction\n \n(\nerr\n,\n \nfluffy\n)\n \n{\n\n    \nif\n \n(\nerr\n)\n \nreturn\n \nconsole\n.\nerror\n(\nerr\n);\n\n    \nfluffy\n.\nspeak\n();\n\n    \n});\n\n\n\n\n\n\u8bf4\u65f6\u95f4\u8fc7\u53bb\u4e86\uff0c\u6211\u4eec\u60f3\u8981\u663e\u793a\u6211\u4eec\u770b\u5230\u7684\u6240\u6709\u5c0f\u732b\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6211\u4eec\u7684\u5c0f\u732b\n\u6a21\u578b\n\u8bbf\u95ee\u6240\u6709\u7684\u5c0f\u732b\u6587\u6863\u3002\n\n\n    \nKitten\n.\nfind\n(\nfunction\n \n(\nerr\n,\n \nkittens\n)\n \n{\n\n      \nif\n \n(\nerr\n)\n \nreturn\n \nconsole\n.\nerror\n(\nerr\n);\n\n      \nconsole\n.\nlog\n(\nkittens\n);\n\n    \n})\n\n\n\n\n\n\u6211\u4eec\u53ea\u628a\u6211\u4eec\u7684\u6570\u636e\u5e93\u4e2d\u7684\u6240\u6709\u5c0f\u732b\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002 \u5982\u679c\u6211\u4eec\u60f3\u6309\u540d\u5b57\u8fc7\u6ee4\u6211\u4eec\u7684\u5c0f\u732b\uff0cMongoose\u652f\u6301MongoDB\u4e30\u5bcc\u7684\n\u67e5\u8be2\n\u8bed\u6cd5\u3002\n\n\n    \nKitten\n.\nfind\n({\n \nname\n:\n \n/^fluff/\n \n},\n \ncallback\n);\n\n\n\n\n\n\u8fd9\u5c06\u641c\u7d22\u540d\u79f0\u5c5e\u6027\u4ee5\u201cFluff\u201d\u5f00\u5934\u7684\u6240\u6709\u6587\u6863\uff0c\u5e76\u5c06\u7ed3\u679c\u4f5c\u4e3a\u5c0f\u732b\u6570\u7ec4\u8fd4\u56de\u7ed9\u56de\u8c03\u3002\n\n\n\u795d\u8d3a\n\n\n\u8fd9\u662f\u6211\u4eec\u5feb\u901f\u542f\u52a8\u7684\u7ed3\u675f\u3002,\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u5f0f\uff0c\u6dfb\u52a0\u4e86\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u6587\u6863\u65b9\u6cd5\uff0c\u4f7f\u7528Mongoose\u5728MongoDB\u4e2d\u4fdd\u5b58\u5e76\u67e5\u8be2\u4e86\u5c0f\u732b\u3002,\u8bf7\u8f6c\u5230\nguide\n\u6216\nAPI\u6587\u6863\n\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002", 
            "title": "\u5feb\u901f\u5f00\u59cb"
        }, 
        {
            "location": "/QuickStart/#_1", 
            "text": "", 
            "title": "\u5165\u95e8"
        }, 
        {
            "location": "/QuickStart/#_2", 
            "text": "\u6e90  \u9996\u5148\u5b89\u88c5 MongoDB \u548c Node.js \u3002  \u63a5\u4e0b\u6765\u4f7f\u7528 npm \u5b89\u88c5Mongoose\uff1a      $ npm install mongoose  \u505a\u4e2a\u5c0f\u732b\u6a21\u578b\uff0c\u5148\u8fde\u63a5\u672c\u5730\u6570\u636e\u5e93 test .  var   mongoose   =   require ( mongoose );  mongoose . connect ( mongodb://localhost/test );   \u6dfb\u52a0\u9519\u8bef\u901a\u77e5\uff0c\u4ee5\u53ca\u8fde\u63a5\u6210\u529f\u65b9\u6cd5:       var   db   =   mongoose . connection ; \n     db . on ( error ,   console . error . bind ( console ,   connection error: )); \n     db . once ( open ,   function ()   { \n\n     });   \u4e00\u65e6\u6211\u4eec\u7684\u8fde\u63a5\u6253\u5f00\uff0c\u6211\u4eec\u7684\u56de\u8c03\u5c06\u88ab\u8c03\u7528\uff0c\u4e3a\u7b80\u6d01\u8d77\u89c1\uff0c\u6211\u4eec\u5047\u8bbe\u4ee5\u4e0b\u6240\u6709\u4ee3\u7801\u90fd\u4f4d\u4e8e\u6b64\u56de\u8c03\u4e2d\u3002  \u5b9a\u4e49\u5c0f\u732b \u6a21\u5f0f .       var   kittySchema   =   mongoose . Schema ({ \n         name :   String \n     });   \u6211\u4eec\u6709\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027  name , \u7c7b\u578b  String . \u4e0b\u4e00\u6b65\u662f\u5c06\u6211\u4eec\u7684\u6a21\u5f0f\u7f16\u8bd1\u6210\u4e00\u4e2a \u6a21\u578b .       var   Kitten   =   mongoose . model ( Kitten ,   kittySchema );   \u6a21\u578b\u662f\u6211\u4eec\u6784\u9020\u6587\u6863\u7684\u7c7b\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c \u6bcf\u4e2a\u6587\u6863\u5c06\u6210\u4e3a\u4e00\u4e2a\u5c0f\u732b\uff0c\u5176\u7279\u6027\u548c\u884c\u4e3a\u5728\u6211\u4eec\u7684\u6a21\u5f0f\u4e2d\u58f0\u660e\u3002 \u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u5c0f\u732b\u6587\u6863\uff0c\u4ee3\u8868\u6211\u4eec\u521a\u521a\u5728\u5916\u9762\u7684\u4eba\u884c\u9053\u4e0a\u9047\u5230\u7684\u5c0f\u5bb6\u4f19\uff1a       var   silence   =   new   Kitten ({   name :   Silence   }); \n     console . log ( silence . name );   \u5c0f\u732b\u53ef\u4ee5\u55b5\u55b5\u53eb\uff0c\u90a3\u4e48\u8ba9\u6211\u4eec\u6765\u770b\u770b\u5982\u4f55\u5728\u6211\u4eec\u7684\u6587\u6863\u4e2d\u6dfb\u52a0\u201cspeak\u201d\u529f\u80fd\uff1a       kittySchema . methods . speak   =   function   ()   { \n       var   greeting   =   this . name \n         ?   Meow name is    +   this . name \n         :   I don t have a name ; \n       console . log ( greeting ); \n     } \n     var   Kitten   =   mongoose . model ( Kitten ,   kittySchema );   \u6dfb\u52a0\u5230\u6a21\u5f0f\u7684\u201c\u65b9\u6cd5\u201d\u5c5e\u6027\u7684\u51fd\u6570\u88ab\u7f16\u8bd1\u5230\u201c\u6a21\u578b\u201d\u539f\u578b\u4e2d\uff0c\u5e76\u663e\u793a\u5728\u6bcf\u4e2a\u6587\u6863\u5b9e\u4f8b\u4e0a\uff1a       var   fluffy   =   new   Kitten ({   name :   fluffy   }); \n     fluffy . speak ();   \u6211\u4eec\u6709\u8bf4\u8bdd\u7684\u5c0f\u732b\uff01\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4fdd\u5b58\u4efb\u4f55\u4e1c\u897f\u7ed9MongoDB\u3002 \u6bcf\u4e2a\u6587\u6863\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 save \u65b9\u6cd5\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\u3002 \u56de\u8c03\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c06\u662f\u4e00\u4e2a\u9519\u8bef\uff0c\u5982\u679c\u6709\u9519\u8bef\u5c06\u663e\u793a\u51fa\u6765\u3002       fluffy . save ( function   ( err ,   fluffy )   { \n     if   ( err )   return   console . error ( err ); \n     fluffy . speak (); \n     });   \u8bf4\u65f6\u95f4\u8fc7\u53bb\u4e86\uff0c\u6211\u4eec\u60f3\u8981\u663e\u793a\u6211\u4eec\u770b\u5230\u7684\u6240\u6709\u5c0f\u732b\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6211\u4eec\u7684\u5c0f\u732b \u6a21\u578b \u8bbf\u95ee\u6240\u6709\u7684\u5c0f\u732b\u6587\u6863\u3002       Kitten . find ( function   ( err ,   kittens )   { \n       if   ( err )   return   console . error ( err ); \n       console . log ( kittens ); \n     })   \u6211\u4eec\u53ea\u628a\u6211\u4eec\u7684\u6570\u636e\u5e93\u4e2d\u7684\u6240\u6709\u5c0f\u732b\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002 \u5982\u679c\u6211\u4eec\u60f3\u6309\u540d\u5b57\u8fc7\u6ee4\u6211\u4eec\u7684\u5c0f\u732b\uff0cMongoose\u652f\u6301MongoDB\u4e30\u5bcc\u7684 \u67e5\u8be2 \u8bed\u6cd5\u3002       Kitten . find ({   name :   /^fluff/   },   callback );   \u8fd9\u5c06\u641c\u7d22\u540d\u79f0\u5c5e\u6027\u4ee5\u201cFluff\u201d\u5f00\u5934\u7684\u6240\u6709\u6587\u6863\uff0c\u5e76\u5c06\u7ed3\u679c\u4f5c\u4e3a\u5c0f\u732b\u6570\u7ec4\u8fd4\u56de\u7ed9\u56de\u8c03\u3002", 
            "title": "\u5165\u95e8\u4f7f\u7528"
        }, 
        {
            "location": "/QuickStart/#_3", 
            "text": "\u8fd9\u662f\u6211\u4eec\u5feb\u901f\u542f\u52a8\u7684\u7ed3\u675f\u3002,\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u5f0f\uff0c\u6dfb\u52a0\u4e86\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u6587\u6863\u65b9\u6cd5\uff0c\u4f7f\u7528Mongoose\u5728MongoDB\u4e2d\u4fdd\u5b58\u5e76\u67e5\u8be2\u4e86\u5c0f\u732b\u3002,\u8bf7\u8f6c\u5230 guide \u6216 API\u6587\u6863 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002", 
            "title": "\u795d\u8d3a"
        }, 
        {
            "location": "/connection/guide/", 
            "text": "\u8fde\u63a5\u5230MongoDB\n\n\nSource\n\n\nYou can connect to MongoDB with the \nmongoose.connect()\n method.\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/myapp\n);\n\n\n\n\n\n\nThis is the minimum needed to connect the \nmyapp\n database running locally on the default port (27017). If the local connection fails then try using 127.0.0.1 instead of localhost. Sometimes issues may arise when the local hostname has been changed.\n\n\nYou can also specify several more parameters in the \nuri\n:\n\n\nmongoose\n.\nconnect\n(\nmongodb://username:password@host:port/database?options...\n);\n\n\n\n\n\n\nSee the \nmongodb connection string spec\n for more detail.\n\n\n\u64cd\u4f5c\u7f13\u51b2\n\n\nMongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/myapp\n);\n\n\nvar\n \nMyModel\n \n=\n \nmongoose\n.\nmodel\n(\nTest\n,\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n));\n\n\n\nMyModel\n.\nfindOne\n(\nfunction\n(\nerror\n,\n \nresult\n)\n \n{\n  \n}\n);\n\n\n\n\n\n\nThat's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will \nnot\n throw any errors by default if you use a model without connecting.\n\n\nvar\n \nMyModel\n \n=\n \nmongoose\n.\nmodel\n(\nTest\n,\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n));\n\n\n\nMyModel\n.\nfindOne\n(\nfunction\n(\nerror\n,\n \nresult\n)\n \n{\n  \n}\n);\n\n\n\nsetTimeout\n(\nfunction\n()\n \n{\n\n  \nmongoose.connect(\nmongodb\n:\n//\nlocalhost\n/\nmyapp\n);\n\n\n}\n,\n \n60000\n);\n\n\n\n\n\n\nTo disable buffering, turn off the \nbufferCommands\n option on your schema\n. If you have \nbufferCommands\n on and your connection is hanging, try turning \nbufferCommands\n off to see if you haven't opened a connection properly. You can also disable \nbufferCommands\n globally:\n\n\nmongoose.set(\nbufferCommands\n, false);\n\n\n\n\n\n\u9009\u9879\n\n\nThe \nconnect\n method also accepts an \noptions\n object which will be passed on to the underlying MongoDB driver.\n\n\nmongoose.connect(uri, options);\n\n\n\n\n\nA full list of options can be found on the \nMongoDB Node.js driver docs for \nconnect()\n. Mongoose passes options to the driver without modification, modulo three exceptions that are explained below.\n\n\n\n\nbufferCommands\n - This is a mongoose-specific option (not passed to the MongoDB driver) that disables \nmongoose's buffering mechanism\n\n\nuser\n/\npass\n - The username and password for authentication. These options are mongoose-specific, they are equivalent to the MongoDB driver's \nauth.user\n and \nauth.password\n options.\n\n\nautoIndex\n - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set \nautoIndex\n to false, mongoose will not automatically build indexes for \nany\n model associated with this connection.\n\n\n\n\nBelow are some of the options that are important for tuning mongoose.\n\n\n\n\nautoReconnect\n - The underlying MongoDB driver will automatically try to reconnect when it loses connection to MongoDB. Unless you are an extremely advanced user that wants to manage their own connection pool, do \nnot\n set this option to \nfalse\n.\n\n\nreconnectTries\n - If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every \nreconnectInterval\n milliseconds for \nreconnectTries\n times, and give up afterward. When the driver gives up, the mongoose connection emits a \nreconnectFailed\n event. This option does nothing for replica set connections.\n\n\nreconnectInterval\n - See \nreconnectTries\n\n\npromiseLibrary\n - sets the \nunderlying driver's promise library\n\n\npoolSize\n - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, \npoolSize\n is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding.\n\n\nbufferMaxEntries\n - The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set \nbufferCommands\n to \nfalse\n on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection.\n\n\n\n\nExample:\n\n\nconst options = {\n  useMongoClient: true,\n  autoIndex: false,\n  reconnectTries: Number.MAX_VALUE,\n  reconnectInterval: 500,\n  poolSize: 10,\n\n  bufferMaxEntries: 0\n};\nmongoose.connect(uri, options);\n\n\n\n\n\n\u56de\u8c03\u51fd\u6570\n\n\nThe \nconnect()\n function also accepts a callback parameter and returns a \npromise\n.\n\n\nmongoose.connect(uri, options, function(error) {\n\n});\n\nmongoose.connect(uri, options).then(\n  () =\n {  },\n  err =\n {  }\n);\n\n\n\n\n\n\u8fde\u63a5\u5b57\u7b26\u4e32\u9009\u9879\n\n\nYou can also specify driver options in your connection string as \nparameters in the query string\n portion of the URI. This only applies to options passed to the MongoDB driver. You \ncan't\n set Mongoose-specific options like \nbufferCommands\n in the query string.\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost:27017/test?connectTimeoutMS=1000\nbufferCommands=false\n);\n\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost:27017/test\n,\n \n{\n\n  \nconnectTimeoutMS\n:\n \n1000\n\n\n\n}\n);\n\n\n\n\n\n\nThe disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for \nsocketTimeoutMS\n, \nconnectTimeoutMS\n, etc. Best practice is to put options that likely differ between development and production, like \nreplicaSet\n or \nssl\n, in the connection string, and options that should remain constant, like \nconnectTimeoutMS\n or \npoolSize\n, in the options object.\n\n\nThe MongoDB docs have a full list of \nsupported connection string options\n\n\n\u6709\u5173keepAlive\u7684\u8bf4\u660e\n\n\nFor long running applications, it is often prudent to enable \nkeepAlive\n with a number of milliseconds. Without it, after some period of time you may start to see \n\"connection closed\"\n errors for what seems like no reason. If so, after \nreading this\n, you may decide to enable \nkeepAlive\n:\n\n\nmongoose\n.\nconnect\n(\nuri\n,\n \n{\n \nkeepAlive\n:\n \n120\n \n}\n);\n\n\n\n\n\n\n\u526f\u672c\u96c6\u8fde\u63a5\n\n\nTo connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.\n\n\nmongoose\n.\nconnect\n(\nmongodb://\n[\nusername\n:\npassword\n@\n]\nhost1\n[\n:\nport1\n][\n,\nhost2\n[\n:\nport2\n]\n,...\n[\n,\nhostN\n[\n:\nportN\n]\n]]\n[\n/\n[\ndatabase\n][\n?\noptions\n]\n]\n \n[\n,\n \noptions\n]\n);\n\n\n\n\n\n\nTo connect to a single node replica set, specify the \nreplicaSet\n option.\n\n\nmongoose\n.\nconnect\n(\nmongodb://host1:port1/?replicaSet=rsName\n);\n\n\n\n\n\n\n\u591amongos\u652f\u6301\n\n\nHigh availability over multiple \nmongos\n instances is also supported. Pass a connection string for your \nmongos\n instances and set the \nmongos\n option to \ntrue\n:\n\n\nmongoose\n.\nconnect\n(\nmongodb://mongosA:27501,mongosB:27501\n,\n \n{\n \nmongos\n:\n \ntrue\n \n}\n,\n \ncb\n);\n\n\n\n\n\n\n\u591a\u4e2a\u8fde\u63a5\n\n\nSo far we've seen how to connect to MongoDB using Mongoose's default connection. At times we may need multiple connections open to Mongo, each with different read/write settings, or maybe just to different databases for example. In these cases we can utilize \nmongoose.createConnection()\n which accepts all the arguments already discussed and returns a fresh connection for you.\n\n\nconst\n \nconn\n \n=\n \nmongoose\n.\ncreateConnection\n(\nmongodb://\n[\nusername\n:\npassword\n@\n]\nhost1\n[\n:\nport1\n][\n,\nhost2\n[\n:\nport2\n]\n,...\n[\n,\nhostN\n[\n:\nportN\n]\n]]\n[\n/\n[\ndatabase\n][\n?\noptions\n]\n]\n,\n \noptions\n);\n\n\n\n\n\n\nThis \nconnection\n object is then used to create and retrieve \nmodels\n. Models are \nalways\n scoped to a single connection.\n\n\nMongoose creates a \ndefault connection\n when you call \nmongoose.connect()\n. You can access the default connection using \nmongoose.connection\n.\n\n\n\u8fde\u63a5\u6c60\n\n\nEach \nconnection\n, whether created with \nmongoose.connect\n or \nmongoose.createConnection\n are all backed by an internal configurable connection pool defaulting to a maximum size of 5. Adjust the pool size using your connection options:\n\n\nmongoose\n.\ncreateConnection\n(\nuri\n,\n \n{\n \npoolSize\n:\n \n4\n \n}\n);\n\n\n\nconst\n \nuri\n \n=\n \nmongodb://localhost/test?poolSize=4\n;\n\n\nmongoose\n.\ncreateConnection\n(\nuri\n);\n\n\n\n\n\n\nv5.x\u4e2d\u7684\u9009\u9879\u66f4\u6539\n\n\nYou may see the following deprecation warning if upgrading from 4.x to 5.x and you didn't use the \nuseMongoClient\n option in 4.x:\n\n\nthe server/replset/mongos options are deprecated, all their options are supported at the top level of the options object\n\n\n\n\n\nIn older version of the MongoDB driver you had to specify distinct options for server connections, replica set connections, and mongos connections:\n\n\nmongoose.connect(myUri, {\n  server: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  replset: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  mongos: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  }\n});\n\n\n\n\n\nIn mongoose v5.x you can instead declare these options at the top level, without all that extra nesting. \nHere's the list of all supported options\n.\n\n\nmongoose.connect(myUri, {\n  socketTimeoutMS: 0,\n  keepAlive: true,\n  reconnectTries: 30\n});\n\n\n\n\n\n\u63a5\u4e0b\u6765\n\n\n\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6db5\u76d6\u4e86\u8fde\u63a5, \u8ba9\u6211\u4eec\u6765\u770b\u770b\n\u6a21\u578b\n.", 
            "title": "\u8fde\u63a5\u624b\u518c"
        }, 
        {
            "location": "/connection/guide/#mongodb", 
            "text": "Source  You can connect to MongoDB with the  mongoose.connect()  method.  mongoose . connect ( mongodb://localhost/myapp );   This is the minimum needed to connect the  myapp  database running locally on the default port (27017). If the local connection fails then try using 127.0.0.1 instead of localhost. Sometimes issues may arise when the local hostname has been changed.  You can also specify several more parameters in the  uri :  mongoose . connect ( mongodb://username:password@host:port/database?options... );   See the  mongodb connection string spec  for more detail.", 
            "title": "\u8fde\u63a5\u5230MongoDB"
        }, 
        {
            "location": "/connection/guide/#_1", 
            "text": "Mongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.  mongoose . connect ( mongodb://localhost/myapp );  var   MyModel   =   mongoose . model ( Test ,   new   Schema ( {   name :   String   } ));  MyModel . findOne ( function ( error ,   result )   {    } );   That's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will  not  throw any errors by default if you use a model without connecting.  var   MyModel   =   mongoose . model ( Test ,   new   Schema ( {   name :   String   } ));  MyModel . findOne ( function ( error ,   result )   {    } );  setTimeout ( function ()   { \n   mongoose.connect( mongodb : // localhost / myapp );  } ,   60000 );   To disable buffering, turn off the  bufferCommands  option on your schema . If you have  bufferCommands  on and your connection is hanging, try turning  bufferCommands  off to see if you haven't opened a connection properly. You can also disable  bufferCommands  globally:  mongoose.set( bufferCommands , false);", 
            "title": "\u64cd\u4f5c\u7f13\u51b2"
        }, 
        {
            "location": "/connection/guide/#_2", 
            "text": "The  connect  method also accepts an  options  object which will be passed on to the underlying MongoDB driver.  mongoose.connect(uri, options);  A full list of options can be found on the  MongoDB Node.js driver docs for  connect() . Mongoose passes options to the driver without modification, modulo three exceptions that are explained below.   bufferCommands  - This is a mongoose-specific option (not passed to the MongoDB driver) that disables  mongoose's buffering mechanism  user / pass  - The username and password for authentication. These options are mongoose-specific, they are equivalent to the MongoDB driver's  auth.user  and  auth.password  options.  autoIndex  - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set  autoIndex  to false, mongoose will not automatically build indexes for  any  model associated with this connection.   Below are some of the options that are important for tuning mongoose.   autoReconnect  - The underlying MongoDB driver will automatically try to reconnect when it loses connection to MongoDB. Unless you are an extremely advanced user that wants to manage their own connection pool, do  not  set this option to  false .  reconnectTries  - If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every  reconnectInterval  milliseconds for  reconnectTries  times, and give up afterward. When the driver gives up, the mongoose connection emits a  reconnectFailed  event. This option does nothing for replica set connections.  reconnectInterval  - See  reconnectTries  promiseLibrary  - sets the  underlying driver's promise library  poolSize  - The maximum number of sockets the MongoDB driver will keep open for this connection. By default,  poolSize  is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding.  bufferMaxEntries  - The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set  bufferCommands  to  false  on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection.   Example:  const options = {\n  useMongoClient: true,\n  autoIndex: false,\n  reconnectTries: Number.MAX_VALUE,\n  reconnectInterval: 500,\n  poolSize: 10,\n\n  bufferMaxEntries: 0\n};\nmongoose.connect(uri, options);", 
            "title": "\u9009\u9879"
        }, 
        {
            "location": "/connection/guide/#_3", 
            "text": "The  connect()  function also accepts a callback parameter and returns a  promise .  mongoose.connect(uri, options, function(error) {\n\n});\n\nmongoose.connect(uri, options).then(\n  () =  {  },\n  err =  {  }\n);", 
            "title": "\u56de\u8c03\u51fd\u6570"
        }, 
        {
            "location": "/connection/guide/#_4", 
            "text": "You can also specify driver options in your connection string as  parameters in the query string  portion of the URI. This only applies to options passed to the MongoDB driver. You  can't  set Mongoose-specific options like  bufferCommands  in the query string.  mongoose . connect ( mongodb://localhost:27017/test?connectTimeoutMS=1000 bufferCommands=false );  mongoose . connect ( mongodb://localhost:27017/test ,   { \n   connectTimeoutMS :   1000  } );   The disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for  socketTimeoutMS ,  connectTimeoutMS , etc. Best practice is to put options that likely differ between development and production, like  replicaSet  or  ssl , in the connection string, and options that should remain constant, like  connectTimeoutMS  or  poolSize , in the options object.  The MongoDB docs have a full list of  supported connection string options", 
            "title": "\u8fde\u63a5\u5b57\u7b26\u4e32\u9009\u9879"
        }, 
        {
            "location": "/connection/guide/#keepalive", 
            "text": "For long running applications, it is often prudent to enable  keepAlive  with a number of milliseconds. Without it, after some period of time you may start to see  \"connection closed\"  errors for what seems like no reason. If so, after  reading this , you may decide to enable  keepAlive :  mongoose . connect ( uri ,   {   keepAlive :   120   } );", 
            "title": "\u6709\u5173keepAlive\u7684\u8bf4\u660e"
        }, 
        {
            "location": "/connection/guide/#_5", 
            "text": "To connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.  mongoose . connect ( mongodb:// [ username : password @ ] host1 [ : port1 ][ , host2 [ : port2 ] ,... [ , hostN [ : portN ] ]] [ / [ database ][ ? options ] ]   [ ,   options ] );   To connect to a single node replica set, specify the  replicaSet  option.  mongoose . connect ( mongodb://host1:port1/?replicaSet=rsName );", 
            "title": "\u526f\u672c\u96c6\u8fde\u63a5"
        }, 
        {
            "location": "/connection/guide/#mongos", 
            "text": "High availability over multiple  mongos  instances is also supported. Pass a connection string for your  mongos  instances and set the  mongos  option to  true :  mongoose . connect ( mongodb://mongosA:27501,mongosB:27501 ,   {   mongos :   true   } ,   cb );", 
            "title": "\u591amongos\u652f\u6301"
        }, 
        {
            "location": "/connection/guide/#_6", 
            "text": "So far we've seen how to connect to MongoDB using Mongoose's default connection. At times we may need multiple connections open to Mongo, each with different read/write settings, or maybe just to different databases for example. In these cases we can utilize  mongoose.createConnection()  which accepts all the arguments already discussed and returns a fresh connection for you.  const   conn   =   mongoose . createConnection ( mongodb:// [ username : password @ ] host1 [ : port1 ][ , host2 [ : port2 ] ,... [ , hostN [ : portN ] ]] [ / [ database ][ ? options ] ] ,   options );   This  connection  object is then used to create and retrieve  models . Models are  always  scoped to a single connection.  Mongoose creates a  default connection  when you call  mongoose.connect() . You can access the default connection using  mongoose.connection .", 
            "title": "\u591a\u4e2a\u8fde\u63a5"
        }, 
        {
            "location": "/connection/guide/#_7", 
            "text": "Each  connection , whether created with  mongoose.connect  or  mongoose.createConnection  are all backed by an internal configurable connection pool defaulting to a maximum size of 5. Adjust the pool size using your connection options:  mongoose . createConnection ( uri ,   {   poolSize :   4   } );  const   uri   =   mongodb://localhost/test?poolSize=4 ;  mongoose . createConnection ( uri );", 
            "title": "\u8fde\u63a5\u6c60"
        }, 
        {
            "location": "/connection/guide/#v5x", 
            "text": "You may see the following deprecation warning if upgrading from 4.x to 5.x and you didn't use the  useMongoClient  option in 4.x:  the server/replset/mongos options are deprecated, all their options are supported at the top level of the options object  In older version of the MongoDB driver you had to specify distinct options for server connections, replica set connections, and mongos connections:  mongoose.connect(myUri, {\n  server: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  replset: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  mongos: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  }\n});  In mongoose v5.x you can instead declare these options at the top level, without all that extra nesting.  Here's the list of all supported options .  mongoose.connect(myUri, {\n  socketTimeoutMS: 0,\n  keepAlive: true,\n  reconnectTries: 30\n});", 
            "title": "v5.x\u4e2d\u7684\u9009\u9879\u66f4\u6539"
        }, 
        {
            "location": "/connection/guide/#_8", 
            "text": "\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6db5\u76d6\u4e86\u8fde\u63a5, \u8ba9\u6211\u4eec\u6765\u770b\u770b \u6a21\u578b .", 
            "title": "\u63a5\u4e0b\u6765"
        }, 
        {
            "location": "/connection/api/", 
            "text": "\u8fde\u63a5\n\n\nConnection()\n\n\n\u53c2\u6570\n\n\n\u57fa\u4e8e \u00abMongoose\u00bb \u4e00\u4e2a\u732b\u9f2c\u7684\u4f8b\u5b50\n\n\n\u8fde\u63a5\u6784\u9020\n\n\n\u51fa\u4e8e\u5b9e\u9645\u7684\u539f\u56e0\uff0c\u8fde\u63a5\u7b49\u4e8eDb\u3002\n\n\nConnection.prototype.readyState\n\n\n\u8fde\u63a5\u51c6\u5907\u72b6\u6001\n\n\n\n\n0 = disconnected\n\n\n1 = connected\n\n\n2 = connecting\n\n\n3 = disconnecting\n\n\n\n\n\u6bcf\u4e2a\u72b6\u6001\u66f4\u6539\u90fd\u4f1a\u53d1\u51fa\u5176\u5173\u8054\u7684\u4e8b\u4ef6\u540d\u79f0\n\n\n\u793a\u4f8b\n\n\nconn.on(\nconnected\n, callback);\nconn.on(\ndisconnected\n, callback);\n\n\n\n\n\nConnection.prototype.collections\n\n\n\u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u96c6\u5408\u7684\u6563\u5217\n\n\nConnection.prototype.db\n\n\n\u5f53\u8fde\u63a5\u6253\u5f00\u65f6\u8bbe\u7f6e\u7684mongodb.Db\u5b9e\u4f8b\n\n\nConnection.prototype.config\n\n\n\u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u5168\u5c40\u9009\u9879\u7684\u6563\u5217\n\n\nConnection.prototype.createCollection()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nConnection.prototype.dropCollection()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\ndropCollection()\n\u52a9\u624b. \u5c06\u5220\u9664\u7ed9\u5b9a\u7684\u96c6\u5408\uff0c\u5305\u62ec\u6240\u6709\u6587\u6863\u548c\u7d22\u5f15.\n\n\nConnection.prototype.dropDatabase()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\ndropDatabase()\n\u52a9\u624b. \u5220\u9664\u7ed9\u5b9a\u7684\u6570\u636e\u5e93\uff0c\u5305\u62ec\u6240\u6709\u96c6\u5408\uff0c\u6587\u6863\u548c\u7d22\u5f15.\n\n\nConnection.prototype.close()\n\n\n\u53c2\u6570\n\n\n\n\n\u56de\u8c03\u00ab\u529f\u80fd\u00bb\u9009\u9879\n\n\n\n\n\u8fd4\u56de\n\n\nConnection.prototype.collection()\n\n\n\u53c2\u6570\n\n\n\n\n\u9009\u9879\u00ab\u5bf9\u8c61\u00bb\u53ef\u9009\u6536\u96c6\u9009\u9879\n\n\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abCollection\u00bb \u6536\u96c6\u5b9e\u4f8b\n\n\n\n\n\u68c0\u7d22\u4e00\u4e2a\u96c6\u5408\uff0c\u5982\u679c\u6ca1\u6709\u7f13\u5b58\u5219\u521b\u5efa\u5b83\n\u901a\u5e38\u4e0d\u9700\u8981\u5e94\u7528\u7a0b\u5e8f\u3002 Just talk to your collection through your model.\n\n\nConnection.prototype.model()\n\n\n\u53c2\u6570\n\n\n\n\ncollection \u00abString\u00bb name of mongodb collection (optional) if not given it will be induced from model name\n\n\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abModel\u00bb \u7f16\u8bd1\u6a21\u5f0f\n\n\n\n\n\u5b9a\u4e49\u6216\u68c0\u7d22\u6a21\u578b\n\n\nvar mongoose = require(\nmongoose\n);\nvar db = mongoose.createConnection(..);\ndb.model(\nVenue\n, new Schema(..));\nvar Ticket = db.model(\nTicket\n, new Schema(..));\nvar Venue = db.model(\nVenue\n);\n\n\n\n\n\nWhen no \ncollection\n argument is passed, Mongoose produces a collection name by passing the model \nname\n to the utils.toCollectionName method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.\n\n\n\u793a\u4f8b\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \ncollection\n:\n \nactor\n \n}\n);\n\n\n\nschema\n.\nset\n(\ncollection\n,\n \nactor\n);\n\n\n\nvar\n \ncollectionName\n \n=\n \nactor\n\n\nvar\n \nM\n \n=\n \nconn\n.\nmodel\n(\nActor\n,\n \nschema\n,\n \ncollectionName\n)\n\n\n\n\n\n\nConnection.prototype.modelNames()\n\n\n\u8fd4\u56de\n\n\n\u8fd4\u56de\u5728\u6b64\u8fde\u63a5\u4e0a\u521b\u5efa\u7684\u6a21\u578b\u540d\u79f0\u6570\u7ec4\u3002", 
            "title": "\u8fde\u63a5API"
        }, 
        {
            "location": "/connection/api/#_1", 
            "text": "", 
            "title": "\u8fde\u63a5"
        }, 
        {
            "location": "/connection/api/#connection", 
            "text": "\u53c2\u6570  \u57fa\u4e8e \u00abMongoose\u00bb \u4e00\u4e2a\u732b\u9f2c\u7684\u4f8b\u5b50  \u8fde\u63a5\u6784\u9020  \u51fa\u4e8e\u5b9e\u9645\u7684\u539f\u56e0\uff0c\u8fde\u63a5\u7b49\u4e8eDb\u3002", 
            "title": "Connection()"
        }, 
        {
            "location": "/connection/api/#connectionprototypereadystate", 
            "text": "\u8fde\u63a5\u51c6\u5907\u72b6\u6001   0 = disconnected  1 = connected  2 = connecting  3 = disconnecting   \u6bcf\u4e2a\u72b6\u6001\u66f4\u6539\u90fd\u4f1a\u53d1\u51fa\u5176\u5173\u8054\u7684\u4e8b\u4ef6\u540d\u79f0  \u793a\u4f8b  conn.on( connected , callback);\nconn.on( disconnected , callback);", 
            "title": "Connection.prototype.readyState"
        }, 
        {
            "location": "/connection/api/#connectionprototypecollections", 
            "text": "\u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u96c6\u5408\u7684\u6563\u5217", 
            "title": "Connection.prototype.collections"
        }, 
        {
            "location": "/connection/api/#connectionprototypedb", 
            "text": "\u5f53\u8fde\u63a5\u6253\u5f00\u65f6\u8bbe\u7f6e\u7684mongodb.Db\u5b9e\u4f8b", 
            "title": "Connection.prototype.db"
        }, 
        {
            "location": "/connection/api/#connectionprototypeconfig", 
            "text": "\u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u5168\u5c40\u9009\u9879\u7684\u6563\u5217", 
            "title": "Connection.prototype.config"
        }, 
        {
            "location": "/connection/api/#connectionprototypecreatecollection", 
            "text": "\u53c2\u6570  \u8fd4\u56de", 
            "title": "Connection.prototype.createCollection()"
        }, 
        {
            "location": "/connection/api/#connectionprototypedropcollection", 
            "text": "\u53c2\u6570  \u8fd4\u56de  dropCollection() \u52a9\u624b. \u5c06\u5220\u9664\u7ed9\u5b9a\u7684\u96c6\u5408\uff0c\u5305\u62ec\u6240\u6709\u6587\u6863\u548c\u7d22\u5f15.", 
            "title": "Connection.prototype.dropCollection()"
        }, 
        {
            "location": "/connection/api/#connectionprototypedropdatabase", 
            "text": "\u53c2\u6570  \u8fd4\u56de  dropDatabase() \u52a9\u624b. \u5220\u9664\u7ed9\u5b9a\u7684\u6570\u636e\u5e93\uff0c\u5305\u62ec\u6240\u6709\u96c6\u5408\uff0c\u6587\u6863\u548c\u7d22\u5f15.", 
            "title": "Connection.prototype.dropDatabase()"
        }, 
        {
            "location": "/connection/api/#connectionprototypeclose", 
            "text": "\u53c2\u6570   \u56de\u8c03\u00ab\u529f\u80fd\u00bb\u9009\u9879   \u8fd4\u56de", 
            "title": "Connection.prototype.close()"
        }, 
        {
            "location": "/connection/api/#connectionprototypecollection", 
            "text": "\u53c2\u6570   \u9009\u9879\u00ab\u5bf9\u8c61\u00bb\u53ef\u9009\u6536\u96c6\u9009\u9879   \u8fd4\u56de   \u00abCollection\u00bb \u6536\u96c6\u5b9e\u4f8b   \u68c0\u7d22\u4e00\u4e2a\u96c6\u5408\uff0c\u5982\u679c\u6ca1\u6709\u7f13\u5b58\u5219\u521b\u5efa\u5b83\n\u901a\u5e38\u4e0d\u9700\u8981\u5e94\u7528\u7a0b\u5e8f\u3002 Just talk to your collection through your model.", 
            "title": "Connection.prototype.collection()"
        }, 
        {
            "location": "/connection/api/#connectionprototypemodel", 
            "text": "\u53c2\u6570   collection \u00abString\u00bb name of mongodb collection (optional) if not given it will be induced from model name   \u8fd4\u56de   \u00abModel\u00bb \u7f16\u8bd1\u6a21\u5f0f   \u5b9a\u4e49\u6216\u68c0\u7d22\u6a21\u578b  var mongoose = require( mongoose );\nvar db = mongoose.createConnection(..);\ndb.model( Venue , new Schema(..));\nvar Ticket = db.model( Ticket , new Schema(..));\nvar Venue = db.model( Venue );  When no  collection  argument is passed, Mongoose produces a collection name by passing the model  name  to the utils.toCollectionName method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.  \u793a\u4f8b  var   schema   =   new   Schema ( {   name :   String   } ,   {   collection :   actor   } );  schema . set ( collection ,   actor );  var   collectionName   =   actor  var   M   =   conn . model ( Actor ,   schema ,   collectionName )", 
            "title": "Connection.prototype.model()"
        }, 
        {
            "location": "/connection/api/#connectionprototypemodelnames", 
            "text": "\u8fd4\u56de  \u8fd4\u56de\u5728\u6b64\u8fde\u63a5\u4e0a\u521b\u5efa\u7684\u6a21\u578b\u540d\u79f0\u6570\u7ec4\u3002", 
            "title": "Connection.prototype.modelNames()"
        }, 
        {
            "location": "/schema/guide/", 
            "text": "\u6a21\u5f0f\n\n\nSource\n\n\nIf you haven't yet done so, please take a minute to read the \nquickstart\n to get an idea of how Mongoose works. If you are migrating from 4.x to 5.x please take a moment to read the \nmigration guide\n.\n\n\n\u5b9a\u4e49\u4f60\u7684\u6a21\u5f0f\n\n\nEverything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.\n\n\n    \nvar\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n    \nvar\n \nSchema\n \n=\n \nmongoose\n.\nSchema\n;\n\n\n    \nvar\n \nblogSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \ntitle\n:\n  \nString\n,\n\n    \nauthor\n:\n \nString\n,\n\n    \nbody\n:\n   \nString\n,\n\n    \ncomments\n:\n \n[{\n \nbody\n:\n \nString\n,\n \ndate\n:\n \nDate\n \n}],\n\n    \ndate\n:\n \n{\n \ntype\n:\n \nDate\n,\n \ndefault\n:\n \nDate\n.\nnow\n \n},\n\n    \nhidden\n:\n \nBoolean\n,\n\n    \nmeta\n:\n \n{\n\n        \nvotes\n:\n \nNumber\n,\n\n        \nfavs\n:\n  \nNumber\n\n    \n}\n\n    \n});\n\n\n\n\n\nIf you want to add additional keys later, use the \nSchema#add\n method.\n\n\nEach key in our code \nblogSchema\n defines a property in our documents which will be cast to its associated \nSchemaType\n. For example, we've defined a property \ntitle\n which will be cast to the \nString\n SchemaType and property \ndate\n which will be cast to a \nDate\n SchemaType. Keys may also be assigned nested objects containing further key/type definitions like the \nmeta\n property above.\n\n\nThe permitted SchemaTypes are:\n\n\n\n\nString\n\n\nNumber\n\n\nDate\n\n\nBuffer\n\n\nBoolean\n\n\nMixed\n\n\nObjectId\n\n\nArray\n\n\n\n\nRead more about \nSchemaTypes here\n.\n\n\nSchemas not only define the structure of your document and casting of properties, they also define document [instance methods][8], [static Model methods][9], [compound indexes][10], and document lifecycle hooks called \nmiddleware\n\n\n\u521b\u5efa\u4e00\u4e2a\u6a21\u5f0f\n\n\nTo use our schema definition, we need to convert our \nblogSchema\n into a \nModel\n we can work with. To do so, we pass it into \nmongoose.model(modelName, schema)\n:\n\n\n    \nvar\n \nBlog\n \n=\n \nmongoose\n.\nmodel\n(\nBlog\n,\n \nblogSchema\n);\n\n\n\n\n\n\u5b9e\u4f8b\u65b9\u6cd5\n\n\nInstances of \nModels\n are \ndocuments\n. Documents have many of their own \nbuilt-in instance methods\n. We may also define our own custom document instance methods too.\n\n\n  \nvar\n \nanimalSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \ntype\n:\n \nString\n \n}\n);\n\n\n  \nanimalSchema\n.\nmethods\n.\nfindSimilarTypes\n \n=\n \nfunction\n(\ncb\n)\n \n{\n\n    \nreturn\n \nthis.model(\nAnimal\n).find({\n \ntype\n:\n \nthis\n.\ntype\n \n}\n,\n \ncb\n);\n\n  \n}\n;\n\n\n\n\n\n\nNow all of our \nanimal\n instances have a \nfindSimilarTypes\n method available to them.\n\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n  \nvar\n \ndog\n \n=\n \nnew\n \nAnimal\n(\n{\n \ntype\n:\n \ndog\n \n}\n);\n\n\n  \ndog\n.\nfindSimilarTypes\n(\nfunction\n(\nerr\n,\n \ndogs\n)\n \n{\n\n    \nconsole.log(dogs)\n;\n\n  \n}\n);\n\n\n\n\n\n\n\n\nOverwriting a default mongoose document method may lead to unpredictable results. See \nthis\n for more details.\n\n\nDo \nnot\n declare methods using ES6 arrow functions (\n=\n). Arrow functions \nexplicitly prevent binding \nthis\n, so your method will \nnot\n have access to the document and the above examples will not work.\n\n\n\n\n\u9759\u6001\u65b9\u6cd5\n\n\nAdding static methods to a \nModel\n is simple as well. Continuing with our \nanimalSchema\n:\n\n\n  \nanimalSchema\n.\nstatics\n.\nfindByName\n \n=\n \nfunction\n(\nname\n,\n \ncb\n)\n \n{\n\n    \nreturn\n \nthis.find({\n \nname\n:\n \nnew\n \nRegExp\n(\nname\n,\n \ni\n)\n \n}\n,\n \ncb\n);\n\n  \n}\n;\n\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n  \nAnimal\n.\nfindByName\n(\nfido\n,\n \nfunction\n(\nerr\n,\n \nanimals\n)\n \n{\n\n    \nconsole.log(animals)\n;\n\n  \n}\n);\n\n\n\n\n\n\nDo \nnot\n declare statics using ES6 arrow functions (\n=\n). Arrow functions \nexplicitly prevent binding \nthis\n, so the above examples will not work because of the value of \nthis\n.\n\n\n\u67e5\u8be2\u52a9\u624b\n\n\nYou can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's \nchainable query builder API\n.\n\n\n  \nanimalSchema\n.\nquery\n.\nbyName\n \n=\n \nfunction\n(\nname\n)\n \n{\n\n    \nreturn\n \nthis.find({\n \nname\n:\n \nnew\n \nRegExp\n(\nname\n,\n \ni\n)\n \n}\n);\n\n  \n}\n;\n\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n  \nAnimal\n.\nfind\n()\n.\nbyName\n(\nfido\n)\n.\nexec\n(\nfunction\n(\nerr\n,\n \nanimals\n)\n \n{\n\n    \nconsole.log(animals)\n;\n\n  \n}\n);\n\n\n\n\n\n\n\u7d22\u5f15\n\n\nMongoDB supports \nsecondary indexes\n. With mongoose, we define these indexes within our \nSchema\n \nat\n \nthe\n \npath\n \nlevel\n or the \nschema\n level. Defining indexes at the schema level is necessary when creating \ncompound indexes\n.\n\n\n  \nvar\n \nanimalSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n    \nname\n:\n \nString\n,\n\n    \ntype\n:\n \nString\n,\n\n    \ntags\n:\n \n{\n \ntype\n:\n \n[\nString\n]\n,\n \nindex\n:\n \ntrue\n \n}\n\n  \n}\n);\n\n\n  \nanimalSchema\n.\nindex\n(\n{\n \nname\n:\n \n1\n,\n \ntype\n:\n \n-1\n \n}\n);\n\n\n\n\n\n\nWhen your application starts up, Mongoose automatically calls \ncreateIndex\n for each defined index in your schema. Mongoose will call \ncreateIndex\n for each index sequentially, and emit an 'index' event on the model when all the \ncreateIndex\n calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a \nsignificant performance impact\n. Disable the behavior by setting the \nautoIndex\n option of your schema to \nfalse\n, or globally on the connection by setting the option \nautoIndex\n to \nfalse\n.\n\n\n  \nmongoose\n.\nconnect\n(\nmongodb://user:pass@localhost:port/database\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\n  \nmongoose\n.\ncreateConnection\n(\nmongodb://user:pass@localhost:port/database\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\n  \nanimalSchema\n.\nset\n(\nautoIndex\n,\n \nfalse\n);\n\n\n  \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\nMongoose will emit an \nindex\n event on the model when indexes are done building or an error occurred.\n\n\n  \nanimalSchema\n.\nindex\n(\n{\n \n_id\n:\n \n1\n \n}\n,\n \n{\n \nsparse\n:\n \ntrue\n \n}\n);\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n\n  \nAnimal\n.\non\n(\nindex\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n    \nconsole.log(error.message)\n;\n\n  \n}\n);\n\n\n\n\n\n\nSee also the \nModel#ensureIndexes\n method.\n\n\n\u865a\u62df\u5b57\u6bb5\n\n\nVirtuals\n are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage.\n\n\n  var personSchema = new Schema({\n    name: {\n      first: String,\n      last: String\n    }\n  });\n\n  var Person = mongoose.model(\nPerson\n, personSchema);\n\n  var axl = new Person({\n    name: { first: \nAxl\n, last: \nRose\n }\n  });\n\n\n\n\n\nSuppose you want to print out the person's full name. You could do it yourself:\n\n\nconsole.log(axl.name.first + \n \n + axl.name.last);\n\n\n\n\n\nBut concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like \nremoving diacritics?\n. A \nvirtual property getter\n lets you\n\n\ndefine a \nfullName\n property that won't get persisted to MongoDB.\n\n\npersonSchema.virtual(\nfullName\n).get(function () {\n  return this.name.first + \n \n + this.name.last;\n});\n\n\n\n\n\nNow, mongoose will call your getter function every time you access the \nfullName\n property:\n\n\nconsole.log(axl.fullName);\n\n\n\n\n\nIf you use \ntoJSON()\n or \ntoObject()\n (or use \nJSON.stringify()\n on a mongoose document) mongoose will \nnot\n include virtuals by default. Pass \n{ virtuals: true }\n to either \ntoObject()\n or \ntoJSON()\n.\n\n\nYou can also add a custom setter to your virtual that will let you set both first name and last name via the \nfullName\n virtual.\n\n\npersonSchema.virtual(\nfullName\n).\n  get(function() { return this.name.first + \n \n + this.name.last; }).\n  set(function(v) {\n    this.name.first = v.substr(0, v.indexOf(\n \n));\n    this.name.last = v.substr(v.indexOf(\n \n) + 1);\n  });\n\naxl.fullName = \nWilliam Rose\n;\n\n\n\n\n\nVirtual property setters are applied before other validation. So the example above would still work even if the \nfirst\n and \nlast\n name fields were required.\n\n\nOnly non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.\n\n\n\u522b\u540d\n\n\nAliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability.\n\n\nvar\n \npersonSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nn\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n\n    \nalias\n:\n \nname\n\n  \n}\n\n\n}\n);\n\n\n\nvar\n \nperson\n \n=\n \nnew\n \nPerson\n(\n{\n \nname\n:\n \nVal\n \n}\n);\n\n\nconsole\n.\nlog\n(\nperson\n);\n\n\nconsole\n.\nlog\n(\nperson\n.\ntoObject\n(\n{\n \nvirtuals\n:\n \ntrue\n \n}\n));\n\n\nconsole\n.\nlog\n(\nperson\n.\nname\n);\n\n\n\nperson\n.\nname\n \n=\n \nNot Val\n;\n\n\nconsole\n.\nlog\n(\nperson\n);\n\n\n\n\n\n\n\u9009\u9879\n\n\nSchemas have a few configurable options which can be passed to the constructor or \nset\n directly:\n\n\nnew Schema({..}, options);\n\nvar schema = new Schema({..});\nschema.set(option, value);\n\n\n\n\n\nValid options:\n\n\nautoIndex\n\n\nAt application startup, Mongoose sends a \ncreateIndex\n command\n for each index declared in your \nSchema\n. As of Mongoose v3, indexes are created in the \nbackground\n by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your \nSchema\ns \nautoIndex\n option to \nfalse\n and use the \nensureIndexes\n method on your model.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nClock\n \n=\n \nmongoose\n.\nmodel\n(\nClock\n,\n \nschema\n);\n\n\nClock\n.\nensureIndexes\n(\ncallback\n);\n\n\n\n\n\n\nbufferCommands\n\n\nBy default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set \nbufferCommands\n to false.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nbufferCommands\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\nThe schema \nbufferCommands\n option overrides the global \nbufferCommands\n option.\n\n\nmongoose\n.\nset\n(\nbufferCommands\n,\n \ntrue\n);\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nbufferCommands\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\ncapped\n\n\nMongoose supports MongoDBs \ncapped\n collections. To specify the underlying MongoDB collection be \ncapped\n, set the \ncapped\n option to the maximum size of the collection in \nbytes\n.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ncapped\n:\n \n1024\n \n}\n);\n\n\n\n\n\n\nThe \ncapped\n option may also be set to an object if you want to pass additional options like \nmax\n or \nautoIndexId\n. In this case you must explicitly pass the \nsize\n option, which is required.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ncapped\n:\n \n{\n \nsize\n:\n \n1024\n,\n \nmax\n:\n \n1000\n,\n \nautoIndexId\n:\n \ntrue\n \n}\n \n}\n);\n\n\n\n\n\n\ncollection\n\n\nMongoose by default produces a collection name by passing the model name to the \nutils.toCollectionName\n method. This method pluralizes the name. Set this option if you need a different name for your collection.\n\n\nvar\n \ndataSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ncollection\n:\n \ndata\n \n}\n);\n\n\n\n\n\n\nid\n\n\nMongoose assigns each of your schemas an \nid\n virtual getter by default which returns the documents \n_id\n field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an \nid\n getter added to your schema, you may disable it passing this option at schema construction time.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nvar\n \nPage\n \n=\n \nmongoose\n.\nmodel\n(\nPage\n,\n \nschema\n);\n\n\nvar\n \np\n \n=\n \nnew\n \nPage\n(\n{\n \nname\n:\n \nmongodb.org\n \n}\n);\n\n\nconsole\n.\nlog\n(\np\n.\nid\n);\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \nid\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nPage\n \n=\n \nmongoose\n.\nmodel\n(\nPage\n,\n \nschema\n);\n\n\nvar\n \np\n \n=\n \nnew\n \nPage\n(\n{\n \nname\n:\n \nmongodb.org\n \n}\n);\n\n\nconsole\n.\nlog\n(\np\n.\nid\n);\n\n\n\n\n\n\n_id\n\n\nMongoose assigns each of your schemas an \n_id\n field by default if one is not passed into the \nSchema\n constructor. The type assigned is an \nObjectId\n to coincide with MongoDB's default behavior. If you don't want an \n_id\n added to your schema at all, you may disable it using this option.\n\n\nYou can \nonly\n use this option on sub-documents. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an \n_id\n.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nvar\n \nPage\n \n=\n \nmongoose\n.\nmodel\n(\nPage\n,\n \nschema\n);\n\n\nvar\n \np\n \n=\n \nnew\n \nPage\n(\n{\n \nname\n:\n \nmongodb.org\n \n}\n);\n\n\nconsole\n.\nlog\n(\np\n);\n\n\n\nvar\n \nchildSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \n_id\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nparentSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nchildren\n:\n \n[\nchildSchema\n]\n \n}\n);\n\n\n\nvar\n \nModel\n \n=\n \nmongoose\n.\nmodel\n(\nModel\n,\n \nparentSchema\n);\n\n\n\nModel\n.\ncreate\n(\n{\n \nchildren\n:\n \n[\n{\n \nname\n:\n \nLuke\n \n}\n]\n \n}\n,\n \nfunction\n(\nerror\n,\n \ndoc\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nminimize\n\n\nMongoose will, by default, \"minimize\" schemas by removing empty objects.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \ninventory\n:\n \n{\n}\n \n}\n);\n\n\nvar\n \nCharacter\n \n=\n \nmongoose\n.\nmodel\n(\nCharacter\n,\n \nschema\n);\n\n\n\nvar\n \nfrodo\n \n=\n \nnew\n \nCharacter\n(\n{\n \nname\n:\n \nFrodo\n,\n \ninventory\n:\n \n{\n \nringOfPower\n:\n \n1\n \n}\n}\n);\n\n\nCharacter\n.\nfindOne\n(\n{\n \nname\n:\n \nFrodo\n \n}\n,\n \nfunction\n(\nerr\n,\n \ncharacter\n)\n \n{\n\n  \nconsole.log(character)\n;\n\n\n}\n);\n\n\n\nvar\n \nsam\n \n=\n \nnew\n \nCharacter\n(\n{\n \nname\n:\n \nSam\n,\n \ninventory\n:\n \n{\n}\n}\n);\n\n\nCharacter\n.\nfindOne\n(\n{\n \nname\n:\n \nSam\n \n}\n,\n \nfunction\n(\nerr\n,\n \ncharacter\n)\n \n{\n\n  \nconsole.log(character)\n;\n\n\n}\n);\n\n\n\n\n\n\nThis behavior can be overridden by setting \nminimize\n option to \nfalse\n. It will then store empty objects.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \ninventory\n:\n \n{\n}\n \n}\n,\n \n{\n \nminimize\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nCharacter\n \n=\n \nmongoose\n.\nmodel\n(\nCharacter\n,\n \nschema\n);\n\n\n\nvar\n \nsam\n \n=\n \nnew\n \nCharacter\n(\n{\n \nname\n:\n \nSam\n,\n \ninventory\n:\n \n{\n}\n}\n);\n\n\nCharacter\n.\nfindOne\n(\n{\n \nname\n:\n \nSam\n \n}\n,\n \nfunction\n(\nerr\n,\n \ncharacter\n)\n \n{\n\n  \nconsole.log(character)\n;\n\n\n}\n);\n\n\n\n\n\n\nread\n\n\nAllows setting \nquery#read\n options at the schema level, providing us a way to apply default \nReadPreferences\n to all queries derived from a model.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nprimary\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nprimaryPreferred\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nsecondary\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nsecondaryPreferred\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nnearest\n \n}\n);\n\n\n\n\n\n\nThe alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.\n\n\nThe read option also allows us to specify \ntag sets\n. These tell the \ndriver\n from which members of the replica-set it should attempt to read. Read more about tag sets \nhere\n and \nhere\n.\n\n\nNOTE: you may also specify the driver read pref \nstrategy\n option when connecting:\n\n\nvar\n \noptions\n \n=\n \n{\n \nreplset\n:\n \n{\n \nstrategy\n:\n \nping\n \n}\n}\n;\n\n\nmongoose\n.\nconnect\n(\nuri\n,\n \noptions\n);\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \n[\nnearest\n,\n \n{\n \ndisk\n:\n \nssd\n \n}\n]\n \n}\n);\n\n\nmongoose\n.\nmodel\n(\nJellyBean\n,\n \nschema\n);\n\n\n\n\n\n\nshardKey\n\n\nThe \nshardKey\n option is used when we have a \nsharded MongoDB architecture\n. Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we'll be all set.\n\n\nnew Schema({ .. }, { shardKey: { tag: 1, name: 1 }})\n\n\n\n\n\nNote that Mongoose does not send the \nshardcollection\n command for you. You must configure your shards yourself.\n\n\nstrict\n\n\nThe strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.\n\n\nvar\n \nthingSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n)\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nthingSchema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \niAmNotInTheSchema\n:\n \ntrue\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\nvar\n \nthingSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \niAmNotInTheSchema\n:\n \ntrue\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\nThis also affects the use of \ndoc.set()\n to set a property value.\n\n\nvar thingSchema = new Schema({..})\nvar Thing = mongoose.model(\nThing\n, thingSchema);\nvar thing = new Thing;\nthing.set(\niAmNotInTheSchema\n, true);\nthing.save();\n\n\n\n\n\nThis value can be overridden at the model instance level by passing a second boolean argument:\n\n\nvar Thing = mongoose.model(\nThing\n);\nvar thing = new Thing(doc, true);\nvar thing = new Thing(doc, false);\n\n\n\n\n\nThe \nstrict\n option may also be set to \n\"throw\"\n which will cause errors to be produced instead of dropping the bad data.\n\n\nNOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.\n\n\nvar thingSchema = new Schema({..})\nvar Thing = mongoose.model(\nThing\n, thingSchema);\nvar thing = new Thing;\nthing.iAmNotInTheSchema = true;\nthing.save();\n\n\n\n\n\ntoJSON\n\n\nExactly the same as the [toObject][60] option but only applies when the documents \ntoJSON\n method is called.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\npath\n(\nname\n)\n.\nget\n(\nfunction\n \n(\nv\n)\n \n{\n\n  \nreturn\n \nv\n \n+\n \n \nis\n \nmy\n \nname\n;\n\n\n}\n);\n\n\nschema\n.\nset\n(\ntoJSON\n,\n \n{\n \ngetters\n:\n \ntrue\n,\n \nvirtuals\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nM\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nschema\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n(\n{\n \nname\n:\n \nMax Headroom\n \n}\n);\n\n\nconsole\n.\nlog\n(\nm\n.\ntoObject\n());\n\n\nconsole\n.\nlog\n(\nm\n.\ntoJSON\n());\n\n\n\nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nm\n));\n\n\n\n\n\n\nTo see all available \ntoJSON/toObject\n options, read \nthis\n.\n\n\ntoObject\n\n\nDocuments have a \ntoObject\n method which converts the mongoose document into a plain javascript object. This method accepts a few options. Instead of applying these options on a per-document basis we may declare the options here and have it applied to all of this schemas documents by default.\n\n\nTo have all virtuals show up in your \nconsole.log\n output, set the \ntoObject\n option to \n{ getters: true }\n:\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\npath\n(\nname\n)\n.\nget\n(\nfunction\n \n(\nv\n)\n \n{\n\n  \nreturn\n \nv\n \n+\n \n \nis\n \nmy\n \nname\n;\n\n\n}\n);\n\n\nschema\n.\nset\n(\ntoObject\n,\n \n{\n \ngetters\n:\n \ntrue\n \n}\n);\n\n\nvar\n \nM\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nschema\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n(\n{\n \nname\n:\n \nMax Headroom\n \n}\n);\n\n\nconsole\n.\nlog\n(\nm\n);\n\n\n\n\n\n\nTo see all available \ntoObject\n options, read \nthis\n.\n\n\ntypeKey\n\n\nBy default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \nString\n,\n \ncoordinates\n:\n \n[\nNumber\n]\n \n}\n \n}\n);\n\n\n\n\n\n\nHowever, for applications like \ngeoJSON\n, the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n\n\n  \nloc\n:\n \n{\n \ntype\n:\n \nString\n,\n \ncoordinates\n:\n \n[\nNumber\n]\n \n}\n,\n\n\n  \nname\n:\n \n{\n \n$\ntype\n:\n \nString\n \n}\n\n\n}\n,\n \n{\n \ntypeKey\n:\n \n$type\n \n}\n);\n\n\n\n\n\n\nvalidateBeforeSave\n\n\nBy default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set \nvalidateBeforeSave\n to false.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\nset\n(\nvalidateBeforeSave\n,\n \nfalse\n);\n\n\nschema\n.\npath\n(\nname\n)\n.\nvalidate\n(\nfunction\n \n(\nvalue\n)\n \n{\n\n    \nreturn\n \nv\n \n!=\n \nnull\n;\n\n\n}\n);\n\n\nvar\n \nM\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nschema\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n(\n{\n \nname\n:\n \nnull\n \n}\n);\n\n\nm\n.\nvalidate\n(\nfunction\n(\nerr\n)\n \n{\n\n    \nconsole.log(err)\n;\n\n\n}\n);\n\n\nm\n.\nsave\n();\n\n\n\n\n\n\nversionKey\n\n\nThe \nversionKey\n is a property set on each document when first created by Mongoose. This keys value contains the internal \nrevision\n of the document. The \nversionKey\n option is a string that represents the path to use for versioning. The default is \n__v\n. If this conflicts with your application you can configure as such:\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nstring\n \n}\n);\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nschema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \nname\n:\n \nmongoose v3\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nversionKey\n:\n \n_somethingElse\n \n}\n)\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nschema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \nname\n:\n \nmongoose v3\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\nDocument versioning can also be disabled by setting the \nversionKey\n to \nfalse\n. \nDO NOT disable versioning unless you \nknow what you are doing\n.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nversionKey\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nschema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \nname\n:\n \nno versioning please\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\ncollation\n\n\nSets a default \ncollation\n for every query and aggregation. \nHere's a beginner-friendly overview of collations\n.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \nString\n\n\n}\n,\n \n{\n \ncollation\n:\n \n{\n \nlocale\n:\n \nen_US\n,\n \nstrength\n:\n \n1\n \n}\n \n}\n);\n\n\n\nvar\n \nMyModel\n \n=\n \ndb\n.\nmodel\n(\nMyModel\n,\n \nschema\n);\n\n\n\nMyModel\n.\ncreate\n(\n[\n{\n \nname\n:\n \nval\n \n},\n \n{\n \nname\n:\n \nVal\n \n}\n]\n).\n\n  \nthen\n(\nfunction\n()\n \n{\n\n    \nreturn\n \nMyModel.find({\n \nname\n:\n \nval\n \n}\n);\n\n  \n}\n).\n\n  \nthen\n(\nfunction\n(\ndocs\n)\n \n{\n\n\n  \n}\n);\n\n\n\n\n\n\nskipVersioning\n\n\nskipVersioning\n allows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For sub-documents, include this on the parent document using the fully qualified path.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nskipVersioning\n:\n \n{\n \ndontVersionMe\n:\n \ntrue\n \n}\n \n}\n);\n\n\nthing\n.\ndontVersionMe\n.\npush\n(\nhey\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\ntimestamps\n\n\nIf set \ntimestamps\n, mongoose assigns \ncreatedAt\n and \nupdatedAt\n fields to your schema, the type assigned is \nDate\n.\n\n\nBy default, the name of two fields are \ncreatedAt\n and \nupdatedAt\n, customize the field name by setting \ntimestamps.createdAt\n and \ntimestamps.updatedAt\n.\n\n\nvar\n \nthingSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ntimestamps\n:\n \n{\n \ncreatedAt\n:\n \ncreated_at\n \n}\n \n}\n);\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nthingSchema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n();\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\nuseNestedStrict\n\n\nIn mongoose 4, \nupdate()\n and \nfindOneAndUpdate()\n only check the top-level schema's strict mode setting.\n\n\nvar\n \nchildSchema\n \n=\n \nnew\n \nSchema\n(\n{}\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nparentSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nchild\n:\n \nchildSchema\n \n}\n,\n \n{\n \nstrict\n:\n \nthrow\n \n}\n);\n\n\nvar\n \nParent\n \n=\n \nmongoose\n.\nmodel\n(\nParent\n,\n \nparentSchema\n);\n\n\nParent\n.\nupdate\n(\n{}\n,\n \n{\n \nchild.name\n:\n \nLuke\n \nSkywalker\n \n}\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\nvar\n \nupdate\n \n=\n \n{\n \nchild.name\n:\n \nLuke\n \nSkywalker\n \n}\n;\n\n\nvar\n \nopts\n \n=\n \n{\n \nstrict\n:\n \nfalse\n \n}\n;\n\n\nParent\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nIf you set \nuseNestedStrict\n to true, mongoose will use the child schema's \nstrict\n option for casting updates.\n\n\nvar\n \nchildSchema\n \n=\n \nnew\n \nSchema\n(\n{}\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nparentSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nchild\n:\n \nchildSchema\n \n}\n,\n\n  \n{\n \nstrict\n:\n \nthrow\n,\n \nuseNestedStrict\n:\n \ntrue\n \n}\n);\n\n\nvar\n \nParent\n \n=\n \nmongoose\n.\nmodel\n(\nParent\n,\n \nparentSchema\n);\n\n\nParent\n.\nupdate\n(\n{}\n,\n \n{\n \nchild.name\n:\n \nLuke\n \nSkywalker\n \n}\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\n\u53ef\u63d2\u62d4\n\n\nSchema\u4e5f\u662f\n\u53ef\u63d2\u62d4\n\uff0c\u5b83\u5141\u8bb8\u6211\u4eec\u5c06\u53ef\u91cd\u7528\u7684\u7279\u6027\u6253\u5305\u6210\u53ef\u4e0e\u793e\u533a\u5171\u4eab\u6216\u53ea\u5728\u60a8\u7684\u9879\u76ee\u4e4b\u95f4\u5171\u4eab\u7684\u63d2\u4ef6\u3002\n\n\n\u63a5\u4e0b\u6765\n\n\n\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u6a21\u5f0f\uff0c\u6211\u4eec\u6765\u770b\u770b\n\u6a21\u5f0f\u7c7b\u578b\n.", 
            "title": "\u6a21\u5f0f\u624b\u518c"
        }, 
        {
            "location": "/schema/guide/#_1", 
            "text": "Source  If you haven't yet done so, please take a minute to read the  quickstart  to get an idea of how Mongoose works. If you are migrating from 4.x to 5.x please take a moment to read the  migration guide .", 
            "title": "\u6a21\u5f0f"
        }, 
        {
            "location": "/schema/guide/#_2", 
            "text": "Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.       var   mongoose   =   require ( mongoose ); \n     var   Schema   =   mongoose . Schema ; \n\n     var   blogSchema   =   new   Schema ({ \n     title :    String , \n     author :   String , \n     body :     String , \n     comments :   [{   body :   String ,   date :   Date   }], \n     date :   {   type :   Date ,   default :   Date . now   }, \n     hidden :   Boolean , \n     meta :   { \n         votes :   Number , \n         favs :    Number \n     } \n     });   If you want to add additional keys later, use the  Schema#add  method.  Each key in our code  blogSchema  defines a property in our documents which will be cast to its associated  SchemaType . For example, we've defined a property  title  which will be cast to the  String  SchemaType and property  date  which will be cast to a  Date  SchemaType. Keys may also be assigned nested objects containing further key/type definitions like the  meta  property above.  The permitted SchemaTypes are:   String  Number  Date  Buffer  Boolean  Mixed  ObjectId  Array   Read more about  SchemaTypes here .  Schemas not only define the structure of your document and casting of properties, they also define document [instance methods][8], [static Model methods][9], [compound indexes][10], and document lifecycle hooks called  middleware", 
            "title": "\u5b9a\u4e49\u4f60\u7684\u6a21\u5f0f"
        }, 
        {
            "location": "/schema/guide/#_3", 
            "text": "To use our schema definition, we need to convert our  blogSchema  into a  Model  we can work with. To do so, we pass it into  mongoose.model(modelName, schema) :       var   Blog   =   mongoose . model ( Blog ,   blogSchema );", 
            "title": "\u521b\u5efa\u4e00\u4e2a\u6a21\u5f0f"
        }, 
        {
            "location": "/schema/guide/#_4", 
            "text": "Instances of  Models  are  documents . Documents have many of their own  built-in instance methods . We may also define our own custom document instance methods too.     var   animalSchema   =   new   Schema ( {   name :   String ,   type :   String   } ); \n\n   animalSchema . methods . findSimilarTypes   =   function ( cb )   { \n     return   this.model( Animal ).find({   type :   this . type   } ,   cb ); \n   } ;   Now all of our  animal  instances have a  findSimilarTypes  method available to them.     var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n   var   dog   =   new   Animal ( {   type :   dog   } ); \n\n   dog . findSimilarTypes ( function ( err ,   dogs )   { \n     console.log(dogs) ; \n   } );    Overwriting a default mongoose document method may lead to unpredictable results. See  this  for more details.  Do  not  declare methods using ES6 arrow functions ( = ). Arrow functions  explicitly prevent binding  this , so your method will  not  have access to the document and the above examples will not work.", 
            "title": "\u5b9e\u4f8b\u65b9\u6cd5"
        }, 
        {
            "location": "/schema/guide/#_5", 
            "text": "Adding static methods to a  Model  is simple as well. Continuing with our  animalSchema :     animalSchema . statics . findByName   =   function ( name ,   cb )   { \n     return   this.find({   name :   new   RegExp ( name ,   i )   } ,   cb ); \n   } ; \n\n   var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n   Animal . findByName ( fido ,   function ( err ,   animals )   { \n     console.log(animals) ; \n   } );   Do  not  declare statics using ES6 arrow functions ( = ). Arrow functions  explicitly prevent binding  this , so the above examples will not work because of the value of  this .", 
            "title": "\u9759\u6001\u65b9\u6cd5"
        }, 
        {
            "location": "/schema/guide/#_6", 
            "text": "You can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's  chainable query builder API .     animalSchema . query . byName   =   function ( name )   { \n     return   this.find({   name :   new   RegExp ( name ,   i )   } ); \n   } ; \n\n   var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n   Animal . find () . byName ( fido ) . exec ( function ( err ,   animals )   { \n     console.log(animals) ; \n   } );", 
            "title": "\u67e5\u8be2\u52a9\u624b"
        }, 
        {
            "location": "/schema/guide/#_7", 
            "text": "MongoDB supports  secondary indexes . With mongoose, we define these indexes within our  Schema   at   the   path   level  or the  schema  level. Defining indexes at the schema level is necessary when creating  compound indexes .     var   animalSchema   =   new   Schema ( { \n     name :   String , \n     type :   String , \n     tags :   {   type :   [ String ] ,   index :   true   } \n   } ); \n\n   animalSchema . index ( {   name :   1 ,   type :   -1   } );   When your application starts up, Mongoose automatically calls  createIndex  for each defined index in your schema. Mongoose will call  createIndex  for each index sequentially, and emit an 'index' event on the model when all the  createIndex  calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a  significant performance impact . Disable the behavior by setting the  autoIndex  option of your schema to  false , or globally on the connection by setting the option  autoIndex  to  false .     mongoose . connect ( mongodb://user:pass@localhost:port/database ,   {   autoIndex :   false   } ); \n\n   mongoose . createConnection ( mongodb://user:pass@localhost:port/database ,   {   autoIndex :   false   } ); \n\n   animalSchema . set ( autoIndex ,   false ); \n\n   new   Schema ( { .. } ,   {   autoIndex :   false   } );   Mongoose will emit an  index  event on the model when indexes are done building or an error occurred.     animalSchema . index ( {   _id :   1   } ,   {   sparse :   true   } ); \n   var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n\n   Animal . on ( index ,   function ( error )   { \n\n     console.log(error.message) ; \n   } );   See also the  Model#ensureIndexes  method.", 
            "title": "\u7d22\u5f15"
        }, 
        {
            "location": "/schema/guide/#_8", 
            "text": "Virtuals  are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage.    var personSchema = new Schema({\n    name: {\n      first: String,\n      last: String\n    }\n  });\n\n  var Person = mongoose.model( Person , personSchema);\n\n  var axl = new Person({\n    name: { first:  Axl , last:  Rose  }\n  });  Suppose you want to print out the person's full name. You could do it yourself:  console.log(axl.name.first +     + axl.name.last);  But concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like  removing diacritics? . A  virtual property getter  lets you  define a  fullName  property that won't get persisted to MongoDB.  personSchema.virtual( fullName ).get(function () {\n  return this.name.first +     + this.name.last;\n});  Now, mongoose will call your getter function every time you access the  fullName  property:  console.log(axl.fullName);  If you use  toJSON()  or  toObject()  (or use  JSON.stringify()  on a mongoose document) mongoose will  not  include virtuals by default. Pass  { virtuals: true }  to either  toObject()  or  toJSON() .  You can also add a custom setter to your virtual that will let you set both first name and last name via the  fullName  virtual.  personSchema.virtual( fullName ).\n  get(function() { return this.name.first +     + this.name.last; }).\n  set(function(v) {\n    this.name.first = v.substr(0, v.indexOf(   ));\n    this.name.last = v.substr(v.indexOf(   ) + 1);\n  });\n\naxl.fullName =  William Rose ;  Virtual property setters are applied before other validation. So the example above would still work even if the  first  and  last  name fields were required.  Only non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.", 
            "title": "\u865a\u62df\u5b57\u6bb5"
        }, 
        {
            "location": "/schema/guide/#_9", 
            "text": "Aliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability.  var   personSchema   =   new   Schema ( { \n   n :   { \n     type :   String , \n\n     alias :   name \n   }  } );  var   person   =   new   Person ( {   name :   Val   } );  console . log ( person );  console . log ( person . toObject ( {   virtuals :   true   } ));  console . log ( person . name );  person . name   =   Not Val ;  console . log ( person );", 
            "title": "\u522b\u540d"
        }, 
        {
            "location": "/schema/guide/#_10", 
            "text": "Schemas have a few configurable options which can be passed to the constructor or  set  directly:  new Schema({..}, options);\n\nvar schema = new Schema({..});\nschema.set(option, value);  Valid options:", 
            "title": "\u9009\u9879"
        }, 
        {
            "location": "/schema/guide/#autoindex", 
            "text": "At application startup, Mongoose sends a  createIndex  command  for each index declared in your  Schema . As of Mongoose v3, indexes are created in the  background  by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your  Schema s  autoIndex  option to  false  and use the  ensureIndexes  method on your model.  var   schema   =   new   Schema ( { .. } ,   {   autoIndex :   false   } );  var   Clock   =   mongoose . model ( Clock ,   schema );  Clock . ensureIndexes ( callback );", 
            "title": "autoIndex"
        }, 
        {
            "location": "/schema/guide/#buffercommands", 
            "text": "By default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set  bufferCommands  to false.  var   schema   =   new   Schema ( { .. } ,   {   bufferCommands :   false   } );   The schema  bufferCommands  option overrides the global  bufferCommands  option.  mongoose . set ( bufferCommands ,   true );  var   schema   =   new   Schema ( { .. } ,   {   bufferCommands :   false   } );", 
            "title": "bufferCommands"
        }, 
        {
            "location": "/schema/guide/#capped", 
            "text": "Mongoose supports MongoDBs  capped  collections. To specify the underlying MongoDB collection be  capped , set the  capped  option to the maximum size of the collection in  bytes .  new   Schema ( { .. } ,   {   capped :   1024   } );   The  capped  option may also be set to an object if you want to pass additional options like  max  or  autoIndexId . In this case you must explicitly pass the  size  option, which is required.  new   Schema ( { .. } ,   {   capped :   {   size :   1024 ,   max :   1000 ,   autoIndexId :   true   }   } );", 
            "title": "capped"
        }, 
        {
            "location": "/schema/guide/#collection", 
            "text": "Mongoose by default produces a collection name by passing the model name to the  utils.toCollectionName  method. This method pluralizes the name. Set this option if you need a different name for your collection.  var   dataSchema   =   new   Schema ( { .. } ,   {   collection :   data   } );", 
            "title": "collection"
        }, 
        {
            "location": "/schema/guide/#id", 
            "text": "Mongoose assigns each of your schemas an  id  virtual getter by default which returns the documents  _id  field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an  id  getter added to your schema, you may disable it passing this option at schema construction time.  var   schema   =   new   Schema ( {   name :   String   } );  var   Page   =   mongoose . model ( Page ,   schema );  var   p   =   new   Page ( {   name :   mongodb.org   } );  console . log ( p . id );  var   schema   =   new   Schema ( {   name :   String   } ,   {   id :   false   } );  var   Page   =   mongoose . model ( Page ,   schema );  var   p   =   new   Page ( {   name :   mongodb.org   } );  console . log ( p . id );", 
            "title": "id"
        }, 
        {
            "location": "/schema/guide/#_id", 
            "text": "Mongoose assigns each of your schemas an  _id  field by default if one is not passed into the  Schema  constructor. The type assigned is an  ObjectId  to coincide with MongoDB's default behavior. If you don't want an  _id  added to your schema at all, you may disable it using this option.  You can  only  use this option on sub-documents. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an  _id .  var   schema   =   new   Schema ( {   name :   String   } );  var   Page   =   mongoose . model ( Page ,   schema );  var   p   =   new   Page ( {   name :   mongodb.org   } );  console . log ( p );  var   childSchema   =   new   Schema ( {   name :   String   } ,   {   _id :   false   } );  var   parentSchema   =   new   Schema ( {   children :   [ childSchema ]   } );  var   Model   =   mongoose . model ( Model ,   parentSchema );  Model . create ( {   children :   [ {   name :   Luke   } ]   } ,   function ( error ,   doc )   {  } );", 
            "title": "_id"
        }, 
        {
            "location": "/schema/guide/#minimize", 
            "text": "Mongoose will, by default, \"minimize\" schemas by removing empty objects.  var   schema   =   new   Schema ( {   name :   String ,   inventory :   { }   } );  var   Character   =   mongoose . model ( Character ,   schema );  var   frodo   =   new   Character ( {   name :   Frodo ,   inventory :   {   ringOfPower :   1   } } );  Character . findOne ( {   name :   Frodo   } ,   function ( err ,   character )   { \n   console.log(character) ;  } );  var   sam   =   new   Character ( {   name :   Sam ,   inventory :   { } } );  Character . findOne ( {   name :   Sam   } ,   function ( err ,   character )   { \n   console.log(character) ;  } );   This behavior can be overridden by setting  minimize  option to  false . It will then store empty objects.  var   schema   =   new   Schema ( {   name :   String ,   inventory :   { }   } ,   {   minimize :   false   } );  var   Character   =   mongoose . model ( Character ,   schema );  var   sam   =   new   Character ( {   name :   Sam ,   inventory :   { } } );  Character . findOne ( {   name :   Sam   } ,   function ( err ,   character )   { \n   console.log(character) ;  } );", 
            "title": "minimize"
        }, 
        {
            "location": "/schema/guide/#read", 
            "text": "Allows setting  query#read  options at the schema level, providing us a way to apply default  ReadPreferences  to all queries derived from a model.  var   schema   =   new   Schema ( { .. } ,   {   read :   primary   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   primaryPreferred   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   secondary   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   secondaryPreferred   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   nearest   } );   The alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.  The read option also allows us to specify  tag sets . These tell the  driver  from which members of the replica-set it should attempt to read. Read more about tag sets  here  and  here .  NOTE: you may also specify the driver read pref  strategy  option when connecting:  var   options   =   {   replset :   {   strategy :   ping   } } ;  mongoose . connect ( uri ,   options );  var   schema   =   new   Schema ( { .. } ,   {   read :   [ nearest ,   {   disk :   ssd   } ]   } );  mongoose . model ( JellyBean ,   schema );", 
            "title": "read"
        }, 
        {
            "location": "/schema/guide/#shardkey", 
            "text": "The  shardKey  option is used when we have a  sharded MongoDB architecture . Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we'll be all set.  new Schema({ .. }, { shardKey: { tag: 1, name: 1 }})  Note that Mongoose does not send the  shardcollection  command for you. You must configure your shards yourself.", 
            "title": "shardKey"
        }, 
        {
            "location": "/schema/guide/#strict", 
            "text": "The strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.  var   thingSchema   =   new   Schema ( { .. } )  var   Thing   =   mongoose . model ( Thing ,   thingSchema );  var   thing   =   new   Thing ( {   iAmNotInTheSchema :   true   } );  thing . save ();  var   thingSchema   =   new   Schema ( { .. } ,   {   strict :   false   } );  var   thing   =   new   Thing ( {   iAmNotInTheSchema :   true   } );  thing . save ();   This also affects the use of  doc.set()  to set a property value.  var thingSchema = new Schema({..})\nvar Thing = mongoose.model( Thing , thingSchema);\nvar thing = new Thing;\nthing.set( iAmNotInTheSchema , true);\nthing.save();  This value can be overridden at the model instance level by passing a second boolean argument:  var Thing = mongoose.model( Thing );\nvar thing = new Thing(doc, true);\nvar thing = new Thing(doc, false);  The  strict  option may also be set to  \"throw\"  which will cause errors to be produced instead of dropping the bad data.  NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.  var thingSchema = new Schema({..})\nvar Thing = mongoose.model( Thing , thingSchema);\nvar thing = new Thing;\nthing.iAmNotInTheSchema = true;\nthing.save();", 
            "title": "strict"
        }, 
        {
            "location": "/schema/guide/#tojson", 
            "text": "Exactly the same as the [toObject][60] option but only applies when the documents  toJSON  method is called.  var   schema   =   new   Schema ( {   name :   String   } );  schema . path ( name ) . get ( function   ( v )   { \n   return   v   +     is   my   name ;  } );  schema . set ( toJSON ,   {   getters :   true ,   virtuals :   false   } );  var   M   =   mongoose . model ( Person ,   schema );  var   m   =   new   M ( {   name :   Max Headroom   } );  console . log ( m . toObject ());  console . log ( m . toJSON ());  console . log ( JSON . stringify ( m ));   To see all available  toJSON/toObject  options, read  this .", 
            "title": "toJSON"
        }, 
        {
            "location": "/schema/guide/#toobject", 
            "text": "Documents have a  toObject  method which converts the mongoose document into a plain javascript object. This method accepts a few options. Instead of applying these options on a per-document basis we may declare the options here and have it applied to all of this schemas documents by default.  To have all virtuals show up in your  console.log  output, set the  toObject  option to  { getters: true } :  var   schema   =   new   Schema ( {   name :   String   } );  schema . path ( name ) . get ( function   ( v )   { \n   return   v   +     is   my   name ;  } );  schema . set ( toObject ,   {   getters :   true   } );  var   M   =   mongoose . model ( Person ,   schema );  var   m   =   new   M ( {   name :   Max Headroom   } );  console . log ( m );   To see all available  toObject  options, read  this .", 
            "title": "toObject"
        }, 
        {
            "location": "/schema/guide/#typekey", 
            "text": "By default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration.  var   schema   =   new   Schema ( {   loc :   {   type :   String ,   coordinates :   [ Number ]   }   } );   However, for applications like  geoJSON , the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option.  var   schema   =   new   Schema ( { \n\n   loc :   {   type :   String ,   coordinates :   [ Number ]   } , \n\n   name :   {   $ type :   String   }  } ,   {   typeKey :   $type   } );", 
            "title": "typeKey"
        }, 
        {
            "location": "/schema/guide/#validatebeforesave", 
            "text": "By default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set  validateBeforeSave  to false.  var   schema   =   new   Schema ( {   name :   String   } );  schema . set ( validateBeforeSave ,   false );  schema . path ( name ) . validate ( function   ( value )   { \n     return   v   !=   null ;  } );  var   M   =   mongoose . model ( Person ,   schema );  var   m   =   new   M ( {   name :   null   } );  m . validate ( function ( err )   { \n     console.log(err) ;  } );  m . save ();", 
            "title": "validateBeforeSave"
        }, 
        {
            "location": "/schema/guide/#versionkey", 
            "text": "The  versionKey  is a property set on each document when first created by Mongoose. This keys value contains the internal  revision  of the document. The  versionKey  option is a string that represents the path to use for versioning. The default is  __v . If this conflicts with your application you can configure as such:  var   schema   =   new   Schema ( {   name :   string   } );  var   Thing   =   mongoose . model ( Thing ,   schema );  var   thing   =   new   Thing ( {   name :   mongoose v3   } );  thing . save ();  new   Schema ( { .. } ,   {   versionKey :   _somethingElse   } )  var   Thing   =   mongoose . model ( Thing ,   schema );  var   thing   =   new   Thing ( {   name :   mongoose v3   } );  thing . save ();   Document versioning can also be disabled by setting the  versionKey  to  false .  DO NOT disable versioning unless you  know what you are doing .  new   Schema ( { .. } ,   {   versionKey :   false   } );  var   Thing   =   mongoose . model ( Thing ,   schema );  var   thing   =   new   Thing ( {   name :   no versioning please   } );  thing . save ();", 
            "title": "versionKey"
        }, 
        {
            "location": "/schema/guide/#collation", 
            "text": "Sets a default  collation  for every query and aggregation.  Here's a beginner-friendly overview of collations .  var   schema   =   new   Schema ( { \n   name :   String  } ,   {   collation :   {   locale :   en_US ,   strength :   1   }   } );  var   MyModel   =   db . model ( MyModel ,   schema );  MyModel . create ( [ {   name :   val   },   {   name :   Val   } ] ). \n   then ( function ()   { \n     return   MyModel.find({   name :   val   } ); \n   } ). \n   then ( function ( docs )   { \n\n   } );", 
            "title": "collation"
        }, 
        {
            "location": "/schema/guide/#skipversioning", 
            "text": "skipVersioning  allows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For sub-documents, include this on the parent document using the fully qualified path.  new   Schema ( { .. } ,   {   skipVersioning :   {   dontVersionMe :   true   }   } );  thing . dontVersionMe . push ( hey );  thing . save ();", 
            "title": "skipVersioning"
        }, 
        {
            "location": "/schema/guide/#timestamps", 
            "text": "If set  timestamps , mongoose assigns  createdAt  and  updatedAt  fields to your schema, the type assigned is  Date .  By default, the name of two fields are  createdAt  and  updatedAt , customize the field name by setting  timestamps.createdAt  and  timestamps.updatedAt .  var   thingSchema   =   new   Schema ( { .. } ,   {   timestamps :   {   createdAt :   created_at   }   } );  var   Thing   =   mongoose . model ( Thing ,   thingSchema );  var   thing   =   new   Thing ();  thing . save ();", 
            "title": "timestamps"
        }, 
        {
            "location": "/schema/guide/#usenestedstrict", 
            "text": "In mongoose 4,  update()  and  findOneAndUpdate()  only check the top-level schema's strict mode setting.  var   childSchema   =   new   Schema ( {} ,   {   strict :   false   } );  var   parentSchema   =   new   Schema ( {   child :   childSchema   } ,   {   strict :   throw   } );  var   Parent   =   mongoose . model ( Parent ,   parentSchema );  Parent . update ( {} ,   {   child.name :   Luke   Skywalker   } ,   function ( error )   {  } );  var   update   =   {   child.name :   Luke   Skywalker   } ;  var   opts   =   {   strict :   false   } ;  Parent . update ( {} ,   update ,   opts ,   function ( error )   {  } );   If you set  useNestedStrict  to true, mongoose will use the child schema's  strict  option for casting updates.  var   childSchema   =   new   Schema ( {} ,   {   strict :   false   } );  var   parentSchema   =   new   Schema ( {   child :   childSchema   } , \n   {   strict :   throw ,   useNestedStrict :   true   } );  var   Parent   =   mongoose . model ( Parent ,   parentSchema );  Parent . update ( {} ,   {   child.name :   Luke   Skywalker   } ,   function ( error )   {  } );", 
            "title": "useNestedStrict"
        }, 
        {
            "location": "/schema/guide/#_11", 
            "text": "Schema\u4e5f\u662f \u53ef\u63d2\u62d4 \uff0c\u5b83\u5141\u8bb8\u6211\u4eec\u5c06\u53ef\u91cd\u7528\u7684\u7279\u6027\u6253\u5305\u6210\u53ef\u4e0e\u793e\u533a\u5171\u4eab\u6216\u53ea\u5728\u60a8\u7684\u9879\u76ee\u4e4b\u95f4\u5171\u4eab\u7684\u63d2\u4ef6\u3002", 
            "title": "\u53ef\u63d2\u62d4"
        }, 
        {
            "location": "/schema/guide/#_12", 
            "text": "\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u6a21\u5f0f\uff0c\u6211\u4eec\u6765\u770b\u770b \u6a21\u5f0f\u7c7b\u578b .", 
            "title": "\u63a5\u4e0b\u6765"
        }, 
        {
            "location": "/schema/api/", 
            "text": "\u6a21\u5f0f\n\n\nSchema()\n\n\n\u53c2\u6570\n\n\n\u6a21\u5f0f\u6784\u9020\u51fd\u6570\n\n\n\u793a\u4f8b\n\n\nvar\n \nchild\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \nage\n:\n \nNumber\n,\n \nchildren\n:\n \n[\nchild\n]\n \n}\n);\n\n\nvar\n \nTree\n \n=\n \nmongoose\n.\nmodel\n(\nTree\n,\n \nschema\n);\n\n\n\n\nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \n_id\n:\n \nfalse\n,\n \nautoIndex\n:\n \nfalse\n \n}\n)\n\n\n\n\n\n\n\u9009\u9879\n\n\n\u6ce8\u610f\n\n\nWhen nesting schemas, (\nchildren\n in the \u793a\u4f8b above), always declare the child schema first before passing it into its parent.\n\n\nSchema.prototype.childSchemas\n\n\nArray of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: \nschema\n and \nmodel\n.\n\n\nThis property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.\n\n\nSchema.prototype.obj\n\n\nThe original object passed to the schema constructor\n\n\n\u793a\u4f8b\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \na\n:\n \nString\n \n}\n)\n.\nadd\n(\n{\n \nb\n:\n \nString\n \n}\n);\n\n\nschema\n.\nobj\n;\n\n\n\n\n\n\nSchema.prototype.clone()\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abSchema\u00bb the cloned schema\n\n\n\n\n\u8fd4\u56de a deep copy of the schema\n\n\nSchema.prototype.add()\n\n\n\u53c2\u6570\n\n\nAdds key path / schema type pairs to this schema.\n\n\n\u793a\u4f8b\n\n\nvar\n \nToySchema\n \n=\n \nnew\n \nSchema\n;\n\n\nToySchema\n.\nadd\n(\n{\n \nname\n:\n \nstring\n,\n \ncolor\n:\n \nstring\n,\n \nprice\n:\n \nnumber\n \n}\n);\n\n\n\n\n\n\nSchema.reserved\n\n\nReserved document keys.\n\n\nKeys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.\n\n\non, emit, _events, db, get, set, init, isNew, errors, schema, \u9009\u9879, modelName, collection, _pres, _posts, toObject\n\n\n\n\n\n\u6ce8\u610f:\n Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n\n\nvar schema = new Schema(..);\n schema.methods.init = function () {}\n\n\n\n\n\nSchema.prototype.path()\n\n\n\u53c2\u6570\n\n\nGets/sets schema paths.\n\n\nSets a path (if arity 2) Gets a path (if arity 1)\n\n\n\u793a\u4f8b\n\n\nschema.path(\nname\n)\nschema.path(\nname\n, Number)\n\n\n\n\n\nSchema.prototype.eachPath()\n\n\n\u53c2\u6570\n\n\n\n\nfn \u00abFunction\u00bb callback function\n\n\n\n\n\u8fd4\u56de\n\n\nIterates the schemas paths similar to Array#forEach.\n\n\nThe callback is passed the pathname and schemaType as arguments on each iteration.\n\n\nSchema.prototype.requiredPaths()\n\n\n\u53c2\u6570\n\n\n\n\ninvalidate \u00abBoolean\u00bb refresh the cache\n\n\n\n\n\u8fd4\u56de\n\n\n\u8fd4\u56de an Array of path strings that are required by this schema.\n\n\nSchema.prototype.pathType()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\n\u8fd4\u56de the pathType of \npath\n for this schema.\n\n\nGiven a path, \u8fd4\u56de whether it is a real, virtual, nested, or ad-hoc/undefined path.\n\n\nSchema.prototype.queue()\n\n\n\u53c2\u6570\n\n\n\n\nargs \u00abArray\u00bb arguments to pass to the method\n\n\n\n\nAdds a method call to the queue.\n\n\nSchema.prototype.pre()\n\n\n\u53c2\u6570\n\n\nDefines a pre hook for the document.\n\n\n\u793a\u4f8b\n\n\nvar toySchema = new Schema(..);\n\ntoySchema.pre(\nsave\n, function (next) {\n  if (!this.created) this.created = new Date;\n  next();\n})\n\ntoySchema.pre(\nvalidate\n, function (next) {\n  if (this.name !== \nWoody\n) this.name = \nWoody\n;\n  next();\n})\n\n\n\n\n\nSchema.prototype.post()\n\n\n\u53c2\u6570\n\n\nDefines a post hook for the document\n\n\nvar schema = new Schema(..);\nschema.post(\nsave\n, function (doc) {\n  console.log(\nthis fired after a document was saved\n);\n});\n\nschema.post(\nfind\n, function(docs) {\n  console.log(\nthis fired after you run a find query\n);\n});\n\nvar Model = mongoose.model(\nModel\n, schema);\n\nvar m = new Model(..);\nm.save(function(err) {\n  console.log(\nthis fires after the `post` hook\n);\n});\n\nm.find(function(err, docs) {\n  console.log(\nthis fires after the post find hook\n);\n});\n\n\n\n\n\nSchema.prototype.plugin()\n\n\n\u53c2\u6570\n\n\nRegisters a plugin for this schema.\n\n\nSchema.prototype.method()\n\n\n\u53c2\u6570\n\n\nAdds an instance method to documents constructed from Models compiled from this schema.\n\n\n\u793a\u4f8b\n\n\nvar schema = kittySchema = new Schema(..);\n\nschema.method(\nmeow\n, function () {\n  console.log(\nmeeeeeoooooooooooow\n);\n})\n\nvar Kitty = mongoose.model(\nKitty\n, schema);\n\nvar fizz = new Kitty;\nfizz.meow();\n\n\n\n\n\nIf a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n\n\nschema.method({\n    purr: function () {}\n  , scratch: function () {}\n});\n\n\nfizz.purr();\nfizz.scratch();\n\n\n\n\n\nSchema.prototype.static()\n\n\n\u53c2\u6570\n\n\nAdds static \"class\" methods to Models compiled from this schema.\n\n\n\u793a\u4f8b\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(..);\n\n\nschema\n.\nstatic\n(\nfindByName\n,\n \nfunction\n \n(\nname\n,\n \ncallback\n)\n \n{\n\n  \nreturn\n \nthis.find({\n \nname\n:\n \nname\n \n}\n,\n \ncallback\n);\n\n\n}\n);\n\n\n\nvar\n \nDrink\n \n=\n \nmongoose\n.\nmodel\n(\nDrink\n,\n \nschema\n);\n\n\nDrink\n.\nfindByName\n(\nsanpellegrino\n,\n \nfunction\n \n(\nerr\n,\n \ndrinks\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nIf a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n\n\nSchema.prototype.index()\n\n\n\u53c2\u6570\n\n\n\n\n[\u9009\u9879.expires=null] \u00abString\u00bb Mongoose-specific syntactic sugar, uses [ms to convert \nexpires\n option into seconds for the \nexpireAfterSeconds\n in the above link.\n\n\n\n\nDefines an index (most likely compound) for this schema.\n\n\n\u793a\u4f8b\n\n\nschema.index({ first: 1, last: -1 })\n\n\n\n\n\nSchema.prototype.set()\n\n\n\u53c2\u6570\n\n\n\n\n[value] \u00abObject\u00bb if not passed, the current option value is returned\n\n\n\n\nSets/gets a schema option.\n\n\n\u793a\u4f8b\n\n\nschema.set(\nstrict\n);\nschema.set(\nstrict\n, false);\nschema.set(\nstrict\n);\n\n\n\n\n\nSchema.prototype.get()\n\n\n\u53c2\u6570\n\n\n\n\nkey \u00abString\u00bb option name\n\n\n\n\n\n\nindexTypes\n\n\nSchema.prototype.indexes()\n\n\nCompiles indexes from fields and schema-level indexes\n\n\nSchema.prototype.virtual()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nCreates a virtual type with the given name.\n\n\nSchema.prototype.virtualpath()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\n\u8fd4\u56de the virtual type with the given \nname\n.\n\n\nSchema.prototype.remove()\n\n\n\u53c2\u6570\n\n\nRemoves the given \npath\n (or [\npaths\n]).\n\n\nSchema.prototype.loadClass()\n\n\n\u53c2\u6570\n\n\nLoads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.\n\n\n\n\nSchema.Types\n\n\nThe various built-in Mongoose Schema Types.\n\n\n\u793a\u4f8b\n\n\nvar mongoose = require(\nmongoose\n);\nvar ObjectId = mongoose.Schema.Types.ObjectId;\n\n\n\n\n\n\u7c7b\u578b\n\n\nUsing this exposed access to the \nMixed\n SchemaType, we can use them in our schema.\n\n\nvar Mixed = mongoose.Schema.Types.Mixed;\nnew mongoose.Schema({ _user: Mixed })", 
            "title": "\u6a21\u5f0fAPI"
        }, 
        {
            "location": "/schema/api/#_1", 
            "text": "", 
            "title": "\u6a21\u5f0f"
        }, 
        {
            "location": "/schema/api/#schema", 
            "text": "\u53c2\u6570  \u6a21\u5f0f\u6784\u9020\u51fd\u6570  \u793a\u4f8b  var   child   =   new   Schema ( {   name :   String   } );  var   schema   =   new   Schema ( {   name :   String ,   age :   Number ,   children :   [ child ]   } );  var   Tree   =   mongoose . model ( Tree ,   schema );  new   Schema ( {   name :   String   } ,   {   _id :   false ,   autoIndex :   false   } )   \u9009\u9879  \u6ce8\u610f  When nesting schemas, ( children  in the \u793a\u4f8b above), always declare the child schema first before passing it into its parent.", 
            "title": "Schema()"
        }, 
        {
            "location": "/schema/api/#schemaprototypechildschemas", 
            "text": "Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties:  schema  and  model .  This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.", 
            "title": "Schema.prototype.childSchemas"
        }, 
        {
            "location": "/schema/api/#schemaprototypeobj", 
            "text": "The original object passed to the schema constructor  \u793a\u4f8b  var   schema   =   new   Schema ( {   a :   String   } ) . add ( {   b :   String   } );  schema . obj ;", 
            "title": "Schema.prototype.obj"
        }, 
        {
            "location": "/schema/api/#schemaprototypeclone", 
            "text": "\u8fd4\u56de   \u00abSchema\u00bb the cloned schema   \u8fd4\u56de a deep copy of the schema", 
            "title": "Schema.prototype.clone()"
        }, 
        {
            "location": "/schema/api/#schemaprototypeadd", 
            "text": "\u53c2\u6570  Adds key path / schema type pairs to this schema.  \u793a\u4f8b  var   ToySchema   =   new   Schema ;  ToySchema . add ( {   name :   string ,   color :   string ,   price :   number   } );", 
            "title": "Schema.prototype.add()"
        }, 
        {
            "location": "/schema/api/#schemareserved", 
            "text": "Reserved document keys.  Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.  on, emit, _events, db, get, set, init, isNew, errors, schema, \u9009\u9879, modelName, collection, _pres, _posts, toObject  \u6ce8\u610f:  Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.  var schema = new Schema(..);\n schema.methods.init = function () {}", 
            "title": "Schema.reserved"
        }, 
        {
            "location": "/schema/api/#schemaprototypepath", 
            "text": "\u53c2\u6570  Gets/sets schema paths.  Sets a path (if arity 2) Gets a path (if arity 1)  \u793a\u4f8b  schema.path( name )\nschema.path( name , Number)", 
            "title": "Schema.prototype.path()"
        }, 
        {
            "location": "/schema/api/#schemaprototypeeachpath", 
            "text": "\u53c2\u6570   fn \u00abFunction\u00bb callback function   \u8fd4\u56de  Iterates the schemas paths similar to Array#forEach.  The callback is passed the pathname and schemaType as arguments on each iteration.", 
            "title": "Schema.prototype.eachPath()"
        }, 
        {
            "location": "/schema/api/#schemaprototyperequiredpaths", 
            "text": "\u53c2\u6570   invalidate \u00abBoolean\u00bb refresh the cache   \u8fd4\u56de  \u8fd4\u56de an Array of path strings that are required by this schema.", 
            "title": "Schema.prototype.requiredPaths()"
        }, 
        {
            "location": "/schema/api/#schemaprototypepathtype", 
            "text": "\u53c2\u6570  \u8fd4\u56de  \u8fd4\u56de the pathType of  path  for this schema.  Given a path, \u8fd4\u56de whether it is a real, virtual, nested, or ad-hoc/undefined path.", 
            "title": "Schema.prototype.pathType()"
        }, 
        {
            "location": "/schema/api/#schemaprototypequeue", 
            "text": "\u53c2\u6570   args \u00abArray\u00bb arguments to pass to the method   Adds a method call to the queue.", 
            "title": "Schema.prototype.queue()"
        }, 
        {
            "location": "/schema/api/#schemaprototypepre", 
            "text": "\u53c2\u6570  Defines a pre hook for the document.  \u793a\u4f8b  var toySchema = new Schema(..);\n\ntoySchema.pre( save , function (next) {\n  if (!this.created) this.created = new Date;\n  next();\n})\n\ntoySchema.pre( validate , function (next) {\n  if (this.name !==  Woody ) this.name =  Woody ;\n  next();\n})", 
            "title": "Schema.prototype.pre()"
        }, 
        {
            "location": "/schema/api/#schemaprototypepost", 
            "text": "\u53c2\u6570  Defines a post hook for the document  var schema = new Schema(..);\nschema.post( save , function (doc) {\n  console.log( this fired after a document was saved );\n});\n\nschema.post( find , function(docs) {\n  console.log( this fired after you run a find query );\n});\n\nvar Model = mongoose.model( Model , schema);\n\nvar m = new Model(..);\nm.save(function(err) {\n  console.log( this fires after the `post` hook );\n});\n\nm.find(function(err, docs) {\n  console.log( this fires after the post find hook );\n});", 
            "title": "Schema.prototype.post()"
        }, 
        {
            "location": "/schema/api/#schemaprototypeplugin", 
            "text": "\u53c2\u6570  Registers a plugin for this schema.", 
            "title": "Schema.prototype.plugin()"
        }, 
        {
            "location": "/schema/api/#schemaprototypemethod", 
            "text": "\u53c2\u6570  Adds an instance method to documents constructed from Models compiled from this schema.  \u793a\u4f8b  var schema = kittySchema = new Schema(..);\n\nschema.method( meow , function () {\n  console.log( meeeeeoooooooooooow );\n})\n\nvar Kitty = mongoose.model( Kitty , schema);\n\nvar fizz = new Kitty;\nfizz.meow();  If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.  schema.method({\n    purr: function () {}\n  , scratch: function () {}\n});\n\n\nfizz.purr();\nfizz.scratch();", 
            "title": "Schema.prototype.method()"
        }, 
        {
            "location": "/schema/api/#schemaprototypestatic", 
            "text": "\u53c2\u6570  Adds static \"class\" methods to Models compiled from this schema.  \u793a\u4f8b  var   schema   =   new   Schema (..);  schema . static ( findByName ,   function   ( name ,   callback )   { \n   return   this.find({   name :   name   } ,   callback );  } );  var   Drink   =   mongoose . model ( Drink ,   schema );  Drink . findByName ( sanpellegrino ,   function   ( err ,   drinks )   {  } );   If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.", 
            "title": "Schema.prototype.static()"
        }, 
        {
            "location": "/schema/api/#schemaprototypeindex", 
            "text": "\u53c2\u6570   [\u9009\u9879.expires=null] \u00abString\u00bb Mongoose-specific syntactic sugar, uses [ms to convert  expires  option into seconds for the  expireAfterSeconds  in the above link.   Defines an index (most likely compound) for this schema.  \u793a\u4f8b  schema.index({ first: 1, last: -1 })", 
            "title": "Schema.prototype.index()"
        }, 
        {
            "location": "/schema/api/#schemaprototypeset", 
            "text": "\u53c2\u6570   [value] \u00abObject\u00bb if not passed, the current option value is returned   Sets/gets a schema option.  \u793a\u4f8b  schema.set( strict );\nschema.set( strict , false);\nschema.set( strict );", 
            "title": "Schema.prototype.set()"
        }, 
        {
            "location": "/schema/api/#schemaprototypeget", 
            "text": "\u53c2\u6570   key \u00abString\u00bb option name", 
            "title": "Schema.prototype.get()"
        }, 
        {
            "location": "/schema/api/#indextypes", 
            "text": "", 
            "title": "indexTypes"
        }, 
        {
            "location": "/schema/api/#schemaprototypeindexes", 
            "text": "Compiles indexes from fields and schema-level indexes", 
            "title": "Schema.prototype.indexes()"
        }, 
        {
            "location": "/schema/api/#schemaprototypevirtual", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Creates a virtual type with the given name.", 
            "title": "Schema.prototype.virtual()"
        }, 
        {
            "location": "/schema/api/#schemaprototypevirtualpath", 
            "text": "\u53c2\u6570  \u8fd4\u56de  \u8fd4\u56de the virtual type with the given  name .", 
            "title": "Schema.prototype.virtualpath()"
        }, 
        {
            "location": "/schema/api/#schemaprototyperemove", 
            "text": "\u53c2\u6570  Removes the given  path  (or [ paths ]).", 
            "title": "Schema.prototype.remove()"
        }, 
        {
            "location": "/schema/api/#schemaprototypeloadclass", 
            "text": "\u53c2\u6570  Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.", 
            "title": "Schema.prototype.loadClass()"
        }, 
        {
            "location": "/schema/api/#schematypes", 
            "text": "The various built-in Mongoose Schema Types.  \u793a\u4f8b  var mongoose = require( mongoose );\nvar ObjectId = mongoose.Schema.Types.ObjectId;  \u7c7b\u578b  Using this exposed access to the  Mixed  SchemaType, we can use them in our schema.  var Mixed = mongoose.Schema.Types.Mixed;\nnew mongoose.Schema({ _user: Mixed })", 
            "title": "Schema.Types"
        }, 
        {
            "location": "/schema/type/", 
            "text": "\u6a21\u5f0f\u7c7b\u578b\n\n\nSchemaType()\n\n\n\u53c2\u6570\n\n\nSchemaType constructor. Do \nnot\n instantiate \nSchemaType\n directly. Mongoose converts your schema paths into SchemaTypes automatically.\n\n\n\u793a\u4f8b\n\n\nconst\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\npath\n(\nname\n)\n \ninstanceof\n \nSchemaType\n;\n\n\n\n\n\n\nSchemaType.prototype.default()\n\n\n\u53c2\u6570\n\n\n\n\nval \u00abFunction,any\u00bb the default value\n\n\n\n\n\u8fd4\u56de\n\n\nSets a default value for this SchemaType.\n\n\n\u793a\u4f8b\n\n\nvar schema = new Schema({ n: { type: Number, default: 10 })\nvar M = db.model(\nM\n, schema)\nvar m = new M;\nconsole.log(m.n)\n\n\n\n\n\nDefaults can be either \nfunctions\n which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n\n\n\u793a\u4f8b\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \naNumber\n:\n \n{\n \ntype\n:\n \nNumber\n,\n \ndefault\n:\n \n4.815162342\n \n}\n}\n)\n\n\nvar\n \nM\n \n=\n \ndb\n.\nmodel\n(\nM\n,\n \nschema\n)\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n;\n\n\nconsole\n.\nlog\n(\nm\n.\naNumber\n)\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nmixed\n:\n \nSchema\n.\nTypes\n.\nMixed\n \n}\n);\n\n\nschema\n.\npath\n(\nmixed\n)\n.\ndefault\n(\nfunction\n \n()\n \n{\n\n  \nreturn\n \n{\n}\n;\n\n\n}\n);\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nmixed\n:\n \nSchema\n.\nTypes\n.\nMixed\n \n}\n);\n\n\nschema\n.\npath\n(\nmixed\n)\n.\ndefault\n(\n{}\n);\n\n\nvar\n \nM\n \n=\n \ndb\n.\nmodel\n(\nM\n,\n \nschema\n);\n\n\nvar\n \nm1\n \n=\n \nnew\n \nM\n;\n\n\nm1\n.\nmixed\n.\nadded\n \n=\n \n1\n;\n\n\nconsole\n.\nlog\n(\nm1\n.\nmixed\n);\n\n\nvar\n \nm2\n \n=\n \nnew\n \nM\n;\n\n\nconsole\n.\nlog\n(\nm2\n.\nmixed\n);\n\n\n\n\n\n\nSchemaType.prototype.index()\n\n\n\u53c2\u6570\n\n\n\n\noptions \u00abObject,Boolean,String\u00bb\n\n\n\n\n\u8fd4\u56de\n\n\nDeclares the index options for this schematype.\n\n\n\u793a\u4f8b\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nindex\n:\n \ntrue\n \n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \n[\nNumber\n]\n,\n \nindex\n:\n \nhashed\n \n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \n[\nNumber\n]\n,\n \nindex\n:\n \n2d\n,\n \nsparse\n:\n \ntrue\n \n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \n[\nNumber\n]\n,\n \nindex\n:\n \n{\n \ntype\n:\n \n2dsphere\n,\n \nsparse\n:\n \ntrue\n \n}\n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \ndate\n:\n \n{\n \ntype\n:\n \nDate\n,\n \nindex\n:\n \n{\n \nunique\n:\n \ntrue\n,\n \nexpires\n:\n \n1d\n \n}\n}\n)\n\n\nSchema\n.\npath\n(\nmy.path\n)\n.\nindex\n(\ntrue\n);\n\n\nSchema\n.\npath\n(\nmy.date\n)\n.\nindex\n(\n{\n \nexpires\n:\n \n60\n \n}\n);\n\n\nSchema\n.\npath\n(\nmy.path\n)\n.\nindex\n(\n{\n \nunique\n:\n \ntrue\n,\n \nsparse\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\n\u6ce8\u91ca\n\n\nIndexes are created in the background by default. Specify \nbackground: false\n to override.\n\n\n[Direction doesn't matter for single key indexes\n\n\nSchemaType.prototype.unique()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDeclares an unique index.\n\n\n\u793a\u4f8b\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nunique\n:\n \ntrue\n \n}\n}\n);\n\n\nSchema\n.\npath\n(\nname\n)\n.\nindex\n(\n{\n \nunique\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\nNOTE: violating the constraint returns an \nE11000\n error from MongoDB when saving, not a Mongoose validation error.\n\n\nSchemaType.prototype.text()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDeclares a full text index.\n\n\n\u793a\u4f8b\n\n\nvar s = new Schema({name : {type: String, text : true })\n Schema.path(\nname\n).index({text : true});\n\n\n\n\n\nSchemaType.prototype.sparse()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDeclares a sparse index.\n\n\n\u793a\u4f8b\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nsparse\n:\n \ntrue\n \n}\n)\n\n\nSchema\n.\npath\n(\nname\n)\n.\nindex\n(\n{\n \nsparse\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\nSchemaType.prototype.set()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nAdds a setter to this schematype.\n\n\n\u793a\u4f8b\n\n\nfunction\n \ncapitalize\n \n(\nval\n)\n \n{\n\n  \nif\n \n(\ntypeof\n \nval\n \n!==\n \nstring\n)\n \nval\n \n=\n \n;\n\n  \nreturn\n \nval\n.\ncharAt\n(\n0\n).\ntoUpperCase\n()\n \n+\n \nval\n.\nsubstring\n(\n1\n);\n\n\n}\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nset\n: \ncapitalize\n \n}})\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nname\n: \nString\n \n})\n\n\ns\n.\npath\n(\nname\n).\nset\n(\ncapitalize\n)\n\n\n\n\n\n\nSetters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.\n\n\nSuppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, [avenue@q.com can be registered for 2 accounts via [avenue@q.com and [AvEnUe@Q.CoM.\n\n\nYou can set up email lower case normalization easily via a Mongoose setter.\n\n\nfunction\n \ntoLower\n(\nv\n)\n \n{\n\n  \nreturn\n \nv\n.\ntoLowerCase\n();\n\n\n}\n\n\n\nvar\n \nUserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nemail\n:\n \n{\n \ntype\n: \nString\n,\n \nset\n: \ntoLower\n \n}\n\n\n});\n\n\n\nvar\n \nUser\n \n=\n \ndb\n.\nmodel\n(\nUser\n,\n \nUserSchema\n);\n\n\n\nvar\n \nuser\n \n=\n \nnew\n \nUser\n({\nemail\n:\n \n[AVENUE@Q.COM\n});\n\n\nconsole\n.\nlog\n(\nuser\n.\nemail\n);\n \n// \n[avenue@q.com\n\n\n\n// or\n\n\nvar\n \nuser\n \n=\n \nnew\n \nUser\n();\n\n\nuser\n.\nemail\n \n=\n \n[Avenue@Q.com\n;\n\n\nconsole\n.\nlog\n(\nuser\n.\nemail\n);\n \n// \n[avenue@q.com\n\n\nUser\n.\nupdateOne\n({\n \n_id\n: \n_id\n \n},\n \n{\n \n$set\n:\n \n{\n \nemail\n:\n \n[AVENUE@Q.COM\n \n}\n \n});\n \n// update to \n[avenue@q.com\n\n\n\n\n\n\nAs you can see above, setters allow you to transform the data before it stored in MongoDB.\n\n\nNOTE: we could have also just used the built-in \nlowercase: true\n SchemaType option instead of defining our own function.\n\n\nnew Schema({ email: { type: String, lowercase: true }})\n\n\n\n\n\nSetters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n\n\nfunction\n \ninspector\n \n(\nval\n,\n \nschematype\n)\n \n{\n\n  \nif\n \n(\nschematype\n.\noptions\n.\nrequired\n)\n \n{\n\n    \nreturn\n \nschematype\n.\npath\n \n+\n \n is required\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nval\n;\n\n  \n}\n\n\n}\n\n\n\nvar\n \nVirusSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nrequired\n: \ntrue\n,\n \nset\n: \ninspector\n \n},\n\n  \ntaxonomy\n:\n \n{\n \ntype\n: \nString\n,\n \nset\n: \ninspector\n \n}\n\n\n})\n\n\n\nvar\n \nVirus\n \n=\n \ndb\n.\nmodel\n(\nVirus\n,\n \nVirusSchema\n);\n\n\nvar\n \nv\n \n=\n \nnew\n \nVirus\n({\n \nname\n:\n \nParvoviridae\n,\n \ntaxonomy\n:\n \nParvovirinae\n \n});\n\n\n\nconsole\n.\nlog\n(\nv\n.\nname\n);\n\n\nconsole\n.\nlog\n(\nv\n.\ntaxonomy\n);\n\n\n\n\n\n\nSchemaType.prototype.get()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nAdds a getter to this schematype.\n\n\n\u793a\u4f8b\n\n\nfunction\n \ndob\n \n(\nval\n)\n \n{\n\n  \nif\n \n(\n!\nval\n)\n \nreturn\n \nval\n;\n\n  \nreturn\n \n(\nval\n.\ngetMonth\n()\n \n+\n \n1\n)\n \n+\n \n/\n \n+\n \nval\n.\ngetDate\n()\n \n+\n \n/\n \n+\n \nval\n.\ngetFullYear\n();\n\n\n}\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nborn\n:\n \n{\n \ntype\n: \nDate\n,\n \nget\n: \ndob\n \n})\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nborn\n: \nDate\n \n})\n\n\ns\n.\npath\n(\nborn\n).\nget\n(\ndob\n)\n\n\n\n\n\n\nGetters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n\n\nSuppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n\n\nfunction\n \nobfuscate\n \n(\ncc\n)\n \n{\n\n  \nreturn\n \n****-****-****-\n \n+\n \ncc\n.\nslice\n(\ncc\n.\nlength\n-\n4\n,\n \ncc\n.\nlength\n);\n\n\n}\n\n\n\nvar\n \nAccountSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \ncreditCardNumber\n:\n \n{\n \ntype\n: \nString\n,\n \nget\n: \nobfuscate\n \n}\n\n\n});\n\n\n\nvar\n \nAccount\n \n=\n \ndb\n.\nmodel\n(\nAccount\n,\n \nAccountSchema\n);\n\n\n\nAccount\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \nfound\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nfound\n.\ncreditCardNumber\n);\n\n\n});\n\n\n\n\n\n\nGetters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n\n\nfunction\n \ninspector\n \n(\nval\n,\n \nschematype\n)\n \n{\n\n  \nif\n \n(\nschematype\n.\noptions\n.\nrequired\n)\n \n{\n\n    \nreturn\n \nschematype\n.\npath\n \n+\n \n is required\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nschematype\n.\npath\n \n+\n \n is not\n;\n\n  \n}\n\n\n}\n\n\n\nvar\n \nVirusSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nrequired\n: \ntrue\n,\n \nget\n: \ninspector\n \n},\n\n  \ntaxonomy\n:\n \n{\n \ntype\n: \nString\n,\n \nget\n: \ninspector\n \n}\n\n\n})\n\n\n\nvar\n \nVirus\n \n=\n \ndb\n.\nmodel\n(\nVirus\n,\n \nVirusSchema\n);\n\n\n\nVirus\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \nvirus\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nvirus\n.\nname\n);\n\n  \nconsole\n.\nlog\n(\nvirus\n.\ntaxonomy\n);\n\n\n})\n\n\n\n\n\n\nSchemaType.prototype.validate()\n\n\n\u53c2\u6570\n\n\n\n\n[type] \u00abString\u00bb optional validator type\n\n\n\n\n\u8fd4\u56de\n\n\nAdds validator(s) for this document path.\n\n\nValidators always receive the value to validate as their first argument and must return \nBoolean\n. Returning \nfalse\n means validation failed.\n\n\nThe error message argument is optional. If not passed, the [default generic error message template will be used.\n\n\n\u793a\u4f8b\n\n\nfunction\n \nvalidator\n \n(\nval\n)\n \n{\n\n  \nreturn\n \nval\n \n==\n \nsomething\n;\n\n\n}\n\n\nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nvalidate\n: \nvalidator\n \n}});\n\n\n\nvar\n \ncustom\n \n=\n \n[\nvalidator\n,\n \nUh oh, {PATH} does not equal \nsomething\n.\n]\n\n\nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nvalidate\n: \ncustom\n \n}});\n\n\n\nvar\n \nmany\n \n=\n \n[\n\n    \n{\n \nvalidator\n: \nvalidator\n,\n \nmsg\n:\n \nuh oh\n \n}\n\n  \n,\n \n{\n \nvalidator\n: \nanotherValidator\n,\n \nmsg\n:\n \nfailed\n \n}\n\n\n]\n\n\nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nvalidate\n: \nmany\n \n}});\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n({\n \nname\n:\n \nstring\n \n});\n\n\nschema\n.\npath\n(\nname\n).\nvalidate\n(\nvalidator\n,\n \nvalidation of `{PATH}` failed with value `{VALUE}`\n);\n\n\n\n\n\n\n\u9519\u8bef\u6d88\u606f\u6a21\u677f\n\n\nFrom the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides \n{PATH}\n and \n{VALUE}\n too. To find out more, details are available [here\n\n\n\u5f02\u6b65\u9a8c\u8bc1\n\n\nPassing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either \ntrue\n or \nfalse\n to communicate either success or failure respectively.\n\n\nschema.path(\nname\n).validate({\n  isAsync: true,\n  validator: function (value, respond) {\n    doStuff(value, function () {\n      ...\n      respond(false);\n    });\n  },\n  message: \nCustom error message!\n\n});\n\nschema.path(\nname\n).validate({\n  validator: function (value) {\n    return new Promise(function (resolve, reject) {\n      resolve(false);\n    });\n  }\n});\n\n\n\n\n\nYou might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n\n\nValidation occurs \npre('save')\n or whenever you manually execute [document#validate.\n\n\nIf validation fails during \npre('save')\n and no callback was passed to receive the error, an \nerror\n event will be emitted on your Models associated db [connection, passing the validation error object along.\n\n\nvar conn = mongoose.createConnection(..);\nconn.on(\nerror\n, handleError);\n\nvar Product = conn.model(\nProduct\n, yourSchema);\nvar dvd = new Product(..);\ndvd.save();\n\n\n\n\n\nIf you desire handling these errors at the Model level, attach an \nerror\n listener to your Model and the event will instead be emitted there.\n\n\nProduct.on(\nerror\n, handleError);\n\n\n\n\n\nSchemaType.prototype.required()\n\n\n\u53c2\u6570\n\n\n\n\n[message] \u00abString\u00bb optional custom error message\n\n\n\n\n\u8fd4\u56de\n\n\nAdds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using \nunshift()\n.\n\n\n\u793a\u4f8b\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nborn\n:\n \n{\n \ntype\n:\n \nDate\n,\n \nrequired\n:\n \ntrue\n \n}\n)\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nborn\n:\n \n{\n \ntype\n:\n \nDate\n,\n \nrequired\n:\n \n{PATH} is required!\n \n}\n)\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nuserId\n:\n \nObjectId\n,\n\n  \nusername\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n    \nrequired\n:\n \nfunction\n()\n \n{\n \nreturn\n \nthis\n.\nuserId\n \n!=\n \nnull\n;\n \n}\n\n  \n}\n\n\n}\n)\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nuserId\n:\n \nObjectId\n,\n\n  \nusername\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n    \nrequired\n:\n \n[\n\n      \nfunction\n()\n \n{\n \nreturn\n \nthis.userId\n \n!=\n \nnull\n;\n \n},\n\n      \nusername is required if id is specified\n\n    \n]\n\n  \n}\n\n\n}\n)\n\n\n\nSchema\n.\npath\n(\nname\n)\n.\nrequired\n(\ntrue\n);\n\n\n\nSchema\n.\npath\n(\nname\n)\n.\nrequired\n(\ntrue\n,\n \ngrrr :( \n);\n\n\n\nvar\n \nisOver18\n \n=\n \nfunction\n()\n \n{\n \nreturn\n \nthis.age\n \n=\n \n18\n;\n \n}\n;\n\n\nSchema\n.\npath\n(\nvoterRegistrationId\n)\n.\nrequired\n(\nisOver18\n);\n\n\n\n\n\n\nThe required validator uses the SchemaType's \ncheckRequired\n function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if \nval != null\n (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default \ncheckRequired\n function:\n\n\nSchemaType.prototype.select()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSets default \nselect()\n behavior for this path.\n\n\nSet to \ntrue\n if this path should always be included in the results, \nfalse\n if it should be excluded by default. This setting can be overridden at the query level.\n\n\n\u793a\u4f8b\n\n\nT\n \n=\n \ndb\n.\nmodel\n(\nT\n,\n \nnew\n \nSchema\n(\n{\n \nx\n:\n \n{\n \ntype\n:\n \nString\n,\n \nselect\n:\n \ntrue\n \n}\n}\n));\n\n\nT\n.\nfind\n(..);\n\n\n\nT\n.\nfind\n()\n.\nselect\n(\n-x\n)\n.\nexec\n(\ncallback\n);", 
            "title": "\u6a21\u5f0f\u7c7b\u578bAPI"
        }, 
        {
            "location": "/schema/type/#_1", 
            "text": "", 
            "title": "\u6a21\u5f0f\u7c7b\u578b"
        }, 
        {
            "location": "/schema/type/#schematype", 
            "text": "\u53c2\u6570  SchemaType constructor. Do  not  instantiate  SchemaType  directly. Mongoose converts your schema paths into SchemaTypes automatically.  \u793a\u4f8b  const   schema   =   new   Schema ( {   name :   String   } );  schema . path ( name )   instanceof   SchemaType ;", 
            "title": "SchemaType()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypedefault", 
            "text": "\u53c2\u6570   val \u00abFunction,any\u00bb the default value   \u8fd4\u56de  Sets a default value for this SchemaType.  \u793a\u4f8b  var schema = new Schema({ n: { type: Number, default: 10 })\nvar M = db.model( M , schema)\nvar m = new M;\nconsole.log(m.n)  Defaults can be either  functions  which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.  \u793a\u4f8b  var   schema   =   new   Schema ( {   aNumber :   {   type :   Number ,   default :   4.815162342   } } )  var   M   =   db . model ( M ,   schema )  var   m   =   new   M ;  console . log ( m . aNumber )  var   schema   =   new   Schema ( {   mixed :   Schema . Types . Mixed   } );  schema . path ( mixed ) . default ( function   ()   { \n   return   { } ;  } );  var   schema   =   new   Schema ( {   mixed :   Schema . Types . Mixed   } );  schema . path ( mixed ) . default ( {} );  var   M   =   db . model ( M ,   schema );  var   m1   =   new   M ;  m1 . mixed . added   =   1 ;  console . log ( m1 . mixed );  var   m2   =   new   M ;  console . log ( m2 . mixed );", 
            "title": "SchemaType.prototype.default()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypeindex", 
            "text": "\u53c2\u6570   options \u00abObject,Boolean,String\u00bb   \u8fd4\u56de  Declares the index options for this schematype.  \u793a\u4f8b  var   s   =   new   Schema ( {   name :   {   type :   String ,   index :   true   } )  var   s   =   new   Schema ( {   loc :   {   type :   [ Number ] ,   index :   hashed   } )  var   s   =   new   Schema ( {   loc :   {   type :   [ Number ] ,   index :   2d ,   sparse :   true   } )  var   s   =   new   Schema ( {   loc :   {   type :   [ Number ] ,   index :   {   type :   2dsphere ,   sparse :   true   } } )  var   s   =   new   Schema ( {   date :   {   type :   Date ,   index :   {   unique :   true ,   expires :   1d   } } )  Schema . path ( my.path ) . index ( true );  Schema . path ( my.date ) . index ( {   expires :   60   } );  Schema . path ( my.path ) . index ( {   unique :   true ,   sparse :   true   } );   \u6ce8\u91ca  Indexes are created in the background by default. Specify  background: false  to override.  [Direction doesn't matter for single key indexes", 
            "title": "SchemaType.prototype.index()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypeunique", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Declares an unique index.  \u793a\u4f8b  var   s   =   new   Schema ( {   name :   {   type :   String ,   unique :   true   } } );  Schema . path ( name ) . index ( {   unique :   true   } );   NOTE: violating the constraint returns an  E11000  error from MongoDB when saving, not a Mongoose validation error.", 
            "title": "SchemaType.prototype.unique()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypetext", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Declares a full text index.  \u793a\u4f8b  var s = new Schema({name : {type: String, text : true })\n Schema.path( name ).index({text : true});", 
            "title": "SchemaType.prototype.text()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypesparse", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Declares a sparse index.  \u793a\u4f8b  var   s   =   new   Schema ( {   name :   {   type :   String ,   sparse :   true   } )  Schema . path ( name ) . index ( {   sparse :   true   } );", 
            "title": "SchemaType.prototype.sparse()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypeset", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Adds a setter to this schematype.  \u793a\u4f8b  function   capitalize   ( val )   { \n   if   ( typeof   val   !==   string )   val   =   ; \n   return   val . charAt ( 0 ). toUpperCase ()   +   val . substring ( 1 );  }  var   s   =   new   Schema ({   name :   {   type :  String ,   set :  capitalize   }})  var   s   =   new   Schema ({   name :  String   })  s . path ( name ). set ( capitalize )   Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.  Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, [avenue@q.com can be registered for 2 accounts via [avenue@q.com and [AvEnUe@Q.CoM.  You can set up email lower case normalization easily via a Mongoose setter.  function   toLower ( v )   { \n   return   v . toLowerCase ();  }  var   UserSchema   =   new   Schema ({ \n   email :   {   type :  String ,   set :  toLower   }  });  var   User   =   db . model ( User ,   UserSchema );  var   user   =   new   User ({ email :   [AVENUE@Q.COM });  console . log ( user . email );   //  [avenue@q.com  // or  var   user   =   new   User ();  user . email   =   [Avenue@Q.com ;  console . log ( user . email );   //  [avenue@q.com  User . updateOne ({   _id :  _id   },   {   $set :   {   email :   [AVENUE@Q.COM   }   });   // update to  [avenue@q.com   As you can see above, setters allow you to transform the data before it stored in MongoDB.  NOTE: we could have also just used the built-in  lowercase: true  SchemaType option instead of defining our own function.  new Schema({ email: { type: String, lowercase: true }})  Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.  function   inspector   ( val ,   schematype )   { \n   if   ( schematype . options . required )   { \n     return   schematype . path   +    is required ; \n   }   else   { \n     return   val ; \n   }  }  var   VirusSchema   =   new   Schema ({ \n   name :   {   type :  String ,   required :  true ,   set :  inspector   }, \n   taxonomy :   {   type :  String ,   set :  inspector   }  })  var   Virus   =   db . model ( Virus ,   VirusSchema );  var   v   =   new   Virus ({   name :   Parvoviridae ,   taxonomy :   Parvovirinae   });  console . log ( v . name );  console . log ( v . taxonomy );", 
            "title": "SchemaType.prototype.set()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypeget", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Adds a getter to this schematype.  \u793a\u4f8b  function   dob   ( val )   { \n   if   ( ! val )   return   val ; \n   return   ( val . getMonth ()   +   1 )   +   /   +   val . getDate ()   +   /   +   val . getFullYear ();  }  var   s   =   new   Schema ({   born :   {   type :  Date ,   get :  dob   })  var   s   =   new   Schema ({   born :  Date   })  s . path ( born ). get ( dob )   Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.  Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:  function   obfuscate   ( cc )   { \n   return   ****-****-****-   +   cc . slice ( cc . length - 4 ,   cc . length );  }  var   AccountSchema   =   new   Schema ({ \n   creditCardNumber :   {   type :  String ,   get :  obfuscate   }  });  var   Account   =   db . model ( Account ,   AccountSchema );  Account . findById ( id ,   function   ( err ,   found )   { \n   console . log ( found . creditCardNumber );  });   Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.  function   inspector   ( val ,   schematype )   { \n   if   ( schematype . options . required )   { \n     return   schematype . path   +    is required ; \n   }   else   { \n     return   schematype . path   +    is not ; \n   }  }  var   VirusSchema   =   new   Schema ({ \n   name :   {   type :  String ,   required :  true ,   get :  inspector   }, \n   taxonomy :   {   type :  String ,   get :  inspector   }  })  var   Virus   =   db . model ( Virus ,   VirusSchema );  Virus . findById ( id ,   function   ( err ,   virus )   { \n   console . log ( virus . name ); \n   console . log ( virus . taxonomy );  })", 
            "title": "SchemaType.prototype.get()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypevalidate", 
            "text": "\u53c2\u6570   [type] \u00abString\u00bb optional validator type   \u8fd4\u56de  Adds validator(s) for this document path.  Validators always receive the value to validate as their first argument and must return  Boolean . Returning  false  means validation failed.  The error message argument is optional. If not passed, the [default generic error message template will be used.  \u793a\u4f8b  function   validator   ( val )   { \n   return   val   ==   something ;  }  new   Schema ({   name :   {   type :  String ,   validate :  validator   }});  var   custom   =   [ validator ,   Uh oh, {PATH} does not equal  something . ]  new   Schema ({   name :   {   type :  String ,   validate :  custom   }});  var   many   =   [ \n     {   validator :  validator ,   msg :   uh oh   } \n   ,   {   validator :  anotherValidator ,   msg :   failed   }  ]  new   Schema ({   name :   {   type :  String ,   validate :  many   }});  var   schema   =   new   Schema ({   name :   string   });  schema . path ( name ). validate ( validator ,   validation of `{PATH}` failed with value `{VALUE}` );   \u9519\u8bef\u6d88\u606f\u6a21\u677f  From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides  {PATH}  and  {VALUE}  too. To find out more, details are available [here  \u5f02\u6b65\u9a8c\u8bc1  Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either  true  or  false  to communicate either success or failure respectively.  schema.path( name ).validate({\n  isAsync: true,\n  validator: function (value, respond) {\n    doStuff(value, function () {\n      ...\n      respond(false);\n    });\n  },\n  message:  Custom error message! \n});\n\nschema.path( name ).validate({\n  validator: function (value) {\n    return new Promise(function (resolve, reject) {\n      resolve(false);\n    });\n  }\n});  You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.  Validation occurs  pre('save')  or whenever you manually execute [document#validate.  If validation fails during  pre('save')  and no callback was passed to receive the error, an  error  event will be emitted on your Models associated db [connection, passing the validation error object along.  var conn = mongoose.createConnection(..);\nconn.on( error , handleError);\n\nvar Product = conn.model( Product , yourSchema);\nvar dvd = new Product(..);\ndvd.save();  If you desire handling these errors at the Model level, attach an  error  listener to your Model and the event will instead be emitted there.  Product.on( error , handleError);", 
            "title": "SchemaType.prototype.validate()"
        }, 
        {
            "location": "/schema/type/#schematypeprototyperequired", 
            "text": "\u53c2\u6570   [message] \u00abString\u00bb optional custom error message   \u8fd4\u56de  Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using  unshift() .  \u793a\u4f8b  var   s   =   new   Schema ( {   born :   {   type :   Date ,   required :   true   } )  var   s   =   new   Schema ( {   born :   {   type :   Date ,   required :   {PATH} is required!   } )  var   s   =   new   Schema ( { \n   userId :   ObjectId , \n   username :   { \n     type :   String , \n     required :   function ()   {   return   this . userId   !=   null ;   } \n   }  } )  var   s   =   new   Schema ( { \n   userId :   ObjectId , \n   username :   { \n     type :   String , \n     required :   [ \n       function ()   {   return   this.userId   !=   null ;   }, \n       username is required if id is specified \n     ] \n   }  } )  Schema . path ( name ) . required ( true );  Schema . path ( name ) . required ( true ,   grrr :(  );  var   isOver18   =   function ()   {   return   this.age   =   18 ;   } ;  Schema . path ( voterRegistrationId ) . required ( isOver18 );   The required validator uses the SchemaType's  checkRequired  function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if  val != null  (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default  checkRequired  function:", 
            "title": "SchemaType.prototype.required()"
        }, 
        {
            "location": "/schema/type/#schematypeprototypeselect", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Sets default  select()  behavior for this path.  Set to  true  if this path should always be included in the results,  false  if it should be excluded by default. This setting can be overridden at the query level.  \u793a\u4f8b  T   =   db . model ( T ,   new   Schema ( {   x :   {   type :   String ,   select :   true   } } ));  T . find (..);  T . find () . select ( -x ) . exec ( callback );", 
            "title": "SchemaType.prototype.select()"
        }, 
        {
            "location": "/model/guide/", 
            "text": "\u6a21\u578b\n\n\n\u8d44\u6e90\n\n\n\u6a21\u578bs\n are fancy constructors compiled from our \nSchema\n definitions. Instances of these models represent \ndocuments\n which can be saved and retrieved from our database. All document creation and retrieval from the database is handled by these models.\n\n\n\u7f16\u8bd1\u4f60\u7684\u7b2c\u4e00\u4e2a\u6a21\u578b\n\n\nvar schema = new mongoose.Schema({ name: 'string', size: 'string' }); var Tank = mongoose.model('Tank', schema);\n\n\nThe first argument is the \nsingular\n name of the collection your model is for. \n Mongoose automatically looks for the \nplural\n version of your model name. \n Thus, for the example above, the model Tank is for the \ntanks\n collection in the database. The \n.model()\n function makes a copy of \nschema\n. Make sure that you've added everything you want to \nschema\n before calling \n.model()\n!\n\n\n\u6784\u5efa\u6587\u6863\n\n\nDocuments\n are instances of our model. Creating them and saving to the database is easy:\n\n\nvar Tank = mongoose.model('Tank', yourSchema); var small = new Tank({ size: 'small' }); small.save(function (err) { if (err) return handleError(err); // saved! }) // or Tank.create({ size: 'small' }, function (err, small) { if (err) return handleError(err); // saved! })\n\n\nNote that no tanks will be created/removed until the connection your model uses is open. Every model has an associated connection. When you use \nmongoose.model()\n, your model will use the default mongoose connection.\n\n\nmongoose.connect('localhost', 'gettingstarted');\n\n\nIf you create a custom connection, use that connection's \nmodel()\n function instead.\n\n\nvar connection = mongoose.createConnection('mongodb://localhost:27017/test'); var Tank = connection.model('Tank', yourSchema);\n\n\n\u67e5\u8be2\n\n\nFinding documents is easy with Mongoose, which supports the \nrich\n query syntax of MongoDB. Documents can be retreived using each \nmodels\n \nfind\n, \nfindById\n, \nfindOne\n, or \nwhere\n static methods.\n\n\nTank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback);\n\n\nSee the chapter on \nquerying\n for more details on how to use the \nQuery\n api.\n\n\n\u5220\u9664\n\n\nModels have a static \nremove\n method available for removing all documents matching \nconditions\n.\n\n\nTank.remove({ size: 'large' }, function (err) { if (err) return handleError(err); // removed! });\n\n\n\u66f4\u65b0\n\n\nEach \nmodel\n has its own \nupdate\n method for modifying documents in the database without returning them to your application. See the \nAPI\n docs for more detail.\n\n\nIf you want to update a single document in the db and return it to your application, use \nfindOneAndUpdate\n instead.\n\n\n\u8fd8\u6709\u66f4\u591a\n\n\nThe \nAPI docs\n cover many additional methods available like \ncount\n, \nmapReduce\n, \naggregate\n, and \nmore\n.\n\n\n\u63a5\u4e0b\u6765\n\n\n\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\nModels\n\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\nDocuments\n.", 
            "title": "\u6a21\u578b\u624b\u518c"
        }, 
        {
            "location": "/model/guide/#_1", 
            "text": "\u8d44\u6e90  \u6a21\u578bs  are fancy constructors compiled from our  Schema  definitions. Instances of these models represent  documents  which can be saved and retrieved from our database. All document creation and retrieval from the database is handled by these models.", 
            "title": "\u6a21\u578b"
        }, 
        {
            "location": "/model/guide/#_2", 
            "text": "var schema = new mongoose.Schema({ name: 'string', size: 'string' }); var Tank = mongoose.model('Tank', schema);  The first argument is the  singular  name of the collection your model is for.   Mongoose automatically looks for the  plural  version of your model name.   Thus, for the example above, the model Tank is for the  tanks  collection in the database. The  .model()  function makes a copy of  schema . Make sure that you've added everything you want to  schema  before calling  .model() !", 
            "title": "\u7f16\u8bd1\u4f60\u7684\u7b2c\u4e00\u4e2a\u6a21\u578b"
        }, 
        {
            "location": "/model/guide/#_3", 
            "text": "Documents  are instances of our model. Creating them and saving to the database is easy:  var Tank = mongoose.model('Tank', yourSchema); var small = new Tank({ size: 'small' }); small.save(function (err) { if (err) return handleError(err); // saved! }) // or Tank.create({ size: 'small' }, function (err, small) { if (err) return handleError(err); // saved! })  Note that no tanks will be created/removed until the connection your model uses is open. Every model has an associated connection. When you use  mongoose.model() , your model will use the default mongoose connection.  mongoose.connect('localhost', 'gettingstarted');  If you create a custom connection, use that connection's  model()  function instead.  var connection = mongoose.createConnection('mongodb://localhost:27017/test'); var Tank = connection.model('Tank', yourSchema);", 
            "title": "\u6784\u5efa\u6587\u6863"
        }, 
        {
            "location": "/model/guide/#_4", 
            "text": "Finding documents is easy with Mongoose, which supports the  rich  query syntax of MongoDB. Documents can be retreived using each  models   find ,  findById ,  findOne , or  where  static methods.  Tank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback);  See the chapter on  querying  for more details on how to use the  Query  api.", 
            "title": "\u67e5\u8be2"
        }, 
        {
            "location": "/model/guide/#_5", 
            "text": "Models have a static  remove  method available for removing all documents matching  conditions .  Tank.remove({ size: 'large' }, function (err) { if (err) return handleError(err); // removed! });", 
            "title": "\u5220\u9664"
        }, 
        {
            "location": "/model/guide/#_6", 
            "text": "Each  model  has its own  update  method for modifying documents in the database without returning them to your application. See the  API  docs for more detail.  If you want to update a single document in the db and return it to your application, use  findOneAndUpdate  instead.", 
            "title": "\u66f4\u65b0"
        }, 
        {
            "location": "/model/guide/#_7", 
            "text": "The  API docs  cover many additional methods available like  count ,  mapReduce ,  aggregate , and  more .", 
            "title": "\u8fd8\u6709\u66f4\u591a"
        }, 
        {
            "location": "/model/guide/#_8", 
            "text": "\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 Models \uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b Documents .", 
            "title": "\u63a5\u4e0b\u6765"
        }, 
        {
            "location": "/model/api/", 
            "text": "\u6a21\u578b\n\n\nModel()\n\n\n\u53c2\u6570\n\n\n\n\ndoc \u00abObject\u00bb values with which to create the document\n\n\n\n\nModel constructor\n\n\nProvides the interface to MongoDB collections as well as creates document instances.\n\n\nModel.prototype.db\n\n\nConnection the model uses.\n\n\nModel.prototype.collection\n\n\nCollection the model uses.\n\n\nModel.prototype.modelName\n\n\nModel.prototype.$where\n\n\nAdditional properties to attach to the query when calling \nsave()\n and \nisNew\n is false.\n\n\nModel.prototype.baseModelName\n\n\nIf this is a discriminator model, \nbaseModelName\n is the name of the base model.\n\n\nModel.prototype.save()\n\n\n\u53c2\u6570\n\n\n\n\n[fn] \u00abFunction\u00bb optional callback\n\n\n\n\n\u8fd4\u56de\n\n\nSaves this document.\n\n\n\u793a\u4f8b\n\n\nproduct.sold = Date.now();\nproduct.save(function (err, product) {\n  if (err) ..\n})\n\n\n\n\n\nThe callback will receive three parameters\n\n\n\n\nerr\n if an error occurred\n\n\nproduct\n which is the saved \nproduct\n\n\n\n\nAs an extra measure of flow control, save will return a Promise.\n\n\n\u793a\u4f8b\n\n\nproduct.save().then(function(product) {\n   ...\n});\n\n\n\n\n\nModel.prototype.increment()\n\n\nSignal that we desire an increment of this documents version.\n\n\n\u793a\u4f8b\n\n\nModel.findById(id, function (err, doc) {\n  doc.increment();\n  doc.save(function (err) { .. })\n})\n\n\n\n\n\nModel.prototype.remove()\n\n\n\u53c2\u6570\n\n\n\n\n[fn] \u00abfunction(err,product)\u00bb optional callback\n\n\n\n\n\u8fd4\u56de\n\n\nRemoves this document from the db.\n\n\n\u793a\u4f8b\n\n\nproduct.remove(function (err, product) {\n  if (err) return handleError(err);\n  Product.findById(product._id, function (err, product) {\n    console.log(product)\n  })\n})\n\n\n\n\n\nAs an extra measure of flow control, remove will return a Promise (bound to \nfn\n if passed) so it could be chained, or hooked to recive errors\n\n\n\u793a\u4f8b\n\n\nproduct.remove().then(function (product) {\n   ...\n}).catch(function (err) {\n   assert.ok(err)\n})\n\n\n\n\n\nModel.prototype.model()\n\n\n\u53c2\u6570\n\n\n\n\nname \u00abString\u00bb model name\n\n\n\n\nReturns another Model instance.\n\n\n\u793a\u4f8b\n\n\nvar doc = new Tank;\ndoc.model(\nUser\n).findById(id, callback);\n\n\n\n\n\nModel.discriminator()\n\n\n\u53c2\u6570\n\n\n\n\nschema \u00abSchema\u00bb discriminator model schema\n\n\n\n\nAdds a discriminator type.\n\n\n\u793a\u4f8b\n\n\nfunction\n \nBaseSchema() {\n\n  \nSchema\n.\napply\n(\nthis\n,\n \narguments\n);\n\n\n  \nthis\n.\nadd\n({\n\n    \nname\n: \nString\n,\n\n    \ncreatedAt\n: \nDate\n\n  \n});\n\n\n}\n\n\nutil\n.\ninherits\n(\nBaseSchema\n,\n \nSchema\n);\n\n\n\nvar\n \nPersonSchema\n \n=\n \nnew\n \nBaseSchema\n();\n\n\nvar\n \nBossSchema\n \n=\n \nnew\n \nBaseSchema\n({\n \ndepartment\n: \nString\n \n});\n\n\n\nvar\n \nPerson\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nPersonSchema\n);\n\n\nvar\n \nBoss\n \n=\n \nPerson\n.\ndiscriminator\n(\nBoss\n,\n \nBossSchema\n);\n\n\n\n\n\n\nModel.init()\n\n\n\u53c2\u6570\n\n\nPerforms any async initialization of this model against MongoDB. Currently, this function is only responsible for building [indexes, unless [\nautoIndex\n is turned off.\n\n\nThis function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to \nMyModel.on('index')\n\n\n\u793a\u4f8b\n\n\nvar eventSchema = new Schema({ thing: { type: \nstring\n, unique: true }})\n\n\nvar Event = mongoose.model(\nEvent\n, eventSchema);\n\nEvent.init().then(function(Event) {\n\n\n  console.log(\nIndexes are done building!\n);\n});\n\n\n\n\n\nModel.ensureIndexes()\n\n\n\u53c2\u6570\n\n\n\n\n[cb] \u00abFunction\u00bb optional callback\n\n\n\n\n\u8fd4\u56de\n\n\nSends \ncreateIndex\n commands to mongo for each index declared in the schema. The \ncreateIndex\n commands are sent in series.\n\n\n\u793a\u4f8b\n\n\nEvent.ensureIndexes(function (err) {\n  if (err) return handleError(err);\n});\n\n\n\n\n\nAfter completion, an \nindex\n event is emitted on this \nModel\n passing an error if one occurred.\n\n\n\u793a\u4f8b\n\n\nvar eventSchema = new Schema({ thing: { type: \nstring\n, unique: true }})\nvar Event = mongoose.model(\nEvent\n, eventSchema);\n\nEvent.on(\nindex\n, function (err) {\n  if (err) console.error(err);\n})\n\n\n\n\n\nNOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.\n\n\nModel.createIndexes()\n\n\n\u53c2\u6570\n\n\n\n\n[cb] \u00abFunction\u00bb optional callback\n\n\n\n\n\u8fd4\u56de\n\n\nSimilar to \nensureIndexes()\n, except for it uses the [\ncreateIndex\n function. The \nensureIndex()\n function checks to see if an index with that name already exists, and, if not, does not attempt to create the index. \ncreateIndex()\n bypasses this check.\n\n\nModel.prototype.schema\n\n\nModel.prototype.base\n\n\nBase Mongoose instance the model uses.\n\n\nModel.prototype.discriminators\n\n\nRegistered discriminators for this model.\n\n\nModel.translateAliases()\n\n\n\u53c2\u6570\n\n\n\n\nraw \u00abObject\u00bb fields/conditions that may contain aliased keys\n\n\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abObject\u00bb the translated 'pure' fields/conditions\n\n\n\n\nTranslate any aliases fields/conditions so the final query or document object is pure\n\n\n\u793a\u4f8b\n\n\nCharacter\n  .find(Character.translateAliases({\n    \n\u540d\n: \nEddard Stark\n\n  })\n  .exec(function(err, characters) {})\n\n\n\n\n\n\u6ce8\u91ca\n\n\nOnly translate arguments of object type anything else is returned raw\n\n\nModel.remove()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nRemoves all documents that match \nconditions\n from the collection. To remove just the first document that matches \nconditions\n, set the \nsingle\n option to true.\n\n\n\u793a\u4f8b\n\n\nCharacter\n.\nremove\n(\n{\n \nname\n:\n \nEddard Stark\n \n}\n,\n \nfunction\n \n(\nerr\n)\n \n{}\n);\n\n\n\n\n\n\n\u6ce8\u91ca\n\n\nThis method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, \nno middleware (hooks) are executed\n.\n\n\nModel.deleteOne()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDeletes the first document that matches \nconditions\n from the collection. Behaves like \nremove()\n, but deletes at most one document regardless of the \nsingle\n option.\n\n\n\u793a\u4f8b\n\n\nCharacter\n.\ndeleteOne\n(\n{\n \nname\n:\n \nEddard Stark\n \n}\n,\n \nfunction\n \n(\nerr\n)\n \n{}\n);\n\n\n\n\n\n\n\u6ce8\u91ca\n\n\nLike \nModel.remove()\n, this function does \nnot\n trigger \npre('remove')\n or \npost('remove')\n hooks.\n\n\n\n\nModel.deleteMany()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDeletes all of the documents that match \nconditions\n from the collection. Behaves like \nremove()\n, but deletes all documents that match \nconditions\n regardless of the \nsingle\n option.\n\n\n\u793a\u4f8b\n\n\nCharacter\n.\ndeleteMany\n(\n{\n \nname\n:\n \n/\nStark\n/\n,\n \nage\n:\n \n{\n \n$\ngte\n:\n \n18\n \n}\n \n}\n,\n \nfunction\n \n(\nerr\n)\n \n{}\n);\n\n\n\n\n\n\n\u6ce8\u91ca\n\n\nLike \nModel.remove()\n, this function does \nnot\n trigger \npre('remove')\n or \npost('remove')\n hooks.\n\n\n\n\nModel.find()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nFinds documents\n\n\nThe \nconditions\n are cast to their respective SchemaTypes before the command is sent.\n\n\n\u793a\u4f8b\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \njohn\n,\n \nage\n:\n \n{\n \n$\ngte\n:\n \n18\n \n}\n}\n);\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \njohn\n,\n \nage\n:\n \n{\n \n$\ngte\n:\n \n18\n \n}\n}\n,\n \nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nname friends\n,\n \nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{\n \n}\n)\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n)\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\nvar\n \nquery\n \n=\n \nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n)\n\n\nquery\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\nvar\n \nquery\n \n=\n \nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n);\n\n\nvar\n \npromise\n \n=\n \nquery\n.\nexec\n();\n\n\npromise\n.\naddBack\n(\nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\n\n\nModel.findById()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nFinds a single document by its _id field. \nfindById(id)\n is almost* equivalent to \nfindOne({ _id: id })\n. If you want to query by a document's \n_id\n, use \nfindById()\n instead of \nfindOne()\n.\n\n\nThe \nid\n is cast based on the Schema before sending the command.\n\n\nThis function triggers the following middleware.\n\n\n\n\nExcept for how it treats \nundefined\n. If you use \nfindOne()\n, you'll see that \nfindOne(undefined)\n and \nfindOne({ _id: undefined })\n are equivalent to \nfindOne({})\n and return arbitrary documents. However, mongoose translates \nfindById(undefined)\n into \nfindOne({ _id: null })\n.\n\n\n\n\n\u793a\u4f8b\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname length\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname length\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \n-length\n)\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname\n,\n \n{\n \nlean\n:\n \ntrue\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \ndoc\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname\n)\n.\nlean\n()\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \ndoc\n)\n \n{}\n);\n\n\n\n\n\n\nModel.findOne()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nFinds one document.\n\n\nThe \nconditions\n are cast to their respective SchemaTypes before the command is sent.\n\n\nNote:\n \nconditions\n is optional, and if \nconditions\n is null or undefined, mongoose will send an empty \nfindOne\n command to MongoDB, which will return an arbitrary document. If you're querying by \n_id\n, use \nfindById()\n instead.\n\n\n\u793a\u4f8b\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n)\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n)\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n,\n \n{\n \nlean\n:\n \ntrue\n \n}\n,\n \ncallback\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n,\n \n{\n \nlean\n:\n \ntrue\n \n}\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n)\n.\nselect\n(\nname\n)\n.\nlean\n()\n.\nexec\n(\ncallback\n);\n\n\n\n\n\n\nModel.count()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nCounts number of matching documents in a database collection.\n\n\n\u793a\u4f8b\n\n\nAdventure.count({ type: \njungle\n }, function (err, count) {\n  if (err) ..\n  console.log(\nthere are %d jungle adventures\n, count);\n});\n\n\n\n\n\nModel.distinct()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nCreates a Query for a \ndistinct\n operation.\n\n\nPassing a \ncallback\n immediately executes the query.\n\n\n\u793a\u4f8b\n\n\nLink.distinct(\nurl\n, \n{\n \nclicks\n:\n \n{\n$gt\n:\n \n100\n}}\n, function (err, result) \n{\n\n  \nif\n \n(\nerr\n)\n \nreturn\n \nhandleError\n(\nerr\n);\n\n\n  \nassert\n(\nArray\n.\nisArray\n(\nresult\n));\n\n  \nconsole\n.\nlog\n(\nunique urls with more than 100 clicks\n,\n \nresult\n);\n\n\n}\n)\n\n\n\nvar query = Link.distinct(\nurl\n);\n\n\nquery.exec(callback);\n\n\n\n\n\n\nModel.where()\n\n\n\u53c2\u6570\n\n\n\n\n[val] \u00abObject\u00bb optional value\n\n\n\n\n\u8fd4\u56de\n\n\nCreates a Query, applies the passed conditions, and returns the Query.\n\n\nFor example, instead of writing:\n\n\nUser\n.\nfind\n(\n{\nage\n:\n \n{$\ngte\n:\n \n21\n,\n \n$\nlte\n:\n \n65\n}\n}\n,\n \ncallback\n);\n\n\n\n\n\n\nwe can instead write:\n\n\nUser.where(\nage\n).gte(21).lte(65).exec(callback);\n\n\n\n\n\nSince the Query class also supports \nwhere\n you can continue chaining\n\n\nUser\n.where(\nage\n).gte(21).lte(65)\n.where(\nname\n, /^b/i)\n... etc\n\n\n\n\n\nModel.prototype.$where()\n\n\n\u53c2\u6570\n\n\n\n\nargument \u00abString,Function\u00bb is a javascript string or anonymous function\n\n\n\n\n\u8fd4\u56de\n\n\nCreates a \nQuery\n and specifies a \n$where\n condition.\n\n\nSometimes you need to query for things in mongodb using a JavaScript expression. You can do so via \nfind({ $where: javascript })\n, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n\n\nBlog.$where(\nthis.username.indexOf(\nval\n) !== -1\n).exec(function (err, docs) {});\n\n\n\n\n\nModel.findOneAndUpdate()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nIssues a mongodb findAndModify update command.\n\n\nFinds a matching document, updates it according to the \nupdate\n arg, passing any \noptions\n, and returns the found document (if any) to the callback. The query executes immediately if \ncallback\n is passed else a Query object is returned.\n\n\n\u9009\u9879\n\n\n\n\nnew\n: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n\n\nupsert\n: bool - creates the object if it doesn't exist. defaults to false.\n\n\nfields\n: {Object|String} - Field selection. Equivalent to \n.select(fields).findOneAndUpdate()\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nrunValidators\n: if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on [MongoDB's \n$setOnInsert\n operator.\n\n\nrawResult\n: if true, returns the [raw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's [strict mode option for this update\n\n\n\n\n\u793a\u4f8b\n\n\nA.findOneAndUpdate(conditions, update, options, callback)\nA.findOneAndUpdate(conditions, update, options)\nA.findOneAndUpdate(conditions, update, callback)\nA.findOneAndUpdate(conditions, update)\nA.findOneAndUpdate()\n\n\n\n\n\n\u6ce8\u91ca\n\n\nAll top level update keys which are not \natomic\n operation names are treated as set operations:\n\n\n\u793a\u4f8b\n\n\nvar\n \nquery\n \n=\n \n{\n \nname\n:\n \nborne\n \n}\n;\n\n\nModel\n.\nfindOneAndUpdate\n(\nquery\n,\n \n{\n \nname\n:\n \njason bourne\n \n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\nModel\n.\nfindOneAndUpdate\n(\nquery\n,\n \n{\n \n$\nset\n:\n \n{\n \nname\n:\n \njason bourne\n \n}\n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\n\n\nThis helps prevent accidentally overwriting your document with \n{ name: 'jason bourne' }\n.\n\n\n\u6ce8\u91ca\n\n\nValues are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.\n\n\n\n\ndefaults. Use the \nsetDefaultsOnInsert\n option to override.\n\n\n\n\nfindAndModify\n helpers support limited validation. You can enable these by setting the \nrunValidators\n options, respectively.\n\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n\nModel.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n});\n\n\n\n\n\nModel.findByIdAndUpdate()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nIssues a mongodb findAndModify update command by a document's _id field. \nfindByIdAndUpdate(id, ...)\n is equivalent to \nfindOneAndUpdate({ _id: id }, ...)\n.\n\n\nFinds a matching document, updates it according to the \nupdate\n arg, passing any \noptions\n, and returns the found document (if any) to the callback. The query executes immediately if \ncallback\n is passed else a Query object is returned.\n\n\nThis function triggers the following middleware.\n\n\n\u9009\u9879\n\n\n\n\nnew\n: bool - true to return the modified document rather than the original. defaults to false\n\n\nupsert\n: bool - creates the object if it doesn't exist. defaults to false.\n\n\nrunValidators\n: if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on [MongoDB's \n$setOnInsert\n operator.\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nselect\n: sets the document fields to return\n\n\nrawResult\n: if true, returns the [raw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's [strict mode option for this update\n\n\n\n\n\u793a\u4f8b\n\n\nA.findByIdAndUpdate(id, update, options, callback)\nA.findByIdAndUpdate(id, update, options)\nA.findByIdAndUpdate(id, update, callback)\nA.findByIdAndUpdate(id, update)\nA.findByIdAndUpdate()\n\n\n\n\n\n\u6ce8\u91ca\n\n\nAll top level update keys which are not \natomic\n operation names are treated as set operations:\n\n\n\u793a\u4f8b\n\n\nModel.findByIdAndUpdate(id, { name: \njason bourne\n }, options, callback)\n\n\nModel.findByIdAndUpdate(id, { $set: { name: \njason bourne\n }}, options, callback)\n\n\n\n\n\nThis helps prevent accidentally overwriting your document with \n{ name: 'jason bourne' }\n.\n\n\n\u6ce8\u91ca\n\n\nValues are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.\n\n\n\n\ndefaults. Use the \nsetDefaultsOnInsert\n option to override.\n\n\n\n\nfindAndModify\n helpers support limited validation. You can enable these by setting the \nrunValidators\n options, respectively.\n\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n\nModel.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n});\n\n\n\n\n\nModel.findOneAndRemove()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nIssue a mongodb findAndModify remove command.\n\n\nFinds a matching document, removes it, passing the found document (if any) to the callback.\n\n\nExecutes immediately if \ncallback\n is passed else a Query object is returned.\n\n\nThis function triggers the following middleware.\n\n\n\u9009\u9879\n\n\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nselect\n: sets the document fields to return\n\n\nrawResult\n: if true, returns the [raw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's [strict mode option for this update\n\n\n\n\n\u793a\u4f8b\n\n\nA.findOneAndRemove(conditions, options, callback)\nA.findOneAndRemove(conditions, options)\nA.findOneAndRemove(conditions, callback)\nA.findOneAndRemove(conditions)\nA.findOneAndRemove()\n\n\n\n\n\nValues are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.\n\n\n\n\ndefaults. Use the \nsetDefaultsOnInsert\n option to override.\n\n\n\n\nfindAndModify\n helpers support limited validation. You can enable these by setting the \nrunValidators\n options, respectively.\n\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n\nModel.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n});\n\n\n\n\n\nModel.findByIdAndRemove()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nIssue a mongodb findAndModify remove command by a document's _id field. \nfindByIdAndRemove(id, ...)\n is equivalent to \nfindOneAndRemove({ _id: id }, ...)\n.\n\n\nFinds a matching document, removes it, passing the found document (if any) to the callback.\n\n\nExecutes immediately if \ncallback\n is passed, else a \nQuery\n object is returned.\n\n\nThis function triggers the following middleware.\n\n\n\u9009\u9879\n\n\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nselect\n: sets the document fields to return\n\n\nrawResult\n: if true, returns the [raw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's [strict mode option for this update\n\n\n\n\n\u793a\u4f8b\n\n\nA.findByIdAndRemove(id, options, callback)\nA.findByIdAndRemove(id, options)\nA.findByIdAndRemove(id, callback)\nA.findByIdAndRemove(id)\nA.findByIdAndRemove()\n\n\n\n\n\nModel.create()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb callback\n\n\n\n\n\u8fd4\u56de\n\n\nShortcut for saving one or more documents to the database. \nMyModel.create(docs)\n does \nnew MyModel(doc).save()\n for every doc in docs.\n\n\nThis function triggers the following middleware.\n\n\n\u793a\u4f8b\n\n\nCandy\n.\ncreate\n(\n{\n \ntype\n:\n \njelly bean\n \n}\n,\n \n{\n \ntype\n:\n \nsnickers\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \njellybean\n,\n \nsnickers\n)\n \n{\n\n  \nif\n \n(err)\n\n\n}\n);\n\n\n\n\nvar\n \narray\n \n=\n \n[\n{\n \ntype\n:\n \njelly bean\n \n},\n \n{\n \ntype\n:\n \nsnickers\n \n}\n]\n;\n\n\nCandy\n.\ncreate\n(\narray\n,\n \nfunction\n \n(\nerr\n,\n \ncandies\n)\n \n{\n\n  \nif\n \n(err)\n\n\n  \nvar\n \njellybean\n \n=\n \ncandies\n[\n0\n]\n;\n\n  \nvar\n \nsnickers\n \n=\n \ncandies\n[\n1\n]\n;\n\n\n\n}\n);\n\n\n\n\nvar\n \npromise\n \n=\n \nCandy\n.\ncreate\n(\n{\n \ntype\n:\n \njawbreaker\n \n}\n);\n\n\npromise\n.\nthen\n(\nfunction\n \n(\njawbreaker\n)\n \n{\n\n\n\n}\n)\n\n\n\n\n\n\nModel.watch()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abChangeStream\u00bb mongoose-specific change stream wrapper\n\n\n\n\nRequires a replica set running MongoDB \n= 3.6.0.\n Watches the underlying collection for changes using [MongoDB change streams.\n\n\nThis function does \nnot\n trigger any middleware. In particular, it does \nnot\n trigger aggregate middleware.\n\n\n\u793a\u4f8b\n\n\nconst\n \ndoc\n \n=\n \nawait\n \nPerson\n.\ncreate\n(\n{\n \nname\n:\n \nNed Stark\n \n}\n);\n\n\nPerson\n.\nwatch\n()\n.\non\n(\nchange\n,\n \nchange\n \n=\n \nconsole\n.\nlog\n(\nchange\n));\n\n\n\n\n\n\n\nawait\n \ndoc\n.\nremove\n();\n\n\n\n\n\n\nModel.insertMany()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb callback\n\n\n\n\n\u8fd4\u56de\n\n\nShortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than \n.create()\n because it only sends one operation to the server, rather than one for each document.\n\n\nMongoose always validates each document \nbefore\n sending \ninsertMany\n to MongoDB. So if one document has a validation error, no documents will be saved, unless you set [the \nordered\n option to false.\n\n\nThis function does \nnot\n trigger save middleware.\n\n\nThis function triggers the following middleware.\n\n\n\u793a\u4f8b\n\n\nvar\n \narr\n \n=\n \n[\n{\n \nname\n:\n \nStar Wars\n \n},\n \n{\n \nname\n:\n \nThe Empire Strikes Back\n \n}\n]\n;\n\n\nMovies\n.\ninsertMany\n(\narr\n,\n \nfunction\n(\nerror\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\n\n\nModel.bulkWrite()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb callback \nfunction(error, bulkWriteOpResult) {}\n\n\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abPromise\u00bb resolves to a \nBulkWriteOpResult\n if the operation succeeds\n\n\n\n\nSends multiple \ninsertOne\n, \nupdateOne\n, \nupdateMany\n, \nreplaceOne\n, \ndeleteOne\n, and/or \ndeleteMany\n operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use \ncreate()\n) because with \nbulkWrite()\n there is only one round trip to MongoDB.\n\n\nMongoose will perform casting on all operations you provide.\n\n\nThis function does \nnot\n trigger any middleware, not \nsave()\n nor \nupdate()\n. If you need to trigger \nsave()\n middleware for every document use [\ncreate()\n instead.\n\n\n\u793a\u4f8b\n\n\nCharacter.bulkWrite([\n  {\n    insertOne: {\n      document: {\n        name: \nEddard Stark\n,\n        title: \nWarden of the North\n\n      }\n    }\n  },\n  {\n    updateOne: {\n      filter: { name: \nEddard Stark\n },\n\n\n\n      update: { title: \nHand of the King\n }\n    }\n  },\n  {\n    deleteOne: {\n      {\n        filter: { name: \nEddard Stark\n }\n      }\n    }\n  }\n]).then(handleResult);\n\n\n\n\n\nModel.hydrate()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abModel\u00bb document instance\n\n\n\n\nShortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.\n\n\n\u793a\u4f8b\n\n\nvar\n \nmongooseCandy\n \n=\n \nCandy\n.\nhydrate\n(\n{\n \n_id\n:\n \n54108337212ffb6d459f854c\n,\n \ntype\n:\n \njelly bean\n \n}\n);\n\n\n\n\n\n\nModel.update()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nUpdates one document in the database without returning it.\n\n\nThis function triggers the following middleware.\n\n\n\u793a\u4f8b\n\n\nMyModel\n.\nupdate\n(\n{\n \nage\n:\n \n{\n \n$\ngt\n:\n \n18\n \n}\n \n}\n,\n \n{\n \noldEnough\n:\n \ntrue\n \n}\n,\n \nfn\n);\n\n\nMyModel\n.\nupdate\n(\n{\n \nname\n:\n \nTobi\n \n}\n,\n \n{\n \nferret\n:\n \ntrue\n \n}\n,\n \n{\n \nmulti\n:\n \ntrue\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \nraw\n)\n \n{\n\n  \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n  \nconsole.log(\nThe\n \nraw\n \nresponse\n \nfrom\n \nMongo\n \nwas\n \n,\n \nraw)\n;\n\n\n}\n);\n\n\n\n\n\n\n\u6709\u6548\u7684\u9009\u9879\n\n\n\n\nsafe\n (boolean) safe mode (defaults to value set in schema (true))\n\n\nupsert\n (boolean) whether to create the doc if it doesn't match (false)\n\n\nmulti\n (boolean) whether multiple documents should be updated (false)\n\n\nrunValidators\n: if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on [MongoDB's \n$setOnInsert\n operator.\n\n\nstrict\n (boolean) overrides the \nstrict\n option for this update\n\n\noverwrite\n (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n\n\n\n\nAll \nupdate\n values are cast to their appropriate SchemaTypes before being sent.\n\n\nThe \ncallback\n function receives \n(err, rawResponse)\n.\n\n\n\n\nerr\n is the error if any occurred\n\n\nrawResponse\n is the full response from Mongo\n\n\n\n\n\u6ce8\u91ca\n\n\nAll top level keys which are not \natomic\n operation names are treated as set operations:\n\n\n\u793a\u4f8b\n\n\nvar\n \nquery\n \n=\n \n{\n \nname\n:\n \nborne\n \n}\n;\n\n\nModel\n.\nupdate\n(\nquery\n,\n \n{\n \nname\n:\n \njason bourne\n \n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\nModel\n.\nupdate\n(\nquery\n,\n \n{\n \n$\nset\n:\n \n{\n \nname\n:\n \njason bourne\n \n}\n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\n\n\nThis helps prevent accidentally overwriting all documents in your collection with \n{ name: 'jason bourne' }\n.\n\n\n\u6ce8\u91ca\n\n\nBe careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error.\n\n\n\u6ce8\u91ca\n\n\nTo update documents without waiting for a response from MongoDB, do not pass a \ncallback\n, then call \nexec\n on the returned [Query:\n\n\nComment\n.\nupdate\n(\n{\n \n_id\n:\n \nid\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \ntext\n:\n \nchanged\n \n}\n}\n)\n.\nexec\n();\n\n\n\n\n\n\n\u6ce8\u91ca\n\n\nAlthough values are casted to their appropriate types when using update, the following are \nnot\n applied:\n\n\n\n\ndefaults\n\n\nsetters\n\n\nvalidators\n\n\nmiddleware\n\n\n\n\nIf you need those features, use the traditional approach of first retrieving the document.\n\n\nModel.findOne({ name: \nborne\n }, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n})\n\n\n\n\n\nModel.updateMany()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSame as \nupdate()\n, except MongoDB will update \nall\n documents that match \ncriteria\n (as opposed to just the first one) regardless of the value of the \nmulti\n option.\n\n\nNote\n updateMany will \nnot\n fire update middleware. Use \npre('updateMany')\n and \npost('updateMany')\n instead.\n\n\nThis function triggers the following middleware.\n\n\nModel.updateOne()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSame as \nupdate()\n, except MongoDB will update \nonly\n the first document that matches \ncriteria\n regardless of the value of the \nmulti\n option.\n\n\nThis function triggers the following middleware.\n\n\nModel.replaceOne()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSame as \nupdate()\n, except MongoDB replace the existing document with the given document (no atomic operators like \n$set\n).\n\n\nThis function triggers the following middleware.\n\n\nModel.mapReduce()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional callback\n\n\n\n\n\u8fd4\u56de\n\n\nExecutes a mapReduce command.\n\n\no\n is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation for more detail about options.\n\n\nThis function does not trigger any middleware.\n\n\n\u793a\u4f8b\n\n\nvar o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\nUser.mapReduce(o, function (err, results) {\n  console.log(results)\n})\n\n\n\n\n\n\u5176\u4ed6\u9009\u9879\n\n\n\n\nquery\n {Object} query filter object.\n\n\nsort\n {Object} sort input objects using this key\n\n\nlimit\n {Number} max number of documents\n\n\nkeeptemp\n {Boolean, default:false} keep temporary data\n\n\nfinalize\n {Function} finalize function\n\n\nscope\n {Object} scope variables exposed to map/reduce/finalize during execution\n\n\njsMode\n {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB \n 2.0.X\n\n\nverbose\n {Boolean, default:false} provide statistics on job execution time.\n\n\nreadPreference\n {String}\n\n\nout*\n {Object, default: {inline:1}} sets the output target for the map reduce job.\n\n\n\n\n\u8f93\u51fa\u9009\u9879\n\n\n\n\n{inline:1}\n the results are returned in an array\n\n\n{replace: 'collectionName'}\n add the results to collectionName: the results replace the collection\n\n\n{reduce: 'collectionName'}\n add the results to collectionName: if dups are detected, uses the reducer / finalize functions\n\n\n{merge: 'collectionName'}\n add the results to collectionName: if dups exist the new docs overwrite the old\n\n\n\n\nIf \noptions.out\n is set to \nreplace\n, \nmerge\n, or \nreduce\n, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the \nlean\n option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).\n\n\n\u793a\u4f8b\n\n\nvar o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\no.out = { replace: \ncreatedCollectionNameForResults\n }\no.verbose = true;\n\nUser.mapReduce(o, function (err, model, stats) {\n  console.log(\nmap reduce took %d ms\n, stats.processtime)\n  model.find().where(\nvalue\n).gt(10).exec(function (err, docs) {\n    console.log(docs);\n  });\n})\n\n\n\no.resolveToObject = true;\nvar promise = User.mapReduce(o);\npromise.then(function (res) {\n  var model = res.model;\n  var stats = res.stats;\n  console.log(\nmap reduce took %d ms\n, stats.processtime)\n  return model.find().where(\nvalue\n).gt(10).exec();\n}).then(function (docs) {\n   console.log(docs);\n}).then(null, handleError).end()\n\n\n\n\n\nModel.aggregate()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nPerforms [aggregations on the models collection.\n\n\nIf a \ncallback\n is passed, the \naggregate\n is executed and a \nPromise\n is returned. If a callback is not passed, the \naggregate\n itself is returned.\n\n\nThis function does not trigger any middleware.\n\n\n\u793a\u4f8b\n\n\nUsers.aggregate(\n  { $group: { _id: null, maxBalance: { $max: \n$balance\n }}},\n  { $project: { _id: 0, maxBalance: 1 }},\n  function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n  });\n\n\nUsers.aggregate()\n  .group({ _id: null, maxBalance: { $max: \n$balance\n } })\n  .select(\n-id maxBalance\n)\n  .exec(function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n});\n\n\n\n\n\n\u6ce8\u91ca\n\n\n\n\nArguments are not cast to the model's schema because \n$project\n operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.\n\n\nThe documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n\n\nRequires MongoDB \n= 2.1\n\n\n\n\n\n\nModel.geoSearch()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional callback\n\n\n\n\n\u8fd4\u56de\n\n\nImplements \n$geoSearch\n functionality for Mongoose\n\n\nThis function does not trigger any middleware\n\n\n\u793a\u4f8b\n\n\nvar\n \noptions\n \n=\n \n{\n \nnear\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n;\n\n\nLocations\n.\ngeoSearch\n(\n{\n \ntype\n \n:\n \nhouse\n \n}\n,\n \noptions\n,\n \nfunction\n(\nerr\n,\n \nres\n)\n \n{\n\n  \nconsole.log(res)\n;\n\n\n}\n);\n\n\n\n\n\n\n\u9009\u9879\n\n\n\n\nnear\n {Array} x,y point to search for\n\n\nmaxDistance\n {Number} the maximum distance from the point near that a result can be\n\n\nlimit\n {Number} The maximum number of results to return\n\n\nlean\n {Boolean} return the raw object instead of the Mongoose Model\n\n\n\n\n\n\nModel.populate()\n\n\n\u53c2\u6570\n\n\n\n\n[callback(err,doc)] \u00abFunction\u00bb Optional callback, executed upon completion. Receives \nerr\n and the \ndoc(s)\n.\n\n\n\n\n\u8fd4\u56de\n\n\nPopulates document references.\n\n\n\u53ef\u7528\u7684\u9009\u9879\n\n\n\n\npath: space delimited path(s) to populate\n\n\nselect: optional fields to select\n\n\nmatch: optional query conditions to match\n\n\nmodel: optional name of the model to use for population\n\n\noptions: optional query options like sort, limit, etc\n\n\n\n\n\u793a\u4f8b\n\n\nUser.findById(id, function (err, user) {\n  var opts = [\n      { path: \ncompany\n, match: { x: 1 }, select: \nname\n }\n    , { path: \nnotes\n, options: { limit: 10 }, model: \noverride\n }\n  ]\n\n  User.populate(user, opts, function (err, user) {\n    console.log(user);\n  });\n});\n\n\nUser.find(match, function (err, users) {\n  var opts = [{ path: \ncompany\n, match: { x: 1 }, select: \nname\n }]\n\n  var promise = User.populate(users, opts);\n  promise.then(console.log).end();\n})\n\n\n\n\n\n\n\n\n\n\nvar user = { name: \nIndiana Jones\n, weapon: 389 }\nWeapon.populate(user, { path: \nweapon\n, model: \nWeapon\n }, function (err, user) {\n  console.log(user.weapon.name)\n})\n\n\nvar users = [{ name: \nIndiana Jones\n, weapon: 389 }]\nusers.push({ name: \nBatman\n, weapon: 8921 })\nWeapon.populate(users, { path: \nweapon\n }, function (err, users) {\n  users.forEach(function (user) {\n    console.log(\n%s uses a %s\n, users.name, user.weapon.name)\n\n\n  });\n});", 
            "title": "\u6a21\u578bAPI"
        }, 
        {
            "location": "/model/api/#_1", 
            "text": "", 
            "title": "\u6a21\u578b"
        }, 
        {
            "location": "/model/api/#model", 
            "text": "\u53c2\u6570   doc \u00abObject\u00bb values with which to create the document   Model constructor  Provides the interface to MongoDB collections as well as creates document instances.", 
            "title": "Model()"
        }, 
        {
            "location": "/model/api/#modelprototypedb", 
            "text": "Connection the model uses.", 
            "title": "Model.prototype.db"
        }, 
        {
            "location": "/model/api/#modelprototypecollection", 
            "text": "Collection the model uses.", 
            "title": "Model.prototype.collection"
        }, 
        {
            "location": "/model/api/#modelprototypemodelname", 
            "text": "", 
            "title": "Model.prototype.modelName"
        }, 
        {
            "location": "/model/api/#modelprototypewhere", 
            "text": "Additional properties to attach to the query when calling  save()  and  isNew  is false.", 
            "title": "Model.prototype.$where"
        }, 
        {
            "location": "/model/api/#modelprototypebasemodelname", 
            "text": "If this is a discriminator model,  baseModelName  is the name of the base model.", 
            "title": "Model.prototype.baseModelName"
        }, 
        {
            "location": "/model/api/#modelprototypesave", 
            "text": "\u53c2\u6570   [fn] \u00abFunction\u00bb optional callback   \u8fd4\u56de  Saves this document.  \u793a\u4f8b  product.sold = Date.now();\nproduct.save(function (err, product) {\n  if (err) ..\n})  The callback will receive three parameters   err  if an error occurred  product  which is the saved  product   As an extra measure of flow control, save will return a Promise.  \u793a\u4f8b  product.save().then(function(product) {\n   ...\n});", 
            "title": "Model.prototype.save()"
        }, 
        {
            "location": "/model/api/#modelprototypeincrement", 
            "text": "Signal that we desire an increment of this documents version.  \u793a\u4f8b  Model.findById(id, function (err, doc) {\n  doc.increment();\n  doc.save(function (err) { .. })\n})", 
            "title": "Model.prototype.increment()"
        }, 
        {
            "location": "/model/api/#modelprototyperemove", 
            "text": "\u53c2\u6570   [fn] \u00abfunction(err,product)\u00bb optional callback   \u8fd4\u56de  Removes this document from the db.  \u793a\u4f8b  product.remove(function (err, product) {\n  if (err) return handleError(err);\n  Product.findById(product._id, function (err, product) {\n    console.log(product)\n  })\n})  As an extra measure of flow control, remove will return a Promise (bound to  fn  if passed) so it could be chained, or hooked to recive errors  \u793a\u4f8b  product.remove().then(function (product) {\n   ...\n}).catch(function (err) {\n   assert.ok(err)\n})", 
            "title": "Model.prototype.remove()"
        }, 
        {
            "location": "/model/api/#modelprototypemodel", 
            "text": "\u53c2\u6570   name \u00abString\u00bb model name   Returns another Model instance.  \u793a\u4f8b  var doc = new Tank;\ndoc.model( User ).findById(id, callback);", 
            "title": "Model.prototype.model()"
        }, 
        {
            "location": "/model/api/#modeldiscriminator", 
            "text": "\u53c2\u6570   schema \u00abSchema\u00bb discriminator model schema   Adds a discriminator type.  \u793a\u4f8b  function   BaseSchema() { \n   Schema . apply ( this ,   arguments ); \n\n   this . add ({ \n     name :  String , \n     createdAt :  Date \n   });  }  util . inherits ( BaseSchema ,   Schema );  var   PersonSchema   =   new   BaseSchema ();  var   BossSchema   =   new   BaseSchema ({   department :  String   });  var   Person   =   mongoose . model ( Person ,   PersonSchema );  var   Boss   =   Person . discriminator ( Boss ,   BossSchema );", 
            "title": "Model.discriminator()"
        }, 
        {
            "location": "/model/api/#modelinit", 
            "text": "\u53c2\u6570  Performs any async initialization of this model against MongoDB. Currently, this function is only responsible for building [indexes, unless [ autoIndex  is turned off.  This function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to  MyModel.on('index')  \u793a\u4f8b  var eventSchema = new Schema({ thing: { type:  string , unique: true }})\n\n\nvar Event = mongoose.model( Event , eventSchema);\n\nEvent.init().then(function(Event) {\n\n\n  console.log( Indexes are done building! );\n});", 
            "title": "Model.init()"
        }, 
        {
            "location": "/model/api/#modelensureindexes", 
            "text": "\u53c2\u6570   [cb] \u00abFunction\u00bb optional callback   \u8fd4\u56de  Sends  createIndex  commands to mongo for each index declared in the schema. The  createIndex  commands are sent in series.  \u793a\u4f8b  Event.ensureIndexes(function (err) {\n  if (err) return handleError(err);\n});  After completion, an  index  event is emitted on this  Model  passing an error if one occurred.  \u793a\u4f8b  var eventSchema = new Schema({ thing: { type:  string , unique: true }})\nvar Event = mongoose.model( Event , eventSchema);\n\nEvent.on( index , function (err) {\n  if (err) console.error(err);\n})  NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.", 
            "title": "Model.ensureIndexes()"
        }, 
        {
            "location": "/model/api/#modelcreateindexes", 
            "text": "\u53c2\u6570   [cb] \u00abFunction\u00bb optional callback   \u8fd4\u56de  Similar to  ensureIndexes() , except for it uses the [ createIndex  function. The  ensureIndex()  function checks to see if an index with that name already exists, and, if not, does not attempt to create the index.  createIndex()  bypasses this check.", 
            "title": "Model.createIndexes()"
        }, 
        {
            "location": "/model/api/#modelprototypeschema", 
            "text": "", 
            "title": "Model.prototype.schema"
        }, 
        {
            "location": "/model/api/#modelprototypebase", 
            "text": "Base Mongoose instance the model uses.", 
            "title": "Model.prototype.base"
        }, 
        {
            "location": "/model/api/#modelprototypediscriminators", 
            "text": "Registered discriminators for this model.", 
            "title": "Model.prototype.discriminators"
        }, 
        {
            "location": "/model/api/#modeltranslatealiases", 
            "text": "\u53c2\u6570   raw \u00abObject\u00bb fields/conditions that may contain aliased keys   \u8fd4\u56de   \u00abObject\u00bb the translated 'pure' fields/conditions   Translate any aliases fields/conditions so the final query or document object is pure  \u793a\u4f8b  Character\n  .find(Character.translateAliases({\n     \u540d :  Eddard Stark \n  })\n  .exec(function(err, characters) {})  \u6ce8\u91ca  Only translate arguments of object type anything else is returned raw", 
            "title": "Model.translateAliases()"
        }, 
        {
            "location": "/model/api/#modelremove", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Removes all documents that match  conditions  from the collection. To remove just the first document that matches  conditions , set the  single  option to true.  \u793a\u4f8b  Character . remove ( {   name :   Eddard Stark   } ,   function   ( err )   {} );   \u6ce8\u91ca  This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved,  no middleware (hooks) are executed .", 
            "title": "Model.remove()"
        }, 
        {
            "location": "/model/api/#modeldeleteone", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Deletes the first document that matches  conditions  from the collection. Behaves like  remove() , but deletes at most one document regardless of the  single  option.  \u793a\u4f8b  Character . deleteOne ( {   name :   Eddard Stark   } ,   function   ( err )   {} );   \u6ce8\u91ca  Like  Model.remove() , this function does  not  trigger  pre('remove')  or  post('remove')  hooks.", 
            "title": "Model.deleteOne()"
        }, 
        {
            "location": "/model/api/#modeldeletemany", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Deletes all of the documents that match  conditions  from the collection. Behaves like  remove() , but deletes all documents that match  conditions  regardless of the  single  option.  \u793a\u4f8b  Character . deleteMany ( {   name :   / Stark / ,   age :   {   $ gte :   18   }   } ,   function   ( err )   {} );   \u6ce8\u91ca  Like  Model.remove() , this function does  not  trigger  pre('remove')  or  post('remove')  hooks.", 
            "title": "Model.deleteMany()"
        }, 
        {
            "location": "/model/api/#modelfind", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Finds documents  The  conditions  are cast to their respective SchemaTypes before the command is sent.  \u793a\u4f8b  MyModel . find ( {   name :   john ,   age :   {   $ gte :   18   } } );  MyModel . find ( {   name :   john ,   age :   {   $ gte :   18   } } ,   function   ( err ,   docs )   {} );  MyModel . find ( {   name :   / john / i   } ,   name friends ,   function   ( err ,   docs )   {   } )  MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } )  MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } ,   function   ( err ,   docs )   {} );  var   query   =   MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } )  query . exec ( function   ( err ,   docs )   {} );  var   query   =   MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } );  var   promise   =   query . exec ();  promise . addBack ( function   ( err ,   docs )   {} );", 
            "title": "Model.find()"
        }, 
        {
            "location": "/model/api/#modelfindbyid", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Finds a single document by its _id field.  findById(id)  is almost* equivalent to  findOne({ _id: id }) . If you want to query by a document's  _id , use  findById()  instead of  findOne() .  The  id  is cast based on the Schema before sending the command.  This function triggers the following middleware.   Except for how it treats  undefined . If you use  findOne() , you'll see that  findOne(undefined)  and  findOne({ _id: undefined })  are equivalent to  findOne({})  and return arbitrary documents. However, mongoose translates  findById(undefined)  into  findOne({ _id: null }) .   \u793a\u4f8b  Adventure . findById ( id ,   function   ( err ,   adventure )   {} );  Adventure . findById ( id ) . exec ( callback );  Adventure . findById ( id ,   name length ,   function   ( err ,   adventure )   {} );  Adventure . findById ( id ,   name length ) . exec ( callback );  Adventure . findById ( id ,   -length ) . exec ( function   ( err ,   adventure )   {} );  Adventure . findById ( id ,   name ,   {   lean :   true   } ,   function   ( err ,   doc )   {} );  Adventure . findById ( id ,   name ) . lean () . exec ( function   ( err ,   doc )   {} );", 
            "title": "Model.findById()"
        }, 
        {
            "location": "/model/api/#modelfindone", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Finds one document.  The  conditions  are cast to their respective SchemaTypes before the command is sent.  Note:   conditions  is optional, and if  conditions  is null or undefined, mongoose will send an empty  findOne  command to MongoDB, which will return an arbitrary document. If you're querying by  _id , use  findById()  instead.  \u793a\u4f8b  Adventure . findOne ( {   type :   iphone   } ,   function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ) . exec ( function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ,   name ,   function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ,   name ) . exec ( function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ,   name ,   {   lean :   true   } ,   callback );  Adventure . findOne ( {   type :   iphone   } ,   name ,   {   lean :   true   } ) . exec ( callback );  Adventure . findOne ( {   type :   iphone   } ) . select ( name ) . lean () . exec ( callback );", 
            "title": "Model.findOne()"
        }, 
        {
            "location": "/model/api/#modelcount", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Counts number of matching documents in a database collection.  \u793a\u4f8b  Adventure.count({ type:  jungle  }, function (err, count) {\n  if (err) ..\n  console.log( there are %d jungle adventures , count);\n});", 
            "title": "Model.count()"
        }, 
        {
            "location": "/model/api/#modeldistinct", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Creates a Query for a  distinct  operation.  Passing a  callback  immediately executes the query.  \u793a\u4f8b  Link.distinct( url ,  {   clicks :   { $gt :   100 }} , function (err, result)  { \n   if   ( err )   return   handleError ( err ); \n\n   assert ( Array . isArray ( result )); \n   console . log ( unique urls with more than 100 clicks ,   result );  } )  var query = Link.distinct( url );  query.exec(callback);", 
            "title": "Model.distinct()"
        }, 
        {
            "location": "/model/api/#modelwhere", 
            "text": "\u53c2\u6570   [val] \u00abObject\u00bb optional value   \u8fd4\u56de  Creates a Query, applies the passed conditions, and returns the Query.  For example, instead of writing:  User . find ( { age :   {$ gte :   21 ,   $ lte :   65 } } ,   callback );   we can instead write:  User.where( age ).gte(21).lte(65).exec(callback);  Since the Query class also supports  where  you can continue chaining  User\n.where( age ).gte(21).lte(65)\n.where( name , /^b/i)\n... etc", 
            "title": "Model.where()"
        }, 
        {
            "location": "/model/api/#modelprototypewhere_1", 
            "text": "\u53c2\u6570   argument \u00abString,Function\u00bb is a javascript string or anonymous function   \u8fd4\u56de  Creates a  Query  and specifies a  $where  condition.  Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via  find({ $where: javascript }) , or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.  Blog.$where( this.username.indexOf( val ) !== -1 ).exec(function (err, docs) {});", 
            "title": "Model.prototype.$where()"
        }, 
        {
            "location": "/model/api/#modelfindoneandupdate", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Issues a mongodb findAndModify update command.  Finds a matching document, updates it according to the  update  arg, passing any  options , and returns the found document (if any) to the callback. The query executes immediately if  callback  is passed else a Query object is returned.  \u9009\u9879   new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)  upsert : bool - creates the object if it doesn't exist. defaults to false.  fields : {Object|String} - Field selection. Equivalent to  .select(fields).findOneAndUpdate()  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on [MongoDB's  $setOnInsert  operator.  rawResult : if true, returns the [raw result from the MongoDB driver  strict : overwrites the schema's [strict mode option for this update   \u793a\u4f8b  A.findOneAndUpdate(conditions, update, options, callback)\nA.findOneAndUpdate(conditions, update, options)\nA.findOneAndUpdate(conditions, update, callback)\nA.findOneAndUpdate(conditions, update)\nA.findOneAndUpdate()  \u6ce8\u91ca  All top level update keys which are not  atomic  operation names are treated as set operations:  \u793a\u4f8b  var   query   =   {   name :   borne   } ;  Model . findOneAndUpdate ( query ,   {   name :   jason bourne   } ,   options ,   callback )  Model . findOneAndUpdate ( query ,   {   $ set :   {   name :   jason bourne   } } ,   options ,   callback )   This helps prevent accidentally overwriting your document with  { name: 'jason bourne' } .  \u6ce8\u91ca  Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.   defaults. Use the  setDefaultsOnInsert  option to override.   findAndModify  helpers support limited validation. You can enable these by setting the  runValidators  options, respectively.  If you need full-fledged validation, use the traditional approach of first retrieving the document.  Model.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n});", 
            "title": "Model.findOneAndUpdate()"
        }, 
        {
            "location": "/model/api/#modelfindbyidandupdate", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Issues a mongodb findAndModify update command by a document's _id field.  findByIdAndUpdate(id, ...)  is equivalent to  findOneAndUpdate({ _id: id }, ...) .  Finds a matching document, updates it according to the  update  arg, passing any  options , and returns the found document (if any) to the callback. The query executes immediately if  callback  is passed else a Query object is returned.  This function triggers the following middleware.  \u9009\u9879   new : bool - true to return the modified document rather than the original. defaults to false  upsert : bool - creates the object if it doesn't exist. defaults to false.  runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on [MongoDB's  $setOnInsert  operator.  sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  select : sets the document fields to return  rawResult : if true, returns the [raw result from the MongoDB driver  strict : overwrites the schema's [strict mode option for this update   \u793a\u4f8b  A.findByIdAndUpdate(id, update, options, callback)\nA.findByIdAndUpdate(id, update, options)\nA.findByIdAndUpdate(id, update, callback)\nA.findByIdAndUpdate(id, update)\nA.findByIdAndUpdate()  \u6ce8\u91ca  All top level update keys which are not  atomic  operation names are treated as set operations:  \u793a\u4f8b  Model.findByIdAndUpdate(id, { name:  jason bourne  }, options, callback)\n\n\nModel.findByIdAndUpdate(id, { $set: { name:  jason bourne  }}, options, callback)  This helps prevent accidentally overwriting your document with  { name: 'jason bourne' } .  \u6ce8\u91ca  Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.   defaults. Use the  setDefaultsOnInsert  option to override.   findAndModify  helpers support limited validation. You can enable these by setting the  runValidators  options, respectively.  If you need full-fledged validation, use the traditional approach of first retrieving the document.  Model.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n});", 
            "title": "Model.findByIdAndUpdate()"
        }, 
        {
            "location": "/model/api/#modelfindoneandremove", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Issue a mongodb findAndModify remove command.  Finds a matching document, removes it, passing the found document (if any) to the callback.  Executes immediately if  callback  is passed else a Query object is returned.  This function triggers the following middleware.  \u9009\u9879   sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  select : sets the document fields to return  rawResult : if true, returns the [raw result from the MongoDB driver  strict : overwrites the schema's [strict mode option for this update   \u793a\u4f8b  A.findOneAndRemove(conditions, options, callback)\nA.findOneAndRemove(conditions, options)\nA.findOneAndRemove(conditions, callback)\nA.findOneAndRemove(conditions)\nA.findOneAndRemove()  Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.   defaults. Use the  setDefaultsOnInsert  option to override.   findAndModify  helpers support limited validation. You can enable these by setting the  runValidators  options, respectively.  If you need full-fledged validation, use the traditional approach of first retrieving the document.  Model.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n});", 
            "title": "Model.findOneAndRemove()"
        }, 
        {
            "location": "/model/api/#modelfindbyidandremove", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Issue a mongodb findAndModify remove command by a document's _id field.  findByIdAndRemove(id, ...)  is equivalent to  findOneAndRemove({ _id: id }, ...) .  Finds a matching document, removes it, passing the found document (if any) to the callback.  Executes immediately if  callback  is passed, else a  Query  object is returned.  This function triggers the following middleware.  \u9009\u9879   sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  select : sets the document fields to return  rawResult : if true, returns the [raw result from the MongoDB driver  strict : overwrites the schema's [strict mode option for this update   \u793a\u4f8b  A.findByIdAndRemove(id, options, callback)\nA.findByIdAndRemove(id, options)\nA.findByIdAndRemove(id, callback)\nA.findByIdAndRemove(id)\nA.findByIdAndRemove()", 
            "title": "Model.findByIdAndRemove()"
        }, 
        {
            "location": "/model/api/#modelcreate", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb callback   \u8fd4\u56de  Shortcut for saving one or more documents to the database.  MyModel.create(docs)  does  new MyModel(doc).save()  for every doc in docs.  This function triggers the following middleware.  \u793a\u4f8b  Candy . create ( {   type :   jelly bean   } ,   {   type :   snickers   } ,   function   ( err ,   jellybean ,   snickers )   { \n   if   (err)  } );  var   array   =   [ {   type :   jelly bean   },   {   type :   snickers   } ] ;  Candy . create ( array ,   function   ( err ,   candies )   { \n   if   (err) \n\n   var   jellybean   =   candies [ 0 ] ; \n   var   snickers   =   candies [ 1 ] ;  } );  var   promise   =   Candy . create ( {   type :   jawbreaker   } );  promise . then ( function   ( jawbreaker )   {  } )", 
            "title": "Model.create()"
        }, 
        {
            "location": "/model/api/#modelwatch", 
            "text": "\u53c2\u6570  \u8fd4\u56de   \u00abChangeStream\u00bb mongoose-specific change stream wrapper   Requires a replica set running MongoDB  = 3.6.0.  Watches the underlying collection for changes using [MongoDB change streams.  This function does  not  trigger any middleware. In particular, it does  not  trigger aggregate middleware.  \u793a\u4f8b  const   doc   =   await   Person . create ( {   name :   Ned Stark   } );  Person . watch () . on ( change ,   change   =   console . log ( change ));  await   doc . remove ();", 
            "title": "Model.watch()"
        }, 
        {
            "location": "/model/api/#modelinsertmany", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb callback   \u8fd4\u56de  Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than  .create()  because it only sends one operation to the server, rather than one for each document.  Mongoose always validates each document  before  sending  insertMany  to MongoDB. So if one document has a validation error, no documents will be saved, unless you set [the  ordered  option to false.  This function does  not  trigger save middleware.  This function triggers the following middleware.  \u793a\u4f8b  var   arr   =   [ {   name :   Star Wars   },   {   name :   The Empire Strikes Back   } ] ;  Movies . insertMany ( arr ,   function ( error ,   docs )   {} );", 
            "title": "Model.insertMany()"
        }, 
        {
            "location": "/model/api/#modelbulkwrite", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb callback  function(error, bulkWriteOpResult) {}   \u8fd4\u56de   \u00abPromise\u00bb resolves to a  BulkWriteOpResult  if the operation succeeds   Sends multiple  insertOne ,  updateOne ,  updateMany ,  replaceOne ,  deleteOne , and/or  deleteMany  operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use  create() ) because with  bulkWrite()  there is only one round trip to MongoDB.  Mongoose will perform casting on all operations you provide.  This function does  not  trigger any middleware, not  save()  nor  update() . If you need to trigger  save()  middleware for every document use [ create()  instead.  \u793a\u4f8b  Character.bulkWrite([\n  {\n    insertOne: {\n      document: {\n        name:  Eddard Stark ,\n        title:  Warden of the North \n      }\n    }\n  },\n  {\n    updateOne: {\n      filter: { name:  Eddard Stark  },\n\n\n\n      update: { title:  Hand of the King  }\n    }\n  },\n  {\n    deleteOne: {\n      {\n        filter: { name:  Eddard Stark  }\n      }\n    }\n  }\n]).then(handleResult);", 
            "title": "Model.bulkWrite()"
        }, 
        {
            "location": "/model/api/#modelhydrate", 
            "text": "\u53c2\u6570  \u8fd4\u56de   \u00abModel\u00bb document instance   Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.  \u793a\u4f8b  var   mongooseCandy   =   Candy . hydrate ( {   _id :   54108337212ffb6d459f854c ,   type :   jelly bean   } );", 
            "title": "Model.hydrate()"
        }, 
        {
            "location": "/model/api/#modelupdate", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Updates one document in the database without returning it.  This function triggers the following middleware.  \u793a\u4f8b  MyModel . update ( {   age :   {   $ gt :   18   }   } ,   {   oldEnough :   true   } ,   fn );  MyModel . update ( {   name :   Tobi   } ,   {   ferret :   true   } ,   {   multi :   true   } ,   function   ( err ,   raw )   { \n   if   (err)   return   handleError(err) ; \n   console.log( The   raw   response   from   Mongo   was   ,   raw) ;  } );   \u6709\u6548\u7684\u9009\u9879   safe  (boolean) safe mode (defaults to value set in schema (true))  upsert  (boolean) whether to create the doc if it doesn't match (false)  multi  (boolean) whether multiple documents should be updated (false)  runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on [MongoDB's  $setOnInsert  operator.  strict  (boolean) overrides the  strict  option for this update  overwrite  (boolean) disables update-only mode, allowing you to overwrite the doc (false)   All  update  values are cast to their appropriate SchemaTypes before being sent.  The  callback  function receives  (err, rawResponse) .   err  is the error if any occurred  rawResponse  is the full response from Mongo   \u6ce8\u91ca  All top level keys which are not  atomic  operation names are treated as set operations:  \u793a\u4f8b  var   query   =   {   name :   borne   } ;  Model . update ( query ,   {   name :   jason bourne   } ,   options ,   callback )  Model . update ( query ,   {   $ set :   {   name :   jason bourne   } } ,   options ,   callback )   This helps prevent accidentally overwriting all documents in your collection with  { name: 'jason bourne' } .  \u6ce8\u91ca  Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error.  \u6ce8\u91ca  To update documents without waiting for a response from MongoDB, do not pass a  callback , then call  exec  on the returned [Query:  Comment . update ( {   _id :   id   } ,   {   $ set :   {   text :   changed   } } ) . exec ();   \u6ce8\u91ca  Although values are casted to their appropriate types when using update, the following are  not  applied:   defaults  setters  validators  middleware   If you need those features, use the traditional approach of first retrieving the document.  Model.findOne({ name:  borne  }, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n})", 
            "title": "Model.update()"
        }, 
        {
            "location": "/model/api/#modelupdatemany", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Same as  update() , except MongoDB will update  all  documents that match  criteria  (as opposed to just the first one) regardless of the value of the  multi  option.  Note  updateMany will  not  fire update middleware. Use  pre('updateMany')  and  post('updateMany')  instead.  This function triggers the following middleware.", 
            "title": "Model.updateMany()"
        }, 
        {
            "location": "/model/api/#modelupdateone", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Same as  update() , except MongoDB will update  only  the first document that matches  criteria  regardless of the value of the  multi  option.  This function triggers the following middleware.", 
            "title": "Model.updateOne()"
        }, 
        {
            "location": "/model/api/#modelreplaceone", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Same as  update() , except MongoDB replace the existing document with the given document (no atomic operators like  $set ).  This function triggers the following middleware.", 
            "title": "Model.replaceOne()"
        }, 
        {
            "location": "/model/api/#modelmapreduce", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional callback   \u8fd4\u56de  Executes a mapReduce command.  o  is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation for more detail about options.  This function does not trigger any middleware.  \u793a\u4f8b  var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\nUser.mapReduce(o, function (err, results) {\n  console.log(results)\n})  \u5176\u4ed6\u9009\u9879   query  {Object} query filter object.  sort  {Object} sort input objects using this key  limit  {Number} max number of documents  keeptemp  {Boolean, default:false} keep temporary data  finalize  {Function} finalize function  scope  {Object} scope variables exposed to map/reduce/finalize during execution  jsMode  {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB   2.0.X  verbose  {Boolean, default:false} provide statistics on job execution time.  readPreference  {String}  out*  {Object, default: {inline:1}} sets the output target for the map reduce job.   \u8f93\u51fa\u9009\u9879   {inline:1}  the results are returned in an array  {replace: 'collectionName'}  add the results to collectionName: the results replace the collection  {reduce: 'collectionName'}  add the results to collectionName: if dups are detected, uses the reducer / finalize functions  {merge: 'collectionName'}  add the results to collectionName: if dups exist the new docs overwrite the old   If  options.out  is set to  replace ,  merge , or  reduce , a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the  lean  option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).  \u793a\u4f8b  var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\no.out = { replace:  createdCollectionNameForResults  }\no.verbose = true;\n\nUser.mapReduce(o, function (err, model, stats) {\n  console.log( map reduce took %d ms , stats.processtime)\n  model.find().where( value ).gt(10).exec(function (err, docs) {\n    console.log(docs);\n  });\n})\n\n\n\no.resolveToObject = true;\nvar promise = User.mapReduce(o);\npromise.then(function (res) {\n  var model = res.model;\n  var stats = res.stats;\n  console.log( map reduce took %d ms , stats.processtime)\n  return model.find().where( value ).gt(10).exec();\n}).then(function (docs) {\n   console.log(docs);\n}).then(null, handleError).end()", 
            "title": "Model.mapReduce()"
        }, 
        {
            "location": "/model/api/#modelaggregate", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Performs [aggregations on the models collection.  If a  callback  is passed, the  aggregate  is executed and a  Promise  is returned. If a callback is not passed, the  aggregate  itself is returned.  This function does not trigger any middleware.  \u793a\u4f8b  Users.aggregate(\n  { $group: { _id: null, maxBalance: { $max:  $balance  }}},\n  { $project: { _id: 0, maxBalance: 1 }},\n  function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n  });\n\n\nUsers.aggregate()\n  .group({ _id: null, maxBalance: { $max:  $balance  } })\n  .select( -id maxBalance )\n  .exec(function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n});  \u6ce8\u91ca   Arguments are not cast to the model's schema because  $project  operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.  The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).  Requires MongoDB  = 2.1", 
            "title": "Model.aggregate()"
        }, 
        {
            "location": "/model/api/#modelgeosearch", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional callback   \u8fd4\u56de  Implements  $geoSearch  functionality for Mongoose  This function does not trigger any middleware  \u793a\u4f8b  var   options   =   {   near :   [ 10 ,   10 ] ,   maxDistance :   5   } ;  Locations . geoSearch ( {   type   :   house   } ,   options ,   function ( err ,   res )   { \n   console.log(res) ;  } );   \u9009\u9879   near  {Array} x,y point to search for  maxDistance  {Number} the maximum distance from the point near that a result can be  limit  {Number} The maximum number of results to return  lean  {Boolean} return the raw object instead of the Mongoose Model", 
            "title": "Model.geoSearch()"
        }, 
        {
            "location": "/model/api/#modelpopulate", 
            "text": "\u53c2\u6570   [callback(err,doc)] \u00abFunction\u00bb Optional callback, executed upon completion. Receives  err  and the  doc(s) .   \u8fd4\u56de  Populates document references.  \u53ef\u7528\u7684\u9009\u9879   path: space delimited path(s) to populate  select: optional fields to select  match: optional query conditions to match  model: optional name of the model to use for population  options: optional query options like sort, limit, etc   \u793a\u4f8b  User.findById(id, function (err, user) {\n  var opts = [\n      { path:  company , match: { x: 1 }, select:  name  }\n    , { path:  notes , options: { limit: 10 }, model:  override  }\n  ]\n\n  User.populate(user, opts, function (err, user) {\n    console.log(user);\n  });\n});\n\n\nUser.find(match, function (err, users) {\n  var opts = [{ path:  company , match: { x: 1 }, select:  name  }]\n\n  var promise = User.populate(users, opts);\n  promise.then(console.log).end();\n})\n\n\n\n\n\n\n\n\n\n\nvar user = { name:  Indiana Jones , weapon: 389 }\nWeapon.populate(user, { path:  weapon , model:  Weapon  }, function (err, user) {\n  console.log(user.weapon.name)\n})\n\n\nvar users = [{ name:  Indiana Jones , weapon: 389 }]\nusers.push({ name:  Batman , weapon: 8921 })\nWeapon.populate(users, { path:  weapon  }, function (err, users) {\n  users.forEach(function (user) {\n    console.log( %s uses a %s , users.name, user.weapon.name)\n\n\n  });\n});", 
            "title": "Model.populate()"
        }, 
        {
            "location": "/document/guide/", 
            "text": "\u6587\u6863\n\n\nSource\n\n\nMongoose \ndocuments\n represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its \nModel\n.\n\n\n\u68c0\u7d22\n\n\nThere are many ways to retrieve documents from MongoDB. We won't cover that in this section. See the chapter on \nquerying\n for detail.\n\n\n\u66f4\u65b0\n\n\nThere are a number of ways to update documents. We'll first look at a traditional approach using \nfindById\n:\n\n\nTank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  tank.size = \nlarge\n;\n  tank.save(function (err, updatedTank) {\n    if (err) return handleError(err);\n    res.send(updatedTank);\n  });\n});\n\n\n\n\n\nYou can also use \n.set()\n to modify documents. Under the hood, \ntank.size = 'large';\n becomes \ntank.set({ size: 'large' })\n.\n\n\nTank\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \ntank\n)\n \n{\n\n  \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n\n  \ntank.set({\n \nsize\n:\n \nlarge\n \n}\n);\n\n  \ntank\n.\nsave\n(\nfunction\n \n(\nerr\n,\n \nupdatedTank\n)\n \n{\n\n    \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n    \nres.send(updatedTank)\n;\n\n  \n}\n);\n\n\n}\n);\n\n\n\n\n\n\nThis approach involves first retrieving the document from Mongo, then issuing an update command (triggered by calling \nsave\n). However, if we don't need the document returned in our application and merely want to update a property in the database directly, \nModel#update\n is right for us:\n\n\nTank\n.\nupdate\n(\n{\n \n_id\n:\n \nid\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \nsize\n:\n \nlarge\n \n}\n}\n,\n \ncallback\n);\n\n\n\n\n\n\nIf we do need the document returned in our application there is another, often \nbetter\n, option:\n\n\nTank.findByIdAndUpdate(id, { $set: { size: \nlarge\n }}, { new: true }, function (err, tank) {\n  if (err) return handleError(err);\n  res.send(tank);\n});\n\n\n\n\n\nThe \nfindAndUpdate/Remove\n static methods all make a change to at most one document, and return it with just one call to the database. There \nare\n \nseveral\n \nvariations\n on the \nfindAndModify\n theme. Read the \nAPI\n docs for more detail.\n\n\nNote that \nfindAndUpdate/Remove\n do _not\n execute any hooks or validation before making the change in the database. You can use the \nrunValidators\n option\n to access a limited subset of document validation. However, if you need hooks and full document validation, first query for the document and then \nsave()\n it._\n\n\n\u8bc1\u5b9e\n\n\nDocuments are validated before they are saved. Read the \napi\n docs or the \nvalidation\n chapter for detail.\n\n\n\u8986\u76d6\n\n\nYou can overwrite an entire document using \n.set()\n. This is handy if you want to change what document is being saved in \nmiddleware\n.\n\n\nTank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  otherTank.set(tank);\n});\n\n\n\n\n\n\u4e0b\u4e00\u4e2a\n\n\nNow that we've covered Documents, let's take a look at \nSub-documents\n.", 
            "title": "\u6587\u6863\u624b\u518c"
        }, 
        {
            "location": "/document/guide/#_1", 
            "text": "Source  Mongoose  documents  represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its  Model .", 
            "title": "\u6587\u6863"
        }, 
        {
            "location": "/document/guide/#_2", 
            "text": "There are many ways to retrieve documents from MongoDB. We won't cover that in this section. See the chapter on  querying  for detail.", 
            "title": "\u68c0\u7d22"
        }, 
        {
            "location": "/document/guide/#_3", 
            "text": "There are a number of ways to update documents. We'll first look at a traditional approach using  findById :  Tank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  tank.size =  large ;\n  tank.save(function (err, updatedTank) {\n    if (err) return handleError(err);\n    res.send(updatedTank);\n  });\n});  You can also use  .set()  to modify documents. Under the hood,  tank.size = 'large';  becomes  tank.set({ size: 'large' }) .  Tank . findById ( id ,   function   ( err ,   tank )   { \n   if   (err)   return   handleError(err) ; \n\n   tank.set({   size :   large   } ); \n   tank . save ( function   ( err ,   updatedTank )   { \n     if   (err)   return   handleError(err) ; \n     res.send(updatedTank) ; \n   } );  } );   This approach involves first retrieving the document from Mongo, then issuing an update command (triggered by calling  save ). However, if we don't need the document returned in our application and merely want to update a property in the database directly,  Model#update  is right for us:  Tank . update ( {   _id :   id   } ,   {   $ set :   {   size :   large   } } ,   callback );   If we do need the document returned in our application there is another, often  better , option:  Tank.findByIdAndUpdate(id, { $set: { size:  large  }}, { new: true }, function (err, tank) {\n  if (err) return handleError(err);\n  res.send(tank);\n});  The  findAndUpdate/Remove  static methods all make a change to at most one document, and return it with just one call to the database. There  are   several   variations  on the  findAndModify  theme. Read the  API  docs for more detail.  Note that  findAndUpdate/Remove  do _not  execute any hooks or validation before making the change in the database. You can use the  runValidators  option  to access a limited subset of document validation. However, if you need hooks and full document validation, first query for the document and then  save()  it._", 
            "title": "\u66f4\u65b0"
        }, 
        {
            "location": "/document/guide/#_4", 
            "text": "Documents are validated before they are saved. Read the  api  docs or the  validation  chapter for detail.", 
            "title": "\u8bc1\u5b9e"
        }, 
        {
            "location": "/document/guide/#_5", 
            "text": "You can overwrite an entire document using  .set() . This is handy if you want to change what document is being saved in  middleware .  Tank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  otherTank.set(tank);\n});", 
            "title": "\u8986\u76d6"
        }, 
        {
            "location": "/document/guide/#_6", 
            "text": "Now that we've covered Documents, let's take a look at  Sub-documents .", 
            "title": "\u4e0b\u4e00\u4e2a"
        }, 
        {
            "location": "/document/api/", 
            "text": "\u6587\u6863\n\n\nDocument.prototype.schema\n\n\nDocument.prototype.isNew\n\n\n\u5e03\u5c14\u6807\u5fd7\u6307\u5b9a\u6587\u6863\n\n\nDocument.prototype.id\n\n\n\u8fd9\u4e2a\u6587\u4ef6\u7684\u5b57\u7b26\u4e32\u7248\u672c_id\n\n\n\u6ce8\u91ca\n\n\n\u8fd9\u4e2agetter\u9ed8\u8ba4\u5b58\u5728\u4e8e\u6240\u6709\u7684\u6587\u4ef6\u4e0a\u3002 The getter can be disabled by setting the \nid\n option of its \nSchema\n to false at construction time.\n\n\nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \nid\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\nDocument.prototype.errors\n\n\nHash containing current validation errors.\n\n\nDocument.prototype.init()\n\n\n\u53c2\u6570\n\n\n\n\ndoc \u00abObject\u00bb document returned by mongo\n\n\n\n\nInitializes the document without setters or marking anything modified.\n\n\nCalled internally after a document is returned from mongodb.\n\n\nDocument.prototype.update()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSends an update command with this document \n_id\n as the query selector.\n\n\n\u793a\u4f8b\n\n\nweirdCar\n.\nupdate\n(\n{\n$\ninc\n:\n \n{\nwheels\n:\n1\n}\n}\n,\n \n{\n \nw\n:\n \n1\n \n}\n,\n \ncallback\n);\n\n\n\n\n\n\n\u6709\u6548\u7684\u9009\u9879\n\n\nDocument.prototype.$set()\n\n\n\u53c2\u6570\n\n\n\n\noptions] \u00abObject\u00bb optionally specify options that modify the behavior of the set\n\n\n\n\nAlias for \nset()\n, used internally to avoid conflicts\n\n\nDocument.prototype.set()\n\n\n\u53c2\u6570\n\n\n\n\noptions] \u00abObject\u00bb optionally specify options that modify the behavior of the set\n\n\n\n\nSets the value of a path, or many paths.\n\n\n\u793a\u4f8b\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n)\n\n\n\n\ndoc\n.\nset\n(\n{\n\n    \npath\n  \n:\n \nvalue\n\n  \n,\n \npath2\n \n:\n \n{\n\n       \npath\n  \n:\n \nvalue\n\n    \n}\n\n\n}\n)\n\n\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n,\n \nNumber\n)\n\n\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n,\n \nString\n)\n\n\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\nDocument.prototype.get()\n\n\n\u53c2\u6570\n\n\n\n\ntype] \u00abSchema,String,Number,Buffer,*\u00bb optionally specify a type for on-the-fly attributes\n\n\n\n\nReturns the value of a path.\n\n\n\u793a\u4f8b\n\n\ndoc.get(\nage\n)\n\n\ndoc.get(\nage\n, String)\n\n\n\n\n\nDocument.prototype.markModified()\n\n\n\u53c2\u6570\n\n\n\n\nscope] \u00abDocument\u00bb the scope to run validators with\n\n\n\n\nMarks the path as having pending changes to write to the db.\n\n\nVery helpful when using Mixed types.\n\n\n\u793a\u4f8b\n\n\ndoc.mixed.type = \nchanged\n;\ndoc.markModified(\nmixed.type\n);\ndoc.save()\n\n\n\n\n\nDocument.prototype.unmarkModified()\n\n\n\u53c2\u6570\n\n\n\n\npath \u00abString\u00bb the path to unmark modified\n\n\n\n\nClears the modified state on the specified path.\n\n\n\u793a\u4f8b\n\n\ndoc.foo = \nbar\n;\ndoc.unmarkModified(\nfoo\n);\ndoc.save()\n\n\n\n\n\nDocument.prototype.$ignore()\n\n\n\u53c2\u6570\n\n\n\n\npath \u00abString\u00bb the path to ignore\n\n\n\n\nDon't run validation on this path or persist changes to this path.\n\n\n\u793a\u4f8b\n\n\ndoc.foo = null;\ndoc.$ignore(\nfoo\n);\ndoc.save()\n\n\n\n\n\nDocument.prototype.modifiedPaths()\n\n\n\u8fd4\u56de\n\n\nReturns the list of paths that have been modified.\n\n\nDocument.prototype.isModified()\n\n\n\u53c2\u6570\n\n\n\n\npath] \u00abString\u00bb optional\n\n\n\n\n\u8fd4\u56de\n\n\nReturns true if this document was modified, else false.\n\n\nIf \npath\n is given, checks if a path or any full path containing \npath\n as part of its path chain has been modified.\n\n\n\u793a\u4f8b\n\n\ndoc.set(\ndocuments.0.title\n, \nchanged\n);\ndoc.isModified()\ndoc.isModified(\ndocuments\n)\ndoc.isModified(\ndocuments.0.title\n)\ndoc.isModified(\ndocuments otherProp\n)\ndoc.isDirectModified(\ndocuments\n)\n\n\n\n\n\nDocument.prototype.$isDefault()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nChecks if a path is set to its default.\n\n\n\u793a\u4f8b\n\n\nMyModel\n \n=\n \nmongoose\n.\nmodel\n(\ntest\n,\n \n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \ndefault\n:\n \nVal \n}\n \n}\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nMyModel\n();\n\n\nm\n.$\nisDefault\n(\nname\n);\n\n\n\n\n\n\nDocument.prototype.$isDeleted()\n\n\n\u53c2\u6570\n\n\n\n\nval] \u00abBoolean\u00bb optional, overrides whether mongoose thinks the doc is deleted\n\n\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abBoolean\u00bb whether mongoose thinks this doc is deleted.\n\n\n\n\nGetter/setter, determines whether the document was removed or not.\n\n\n\u793a\u4f8b\n\n\nproduct.remove(function (err, product) {\n  product.isDeleted();\n  product.remove();\n\n  product.isDeleted(false);\n  product.isDeleted();\n  product.remove();\n})\n\n\n\n\n\nDocument.prototype.isDirectModified()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nReturns true if \npath\n was directly set and modified, else false.\n\n\n\u793a\u4f8b\n\n\ndoc.set(\ndocuments.0.title\n, \nchanged\n);\ndoc.isDirectModified(\ndocuments.0.title\n)\ndoc.isDirectModified(\ndocuments\n)\n\n\n\n\n\nDocument.prototype.isInit()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nChecks if \npath\n was initialized.\n\n\nDocument.prototype.isSelected()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nChecks if \npath\n was selected in the source query which initialized this document.\n\n\n\u793a\u4f8b\n\n\nThing.findOne().select(\nname\n).exec(function (err, doc) {\n   doc.isSelected(\nname\n)\n   doc.isSelected(\nage\n)\n})\n\n\n\n\n\nDocument.prototype.isDirectSelected()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nChecks if \npath\n was explicitly selected. If no projection, always returns true.\n\n\n\u793a\u4f8b\n\n\nThing.findOne().select(\nnested.name\n).exec(function (err, doc) {\n   doc.isDirectSelected(\nnested.name\n)\n   doc.isDirectSelected(\nnested.otherName\n)\n   doc.isDirectSelected(\nnested\n)\n})\n\n\n\n\n\nDocument.prototype.validate()\n\n\n\u53c2\u6570\n\n\n\n\ncallback \u00abFunction\u00bb optional callback called after validation completes, passing an error if one occurred\n\n\n\n\n\u8fd4\u56de\n\n\nExecutes registered validation rules for this document.\n\n\n\u6ce8\u91ca\n\n\nThis method is called \npre\n save and if a validation rule is violated, save is aborted and the error is returned to your \ncallback\n.\n\n\n\u793a\u4f8b\n\n\ndoc.validate(function (err) {\n  if (err) handleError(err);\n  else\n});\n\n\n\n\n\nDocument.prototype.validateSync()\n\n\n\u53c2\u6570\n\n\n\n\npathsToValidate \u00abArray,string\u00bb only validate the given paths\n\n\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abMongooseError,undefined\u00bb MongooseError if there are errors during validation, or undefined if there is no error.\n\n\n\n\nExecutes registered validation rules (skipping asynchronous validators) for this document.\n\n\n\u6ce8\u91ca\n\n\nThis method is useful if you need synchronous validation.\n\n\n\u793a\u4f8b\n\n\nvar err = doc.validateSync();\nif ( err ){\n  handleError( err );\n} else {\n\n}\n\n\n\n\n\nDocument.prototype.invalidate()\n\n\n\u53c2\u6570\n\n\n\n\nkind] \u00abString\u00bb optional \nkind\n property for the error\n\n\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abValidationError\u00bb the current ValidationError, with all currently invalidated paths\n\n\n\n\nMarks a path as invalid, causing validation to fail.\n\n\nThe \nerrorMsg\n argument will become the message of the \nValidationError\n.\n\n\nThe \nvalue\n argument (if passed) will be available through the \nValidationError.value\n property.\n\n\ndoc.invalidate(\nsize\n, \nmust be less than 20\n, 14);\n\ndoc.validate(function (err) {\n  console.log(err)\n\n  { message: \nValidation failed\n,\n    name: \nValidationError\n,\n    errors:\n     { size:\n        { message: \nmust be less than 20\n,\n          name: \nValidatorError\n,\n          path: \nsize\n,\n          type: \nuser defined\n,\n          value: 14 } } }\n})\n\n\n\n\n\nDocument.prototype.$markValid()\n\n\n\u53c2\u6570\n\n\n\n\npath \u00abString\u00bb the field to mark as valid\n\n\n\n\nMarks a path as valid, removing existing validation errors.\n\n\nDocument.prototype.save()\n\n\n\u53c2\u6570\n\n\n\n\nfn] \u00abFunction\u00bb optional callback\n\n\n\n\n\u8fd4\u56de\n\n\nSaves this document.\n\n\n\u793a\u4f8b\n\n\nproduct.sold = Date.now();\nproduct.save(function (err, product, numAffected) {\n  if (err) ..\n})\n\n\n\n\n\nThe callback will receive three parameters\n\n\n\n\nerr\n if an error occurred\n\n\nproduct\n which is the saved \nproduct\n\n\nnumAffected\n will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking \nerr\n is sufficient to make sure your document was properly saved.\n\n\n\n\nAs an extra measure of flow control, save will return a Promise.\n\n\n\u793a\u4f8b\n\n\nproduct.save().then(function(product) {\n   ...\n});\n\n\n\n\n\nDocument.prototype.toObject()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nConverts this document into a plain javascript object, ready for storage in MongoDB.\n\n\nBuffers are converted to instances of mongodb.Binary for proper storage.\n\n\n\u9009\u9879:\n\n\n\n\ngetters\n apply all getters (path and virtual getters)\n\n\nvirtuals\n apply virtual getters (can override \ngetters\n option)\n\n\nminimize\n remove empty objects (defaults to true)\n\n\ntransform\n a transform function to apply to the resulting document before returning\n\n\ndepopulate\n depopulate any populated paths, replacing them with their original refs (defaults to false)\n\n\nversionKey\n whether to include the version key (defaults to true)\n\n\n\n\nGetters/Virtuals\n\n\nExample of only applying path getters\n\n\ndoc.toObject({ getters: true, virtuals: false })\n\n\n\n\n\nExample of only applying virtual getters\n\n\ndoc.toObject({ virtuals: true })\n\n\n\n\n\nExample of applying both path and virtual getters\n\n\ndoc.toObject({ getters: true })\n\n\n\n\n\nTo apply these options to every document of your schema by default, set your schemas \ntoObject\n option to the same argument.\n\n\nschema.set(\ntoObject\n, { virtuals: true })\n\n\n\n\n\n\u8f6c\u53d8\n\n\nWe may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional \ntransform\n function.\n\n\nTransform functions receive three arguments\n\n\nfunction\n \n(\ndoc\n,\n \nret\n,\n \noptions\n)\n \n{}\n\n\n\n\n\n\n\n\ndoc\n The mongoose document which is being converted\n\n\nret\n The plain object representation which has been converted\n\n\noptions\n The options in use (either schema options or the options passed inline)\n\n\n\n\n\u793a\u4f8b\n\n\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n\n  delete ret._id;\n  return ret;\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();\n\n\n\n\n\nWith transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n\n\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  return { movie: ret.name }\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();\n\n\n\n\n\nNote: if a transform function returns \nundefined\n, the return value will be ignored.\n\n\nTransformations may also be applied inline, overridding any transform set in the options:\n\n\nfunction\n \nxform\n \n(\ndoc\n,\n \nret\n,\n \noptions\n)\n \n{\n\n  \nreturn\n \n{\n \ninline\n: \nret.name\n,\n \ncustom\n: \ntrue\n \n}\n\n\n}\n\n\n\n\ndoc\n.\ntoObject\n({\n \ntransform\n: \nxform\n \n});\n\n\n\n\n\n\nIf you want to skip transformations, use \ntransform: false\n:\n\n\nif\n \n(!\nschema\n.\noptions\n.\ntoObject\n)\n \nschema\n.\noptions\n.\ntoObject\n \n=\n \n{}\n;\n\n\nschema\n.\noptions\n.\ntoObject\n.\nhide\n \n=\n \n_id\n;\n\n\nschema\n.\noptions\n.\ntoObject\n.\ntransform\n \n=\n \nfunction\n \n(\ndoc\n,\n \nret\n,\n \noptions\n)\n \n{\n\n  \nif\n \n(options.hide)\n \n{\n\n    \noptions.hide.split(\n \n).forEach(function\n \n(prop)\n \n{\n\n      \ndelete\n \nretprop]\n;\n\n    \n}\n);\n\n  \n}\n\n  \nreturn\n \nret\n;\n\n\n}\n\n\n\nvar\n \ndoc\n \n=\n \nnew\n \nDoc\n(\n{\n \n_id\n:\n \nanId\n,\n \nsecret\n:\n \n47\n,\n \nname\n:\n \nWreck-it Ralph\n \n}\n);\n\n\ndoc\n.\ntoObject\n();\n\n\ndoc\n.\ntoObject\n(\n{\n \nhide\n:\n \nsecret _id\n,\n \ntransform\n:\n \nfalse\n \n}\n);\n\n\ndoc\n.\ntoObject\n(\n{\n \nhide\n:\n \nsecret _id\n,\n \ntransform\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\nTransforms are applied \nonly to the document and are not applied to sub-documents\n.\n\n\nTransforms, like all of these options, are also available for \ntoJSON\n.\n\n\nSee schema options for some more details.\n\n\nDuring save, no custom options are applied to the document before being sent to the database.\n\n\nDocument.prototype.toJSON()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nThe return value of this method is used in calls to JSON.stringify(doc).\n\n\nThis method accepts the same options as Document#toObject. To apply the options to every document of your schema by default, set your schemas \ntoJSON\n option to the same argument.\n\n\nschema.set(\ntoJSON\n, { virtuals: true })\n\n\n\n\n\nSee schema options for details.\n\n\nDocument.prototype.inspect()\n\n\nDocument.prototype.toString()\n\n\nDocument.prototype.equals()\n\n\n\u53c2\u6570\n\n\n\n\ndoc \u00abDocument\u00bb a document to compare\n\n\n\n\n\u8fd4\u56de\n\n\nReturns true if the Document stores the same data as doc.\n\n\nDocuments are considered equal when they have matching \n_id\ns, unless neither document has an \n_id\n, in which case this function falls back to using \ndeepEqual()\n.\n\n\nDocument.prototype.populate()\n\n\n\u53c2\u6570\n\n\n\n\ncallback] \u00abFunction\u00bb When passed, population is invoked\n\n\n\n\n\u8fd4\u56de\n\n\nPopulates document references, executing the \ncallback\n when complete. If you want to use promises instead, use this function with \nexecPopulate()\n\n\n\u793a\u4f8b\n\n\ndoc\n.populate(\ncompany\n)\n.populate({\n  path: \nnotes\n,\n  match: /airline/,\n  select: \ntext\n,\n  model: \nmodelName\n\n  options: opts\n}, function (err, user) {\n  assert(doc._id === user._id)\n})\n\n\ndoc.populate(path)\ndoc.populate(options);\ndoc.populate(path, callback)\ndoc.populate(options, callback);\ndoc.populate(callback);\ndoc.populate(options).execPopulate()\n\n\n\n\n\n\u6ce8\u91ca\n\n\nPopulation does not occur unless a \ncallback\n is passed \nor\n you explicitly call \nexecPopulate()\n. Passing the same path a second time will overwrite the previous path options. See Model.populate() for explaination of options.\n\n\nDocument.prototype.execPopulate()\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abPromise\u00bb promise that resolves to the document when population is done\n\n\n\n\nExplicitly executes population and returns a promise. Useful for ES2015 integration.\n\n\n\u793a\u4f8b\n\n\nvar promise = doc.\n  populate(\ncompany\n).\n  populate({\n    path: \nnotes\n,\n    match: /airline/,\n    select: \ntext\n,\n    model: \nmodelName\n\n    options: opts\n  }).\n  execPopulate();\n\n\ndoc.execPopulate().then(resolve, reject);\n\n\n\n\n\nDocument.prototype.populated()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abArray,ObjectId,Number,Buffer,String,undefined\u00bb\n\n\n\n\nGets _id(s) used during population of the given \npath\n.\n\n\n\u793a\u4f8b\n\n\nModel.findOne().populate(\nauthor\n).exec(function (err, doc) {\n  console.log(doc.author.name)\n  console.log(doc.populated(\nauthor\n))\n})\n\n\n\n\n\nIf the path was not populated, undefined is returned.\n\n\nDocument.prototype.depopulate()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nTakes a populated field and returns it to its unpopulated state.\n\n\n\u793a\u4f8b\n\n\nModel.findOne().populate(\nauthor\n).exec(function (err, doc) {\n  console.log(doc.author.name);\n  console.log(doc.depopulate(\nauthor\n));\n  console.log(doc.author);\n})\n\n\n\n\n\nIf the path was not populated, this is a no-op.", 
            "title": "\u6587\u6863API"
        }, 
        {
            "location": "/document/api/#_1", 
            "text": "", 
            "title": "\u6587\u6863"
        }, 
        {
            "location": "/document/api/#documentprototypeschema", 
            "text": "", 
            "title": "Document.prototype.schema"
        }, 
        {
            "location": "/document/api/#documentprototypeisnew", 
            "text": "\u5e03\u5c14\u6807\u5fd7\u6307\u5b9a\u6587\u6863", 
            "title": "Document.prototype.isNew"
        }, 
        {
            "location": "/document/api/#documentprototypeid", 
            "text": "\u8fd9\u4e2a\u6587\u4ef6\u7684\u5b57\u7b26\u4e32\u7248\u672c_id  \u6ce8\u91ca  \u8fd9\u4e2agetter\u9ed8\u8ba4\u5b58\u5728\u4e8e\u6240\u6709\u7684\u6587\u4ef6\u4e0a\u3002 The getter can be disabled by setting the  id  option of its  Schema  to false at construction time.  new   Schema ( {   name :   String   } ,   {   id :   false   } );", 
            "title": "Document.prototype.id"
        }, 
        {
            "location": "/document/api/#documentprototypeerrors", 
            "text": "Hash containing current validation errors.", 
            "title": "Document.prototype.errors"
        }, 
        {
            "location": "/document/api/#documentprototypeinit", 
            "text": "\u53c2\u6570   doc \u00abObject\u00bb document returned by mongo   Initializes the document without setters or marking anything modified.  Called internally after a document is returned from mongodb.", 
            "title": "Document.prototype.init()"
        }, 
        {
            "location": "/document/api/#documentprototypeupdate", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Sends an update command with this document  _id  as the query selector.  \u793a\u4f8b  weirdCar . update ( { $ inc :   { wheels : 1 } } ,   {   w :   1   } ,   callback );   \u6709\u6548\u7684\u9009\u9879", 
            "title": "Document.prototype.update()"
        }, 
        {
            "location": "/document/api/#documentprototypeset", 
            "text": "\u53c2\u6570   options] \u00abObject\u00bb optionally specify options that modify the behavior of the set   Alias for  set() , used internally to avoid conflicts", 
            "title": "Document.prototype.$set()"
        }, 
        {
            "location": "/document/api/#documentprototypeset_1", 
            "text": "\u53c2\u6570   options] \u00abObject\u00bb optionally specify options that modify the behavior of the set   Sets the value of a path, or many paths.  \u793a\u4f8b  doc . set ( path ,   value )  doc . set ( { \n     path    :   value \n   ,   path2   :   { \n        path    :   value \n     }  } )  doc . set ( path ,   value ,   Number )  doc . set ( path ,   value ,   String )  doc . set ( path ,   value ,   {   strict :   false   } );", 
            "title": "Document.prototype.set()"
        }, 
        {
            "location": "/document/api/#documentprototypeget", 
            "text": "\u53c2\u6570   type] \u00abSchema,String,Number,Buffer,*\u00bb optionally specify a type for on-the-fly attributes   Returns the value of a path.  \u793a\u4f8b  doc.get( age )\n\n\ndoc.get( age , String)", 
            "title": "Document.prototype.get()"
        }, 
        {
            "location": "/document/api/#documentprototypemarkmodified", 
            "text": "\u53c2\u6570   scope] \u00abDocument\u00bb the scope to run validators with   Marks the path as having pending changes to write to the db.  Very helpful when using Mixed types.  \u793a\u4f8b  doc.mixed.type =  changed ;\ndoc.markModified( mixed.type );\ndoc.save()", 
            "title": "Document.prototype.markModified()"
        }, 
        {
            "location": "/document/api/#documentprototypeunmarkmodified", 
            "text": "\u53c2\u6570   path \u00abString\u00bb the path to unmark modified   Clears the modified state on the specified path.  \u793a\u4f8b  doc.foo =  bar ;\ndoc.unmarkModified( foo );\ndoc.save()", 
            "title": "Document.prototype.unmarkModified()"
        }, 
        {
            "location": "/document/api/#documentprototypeignore", 
            "text": "\u53c2\u6570   path \u00abString\u00bb the path to ignore   Don't run validation on this path or persist changes to this path.  \u793a\u4f8b  doc.foo = null;\ndoc.$ignore( foo );\ndoc.save()", 
            "title": "Document.prototype.$ignore()"
        }, 
        {
            "location": "/document/api/#documentprototypemodifiedpaths", 
            "text": "\u8fd4\u56de  Returns the list of paths that have been modified.", 
            "title": "Document.prototype.modifiedPaths()"
        }, 
        {
            "location": "/document/api/#documentprototypeismodified", 
            "text": "\u53c2\u6570   path] \u00abString\u00bb optional   \u8fd4\u56de  Returns true if this document was modified, else false.  If  path  is given, checks if a path or any full path containing  path  as part of its path chain has been modified.  \u793a\u4f8b  doc.set( documents.0.title ,  changed );\ndoc.isModified()\ndoc.isModified( documents )\ndoc.isModified( documents.0.title )\ndoc.isModified( documents otherProp )\ndoc.isDirectModified( documents )", 
            "title": "Document.prototype.isModified()"
        }, 
        {
            "location": "/document/api/#documentprototypeisdefault", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Checks if a path is set to its default.  \u793a\u4f8b  MyModel   =   mongoose . model ( test ,   {   name :   {   type :   String ,   default :   Val  }   } );  var   m   =   new   MyModel ();  m .$ isDefault ( name );", 
            "title": "Document.prototype.$isDefault()"
        }, 
        {
            "location": "/document/api/#documentprototypeisdeleted", 
            "text": "\u53c2\u6570   val] \u00abBoolean\u00bb optional, overrides whether mongoose thinks the doc is deleted   \u8fd4\u56de   \u00abBoolean\u00bb whether mongoose thinks this doc is deleted.   Getter/setter, determines whether the document was removed or not.  \u793a\u4f8b  product.remove(function (err, product) {\n  product.isDeleted();\n  product.remove();\n\n  product.isDeleted(false);\n  product.isDeleted();\n  product.remove();\n})", 
            "title": "Document.prototype.$isDeleted()"
        }, 
        {
            "location": "/document/api/#documentprototypeisdirectmodified", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Returns true if  path  was directly set and modified, else false.  \u793a\u4f8b  doc.set( documents.0.title ,  changed );\ndoc.isDirectModified( documents.0.title )\ndoc.isDirectModified( documents )", 
            "title": "Document.prototype.isDirectModified()"
        }, 
        {
            "location": "/document/api/#documentprototypeisinit", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Checks if  path  was initialized.", 
            "title": "Document.prototype.isInit()"
        }, 
        {
            "location": "/document/api/#documentprototypeisselected", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Checks if  path  was selected in the source query which initialized this document.  \u793a\u4f8b  Thing.findOne().select( name ).exec(function (err, doc) {\n   doc.isSelected( name )\n   doc.isSelected( age )\n})", 
            "title": "Document.prototype.isSelected()"
        }, 
        {
            "location": "/document/api/#documentprototypeisdirectselected", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Checks if  path  was explicitly selected. If no projection, always returns true.  \u793a\u4f8b  Thing.findOne().select( nested.name ).exec(function (err, doc) {\n   doc.isDirectSelected( nested.name )\n   doc.isDirectSelected( nested.otherName )\n   doc.isDirectSelected( nested )\n})", 
            "title": "Document.prototype.isDirectSelected()"
        }, 
        {
            "location": "/document/api/#documentprototypevalidate", 
            "text": "\u53c2\u6570   callback \u00abFunction\u00bb optional callback called after validation completes, passing an error if one occurred   \u8fd4\u56de  Executes registered validation rules for this document.  \u6ce8\u91ca  This method is called  pre  save and if a validation rule is violated, save is aborted and the error is returned to your  callback .  \u793a\u4f8b  doc.validate(function (err) {\n  if (err) handleError(err);\n  else\n});", 
            "title": "Document.prototype.validate()"
        }, 
        {
            "location": "/document/api/#documentprototypevalidatesync", 
            "text": "\u53c2\u6570   pathsToValidate \u00abArray,string\u00bb only validate the given paths   \u8fd4\u56de   \u00abMongooseError,undefined\u00bb MongooseError if there are errors during validation, or undefined if there is no error.   Executes registered validation rules (skipping asynchronous validators) for this document.  \u6ce8\u91ca  This method is useful if you need synchronous validation.  \u793a\u4f8b  var err = doc.validateSync();\nif ( err ){\n  handleError( err );\n} else {\n\n}", 
            "title": "Document.prototype.validateSync()"
        }, 
        {
            "location": "/document/api/#documentprototypeinvalidate", 
            "text": "\u53c2\u6570   kind] \u00abString\u00bb optional  kind  property for the error   \u8fd4\u56de   \u00abValidationError\u00bb the current ValidationError, with all currently invalidated paths   Marks a path as invalid, causing validation to fail.  The  errorMsg  argument will become the message of the  ValidationError .  The  value  argument (if passed) will be available through the  ValidationError.value  property.  doc.invalidate( size ,  must be less than 20 , 14);\n\ndoc.validate(function (err) {\n  console.log(err)\n\n  { message:  Validation failed ,\n    name:  ValidationError ,\n    errors:\n     { size:\n        { message:  must be less than 20 ,\n          name:  ValidatorError ,\n          path:  size ,\n          type:  user defined ,\n          value: 14 } } }\n})", 
            "title": "Document.prototype.invalidate()"
        }, 
        {
            "location": "/document/api/#documentprototypemarkvalid", 
            "text": "\u53c2\u6570   path \u00abString\u00bb the field to mark as valid   Marks a path as valid, removing existing validation errors.", 
            "title": "Document.prototype.$markValid()"
        }, 
        {
            "location": "/document/api/#documentprototypesave", 
            "text": "\u53c2\u6570   fn] \u00abFunction\u00bb optional callback   \u8fd4\u56de  Saves this document.  \u793a\u4f8b  product.sold = Date.now();\nproduct.save(function (err, product, numAffected) {\n  if (err) ..\n})  The callback will receive three parameters   err  if an error occurred  product  which is the saved  product  numAffected  will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking  err  is sufficient to make sure your document was properly saved.   As an extra measure of flow control, save will return a Promise.  \u793a\u4f8b  product.save().then(function(product) {\n   ...\n});", 
            "title": "Document.prototype.save()"
        }, 
        {
            "location": "/document/api/#documentprototypetoobject", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Converts this document into a plain javascript object, ready for storage in MongoDB.  Buffers are converted to instances of mongodb.Binary for proper storage.  \u9009\u9879:   getters  apply all getters (path and virtual getters)  virtuals  apply virtual getters (can override  getters  option)  minimize  remove empty objects (defaults to true)  transform  a transform function to apply to the resulting document before returning  depopulate  depopulate any populated paths, replacing them with their original refs (defaults to false)  versionKey  whether to include the version key (defaults to true)   Getters/Virtuals  Example of only applying path getters  doc.toObject({ getters: true, virtuals: false })  Example of only applying virtual getters  doc.toObject({ virtuals: true })  Example of applying both path and virtual getters  doc.toObject({ getters: true })  To apply these options to every document of your schema by default, set your schemas  toObject  option to the same argument.  schema.set( toObject , { virtuals: true })  \u8f6c\u53d8  We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional  transform  function.  Transform functions receive three arguments  function   ( doc ,   ret ,   options )   {}    doc  The mongoose document which is being converted  ret  The plain object representation which has been converted  options  The options in use (either schema options or the options passed inline)   \u793a\u4f8b  if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n\n  delete ret._id;\n  return ret;\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();  With transformations we can do a lot more than remove properties. We can even return completely new customized objects:  if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  return { movie: ret.name }\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();  Note: if a transform function returns  undefined , the return value will be ignored.  Transformations may also be applied inline, overridding any transform set in the options:  function   xform   ( doc ,   ret ,   options )   { \n   return   {   inline :  ret.name ,   custom :  true   }  }  doc . toObject ({   transform :  xform   });   If you want to skip transformations, use  transform: false :  if   (! schema . options . toObject )   schema . options . toObject   =   {} ;  schema . options . toObject . hide   =   _id ;  schema . options . toObject . transform   =   function   ( doc ,   ret ,   options )   { \n   if   (options.hide)   { \n     options.hide.split(   ).forEach(function   (prop)   { \n       delete   retprop] ; \n     } ); \n   } \n   return   ret ;  }  var   doc   =   new   Doc ( {   _id :   anId ,   secret :   47 ,   name :   Wreck-it Ralph   } );  doc . toObject ();  doc . toObject ( {   hide :   secret _id ,   transform :   false   } );  doc . toObject ( {   hide :   secret _id ,   transform :   true   } );   Transforms are applied  only to the document and are not applied to sub-documents .  Transforms, like all of these options, are also available for  toJSON .  See schema options for some more details.  During save, no custom options are applied to the document before being sent to the database.", 
            "title": "Document.prototype.toObject()"
        }, 
        {
            "location": "/document/api/#documentprototypetojson", 
            "text": "\u53c2\u6570  \u8fd4\u56de  The return value of this method is used in calls to JSON.stringify(doc).  This method accepts the same options as Document#toObject. To apply the options to every document of your schema by default, set your schemas  toJSON  option to the same argument.  schema.set( toJSON , { virtuals: true })  See schema options for details.", 
            "title": "Document.prototype.toJSON()"
        }, 
        {
            "location": "/document/api/#documentprototypeinspect", 
            "text": "", 
            "title": "Document.prototype.inspect()"
        }, 
        {
            "location": "/document/api/#documentprototypetostring", 
            "text": "", 
            "title": "Document.prototype.toString()"
        }, 
        {
            "location": "/document/api/#documentprototypeequals", 
            "text": "\u53c2\u6570   doc \u00abDocument\u00bb a document to compare   \u8fd4\u56de  Returns true if the Document stores the same data as doc.  Documents are considered equal when they have matching  _id s, unless neither document has an  _id , in which case this function falls back to using  deepEqual() .", 
            "title": "Document.prototype.equals()"
        }, 
        {
            "location": "/document/api/#documentprototypepopulate", 
            "text": "\u53c2\u6570   callback] \u00abFunction\u00bb When passed, population is invoked   \u8fd4\u56de  Populates document references, executing the  callback  when complete. If you want to use promises instead, use this function with  execPopulate()  \u793a\u4f8b  doc\n.populate( company )\n.populate({\n  path:  notes ,\n  match: /airline/,\n  select:  text ,\n  model:  modelName \n  options: opts\n}, function (err, user) {\n  assert(doc._id === user._id)\n})\n\n\ndoc.populate(path)\ndoc.populate(options);\ndoc.populate(path, callback)\ndoc.populate(options, callback);\ndoc.populate(callback);\ndoc.populate(options).execPopulate()  \u6ce8\u91ca  Population does not occur unless a  callback  is passed  or  you explicitly call  execPopulate() . Passing the same path a second time will overwrite the previous path options. See Model.populate() for explaination of options.", 
            "title": "Document.prototype.populate()"
        }, 
        {
            "location": "/document/api/#documentprototypeexecpopulate", 
            "text": "\u8fd4\u56de   \u00abPromise\u00bb promise that resolves to the document when population is done   Explicitly executes population and returns a promise. Useful for ES2015 integration.  \u793a\u4f8b  var promise = doc.\n  populate( company ).\n  populate({\n    path:  notes ,\n    match: /airline/,\n    select:  text ,\n    model:  modelName \n    options: opts\n  }).\n  execPopulate();\n\n\ndoc.execPopulate().then(resolve, reject);", 
            "title": "Document.prototype.execPopulate()"
        }, 
        {
            "location": "/document/api/#documentprototypepopulated", 
            "text": "\u53c2\u6570  \u8fd4\u56de   \u00abArray,ObjectId,Number,Buffer,String,undefined\u00bb   Gets _id(s) used during population of the given  path .  \u793a\u4f8b  Model.findOne().populate( author ).exec(function (err, doc) {\n  console.log(doc.author.name)\n  console.log(doc.populated( author ))\n})  If the path was not populated, undefined is returned.", 
            "title": "Document.prototype.populated()"
        }, 
        {
            "location": "/document/api/#documentprototypedepopulate", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Takes a populated field and returns it to its unpopulated state.  \u793a\u4f8b  Model.findOne().populate( author ).exec(function (err, doc) {\n  console.log(doc.author.name);\n  console.log(doc.depopulate( author ));\n  console.log(doc.author);\n})  If the path was not populated, this is a no-op.", 
            "title": "Document.prototype.depopulate()"
        }, 
        {
            "location": "/query/guide/", 
            "text": "\u67e5\u8be2\n\n\nSource\n\n\nDocuments can be retrieved through several static helper methods of \nmodels\n.\n\n\nAny \nmodel\n method which \ninvolves\n \nspecifying\n \nquery\n \nconditions\n can be executed two ways:\n\n\nWhen a \ncallback\n function:\n\n\n\n\nis passed, the operation will be executed immediately with the results passed to the callback.\n\n\nis not passed, an instance of \nQuery\n is returned, which provides a special query builder interface.\n\n\n\n\nA \nQuery\n has a \n.then()\n function, and thus can be used as a promise.\n\n\nWhen executing a query with a \ncallback\n function, you specify your query as a JSON document. The JSON document's syntax is the same as the \nMongoDB shell\n.\n\n\nvar Person = mongoose.model(\nPerson\n, yourSchema);\n\n\nPerson.findOne({ \nname.last\n: \nGhost\n }, \nname occupation\n, function (err, person) {\n  if (err) return handleError(err);\n\n  console.log(\n%s %s is a %s.\n, person.name.first, person.name.last,\n    person.occupation);\n});\n\n\n\n\n\nHere we see that the query was executed immediately and the results passed to our callback. All callbacks in Mongoose use the pattern: \ncallback(error, result)\n. If an error occurs executing the query, the \nerror\n parameter will contain an error document, and \nresult\n will be null. If the query is successful, the \nerror\n parameter will be null, and the \nresult\n will be populated with the results of the query.\n\n\nAnywhere a callback is passed to a query in Mongoose, the callback follows the pattern \ncallback(error, results)\n. What \nresults\n is depends on the operation: For \nfindOne()\n it is a \npotentially-null single document\n, \nfind()\n a \nlist of documents\n, \ncount()\n \nthe number of documents\n, \nupdate()\n the \nnumber of documents affected\n, etc. The \nAPI docs for Models\n provide more detail on what is passed to the callbacks.\n\n\nNow let's look at what happens when no \ncallback\n is passed:\n\n\nvar query = Person.findOne({ \nname.last\n: \nGhost\n });\n\n\nquery.select(\nname occupation\n);\n\n\nquery.exec(function (err, person) {\n  if (err) return handleError(err);\n\n  console.log(\n%s %s is a %s.\n, person.name.first, person.name.last,\n    person.occupation);\n});\n\n\n\n\n\nIn the above code, the \nquery\n variable is of type \nQuery\n. A \nQuery\n enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent.\n\n\nPerson.\n  find({\n    occupation: /host/,\n    \nname.last\n: \nGhost\n,\n    age: { $gt: 17, $lt: 66 },\n    likes: { $in: [\nvaporizing\n, \ntalking\n] }\n  }).\n  limit(10).\n  sort({ occupation: -1 }).\n  select({ name: 1, occupation: 1 }).\n  exec(callback);\n\n\nPerson.\n  find({ occupation: /host/ }).\n  where(\nname.last\n).equals(\nGhost\n).\n  where(\nage\n).gt(17).lt(66).\n  where(\nlikes\n).in([\nvaporizing\n, \ntalking\n]).\n  limit(10).\n  sort(\n-occupation\n).\n  select(\nname occupation\n).\n  exec(callback);\n\n\n\n\n\nA full list of \nQuery helper functions can be found in the API docs\n.\n\n\n\u53c2\u8003\u5176\u4ed6\u6587\u4ef6\n\n\nThere are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where \npopulation\n comes in. Read more about how to include documents from other collections in your query results \nhere\n.\n\n\n\u6d41\n\n\nYou can \nstream\n query results from MongoDB. You need to call the \nQuery#cursor()\n function to return an instance of \nQueryCursor\n.\n\n\nvar\n \ncursor\n \n=\n \nPerson\n.\nfind\n(\n{\n \noccupation\n:\n \n/\nhost\n/\n \n}\n)\n.\ncursor\n();\n\n\ncursor\n.\non\n(\ndata\n,\n \nfunction\n(\ndoc\n)\n \n{\n\n\n\n}\n);\n\n\ncursor\n.\non\n(\nclose\n,\n \nfunction\n()\n \n{\n\n\n\n}\n);", 
            "title": "\u67e5\u8be2\u624b\u518c"
        }, 
        {
            "location": "/query/guide/#_1", 
            "text": "Source  Documents can be retrieved through several static helper methods of  models .  Any  model  method which  involves   specifying   query   conditions  can be executed two ways:  When a  callback  function:   is passed, the operation will be executed immediately with the results passed to the callback.  is not passed, an instance of  Query  is returned, which provides a special query builder interface.   A  Query  has a  .then()  function, and thus can be used as a promise.  When executing a query with a  callback  function, you specify your query as a JSON document. The JSON document's syntax is the same as the  MongoDB shell .  var Person = mongoose.model( Person , yourSchema);\n\n\nPerson.findOne({  name.last :  Ghost  },  name occupation , function (err, person) {\n  if (err) return handleError(err);\n\n  console.log( %s %s is a %s. , person.name.first, person.name.last,\n    person.occupation);\n});  Here we see that the query was executed immediately and the results passed to our callback. All callbacks in Mongoose use the pattern:  callback(error, result) . If an error occurs executing the query, the  error  parameter will contain an error document, and  result  will be null. If the query is successful, the  error  parameter will be null, and the  result  will be populated with the results of the query.  Anywhere a callback is passed to a query in Mongoose, the callback follows the pattern  callback(error, results) . What  results  is depends on the operation: For  findOne()  it is a  potentially-null single document ,  find()  a  list of documents ,  count()   the number of documents ,  update()  the  number of documents affected , etc. The  API docs for Models  provide more detail on what is passed to the callbacks.  Now let's look at what happens when no  callback  is passed:  var query = Person.findOne({  name.last :  Ghost  });\n\n\nquery.select( name occupation );\n\n\nquery.exec(function (err, person) {\n  if (err) return handleError(err);\n\n  console.log( %s %s is a %s. , person.name.first, person.name.last,\n    person.occupation);\n});  In the above code, the  query  variable is of type  Query . A  Query  enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent.  Person.\n  find({\n    occupation: /host/,\n     name.last :  Ghost ,\n    age: { $gt: 17, $lt: 66 },\n    likes: { $in: [ vaporizing ,  talking ] }\n  }).\n  limit(10).\n  sort({ occupation: -1 }).\n  select({ name: 1, occupation: 1 }).\n  exec(callback);\n\n\nPerson.\n  find({ occupation: /host/ }).\n  where( name.last ).equals( Ghost ).\n  where( age ).gt(17).lt(66).\n  where( likes ).in([ vaporizing ,  talking ]).\n  limit(10).\n  sort( -occupation ).\n  select( name occupation ).\n  exec(callback);  A full list of  Query helper functions can be found in the API docs .", 
            "title": "\u67e5\u8be2"
        }, 
        {
            "location": "/query/guide/#_2", 
            "text": "There are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where  population  comes in. Read more about how to include documents from other collections in your query results  here .", 
            "title": "\u53c2\u8003\u5176\u4ed6\u6587\u4ef6"
        }, 
        {
            "location": "/query/guide/#_3", 
            "text": "You can  stream  query results from MongoDB. You need to call the  Query#cursor()  function to return an instance of  QueryCursor .  var   cursor   =   Person . find ( {   occupation :   / host /   } ) . cursor ();  cursor . on ( data ,   function ( doc )   {  } );  cursor . on ( close ,   function ()   {  } );", 
            "title": "\u6d41"
        }, 
        {
            "location": "/query/api/", 
            "text": "\u67e5\u8be2\n\n\nQuery()\n\n\n\u53c2\u6570\n\n\n\n\n[collection] \u00abObject\u00bb Mongoose collection\n\n\n\n\nQuery constructor used for building queries. You do not need to instantiate a \nQuery\n directly. Instead use Model functions like [\nModel.find()\n.\n\n\n\u793a\u4f8b\n\n\nconst query = MyModel.find();\nquery.setOptions({ lean : true });\nquery.collection(model.collection);\nquery.where(\nage\n).gte(21).exec(callback);\n\nconst query = new mongoose.Query();\n\n\n\n\n\nQuery.prototype.use$geoWithin\n\n\nFlag to opt out of using \n$geoWithin\n.\n\n\nmongoose.Query.use$geoWithin = false;\n\n\n\n\n\nMongoDB 2.4 deprecated the use of \n$within\n, replacing it with \n$geoWithin\n. Mongoose uses \n$geoWithin\n by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to \nfalse\n so your \nwithin()\n queries continue to work.\n\n\nQuery.prototype.toConstructor()\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abQuery\u00bb subclass-of-Query\n\n\n\n\nConverts this query to a customized, reusable query constructor with all arguments and options retained.\n\n\n\u793a\u4f8b\n\n\nvar\n \nquery\n \n=\n \nMovie\n.\nfind\n(\n{\n \ntags\n:\n \nadventure\n \n}\n)\n.\nread\n(\nprimaryPreferred\n);\n\n\n\nvar\n \nAdventure\n \n=\n \nquery\n.\ntoConstructor\n();\n\n\n\nAdventure\n()\n.\nexec\n(\ncallback\n)\n\n\n\nAdventure\n()\n.\nwhere\n(\n{\n \nname\n:\n \n/^\nLife\n/\n \n}\n)\n.\nexec\n(\ncallback\n);\n\n\n\nAdventure\n.\nprototype\n.\nstartsWith\n \n=\n \nfunction\n \n(\nprefix\n)\n \n{\n\n  \nthis.where({\n \nname\n:\n \nnew\n \nRegExp\n(\n^\n \n+\n \nprefix\n)\n \n}\n)\n\n  \nreturn\n \nthis\n;\n\n\n}\n\n\nObject\n.\ndefineProperty\n(\nAdventure\n.\nprototype\n,\n \nhighlyRated\n,\n \n{\n\n  \nget\n:\n \nfunction\n \n()\n \n{\n\n    \nthis\n.\nwhere\n(\n{\n \nrating\n:\n \n{\n \n$\ngt\n:\n \n4.5\n \n}}\n);\n\n    \nreturn\n \nthis\n;\n\n  \n}\n\n\n}\n)\n\n\nAdventure\n()\n.\nhighlyRated\n.\nstartsWith\n(\nLife\n)\n.\nexec\n(\ncallback\n)\n\n\n\n\n\n\nNew in 3.7.3\n\n\nQuery.prototype.$where()\n\n\n\u53c2\u6570\n\n\n\n\njs \u00abString,Function\u00bb javascript string or function\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies a javascript function or expression to pass to MongoDBs query system.\n\n\n\u793a\u4f8b\n\n\nquery.$where(\nthis.comments.length === 10 || this.name.length === 5\n)\n\nquery.$where(function () {\n  return this.comments.length === 10 || this.name.length === 5;\n})\n\n\n\n\n\n\u6ce8\u91ca\n\n\nOnly use \n$where\n when you have a condition that cannot be met using other MongoDB operators like \n$lt\n. \nBe sure to read about all of [its caveats before using.\n\n\nQuery.prototype.where()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSpecifies a \npath\n for use with chaining.\n\n\n\u793a\u4f8b\n\n\nUser\n.\nfind\n(\n{\nage\n:\n \n{$\ngte\n:\n \n21\n,\n \n$\nlte\n:\n \n65\n}\n}\n,\n \ncallback\n);\n\n\n\nUser\n.\nwhere\n(\nage\n)\n.\ngte\n(\n21\n)\n.\nlte\n(\n65\n);\n\n\n\nUser\n.\nfind\n()\n.\nwhere\n(\n{\n \nname\n:\n \nvonderful\n \n}\n)\n\n\n\nUser\n\n\n.\nwhere\n(\nage\n)\n.\ngte\n(\n21\n)\n.\nlte\n(\n65\n)\n\n\n.\nwhere\n(\nname\n,\n \n/^\nvonderful\n/\ni\n)\n\n\n.\nwhere\n(\nfriends\n)\n.\nslice\n(\n10\n)\n\n\n.\nexec\n(\ncallback\n)\n\n\n\n\n\n\nQuery.prototype.equals()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSpecifies the complementary comparison value for paths specified with \nwhere()\n\n\n\u793a\u4f8b\n\n\nUser.where(\nage\n).equals(49);\n\nUser.where(\nage\n, 49);\n\n\n\n\n\nQuery.prototype.or()\n\n\n\u53c2\u6570\n\n\n\n\narray \u00abArray\u00bb array of conditions\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies arguments for an \n$or\n condition.\n\n\n\u793a\u4f8b\n\n\nquery.or([{ color: \nred\n }, { status: \nemergency\n }])\n\n\n\n\n\nQuery.prototype.nor()\n\n\n\u53c2\u6570\n\n\n\n\narray \u00abArray\u00bb array of conditions\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies arguments for a \n$nor\n condition.\n\n\n\u793a\u4f8b\n\n\nquery.nor([{ color: \ngreen\n }, { status: \nok\n }])\n\n\n\n\n\nQuery.prototype.and()\n\n\n\u53c2\u6570\n\n\n\n\narray \u00abArray\u00bb array of conditions\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies arguments for a \n$and\n condition.\n\n\n\u793a\u4f8b\n\n\nquery.and([{ color: \ngreen\n }, { status: \nok\n }])\n\n\n\n\n\nQuery.prototype.gt()\n\n\n\u53c2\u6570\n\n\nSpecifies a $gt query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\u793a\u4f8b\n\n\nThing.find().where(\nage\n).gt(21)\n\nThing.find().gt(\nage\n, 21)\n\n\n\n\n\nQuery.prototype.gte()\n\n\n\u53c2\u6570\n\n\nSpecifies a $gte query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.lt()\n\n\n\u53c2\u6570\n\n\nSpecifies a $lt query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.lte()\n\n\n\u53c2\u6570\n\n\nSpecifies a $lte query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.ne()\n\n\n\u53c2\u6570\n\n\nSpecifies a $ne query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.in()\n\n\n\u53c2\u6570\n\n\nSpecifies an $in query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.nin()\n\n\n\u53c2\u6570\n\n\nSpecifies an $nin query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.all()\n\n\n\u53c2\u6570\n\n\nSpecifies an $all query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.size()\n\n\n\u53c2\u6570\n\n\nSpecifies a $size query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\u793a\u4f8b\n\n\nMyModel.where(\ntags\n).size(0).exec(function (err, docs) {\n  if (err) return handleError(err);\n\n  assert(Array.isArray(docs));\n  console.log(\ndocuments with 0 tags\n, docs);\n})\n\n\n\n\n\nQuery.prototype.regex()\n\n\n\u53c2\u6570\n\n\nSpecifies a $regex query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.maxDistance()\n\n\n\u53c2\u6570\n\n\nSpecifies a $maxDistance query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nQuery.prototype.mod()\n\n\n\u53c2\u6570\n\n\n\n\nval \u00abArray\u00bb must be of length 2, first element is \ndivisor\n, 2nd element is \nremainder\n.\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies a \n$mod\n condition, filters documents for documents whose \npath\n property is a number that is equal to \nremainder\n modulo \ndivisor\n.\n\n\n\u793a\u4f8b\n\n\nProduct.find().mod(\ninventory\n, [2, 1]);\nProduct.find().where(\ninventory\n).mod([2, 1]);\n\nProduct.find().where(\ninventory\n).mod(2, 1);\n\n\n\n\n\nQuery.prototype.exists()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSpecifies an \n$exists\n condition\n\n\n\u793a\u4f8b\n\n\nThing.where(\nname\n).exists()\nThing.where(\nname\n).exists(true)\nThing.find().exists(\nname\n)\n\nThing.where(\nname\n).exists(false);\nThing.find().exists(\nname\n, false);\n\n\n\n\n\nQuery.prototype.elemMatch()\n\n\n\u53c2\u6570\n\n\n\n\ncriteria \u00abObject,Function\u00bb\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies an \n$elemMatch\n condition\n\n\n\u793a\u4f8b\n\n\nquery\n.\nelemMatch\n(\ncomment\n,\n \n{\n \nauthor\n:\n \nautobot\n,\n \nvotes\n:\n \n{$\ngte\n:\n \n5\n}\n}\n)\n\n\n\nquery\n.\nwhere\n(\ncomment\n)\n.\nelemMatch\n(\n{\n \nauthor\n:\n \nautobot\n,\n \nvotes\n:\n \n{$\ngte\n:\n \n5\n}\n}\n)\n\n\n\nquery\n.\nelemMatch\n(\ncomment\n,\n \nfunction\n \n(\nelem\n)\n \n{\n\n  \nelem.where(\nauthor\n).equals(\nautobot\n)\n;\n\n  \nelem.where(\nvotes\n).gte(5)\n;\n\n\n}\n)\n\n\n\nquery\n.\nwhere\n(\ncomment\n)\n.\nelemMatch\n(\nfunction\n \n(\nelem\n)\n \n{\n\n  \nelem.where({\n \nauthor\n:\n \nautobot\n \n}\n);\n\n  \nelem\n.\nwhere\n(\nvotes\n)\n.\ngte\n(\n5\n);\n\n\n}\n)\n\n\n\n\n\n\nQuery.prototype.within()\n\n\n\u8fd4\u56de\n\n\nDefines a \n$within\n or \n$geoWithin\n argument for geo-spatial queries.\n\n\n\u793a\u4f8b\n\n\nquery\n.\nwhere\n(\npath\n)\n.\nwithin\n()\n.\nbox\n()\n\n\nquery\n.\nwhere\n(\npath\n)\n.\nwithin\n()\n.\ncircle\n()\n\n\nquery\n.\nwhere\n(\npath\n)\n.\nwithin\n()\n.\ngeometry\n()\n\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \ncenter\n:\n \n[\n50\n,\n50\n]\n,\n \nradius\n:\n \n10\n,\n \nunique\n:\n \ntrue\n,\n \nspherical\n:\n \ntrue\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \nbox\n:\n \n[\n[\n40.73\n,\n \n-\n73.9\n]\n,\n \n[\n40.7\n,\n \n-\n73.988\n]\n]\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \npolygon\n:\n \n[\n[\n]\n,\n[]\n,\n[]\n,\n[]\n]\n \n}\n);\n\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n[]\n,\n \n[]\n,\n \n[]\n)\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n[]\n,\n \n[]\n)\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \ntype\n:\n \nLineString\n,\n \ncoordinates\n:\n \n[\n...\n]\n \n}\n);\n\n\n\n\n\n\nMUST\n be used after \nwhere()\n.\n\n\n\u6ce8\u91ca\n\n\nAs of Mongoose 3.7, \n$geoWithin\n is always used for queries. To change this behavior, see [Query.use$geoWithin.\n\n\n\u6ce8\u91ca\n\n\nIn Mongoose 3.7, \nwithin\n changed from a getter to a function. If you need the old syntax, use [this.\n\n\nQuery.prototype.slice()\n\n\n\u53c2\u6570\n\n\n\n\nval \u00abNumber\u00bb number/range of elements to slice\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies a $slice projection for an array.\n\n\n\u793a\u4f8b\n\n\nquery.slice(\ncomments\n, 5)\nquery.slice(\ncomments\n, -5)\nquery.slice(\ncomments\n, [10, 5])\nquery.where(\ncomments\n).slice(5)\nquery.where(\ncomments\n).slice([-10, 5])\n\n\n\n\n\nQuery.prototype.limit()\n\n\n\u53c2\u6570\n\n\nSpecifies the maximum number of documents the query will return.\n\n\n\u793a\u4f8b\n\n\nquery.limit(20)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.skip()\n\n\n\u53c2\u6570\n\n\nSpecifies the number of documents to skip.\n\n\n\u793a\u4f8b\n\n\nquery.skip(100).limit(20)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.maxScan()\n\n\n\u53c2\u6570\n\n\nSpecifies the maxScan option.\n\n\n\u793a\u4f8b\n\n\nquery.maxScan(100)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.batchSize()\n\n\n\u53c2\u6570\n\n\nSpecifies the batchSize option.\n\n\n\u793a\u4f8b\n\n\nquery.batchSize(100)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\n\u53c2\u6570\n\n\nSpecifies the \ncomment\n option.\n\n\n\u793a\u4f8b\n\n\nquery.comment(\nlogin query\n)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.snapshot()\n\n\n\u8fd4\u56de\n\n\nSpecifies this query as a \nsnapshot\n query.\n\n\n\u793a\u4f8b\n\n\nquery.snapshot()\nquery.snapshot(true)\nquery.snapshot(false)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.hint()\n\n\n\u53c2\u6570\n\n\n\n\nval \u00abObject\u00bb a hint object\n\n\n\n\n\u8fd4\u56de\n\n\nSets query hints.\n\n\n\u793a\u4f8b\n\n\nquery.hint({ indexA: 1, indexB: -1})\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.select()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSpecifies which document fields to include or exclude (also known as the query \"projection\")\n\n\nWhen using string syntax, prefixing a path with \n-\n will flag that path as excluded. When a path does not have the \n-\n prefix, it is included. Lastly, if a path is prefixed with \n+\n, it forces inclusion of the path, which is useful for paths excluded at the [schema level.\n\n\nA projection \nmust\n be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The [\n_id\n field is the only exception because MongoDB includes it by default.\n\n\n\u793a\u4f8b\n\n\nquery\n.\nselect\n(\na b\n);\n\n\n\nquery\n.\nselect\n(\n-c -d\n);\n\n\n\nquery\n.\nselect\n(\n{\n \na\n:\n \n1\n,\n \nb\n:\n \n1\n \n}\n);\n\n\nquery\n.\nselect\n(\n{\n \nc\n:\n \n0\n,\n \nd\n:\n \n0\n \n}\n);\n\n\n\nquery\n.\nselect\n(\n+path\n)\n\n\n\n\n\n\nQuery.prototype.slaveOk()\n\n\n\u53c2\u6570\n\n\n\n\nv \u00abBoolean\u00bb defaults to true\n\n\n\n\n\u8fd4\u56de\n\n\nDEPRECATED\n Sets the slaveOk option.\n\n\nDeprecated\n in MongoDB 2.2 in favor of [read preferences.\n\n\n\u793a\u4f8b\n\n\nquery.slaveOk()\nquery.slaveOk(true)\nquery.slaveOk(false)\n\n\n\n\n\nQuery.prototype.read()\n\n\n\u53c2\u6570\n\n\n\n\n[tags] \u00abArray\u00bb optional tags for this query\n\n\n\n\n\u8fd4\u56de\n\n\nDetermines the MongoDB nodes from which to read.\n\n\n\u559c\u597d\n\n\nprimary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\nsecondary            Read from secondary if available, otherwise error.\nprimaryPreferred     Read from primary if available, otherwise a secondary.\nsecondaryPreferred   Read from a secondary if available, otherwise read from the primary.\nnearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n\n\n\n\n\n\u522b\u540d\n\n\np   primary\npp  primaryPreferred\ns   secondary\nsp  secondaryPreferred\nn   nearest\n\n\n\n\n\n\u793a\u4f8b\n\n\nnew Query().read(\nprimary\n)\nnew Query().read(\np\n)\n\nnew Query().read(\nprimaryPreferred\n)\nnew Query().read(\npp\n)\n\nnew Query().read(\nsecondary\n)\nnew Query().read(\ns\n)\n\nnew Query().read(\nsecondaryPreferred\n)\nnew Query().read(\nsp\n)\n\nnew Query().read(\nnearest\n)\nnew Query().read(\nn\n)\n\nnew Query().read(\ns\n, [{ dc:\nsf\n, s: 1 },{ dc:\nma\n, s: 2 }])\n\n\n\n\n\nRead more about how to use read preferrences [here and [here.\n\n\nQuery.prototype.merge()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nMerges another Query or conditions object into this one.\n\n\nWhen a Query is passed, conditions, field selection and options are merged.\n\n\nNew in 3.7.0\n\n\nQuery.prototype.setOptions()\n\n\n\u53c2\u6570\n\n\nSets query options. Some options only make sense for certain operations.\n\n\n\u9009\u9879\n\n\nThe following options are only for \nfind()\n: - [tailable - [sort - [limit - [skip - [maxscan - [batchSize - [comment - [snapshot - [readPreference - [hint\n\n\nThe following options are only for \nupdate()\n, \nupdateOne()\n, \nupdateMany()\n, \nreplaceOne()\n, \nfindOneAndUpdate()\n, and \nfindByIdAndUpdate()\n: - [upsert - [writeConcern\n\n\nThe following options are only for \nfind()\n, \nfindOne()\n, \nfindById()\n, \nfindOneAndUpdate()\n, \nfindByIdAndUpdate()\n, and \ngeoSearch()\n: - [lean\n\n\nThe following options are for all operations\n\n\nQuery.prototype.getQuery()\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abObject\u00bb current query conditions\n\n\n\n\nReturns the current query conditions as a JSON object.\n\n\n\u793a\u4f8b\n\n\nvar\n \nquery\n \n=\n \nnew\n \nQuery\n();\n\n\nquery\n.\nfind\n(\n{\n \na\n:\n \n1\n \n}\n)\n.\nwhere\n(\nb\n)\n.\ngt\n(\n2\n);\n\n\nquery\n.\ngetQuery\n();\n\n\n\n\n\n\nQuery.prototype.getUpdate()\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abObject\u00bb current update operations\n\n\n\n\nReturns the current update operations as a JSON object.\n\n\n\u793a\u4f8b\n\n\nvar\n \nquery\n \n=\n \nnew\n \nQuery\n();\n\n\nquery\n.\nupdate\n(\n{}\n,\n \n{\n \n$\nset\n:\n \n{\n \na\n:\n \n5\n \n}\n \n}\n);\n\n\nquery\n.\ngetUpdate\n();\n\n\n\n\n\n\nQuery.prototype.lean()\n\n\n\u53c2\u6570\n\n\n\n\nbool \u00abBoolean,Object\u00bb defaults to true\n\n\n\n\n\u8fd4\u56de\n\n\nSets the lean option.\n\n\nDocuments returned from queries with the \nlean\n option enabled are plain javascript objects, not [MongooseDocuments. They have no \nsave\n method, getters/setters or other Mongoose magic applied.\n\n\n\u793a\u4f8b\n\n\nnew Query().lean()\nnew Query().lean(true)\nnew Query().lean(false)\n\nModel.find().lean().exec(function (err, docs) {\n  docs[0] instanceof mongoose.Document\n});\n\n\n\n\n\nThis is a [great option in high-performance read-only scenarios, especially when combined with [stream.\n\n\nQuery.prototype.error()\n\n\n\u53c2\u6570\n\n\n\n\nerr \u00abError,null\u00bb if set, \nexec()\n will fail fast before sending the query to MongoDB\n\n\n\n\nGets/sets the error flag on this query. If this flag is not null or undefined, the \nexec()\n promise will reject without executing.\n\n\n\u793a\u4f8b\n\n\nQuery().error();\nQuery().error(null);\nQuery().error(new Error(\ntest\n));\nSchema.pre(\nfind\n, function() {\n  if (!this.getQuery().userId) {\n    this.error(new Error(\nNot allowed to query without setting userId\n));\n  }\n});\n\n\n\n\n\nNote that query casting runs \nafter\n hooks, so cast errors will override custom errors.\n\n\n\u793a\u4f8b\n\n\nvar\n \nTestSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nnum\n:\n \nNumber\n \n}\n);\n\n\nvar\n \nTestModel\n \n=\n \ndb\n.\nmodel\n(\nTest\n,\n \nTestSchema\n);\n\n\nTestModel\n.\nfind\n(\n{\n \nnum\n:\n \nnot a number\n \n}\n)\n.\nerror\n(\nnew\n \nError\n(\nwoops\n))\n.\nexec\n(\nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nQuery.prototype.mongooseOptions()\n\n\n\u53c2\u6570\n\n\n\n\noptions \u00abObject\u00bb if specified, overwrites the current options\n\n\n\n\nGetter/setter around the current mongoose-specific options for this query (populate, lean, etc.)\n\n\nQuery.prototype.find()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nFinds documents.\n\n\nWhen no \ncallback\n is passed, the query is not executed. When the query is executed, the result will be an array of documents.\n\n\n\u793a\u4f8b\n\n\nquery.find({ name: \nLos Pollos Hermanos\n }).find(callback)\n\n\n\n\n\nQuery.prototype.merge()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nMerges another Query or conditions object into this one.\n\n\nWhen a Query is passed, conditions, field selection and options are merged.\n\n\nQuery.prototype.collation()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nAdds a collation to this op (MongoDB 3.4 and up)\n\n\nQuery.prototype.findOne()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, document)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclares the query a findOne operation. When executed, the first found document is passed to the callback.\n\n\nPassing a \ncallback\n executes the query. The result of the query is a single document.\n\n\n\n\nNote:\n \nconditions\n is optional, and if \nconditions\n is null or undefined, mongoose will send an empty \nfindOne\n command to MongoDB, which will return an arbitrary document. If you're querying by \n_id\n, use \nModel.findById()\n instead.\n\n\n\n\nThis function triggers the following middleware.\n\n\n\u793a\u4f8b\n\n\nvar\n \nquery\n  \n=\n \nKitten\n.\nwhere\n(\n{\n \ncolor\n:\n \nwhite\n \n}\n);\n\n\nquery\n.\nfindOne\n(\nfunction\n \n(\nerr\n,\n \nkitten\n)\n \n{\n\n  \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n  \nif\n \n(kitten)\n \n{\n\n\n  \n}\n\n\n}\n);\n\n\n\n\n\n\nQuery.prototype.count()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, count)\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifying this query as a \ncount\n query.\n\n\nPassing a \ncallback\n executes the query.\n\n\nThis function triggers the following middleware.\n\n\n\u793a\u4f8b\n\n\nvar countQuery = model.where({ \ncolor\n: \nblack\n }).count();\n\nquery.count({ color: \nblack\n }).count(callback)\n\nquery.count({ color: \nblack\n }, callback)\n\nquery.where(\ncolor\n, \nblack\n).count(function (err, count) {\n  if (err) return handleError(err);\n  console.log(\nthere are %d kittens\n, count);\n})\n\n\n\n\n\nQuery.prototype.distinct()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, arr)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclares or executes a distict() operation.\n\n\nPassing a \ncallback\n executes the query.\n\n\nThis function does not trigger any middleware.\n\n\n\u793a\u4f8b\n\n\ndistinct(field, conditions, callback)\ndistinct(field, conditions)\ndistinct(field, callback)\ndistinct(field)\ndistinct(callback)\ndistinct()\n\n\n\n\n\nQuery.prototype.sort()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSets the sort order\n\n\nIf an object is passed, values allowed are \nasc\n, \ndesc\n, \nascending\n, \ndescending\n, \n1\n, and \n-1\n.\n\n\nIf a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with \n-\n which will be treated as descending.\n\n\n\u793a\u4f8b\n\n\nquery\n.\nsort\n(\n{\n \nfield\n:\n \nasc\n,\n \ntest\n:\n \n-1\n \n}\n);\n\n\n\nquery\n.\nsort\n(\nfield -test\n);\n\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.remove()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclare and/or execute this query as a remove() operation.\n\n\nThis function does not trigger any middleware\n\n\n\u793a\u4f8b\n\n\nModel.remove({ artist: \nAnne Murray\n }, callback)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nThe operation is only executed when a callback is passed. To force execution without a callback, you must first call \nremove()\n and then execute it by using the \nexec()\n method.\n\n\nvar query = Model.find().remove({ name: \nAnne Murray\n })\n\nquery.remove({ name: \nAnne Murray\n }, callback)\nquery.remove({ name: \nAnne Murray\n }).remove(callback)\n\nquery.exec()\n\nquery.remove(conds, fn);\nquery.remove(conds)\nquery.remove(fn)\nquery.remove()\n\n\n\n\n\nQuery.prototype.deleteOne()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclare and/or execute this query as a \ndeleteOne()\n operation. Works like remove, except it deletes at most one document regardless of the \nsingle\n option.\n\n\nThis function does not trigger any middleware.\n\n\n\u793a\u4f8b\n\n\nCharacter.deleteOne({ name: \nEddard Stark\n }, callback)\nCharacter.deleteOne({ name: \nEddard Stark\n }).then(next)\n\n\n\n\n\nQuery.prototype.deleteMany()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclare and/or execute this query as a \ndeleteMany()\n operation. Works like remove, except it deletes \nevery\n document that matches \ncriteria\n in the collection, regardless of the value of \nsingle\n.\n\n\nThis function does not trigger any middleware\n\n\n\u793a\u4f8b\n\n\nCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)\nCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)\n\n\n\n\n\nQuery.prototype.findOneAndUpdate()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, doc), \nunless\n \nrawResult\n is used, in which case params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nIssues a mongodb [findAndModify update command.\n\n\nFinds a matching document, updates it according to the \nupdate\n arg, passing any \noptions\n, and returns the found document (if any) to the callback. The query executes immediately if \ncallback\n is passed.\n\n\nThis function triggers the following middleware.\n\n\n\u9009\u9879\n\n\n\n\nnew\n: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n\n\nupsert\n: bool - creates the object if it doesn't exist. defaults to false.\n\n\nfields\n: {Object|String} - Field selection. Equivalent to \n.select(fields).findOneAndUpdate()\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nrunValidators\n: if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on [MongoDB's \n$setOnInsert\n operator.\n\n\nrawResult\n: if true, returns the [raw result from the MongoDB driver\n\n\ncontext\n (string) if set to 'query' and \nrunValidators\n is on, \nthis\n will refer to the query in custom validator functions that update validation runs. Does nothing if \nrunValidators\n is false.\n\n\n\n\n\u56de\u8c03\u7b7e\u540d\n\n\nfunction(error, doc) {\n\n}\n\n\n\n\n\n\u793a\u4f8b\n\n\nquery.findOneAndUpdate(conditions, update, options, callback)\nquery.findOneAndUpdate(conditions, update, options)\nquery.findOneAndUpdate(conditions, update, callback)\nquery.findOneAndUpdate(conditions, update)\nquery.findOneAndUpdate(update, callback)\nquery.findOneAndUpdate(update)\nquery.findOneAndUpdate(callback)\nquery.findOneAndUpdate()\n\n\n\n\n\nQuery.prototype.findOneAndRemove()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, document)\n\n\n\n\n\u8fd4\u56de\n\n\nIssues a mongodb [findAndModify remove command.\n\n\nFinds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if \ncallback\n is passed.\n\n\nThis function triggers the following middleware.\n\n\n\u9009\u9879\n\n\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nrawResult\n: if true, resolves to the [raw result from the MongoDB driver\n\n\n\n\n\u56de\u8c03\u7b7e\u540d\n\n\nfunction(error, doc) {\n\n}\n\n\n\n\n\n\u793a\u4f8b\ns\n\n\nA.where().findOneAndRemove(conditions, options, callback)\nA.where().findOneAndRemove(conditions, options)\nA.where().findOneAndRemove(conditions, callback)\nA.where().findOneAndRemove(conditions)\nA.where().findOneAndRemove(callback)\nA.where().findOneAndRemove()\n\n\n\n\n\nQuery.prototype.update()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional, params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclare and/or execute this query as an update() operation.\n\n\nAll paths passed that are not $atomic operations will become $set ops.\n\n\nThis function triggers the following middleware.\n\n\n\u793a\u4f8b\n\n\nModel.where({ _id: id }).update({ title: \nwords\n })\n\nModel.where({ _id: id }).update({ $set: { title: \nwords\n }})\n\n\n\n\n\n\u9009\u9879\n\n\n\n\nsafe\n (boolean) safe mode (defaults to value set in schema (true))\n\n\nupsert\n (boolean) whether to create the doc if it doesn't match (false)\n\n\nmulti\n (boolean) whether multiple documents should be updated (false)\n\n\nrunValidators\n: if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on [MongoDB's \n$setOnInsert\n operator.\n\n\nstrict\n (boolean) overrides the \nstrict\n option for this update\n\n\noverwrite\n (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n\n\ncontext\n (string) if set to 'query' and \nrunValidators\n is on, \nthis\n will refer to the query in custom validator functions that update validation runs. Does nothing if \nrunValidators\n is false.\n\n\n\n\n\u6ce8\u91ca\n\n\nPassing an empty object \n{}\n as the doc will result in a no-op unless the \noverwrite\n option is passed. Without the \noverwrite\n option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.\n\n\n\u6ce8\u91ca\n\n\nThe operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the \nexec()\n method.\n\n\nvar\n \nq\n \n=\n \nModel\n.\nwhere\n(\n{\n \n_id\n:\n \nid\n \n}\n);\n\n\nq\n.\nupdate\n(\n{\n \n$\nset\n:\n \n{\n \nname\n:\n \nbob\n \n}\n}\n)\n.\nupdate\n();\n \n//\n \nnot\n \nexecuted\n\n\n\nq\n.\nupdate\n(\n{\n \n$\nset\n:\n \n{\n \nname\n:\n \nbob\n \n}\n}\n)\n.\nexec\n();\n \n//\n \nexecuted\n\n\n\n//\n \nkeys\n \nthat\n \nare\n \nnot\n \n$\natomic\n \nops\n \nbecome\n \n$\nset\n.\n\n\n//\n \nthis\n \nexecutes\n \nthe\n \nsame\n \ncommand\n \nas\n \nthe\n \nprevious\n \nexample\n.\n\n\nq\n.\nupdate\n(\n{\n \nname\n:\n \nbob\n \n}\n)\n.\nexec\n();\n\n\n\n//\n \noverwriting\n \nwith\n \nempty\n \ndocs\n\n\nvar\n \nq\n \n=\n \nModel\n.\nwhere\n(\n{\n \n_id\n:\n \nid\n \n}\n)\n.\nsetOptions\n(\n{\n \noverwrite\n:\n \ntrue\n \n}\n)\n\n\nq\n.\nupdate\n(\n{\n \n}\n,\n \ncallback\n);\n \n//\n \nexecutes\n\n\n\n//\n \nmulti\n \nupdate\n \nwith\n \noverwrite\n \nto\n \nempty\n \ndoc\n\n\nvar\n \nq\n \n=\n \nModel\n.\nwhere\n(\n{\n \n_id\n:\n \nid\n \n}\n);\n\n\nq\n.\nsetOptions\n(\n{\n \nmulti\n:\n \ntrue\n,\n \noverwrite\n:\n \ntrue\n \n}\n)\n\n\nq\n.\nupdate\n(\n{\n \n}\n);\n\n\nq\n.\nupdate\n(\ncallback\n);\n \n//\n \nexecuted\n\n\n\n//\n \nmulti\n \nupdates\n\n\nModel\n.\nwhere\n()\n\n     \n.\nupdate\n(\n{\n \nname\n:\n \n/^\nmatch\n/\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \narr\n:\n \n[]\n \n}\n}\n,\n \n{\n \nmulti\n:\n \ntrue\n \n}\n,\n \ncallback\n)\n\n\n\n//\n \nmore\n \nmulti\n \nupdates\n\n\nModel\n.\nwhere\n()\n\n     \n.\nsetOptions\n(\n{\n \nmulti\n:\n \ntrue\n \n}\n)\n\n     \n.\nupdate\n(\n{\n \n$\nset\n:\n \n{\n \narr\n:\n \n[]\n \n}\n}\n,\n \ncallback\n)\n\n\n\n//\n \nsingle\n \nupdate\n \nby\n \ndefault\n\n\nModel\n.\nwhere\n(\n{\n \nemail\n:\n \n[\naddress\n@\nexample.com\n })\n\n\n     .update({ $inc: { counter: 1 }}, callback)\n\n\n\n\n\n\nAPI summary\n\n\nupdate(criteria, doc, options, cb)\nupdate(criteria, doc, options)\nupdate(criteria, doc, cb)\nupdate(criteria, doc)\nupdate(doc, cb)\nupdate(doc)\nupdate(cb)\nupdate(true)\nupdate()\n\n\n\n\n\nQuery.prototype.updateMany()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclare and/or execute this query as an updateMany() operation. Same as \nupdate()\n, except MongoDB will update \nall\n documents that match \ncriteria\n (as opposed to just the first one) regardless of the value of the \nmulti\n option.\n\n\nNote\n updateMany will \nnot\n fire update middleware. Use \npre('updateMany')\n and \npost('updateMany')\n instead.\n\n\nThis function triggers the following middleware.\n\n\nQuery.prototype.updateOne()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclare and/or execute this query as an updateOne() operation. Same as \nupdate()\n, except MongoDB will update \nonly\n the first document that matches \ncriteria\n regardless of the value of the \nmulti\n option.\n\n\nNote\n updateOne will \nnot\n fire update middleware. Use \npre('updateOne')\n and \npost('updateOne')\n instead.\n\n\nThis function triggers the following middleware.\n\n\nQuery.prototype.replaceOne()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\n\u8fd4\u56de\n\n\nDeclare and/or execute this query as a replaceOne() operation. Same as \nupdate()\n, except MongoDB will replace the existing document and will not accept any atomic operators (\n$set\n, etc.)\n\n\nNote\n replaceOne will \nnot\n fire update middleware. Use \npre('replaceOne')\n and \npost('replaceOne')\n instead.\n\n\nThis function triggers the following middleware.\n\n\nQuery.prototype.exec()\n\n\n\u53c2\u6570\n\n\n\n\n[callback] \u00abFunction\u00bb optional params depend on the function being called\n\n\n\n\n\u8fd4\u56de\n\n\nExecutes the query\n\n\n\u793a\u4f8b\n\n\nvar promise = query.exec();\nvar promise = query.exec(\nupdate\n);\n\nquery.exec(callback);\nquery.exec(\nfind\n, callback);\n\n\n\n\n\nQuery.prototype.then()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nExecutes the query returning a \nPromise\n which will be resolved with either the doc(s) or rejected with the error.\n\n\nQuery.prototype.catch()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nExecutes the query returning a \nPromise\n which will be resolved with either the doc(s) or rejected with the error. Like \n.then()\n, but only takes a rejection handler.\n\n\nQuery.prototype.populate()\n\n\n\u53c2\u6570\n\n\n\n\n[options] \u00abObject\u00bb Options for the population query (sort, etc)\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies paths which should be populated with other documents.\n\n\n\u793a\u4f8b\n\n\nKitten.findOne().populate(\nowner\n).exec(function (err, kitten) {\n  console.log(kitten.owner.name)\n})\n\nKitten.find().populate({\n    path: \nowner\n\n  , select: \nname\n\n  , match: { color: \nblack\n }\n  , options: { sort: { name: -1 }}\n}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})\n\nKitten.find().populate(\nowner\n, \nname\n, null, {sort: { name: -1 }}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})\n\n\n\n\n\nPaths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n\n\nQuery.prototype.cast()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nCasts this query to the schema of \nmodel\n\n\n\u6ce8\u91ca\n\n\nIf \nobj\n is present, it is cast instead of this query.\n\n\nQuery.prototype.cursor()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nReturns a wrapper around a [mongodb driver cursor. A QueryCursor exposes a [Streams3-compatible interface, as well as a \n.next()\n function.\n\n\nThe \n.cursor()\n function triggers pre find hooks, but \nnot\n post find hooks.\n\n\n\u793a\u4f8b\n\n\nThing\n.\n\n  \nfind\n(\n{\n \nname\n:\n \n/^\nhello\n/\n \n}\n).\n\n  \ncursor\n().\n\n  \non\n(\ndata\n,\n \nfunction\n(\ndoc\n)\n \n{\n \nconsole.log(doc)\n;\n \n}\n).\n\n  \non\n(\nend\n,\n \nfunction\n()\n \n{\n \nconsole.log(\nDone!\n)\n;\n \n}\n);\n\n\n\nvar\n \ncursor\n \n=\n \nThing\n.\nfind\n(\n{\n \nname\n:\n \n/^\nhello\n/\n \n}\n)\n.\ncursor\n();\n\n\ncursor\n.\nnext\n(\nfunction\n(\nerror\n,\n \ndoc\n)\n \n{\n\n  \nconsole.log(doc)\n;\n\n\n}\n);\n\n\n\nco\n(\nfunction\n*()\n \n{\n\n  \nconst\n \ncursor\n \n=\n \nThing.find({\n \nname\n:\n \n/^\nhello\n/\n \n}\n)\n.\ncursor\n();\n\n  \nfor\n \n(\nlet\n \ndoc\n \n=\n \nyield\n \ncursor\n.\nnext\n();\n \ndoc\n \n!=\n \nnull\n;\n \ndoc\n \n=\n \nyield\n \ncursor\n.\nnext\n())\n \n{\n\n    \nconsole.log(doc)\n;\n\n  \n}\n\n\n}\n);\n\n\n\n\n\n\n\u9009\u9879\n\n\n\n\ntransform\n: optional function which accepts a mongoose document. The return value of the function will be emitted on \ndata\n and returned by \n.next()\n.\n\n\n\n\n\n\nQuery.prototype.maxscan()\n\n\nDEPRECATED\n Alias of \nmaxScan\n\n\nQuery.prototype.tailable()\n\n\n\u53c2\u6570\n\n\n\n\n[opts.tailableRetryInterval] \u00abNumber\u00bb if cursor is exhausted, wait this many milliseconds before retrying\n\n\n\n\nSets the tailable option (for use with capped collections).\n\n\n\u793a\u4f8b\n\n\nquery.tailable()\nquery.tailable(true)\nquery.tailable(false)\n\n\n\n\n\n\u6ce8\u91ca\n\n\nCannot be used with \ndistinct()\n\n\nQuery.prototype.intersects()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDeclares an intersects query for \ngeometry()\n.\n\n\n\u793a\u4f8b\n\n\nquery.where(\npath\n).intersects().geometry({\n    type: \nLineString\n\n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})\n\nquery.where(\npath\n).intersects({\n    type: \nLineString\n\n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})\n\n\n\n\n\n\u6ce8\u91ca\n\n\nMUST\n be used after \nwhere()\n.\n\n\n\u6ce8\u91ca\n\n\nIn Mongoose 3.7, \nintersects\n changed from a getter to a function. If you need the old syntax, use [this.\n\n\nQuery.prototype.geometry()\n\n\n\u53c2\u6570\n\n\n\n\nobject \u00abObject\u00bb Must contain a \ntype\n property which is a String and a \ncoordinates\n property which is an Array. See the examples.\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies a \n$geometry\n condition\n\n\n\u793a\u4f8b\n\n\nvar polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\nquery.where(\nloc\n).within().geometry({ type: \nPolygon\n, coordinates: polyA })\n\nvar polyB = [[ 0, 0 ], [ 1, 1 ]]\nquery.where(\nloc\n).within().geometry({ type: \nLineString\n, coordinates: polyB })\n\nvar polyC = [ 0, 0 ]\nquery.where(\nloc\n).within().geometry({ type: \nPoint\n, coordinates: polyC })\n\nquery.where(\nloc\n).intersects().geometry({ type: \nPoint\n, coordinates: polyC })\n\n\n\n\n\nThe argument is assigned to the most recent path passed to \nwhere()\n.\n\n\n\u6ce8\u91ca\n\n\ngeometry()\n \nmust\n come after either \nintersects()\n or \nwithin()\n.\n\n\nThe \nobject\n argument must contain \ntype\n and \ncoordinates\n properties. - type {String} - coordinates {Array}\n\n\n\n\nQuery.prototype.near()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSpecifies a \n$near\n or \n$nearSphere\n condition\n\n\nThese operators return documents sorted by distance.\n\n\n\u793a\u4f8b\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n,\n \nspherical\n:\n \ntrue\n \n}\n);\n\n\nquery\n.\nnear\n(\nloc\n,\n \n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n);\n\n\n\n\n\n\nQuery.prototype.nearSphere()\n\n\nDEPRECATED\n Specifies a \n$nearSphere\n condition\n\n\n\u793a\u4f8b\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnearSphere\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n);\n\n\n\n\n\n\nDeprecated.\n Use \nquery.near()\n instead with the \nspherical\n option set to \ntrue\n.\n\n\n\u793a\u4f8b\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nspherical\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\nQuery.prototype.polygon()\n\n\n\u53c2\u6570\n\n\n\n\n[coordinatePairs...] \u00abArray,Object\u00bb\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies a $polygon condition\n\n\n\u793a\u4f8b\n\n\nquery.where(\nloc\n).within().polygon([10,20], [13, 25], [7,15])\nquery.polygon(\nloc\n, [10,20], [13, 25], [7,15])\n\n\n\n\n\nQuery.prototype.box()\n\n\n\u53c2\u6570\n\n\n\n\nUpper \u00ab[Array]\u00bb Right Coords\n\n\n\n\n\u8fd4\u56de\n\n\nSpecifies a $box condition\n\n\n\u793a\u4f8b\n\n\nvar lowerLeft = [40.73083, -73.99756]\nvar upperRight= [40.741404,  -73.988135]\n\nquery.where(\nloc\n).within().box(lowerLeft, upperRight)\nquery.box({ ll : lowerLeft, ur : upperRight })\n\n\n\n\n\nQuery.prototype.circle()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nSpecifies a $center or $centerSphere condition.\n\n\n\u793a\u4f8b\n\n\nvar area = { center: [50, 50], radius: 10, unique: true }\nquery.where(\nloc\n).within().circle(area)\n\nquery.circle(\nloc\n, area);\n\nvar area = { center: [50, 50], radius: 10, unique: true, spherical: true }\nquery.where(\nloc\n).within().circle(area)\n\nquery.circle(\nloc\n, area);\n\n\n\n\n\nNew in 3.7.0\n\n\nQuery.prototype.center()\n\n\nQuery.prototype.centerSphere()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDEPRECATED\n Specifies a $centerSphere condition\n\n\nDeprecated.\n Use [circle instead.\n\n\n\u793a\u4f8b\n\n\nvar\n \narea\n \n=\n \n{\n \ncenter\n:\n \n[\n50\n,\n \n50\n]\n,\n \nradius\n:\n \n10\n \n}\n;\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n()\n.\ncenterSphere\n(\narea\n);\n\n\n\n\n\n\nQuery.prototype.selected()\n\n\n\u8fd4\u56de\n\n\nDetermines if field selection has been made.\n\n\nQuery.prototype.selectedInclusively()\n\n\n\u8fd4\u56de\n\n\nDetermines if inclusive field selection has been made.\n\n\nquery.selectedInclusively()\nquery.select(\nname\n)\nquery.selectedInclusively()\n\n\n\n\n\nQuery.prototype.selectedExclusively()\n\n\n\u8fd4\u56de\n\n\nDetermines if exclusive field selection has been made.\n\n\nquery.selectedExclusively()\nquery.select(\n-name\n)\nquery.selectedExclusively()\nquery.selectedInclusively()", 
            "title": "\u67e5\u8be2API"
        }, 
        {
            "location": "/query/api/#_1", 
            "text": "", 
            "title": "\u67e5\u8be2"
        }, 
        {
            "location": "/query/api/#query", 
            "text": "\u53c2\u6570   [collection] \u00abObject\u00bb Mongoose collection   Query constructor used for building queries. You do not need to instantiate a  Query  directly. Instead use Model functions like [ Model.find() .  \u793a\u4f8b  const query = MyModel.find();\nquery.setOptions({ lean : true });\nquery.collection(model.collection);\nquery.where( age ).gte(21).exec(callback);\n\nconst query = new mongoose.Query();", 
            "title": "Query()"
        }, 
        {
            "location": "/query/api/#queryprototypeusegeowithin", 
            "text": "Flag to opt out of using  $geoWithin .  mongoose.Query.use$geoWithin = false;  MongoDB 2.4 deprecated the use of  $within , replacing it with  $geoWithin . Mongoose uses  $geoWithin  by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to  false  so your  within()  queries continue to work.", 
            "title": "Query.prototype.use$geoWithin"
        }, 
        {
            "location": "/query/api/#queryprototypetoconstructor", 
            "text": "\u8fd4\u56de   \u00abQuery\u00bb subclass-of-Query   Converts this query to a customized, reusable query constructor with all arguments and options retained.  \u793a\u4f8b  var   query   =   Movie . find ( {   tags :   adventure   } ) . read ( primaryPreferred );  var   Adventure   =   query . toConstructor ();  Adventure () . exec ( callback )  Adventure () . where ( {   name :   /^ Life /   } ) . exec ( callback );  Adventure . prototype . startsWith   =   function   ( prefix )   { \n   this.where({   name :   new   RegExp ( ^   +   prefix )   } ) \n   return   this ;  }  Object . defineProperty ( Adventure . prototype ,   highlyRated ,   { \n   get :   function   ()   { \n     this . where ( {   rating :   {   $ gt :   4.5   }} ); \n     return   this ; \n   }  } )  Adventure () . highlyRated . startsWith ( Life ) . exec ( callback )   New in 3.7.3", 
            "title": "Query.prototype.toConstructor()"
        }, 
        {
            "location": "/query/api/#queryprototypewhere", 
            "text": "\u53c2\u6570   js \u00abString,Function\u00bb javascript string or function   \u8fd4\u56de  Specifies a javascript function or expression to pass to MongoDBs query system.  \u793a\u4f8b  query.$where( this.comments.length === 10 || this.name.length === 5 )\n\nquery.$where(function () {\n  return this.comments.length === 10 || this.name.length === 5;\n})  \u6ce8\u91ca  Only use  $where  when you have a condition that cannot be met using other MongoDB operators like  $lt .  Be sure to read about all of [its caveats before using.", 
            "title": "Query.prototype.$where()"
        }, 
        {
            "location": "/query/api/#queryprototypewhere_1", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Specifies a  path  for use with chaining.  \u793a\u4f8b  User . find ( { age :   {$ gte :   21 ,   $ lte :   65 } } ,   callback );  User . where ( age ) . gte ( 21 ) . lte ( 65 );  User . find () . where ( {   name :   vonderful   } )  User  . where ( age ) . gte ( 21 ) . lte ( 65 )  . where ( name ,   /^ vonderful / i )  . where ( friends ) . slice ( 10 )  . exec ( callback )", 
            "title": "Query.prototype.where()"
        }, 
        {
            "location": "/query/api/#queryprototypeequals", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Specifies the complementary comparison value for paths specified with  where()  \u793a\u4f8b  User.where( age ).equals(49);\n\nUser.where( age , 49);", 
            "title": "Query.prototype.equals()"
        }, 
        {
            "location": "/query/api/#queryprototypeor", 
            "text": "\u53c2\u6570   array \u00abArray\u00bb array of conditions   \u8fd4\u56de  Specifies arguments for an  $or  condition.  \u793a\u4f8b  query.or([{ color:  red  }, { status:  emergency  }])", 
            "title": "Query.prototype.or()"
        }, 
        {
            "location": "/query/api/#queryprototypenor", 
            "text": "\u53c2\u6570   array \u00abArray\u00bb array of conditions   \u8fd4\u56de  Specifies arguments for a  $nor  condition.  \u793a\u4f8b  query.nor([{ color:  green  }, { status:  ok  }])", 
            "title": "Query.prototype.nor()"
        }, 
        {
            "location": "/query/api/#queryprototypeand", 
            "text": "\u53c2\u6570   array \u00abArray\u00bb array of conditions   \u8fd4\u56de  Specifies arguments for a  $and  condition.  \u793a\u4f8b  query.and([{ color:  green  }, { status:  ok  }])", 
            "title": "Query.prototype.and()"
        }, 
        {
            "location": "/query/api/#queryprototypegt", 
            "text": "\u53c2\u6570  Specifies a $gt query condition.  When called with one argument, the most recent path passed to  where()  is used.  \u793a\u4f8b  Thing.find().where( age ).gt(21)\n\nThing.find().gt( age , 21)", 
            "title": "Query.prototype.gt()"
        }, 
        {
            "location": "/query/api/#queryprototypegte", 
            "text": "\u53c2\u6570  Specifies a $gte query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.gte()"
        }, 
        {
            "location": "/query/api/#queryprototypelt", 
            "text": "\u53c2\u6570  Specifies a $lt query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.lt()"
        }, 
        {
            "location": "/query/api/#queryprototypelte", 
            "text": "\u53c2\u6570  Specifies a $lte query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.lte()"
        }, 
        {
            "location": "/query/api/#queryprototypene", 
            "text": "\u53c2\u6570  Specifies a $ne query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.ne()"
        }, 
        {
            "location": "/query/api/#queryprototypein", 
            "text": "\u53c2\u6570  Specifies an $in query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.in()"
        }, 
        {
            "location": "/query/api/#queryprototypenin", 
            "text": "\u53c2\u6570  Specifies an $nin query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.nin()"
        }, 
        {
            "location": "/query/api/#queryprototypeall", 
            "text": "\u53c2\u6570  Specifies an $all query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.all()"
        }, 
        {
            "location": "/query/api/#queryprototypesize", 
            "text": "\u53c2\u6570  Specifies a $size query condition.  When called with one argument, the most recent path passed to  where()  is used.  \u793a\u4f8b  MyModel.where( tags ).size(0).exec(function (err, docs) {\n  if (err) return handleError(err);\n\n  assert(Array.isArray(docs));\n  console.log( documents with 0 tags , docs);\n})", 
            "title": "Query.prototype.size()"
        }, 
        {
            "location": "/query/api/#queryprototyperegex", 
            "text": "\u53c2\u6570  Specifies a $regex query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.regex()"
        }, 
        {
            "location": "/query/api/#queryprototypemaxdistance", 
            "text": "\u53c2\u6570  Specifies a $maxDistance query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Query.prototype.maxDistance()"
        }, 
        {
            "location": "/query/api/#queryprototypemod", 
            "text": "\u53c2\u6570   val \u00abArray\u00bb must be of length 2, first element is  divisor , 2nd element is  remainder .   \u8fd4\u56de  Specifies a  $mod  condition, filters documents for documents whose  path  property is a number that is equal to  remainder  modulo  divisor .  \u793a\u4f8b  Product.find().mod( inventory , [2, 1]);\nProduct.find().where( inventory ).mod([2, 1]);\n\nProduct.find().where( inventory ).mod(2, 1);", 
            "title": "Query.prototype.mod()"
        }, 
        {
            "location": "/query/api/#queryprototypeexists", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Specifies an  $exists  condition  \u793a\u4f8b  Thing.where( name ).exists()\nThing.where( name ).exists(true)\nThing.find().exists( name )\n\nThing.where( name ).exists(false);\nThing.find().exists( name , false);", 
            "title": "Query.prototype.exists()"
        }, 
        {
            "location": "/query/api/#queryprototypeelemmatch", 
            "text": "\u53c2\u6570   criteria \u00abObject,Function\u00bb   \u8fd4\u56de  Specifies an  $elemMatch  condition  \u793a\u4f8b  query . elemMatch ( comment ,   {   author :   autobot ,   votes :   {$ gte :   5 } } )  query . where ( comment ) . elemMatch ( {   author :   autobot ,   votes :   {$ gte :   5 } } )  query . elemMatch ( comment ,   function   ( elem )   { \n   elem.where( author ).equals( autobot ) ; \n   elem.where( votes ).gte(5) ;  } )  query . where ( comment ) . elemMatch ( function   ( elem )   { \n   elem.where({   author :   autobot   } ); \n   elem . where ( votes ) . gte ( 5 );  } )", 
            "title": "Query.prototype.elemMatch()"
        }, 
        {
            "location": "/query/api/#queryprototypewithin", 
            "text": "\u8fd4\u56de  Defines a  $within  or  $geoWithin  argument for geo-spatial queries.  \u793a\u4f8b  query . where ( path ) . within () . box ()  query . where ( path ) . within () . circle ()  query . where ( path ) . within () . geometry ()  query . where ( loc ) . within ( {   center :   [ 50 , 50 ] ,   radius :   10 ,   unique :   true ,   spherical :   true   } );  query . where ( loc ) . within ( {   box :   [ [ 40.73 ,   - 73.9 ] ,   [ 40.7 ,   - 73.988 ] ]   } );  query . where ( loc ) . within ( {   polygon :   [ [ ] , [] , [] , [] ]   } );  query . where ( loc ) . within ( [] ,   [] ,   [] )  query . where ( loc ) . within ( [] ,   [] )  query . where ( loc ) . within ( {   type :   LineString ,   coordinates :   [ ... ]   } );   MUST  be used after  where() .  \u6ce8\u91ca  As of Mongoose 3.7,  $geoWithin  is always used for queries. To change this behavior, see [Query.use$geoWithin.  \u6ce8\u91ca  In Mongoose 3.7,  within  changed from a getter to a function. If you need the old syntax, use [this.", 
            "title": "Query.prototype.within()"
        }, 
        {
            "location": "/query/api/#queryprototypeslice", 
            "text": "\u53c2\u6570   val \u00abNumber\u00bb number/range of elements to slice   \u8fd4\u56de  Specifies a $slice projection for an array.  \u793a\u4f8b  query.slice( comments , 5)\nquery.slice( comments , -5)\nquery.slice( comments , [10, 5])\nquery.where( comments ).slice(5)\nquery.where( comments ).slice([-10, 5])", 
            "title": "Query.prototype.slice()"
        }, 
        {
            "location": "/query/api/#queryprototypelimit", 
            "text": "\u53c2\u6570  Specifies the maximum number of documents the query will return.  \u793a\u4f8b  query.limit(20)  \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.limit()"
        }, 
        {
            "location": "/query/api/#queryprototypeskip", 
            "text": "\u53c2\u6570  Specifies the number of documents to skip.  \u793a\u4f8b  query.skip(100).limit(20)  \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.skip()"
        }, 
        {
            "location": "/query/api/#queryprototypemaxscan", 
            "text": "\u53c2\u6570  Specifies the maxScan option.  \u793a\u4f8b  query.maxScan(100)  \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.maxScan()"
        }, 
        {
            "location": "/query/api/#queryprototypebatchsize", 
            "text": "\u53c2\u6570  Specifies the batchSize option.  \u793a\u4f8b  query.batchSize(100)  \u6ce8\u91ca  Cannot be used with  distinct()  \u53c2\u6570  Specifies the  comment  option.  \u793a\u4f8b  query.comment( login query )  \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.batchSize()"
        }, 
        {
            "location": "/query/api/#queryprototypesnapshot", 
            "text": "\u8fd4\u56de  Specifies this query as a  snapshot  query.  \u793a\u4f8b  query.snapshot()\nquery.snapshot(true)\nquery.snapshot(false)  \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.snapshot()"
        }, 
        {
            "location": "/query/api/#queryprototypehint", 
            "text": "\u53c2\u6570   val \u00abObject\u00bb a hint object   \u8fd4\u56de  Sets query hints.  \u793a\u4f8b  query.hint({ indexA: 1, indexB: -1})  \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.hint()"
        }, 
        {
            "location": "/query/api/#queryprototypeselect", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Specifies which document fields to include or exclude (also known as the query \"projection\")  When using string syntax, prefixing a path with  -  will flag that path as excluded. When a path does not have the  -  prefix, it is included. Lastly, if a path is prefixed with  + , it forces inclusion of the path, which is useful for paths excluded at the [schema level.  A projection  must  be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The [ _id  field is the only exception because MongoDB includes it by default.  \u793a\u4f8b  query . select ( a b );  query . select ( -c -d );  query . select ( {   a :   1 ,   b :   1   } );  query . select ( {   c :   0 ,   d :   0   } );  query . select ( +path )", 
            "title": "Query.prototype.select()"
        }, 
        {
            "location": "/query/api/#queryprototypeslaveok", 
            "text": "\u53c2\u6570   v \u00abBoolean\u00bb defaults to true   \u8fd4\u56de  DEPRECATED  Sets the slaveOk option.  Deprecated  in MongoDB 2.2 in favor of [read preferences.  \u793a\u4f8b  query.slaveOk()\nquery.slaveOk(true)\nquery.slaveOk(false)", 
            "title": "Query.prototype.slaveOk()"
        }, 
        {
            "location": "/query/api/#queryprototyperead", 
            "text": "\u53c2\u6570   [tags] \u00abArray\u00bb optional tags for this query   \u8fd4\u56de  Determines the MongoDB nodes from which to read.  \u559c\u597d  primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\nsecondary            Read from secondary if available, otherwise error.\nprimaryPreferred     Read from primary if available, otherwise a secondary.\nsecondaryPreferred   Read from a secondary if available, otherwise read from the primary.\nnearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.  \u522b\u540d  p   primary\npp  primaryPreferred\ns   secondary\nsp  secondaryPreferred\nn   nearest  \u793a\u4f8b  new Query().read( primary )\nnew Query().read( p )\n\nnew Query().read( primaryPreferred )\nnew Query().read( pp )\n\nnew Query().read( secondary )\nnew Query().read( s )\n\nnew Query().read( secondaryPreferred )\nnew Query().read( sp )\n\nnew Query().read( nearest )\nnew Query().read( n )\n\nnew Query().read( s , [{ dc: sf , s: 1 },{ dc: ma , s: 2 }])  Read more about how to use read preferrences [here and [here.", 
            "title": "Query.prototype.read()"
        }, 
        {
            "location": "/query/api/#queryprototypemerge", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Merges another Query or conditions object into this one.  When a Query is passed, conditions, field selection and options are merged.  New in 3.7.0", 
            "title": "Query.prototype.merge()"
        }, 
        {
            "location": "/query/api/#queryprototypesetoptions", 
            "text": "\u53c2\u6570  Sets query options. Some options only make sense for certain operations.  \u9009\u9879  The following options are only for  find() : - [tailable - [sort - [limit - [skip - [maxscan - [batchSize - [comment - [snapshot - [readPreference - [hint  The following options are only for  update() ,  updateOne() ,  updateMany() ,  replaceOne() ,  findOneAndUpdate() , and  findByIdAndUpdate() : - [upsert - [writeConcern  The following options are only for  find() ,  findOne() ,  findById() ,  findOneAndUpdate() ,  findByIdAndUpdate() , and  geoSearch() : - [lean  The following options are for all operations", 
            "title": "Query.prototype.setOptions()"
        }, 
        {
            "location": "/query/api/#queryprototypegetquery", 
            "text": "\u8fd4\u56de   \u00abObject\u00bb current query conditions   Returns the current query conditions as a JSON object.  \u793a\u4f8b  var   query   =   new   Query ();  query . find ( {   a :   1   } ) . where ( b ) . gt ( 2 );  query . getQuery ();", 
            "title": "Query.prototype.getQuery()"
        }, 
        {
            "location": "/query/api/#queryprototypegetupdate", 
            "text": "\u8fd4\u56de   \u00abObject\u00bb current update operations   Returns the current update operations as a JSON object.  \u793a\u4f8b  var   query   =   new   Query ();  query . update ( {} ,   {   $ set :   {   a :   5   }   } );  query . getUpdate ();", 
            "title": "Query.prototype.getUpdate()"
        }, 
        {
            "location": "/query/api/#queryprototypelean", 
            "text": "\u53c2\u6570   bool \u00abBoolean,Object\u00bb defaults to true   \u8fd4\u56de  Sets the lean option.  Documents returned from queries with the  lean  option enabled are plain javascript objects, not [MongooseDocuments. They have no  save  method, getters/setters or other Mongoose magic applied.  \u793a\u4f8b  new Query().lean()\nnew Query().lean(true)\nnew Query().lean(false)\n\nModel.find().lean().exec(function (err, docs) {\n  docs[0] instanceof mongoose.Document\n});  This is a [great option in high-performance read-only scenarios, especially when combined with [stream.", 
            "title": "Query.prototype.lean()"
        }, 
        {
            "location": "/query/api/#queryprototypeerror", 
            "text": "\u53c2\u6570   err \u00abError,null\u00bb if set,  exec()  will fail fast before sending the query to MongoDB   Gets/sets the error flag on this query. If this flag is not null or undefined, the  exec()  promise will reject without executing.  \u793a\u4f8b  Query().error();\nQuery().error(null);\nQuery().error(new Error( test ));\nSchema.pre( find , function() {\n  if (!this.getQuery().userId) {\n    this.error(new Error( Not allowed to query without setting userId ));\n  }\n});  Note that query casting runs  after  hooks, so cast errors will override custom errors.  \u793a\u4f8b  var   TestSchema   =   new   Schema ( {   num :   Number   } );  var   TestModel   =   db . model ( Test ,   TestSchema );  TestModel . find ( {   num :   not a number   } ) . error ( new   Error ( woops )) . exec ( function ( error )   {  } );", 
            "title": "Query.prototype.error()"
        }, 
        {
            "location": "/query/api/#queryprototypemongooseoptions", 
            "text": "\u53c2\u6570   options \u00abObject\u00bb if specified, overwrites the current options   Getter/setter around the current mongoose-specific options for this query (populate, lean, etc.)", 
            "title": "Query.prototype.mongooseOptions()"
        }, 
        {
            "location": "/query/api/#queryprototypefind", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Finds documents.  When no  callback  is passed, the query is not executed. When the query is executed, the result will be an array of documents.  \u793a\u4f8b  query.find({ name:  Los Pollos Hermanos  }).find(callback)", 
            "title": "Query.prototype.find()"
        }, 
        {
            "location": "/query/api/#queryprototypemerge_1", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Merges another Query or conditions object into this one.  When a Query is passed, conditions, field selection and options are merged.", 
            "title": "Query.prototype.merge()"
        }, 
        {
            "location": "/query/api/#queryprototypecollation", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Adds a collation to this op (MongoDB 3.4 and up)", 
            "title": "Query.prototype.collation()"
        }, 
        {
            "location": "/query/api/#queryprototypefindone", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, document)   \u8fd4\u56de  Declares the query a findOne operation. When executed, the first found document is passed to the callback.  Passing a  callback  executes the query. The result of the query is a single document.   Note:   conditions  is optional, and if  conditions  is null or undefined, mongoose will send an empty  findOne  command to MongoDB, which will return an arbitrary document. If you're querying by  _id , use  Model.findById()  instead.   This function triggers the following middleware.  \u793a\u4f8b  var   query    =   Kitten . where ( {   color :   white   } );  query . findOne ( function   ( err ,   kitten )   { \n   if   (err)   return   handleError(err) ; \n   if   (kitten)   { \n\n   }  } );", 
            "title": "Query.prototype.findOne()"
        }, 
        {
            "location": "/query/api/#queryprototypecount", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, count)   \u8fd4\u56de  Specifying this query as a  count  query.  Passing a  callback  executes the query.  This function triggers the following middleware.  \u793a\u4f8b  var countQuery = model.where({  color :  black  }).count();\n\nquery.count({ color:  black  }).count(callback)\n\nquery.count({ color:  black  }, callback)\n\nquery.where( color ,  black ).count(function (err, count) {\n  if (err) return handleError(err);\n  console.log( there are %d kittens , count);\n})", 
            "title": "Query.prototype.count()"
        }, 
        {
            "location": "/query/api/#queryprototypedistinct", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, arr)   \u8fd4\u56de  Declares or executes a distict() operation.  Passing a  callback  executes the query.  This function does not trigger any middleware.  \u793a\u4f8b  distinct(field, conditions, callback)\ndistinct(field, conditions)\ndistinct(field, callback)\ndistinct(field)\ndistinct(callback)\ndistinct()", 
            "title": "Query.prototype.distinct()"
        }, 
        {
            "location": "/query/api/#queryprototypesort", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Sets the sort order  If an object is passed, values allowed are  asc ,  desc ,  ascending ,  descending ,  1 , and  -1 .  If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with  -  which will be treated as descending.  \u793a\u4f8b  query . sort ( {   field :   asc ,   test :   -1   } );  query . sort ( field -test );   \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.sort()"
        }, 
        {
            "location": "/query/api/#queryprototyperemove", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, writeOpResult)   \u8fd4\u56de  Declare and/or execute this query as a remove() operation.  This function does not trigger any middleware  \u793a\u4f8b  Model.remove({ artist:  Anne Murray  }, callback)  \u6ce8\u91ca  The operation is only executed when a callback is passed. To force execution without a callback, you must first call  remove()  and then execute it by using the  exec()  method.  var query = Model.find().remove({ name:  Anne Murray  })\n\nquery.remove({ name:  Anne Murray  }, callback)\nquery.remove({ name:  Anne Murray  }).remove(callback)\n\nquery.exec()\n\nquery.remove(conds, fn);\nquery.remove(conds)\nquery.remove(fn)\nquery.remove()", 
            "title": "Query.prototype.remove()"
        }, 
        {
            "location": "/query/api/#queryprototypedeleteone", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, writeOpResult)   \u8fd4\u56de  Declare and/or execute this query as a  deleteOne()  operation. Works like remove, except it deletes at most one document regardless of the  single  option.  This function does not trigger any middleware.  \u793a\u4f8b  Character.deleteOne({ name:  Eddard Stark  }, callback)\nCharacter.deleteOne({ name:  Eddard Stark  }).then(next)", 
            "title": "Query.prototype.deleteOne()"
        }, 
        {
            "location": "/query/api/#queryprototypedeletemany", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, writeOpResult)   \u8fd4\u56de  Declare and/or execute this query as a  deleteMany()  operation. Works like remove, except it deletes  every  document that matches  criteria  in the collection, regardless of the value of  single .  This function does not trigger any middleware  \u793a\u4f8b  Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)\nCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)", 
            "title": "Query.prototype.deleteMany()"
        }, 
        {
            "location": "/query/api/#queryprototypefindoneandupdate", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, doc),  unless   rawResult  is used, in which case params are (error, writeOpResult)   \u8fd4\u56de  Issues a mongodb [findAndModify update command.  Finds a matching document, updates it according to the  update  arg, passing any  options , and returns the found document (if any) to the callback. The query executes immediately if  callback  is passed.  This function triggers the following middleware.  \u9009\u9879   new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)  upsert : bool - creates the object if it doesn't exist. defaults to false.  fields : {Object|String} - Field selection. Equivalent to  .select(fields).findOneAndUpdate()  sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on [MongoDB's  $setOnInsert  operator.  rawResult : if true, returns the [raw result from the MongoDB driver  context  (string) if set to 'query' and  runValidators  is on,  this  will refer to the query in custom validator functions that update validation runs. Does nothing if  runValidators  is false.   \u56de\u8c03\u7b7e\u540d  function(error, doc) {\n\n}  \u793a\u4f8b  query.findOneAndUpdate(conditions, update, options, callback)\nquery.findOneAndUpdate(conditions, update, options)\nquery.findOneAndUpdate(conditions, update, callback)\nquery.findOneAndUpdate(conditions, update)\nquery.findOneAndUpdate(update, callback)\nquery.findOneAndUpdate(update)\nquery.findOneAndUpdate(callback)\nquery.findOneAndUpdate()", 
            "title": "Query.prototype.findOneAndUpdate()"
        }, 
        {
            "location": "/query/api/#queryprototypefindoneandremove", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, document)   \u8fd4\u56de  Issues a mongodb [findAndModify remove command.  Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if  callback  is passed.  This function triggers the following middleware.  \u9009\u9879   sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  rawResult : if true, resolves to the [raw result from the MongoDB driver   \u56de\u8c03\u7b7e\u540d  function(error, doc) {\n\n}  \u793a\u4f8b s  A.where().findOneAndRemove(conditions, options, callback)\nA.where().findOneAndRemove(conditions, options)\nA.where().findOneAndRemove(conditions, callback)\nA.where().findOneAndRemove(conditions)\nA.where().findOneAndRemove(callback)\nA.where().findOneAndRemove()", 
            "title": "Query.prototype.findOneAndRemove()"
        }, 
        {
            "location": "/query/api/#queryprototypeupdate", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional, params are (error, writeOpResult)   \u8fd4\u56de  Declare and/or execute this query as an update() operation.  All paths passed that are not $atomic operations will become $set ops.  This function triggers the following middleware.  \u793a\u4f8b  Model.where({ _id: id }).update({ title:  words  })\n\nModel.where({ _id: id }).update({ $set: { title:  words  }})  \u9009\u9879   safe  (boolean) safe mode (defaults to value set in schema (true))  upsert  (boolean) whether to create the doc if it doesn't match (false)  multi  (boolean) whether multiple documents should be updated (false)  runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on [MongoDB's  $setOnInsert  operator.  strict  (boolean) overrides the  strict  option for this update  overwrite  (boolean) disables update-only mode, allowing you to overwrite the doc (false)  context  (string) if set to 'query' and  runValidators  is on,  this  will refer to the query in custom validator functions that update validation runs. Does nothing if  runValidators  is false.   \u6ce8\u91ca  Passing an empty object  {}  as the doc will result in a no-op unless the  overwrite  option is passed. Without the  overwrite  option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.  \u6ce8\u91ca  The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the  exec()  method.  var   q   =   Model . where ( {   _id :   id   } );  q . update ( {   $ set :   {   name :   bob   } } ) . update ();   //   not   executed  q . update ( {   $ set :   {   name :   bob   } } ) . exec ();   //   executed  //   keys   that   are   not   $ atomic   ops   become   $ set .  //   this   executes   the   same   command   as   the   previous   example .  q . update ( {   name :   bob   } ) . exec ();  //   overwriting   with   empty   docs  var   q   =   Model . where ( {   _id :   id   } ) . setOptions ( {   overwrite :   true   } )  q . update ( {   } ,   callback );   //   executes  //   multi   update   with   overwrite   to   empty   doc  var   q   =   Model . where ( {   _id :   id   } );  q . setOptions ( {   multi :   true ,   overwrite :   true   } )  q . update ( {   } );  q . update ( callback );   //   executed  //   multi   updates  Model . where () \n      . update ( {   name :   /^ match /   } ,   {   $ set :   {   arr :   []   } } ,   {   multi :   true   } ,   callback )  //   more   multi   updates  Model . where () \n      . setOptions ( {   multi :   true   } ) \n      . update ( {   $ set :   {   arr :   []   } } ,   callback )  //   single   update   by   default  Model . where ( {   email :   [ address @ example.com  })       .update({ $inc: { counter: 1 }}, callback)   API summary  update(criteria, doc, options, cb)\nupdate(criteria, doc, options)\nupdate(criteria, doc, cb)\nupdate(criteria, doc)\nupdate(doc, cb)\nupdate(doc)\nupdate(cb)\nupdate(true)\nupdate()", 
            "title": "Query.prototype.update()"
        }, 
        {
            "location": "/query/api/#queryprototypeupdatemany", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, writeOpResult)   \u8fd4\u56de  Declare and/or execute this query as an updateMany() operation. Same as  update() , except MongoDB will update  all  documents that match  criteria  (as opposed to just the first one) regardless of the value of the  multi  option.  Note  updateMany will  not  fire update middleware. Use  pre('updateMany')  and  post('updateMany')  instead.  This function triggers the following middleware.", 
            "title": "Query.prototype.updateMany()"
        }, 
        {
            "location": "/query/api/#queryprototypeupdateone", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb params are (error, writeOpResult)   \u8fd4\u56de  Declare and/or execute this query as an updateOne() operation. Same as  update() , except MongoDB will update  only  the first document that matches  criteria  regardless of the value of the  multi  option.  Note  updateOne will  not  fire update middleware. Use  pre('updateOne')  and  post('updateOne')  instead.  This function triggers the following middleware.", 
            "title": "Query.prototype.updateOne()"
        }, 
        {
            "location": "/query/api/#queryprototypereplaceone", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params are (error, writeOpResult)   \u8fd4\u56de  Declare and/or execute this query as a replaceOne() operation. Same as  update() , except MongoDB will replace the existing document and will not accept any atomic operators ( $set , etc.)  Note  replaceOne will  not  fire update middleware. Use  pre('replaceOne')  and  post('replaceOne')  instead.  This function triggers the following middleware.", 
            "title": "Query.prototype.replaceOne()"
        }, 
        {
            "location": "/query/api/#queryprototypeexec", 
            "text": "\u53c2\u6570   [callback] \u00abFunction\u00bb optional params depend on the function being called   \u8fd4\u56de  Executes the query  \u793a\u4f8b  var promise = query.exec();\nvar promise = query.exec( update );\n\nquery.exec(callback);\nquery.exec( find , callback);", 
            "title": "Query.prototype.exec()"
        }, 
        {
            "location": "/query/api/#queryprototypethen", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Executes the query returning a  Promise  which will be resolved with either the doc(s) or rejected with the error.", 
            "title": "Query.prototype.then()"
        }, 
        {
            "location": "/query/api/#queryprototypecatch", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Executes the query returning a  Promise  which will be resolved with either the doc(s) or rejected with the error. Like  .then() , but only takes a rejection handler.", 
            "title": "Query.prototype.catch()"
        }, 
        {
            "location": "/query/api/#queryprototypepopulate", 
            "text": "\u53c2\u6570   [options] \u00abObject\u00bb Options for the population query (sort, etc)   \u8fd4\u56de  Specifies paths which should be populated with other documents.  \u793a\u4f8b  Kitten.findOne().populate( owner ).exec(function (err, kitten) {\n  console.log(kitten.owner.name)\n})\n\nKitten.find().populate({\n    path:  owner \n  , select:  name \n  , match: { color:  black  }\n  , options: { sort: { name: -1 }}\n}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})\n\nKitten.find().populate( owner ,  name , null, {sort: { name: -1 }}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})  Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.", 
            "title": "Query.prototype.populate()"
        }, 
        {
            "location": "/query/api/#queryprototypecast", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Casts this query to the schema of  model  \u6ce8\u91ca  If  obj  is present, it is cast instead of this query.", 
            "title": "Query.prototype.cast()"
        }, 
        {
            "location": "/query/api/#queryprototypecursor", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Returns a wrapper around a [mongodb driver cursor. A QueryCursor exposes a [Streams3-compatible interface, as well as a  .next()  function.  The  .cursor()  function triggers pre find hooks, but  not  post find hooks.  \u793a\u4f8b  Thing . \n   find ( {   name :   /^ hello /   } ). \n   cursor (). \n   on ( data ,   function ( doc )   {   console.log(doc) ;   } ). \n   on ( end ,   function ()   {   console.log( Done! ) ;   } );  var   cursor   =   Thing . find ( {   name :   /^ hello /   } ) . cursor ();  cursor . next ( function ( error ,   doc )   { \n   console.log(doc) ;  } );  co ( function *()   { \n   const   cursor   =   Thing.find({   name :   /^ hello /   } ) . cursor (); \n   for   ( let   doc   =   yield   cursor . next ();   doc   !=   null ;   doc   =   yield   cursor . next ())   { \n     console.log(doc) ; \n   }  } );   \u9009\u9879   transform : optional function which accepts a mongoose document. The return value of the function will be emitted on  data  and returned by  .next() .", 
            "title": "Query.prototype.cursor()"
        }, 
        {
            "location": "/query/api/#queryprototypemaxscan_1", 
            "text": "DEPRECATED  Alias of  maxScan", 
            "title": "Query.prototype.maxscan()"
        }, 
        {
            "location": "/query/api/#queryprototypetailable", 
            "text": "\u53c2\u6570   [opts.tailableRetryInterval] \u00abNumber\u00bb if cursor is exhausted, wait this many milliseconds before retrying   Sets the tailable option (for use with capped collections).  \u793a\u4f8b  query.tailable()\nquery.tailable(true)\nquery.tailable(false)  \u6ce8\u91ca  Cannot be used with  distinct()", 
            "title": "Query.prototype.tailable()"
        }, 
        {
            "location": "/query/api/#queryprototypeintersects", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Declares an intersects query for  geometry() .  \u793a\u4f8b  query.where( path ).intersects().geometry({\n    type:  LineString \n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})\n\nquery.where( path ).intersects({\n    type:  LineString \n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})  \u6ce8\u91ca  MUST  be used after  where() .  \u6ce8\u91ca  In Mongoose 3.7,  intersects  changed from a getter to a function. If you need the old syntax, use [this.", 
            "title": "Query.prototype.intersects()"
        }, 
        {
            "location": "/query/api/#queryprototypegeometry", 
            "text": "\u53c2\u6570   object \u00abObject\u00bb Must contain a  type  property which is a String and a  coordinates  property which is an Array. See the examples.   \u8fd4\u56de  Specifies a  $geometry  condition  \u793a\u4f8b  var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\nquery.where( loc ).within().geometry({ type:  Polygon , coordinates: polyA })\n\nvar polyB = [[ 0, 0 ], [ 1, 1 ]]\nquery.where( loc ).within().geometry({ type:  LineString , coordinates: polyB })\n\nvar polyC = [ 0, 0 ]\nquery.where( loc ).within().geometry({ type:  Point , coordinates: polyC })\n\nquery.where( loc ).intersects().geometry({ type:  Point , coordinates: polyC })  The argument is assigned to the most recent path passed to  where() .  \u6ce8\u91ca  geometry()   must  come after either  intersects()  or  within() .  The  object  argument must contain  type  and  coordinates  properties. - type {String} - coordinates {Array}", 
            "title": "Query.prototype.geometry()"
        }, 
        {
            "location": "/query/api/#queryprototypenear", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Specifies a  $near  or  $nearSphere  condition  These operators return documents sorted by distance.  \u793a\u4f8b  query . where ( loc ) . near ( {   center :   [ 10 ,   10 ]   } );  query . where ( loc ) . near ( {   center :   [ 10 ,   10 ] ,   maxDistance :   5   } );  query . where ( loc ) . near ( {   center :   [ 10 ,   10 ] ,   maxDistance :   5 ,   spherical :   true   } );  query . near ( loc ,   {   center :   [ 10 ,   10 ] ,   maxDistance :   5   } );", 
            "title": "Query.prototype.near()"
        }, 
        {
            "location": "/query/api/#queryprototypenearsphere", 
            "text": "DEPRECATED  Specifies a  $nearSphere  condition  \u793a\u4f8b  query . where ( loc ) . nearSphere ( {   center :   [ 10 ,   10 ] ,   maxDistance :   5   } );   Deprecated.  Use  query.near()  instead with the  spherical  option set to  true .  \u793a\u4f8b  query . where ( loc ) . near ( {   center :   [ 10 ,   10 ] ,   spherical :   true   } );", 
            "title": "Query.prototype.nearSphere()"
        }, 
        {
            "location": "/query/api/#queryprototypepolygon", 
            "text": "\u53c2\u6570   [coordinatePairs...] \u00abArray,Object\u00bb   \u8fd4\u56de  Specifies a $polygon condition  \u793a\u4f8b  query.where( loc ).within().polygon([10,20], [13, 25], [7,15])\nquery.polygon( loc , [10,20], [13, 25], [7,15])", 
            "title": "Query.prototype.polygon()"
        }, 
        {
            "location": "/query/api/#queryprototypebox", 
            "text": "\u53c2\u6570   Upper \u00ab[Array]\u00bb Right Coords   \u8fd4\u56de  Specifies a $box condition  \u793a\u4f8b  var lowerLeft = [40.73083, -73.99756]\nvar upperRight= [40.741404,  -73.988135]\n\nquery.where( loc ).within().box(lowerLeft, upperRight)\nquery.box({ ll : lowerLeft, ur : upperRight })", 
            "title": "Query.prototype.box()"
        }, 
        {
            "location": "/query/api/#queryprototypecircle", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Specifies a $center or $centerSphere condition.  \u793a\u4f8b  var area = { center: [50, 50], radius: 10, unique: true }\nquery.where( loc ).within().circle(area)\n\nquery.circle( loc , area);\n\nvar area = { center: [50, 50], radius: 10, unique: true, spherical: true }\nquery.where( loc ).within().circle(area)\n\nquery.circle( loc , area);  New in 3.7.0", 
            "title": "Query.prototype.circle()"
        }, 
        {
            "location": "/query/api/#queryprototypecenter", 
            "text": "", 
            "title": "Query.prototype.center()"
        }, 
        {
            "location": "/query/api/#queryprototypecentersphere", 
            "text": "\u53c2\u6570  \u8fd4\u56de  DEPRECATED  Specifies a $centerSphere condition  Deprecated.  Use [circle instead.  \u793a\u4f8b  var   area   =   {   center :   [ 50 ,   50 ] ,   radius :   10   } ;  query . where ( loc ) . within () . centerSphere ( area );", 
            "title": "Query.prototype.centerSphere()"
        }, 
        {
            "location": "/query/api/#queryprototypeselected", 
            "text": "\u8fd4\u56de  Determines if field selection has been made.", 
            "title": "Query.prototype.selected()"
        }, 
        {
            "location": "/query/api/#queryprototypeselectedinclusively", 
            "text": "\u8fd4\u56de  Determines if inclusive field selection has been made.  query.selectedInclusively()\nquery.select( name )\nquery.selectedInclusively()", 
            "title": "Query.prototype.selectedInclusively()"
        }, 
        {
            "location": "/query/api/#queryprototypeselectedexclusively", 
            "text": "\u8fd4\u56de  Determines if exclusive field selection has been made.  query.selectedExclusively()\nquery.select( -name )\nquery.selectedExclusively()\nquery.selectedInclusively()", 
            "title": "Query.prototype.selectedExclusively()"
        }, 
        {
            "location": "/guide/Validation/", 
            "text": "\u9a8c\u8bc1\n\n\nSource\n\n\n\u9a8c\u8bc1\u8bed\u6cd5\u89c4\u5219\n\n\n\n\n\u9a8c\u8bc1\u5728\nSchemaType\n\u4e2d\u5b9a\u4e49\n\n\n\u9a8c\u8bc1\u662f\n\u4e2d\u95f4\u4ef6\n. \u5728\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cMongoose\u5c06\u9a8c\u8bc1\u6ce8\u518c\u4e3a\u6bcf\u4e2a\u6a21\u5f0f\u7684\u201cpre\u201d\uff08'save'\uff09`\u94a9\u5b50\u3002\n\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\ndoc.validate\uff08callback\uff09\n\u6216\ndoc.validateSync\uff08\uff09\n\u624b\u52a8\u8fd0\u884c\u9a8c\u8bc1\n\n\n\u9a8c\u8bc1\u5668\u4e0d\u5728\u672a\u5b9a\u4e49\u7684\u503c\u4e0a\u8fd0\u884c\u3002 \u552f\u4e00\u7684\u4f8b\u5916\u662f\nrequired\n validator\n\u3002\n\n\n\u9a8c\u8bc1\u662f\u5f02\u6b65\u9012\u5f52\u7684; \u5f53\u4f60\u8c03\u7528\nModel\uff03save\n, \u5b50\u6587\u6863\u9a8c\u8bc1\u4e5f\u88ab\u6267\u884c. \u5982\u679c\u53d1\u751f\u9519\u8bef\uff0c\u4f60\u7684\nModel\uff03save\n\u56de\u8c03\u63a5\u6536\u5230\u5b83\n\n\n\u9a8c\u8bc1\u662f\u53ef\u5b9a\u5236\u7684\n\n\n\n\n  \nvar\n \nschema\n \n=\n \nnew\n \nSchema\n({\n\n    \nname\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n      \nrequired\n:\n \ntrue\n\n    \n}\n\n  \n});\n\n  \nvar\n \nCat\n \n=\n \ndb\n.\nmodel\n(\nCat\n,\n \nschema\n);\n\n\n  \nvar\n \ncat\n \n=\n \nnew\n \nCat\n();\n\n  \ncat\n.\nsave\n(\nfunction\n(\nerror\n)\n \n{\n\n    \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\nname\n].\nmessage\n,\n\n      \nPath `name` is required.\n);\n\n\n    \nerror\n \n=\n \ncat\n.\nvalidateSync\n();\n\n    \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\nname\n].\nmessage\n,\n\n      \nPath `name` is required.\n);\n\n  \n});\n\n\n\n\n\n\u5185\u7f6e\u9a8c\u8bc1\u5668\n\n\n\n\n\u6240\u6709\u7684\nSchemaTypes\n\u90fd\u6709\u5185\u7f6e\u7684\nrequired\n\u9a8c\u8bc1\u5668. \u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f\u4f7f\u7528\nSchemaType\n\u7684\ncheckRequired()\n\u51fd\u6570\u6765\u786e\u5b9a\u8be5\u503c\u662f\u5426\u6ee1\u8db3\u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f\n\n\nNumbers\n \u6709 \nmin\n \u548c \nmax\n \u9a8c\u8bc1\u5668.\n\n\nStrings\n \u6709 \nenum\n, \nmatch\n, \nmaxlength\n \u4f55 \nminlength\n \u9a8c\u8bc1\u5668.\n\n\n\n\n\u4e0a\u9762\u7684\u6bcf\u4e2a\u9a8c\u8bc1\u5668\u94fe\u63a5\u90fd\u63d0\u4f9b\u4e86\u6709\u5173\u5982\u4f55\u542f\u7528\u5b83\u4eec\u5e76\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u66f4\u591a\u4fe1\u606f.\n\n\n  \nvar\n \nbreakfastSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \neggs\n:\n \n{\n\n      \ntype\n:\n \nNumber\n,\n\n      \nmin\n:\n \n[\n6\n,\n \nToo few eggs\n],\n\n      \nmax\n:\n \n12\n\n    \n},\n\n    \nbacon\n:\n \n{\n\n      \ntype\n:\n \nNumber\n,\n\n      \nrequired\n:\n \n[\ntrue\n,\n \nWhy no bacon?\n]\n\n    \n},\n\n    \ndrink\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n      \nenum\n:\n \n[\nCoffee\n,\n \nTea\n],\n\n      \nrequired\n:\n \nfunction\n()\n \n{\n\n        \nreturn\n \nthis\n.\nbacon\n \n \n3\n;\n\n      \n}\n\n    \n}\n\n  \n});\n\n  \nvar\n \nBreakfast\n \n=\n \ndb\n.\nmodel\n(\nBreakfast\n,\n \nbreakfastSchema\n);\n\n\n  \nvar\n \nbadBreakfast\n \n=\n \nnew\n \nBreakfast\n({\n\n    \neggs\n:\n \n2\n,\n\n    \nbacon\n:\n \n0\n,\n\n    \ndrink\n:\n \nMilk\n\n  \n});\n\n  \nvar\n \nerror\n \n=\n \nbadBreakfast\n.\nvalidateSync\n();\n\n  \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\neggs\n].\nmessage\n,\n\n    \nToo few eggs\n);\n\n  \nassert\n.\nok\n(\n!\nerror\n.\nerrors\n[\nbacon\n]);\n\n  \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\ndrink\n].\nmessage\n,\n\n    \n`Milk` is not a valid enum value for path `drink`.\n);\n\n\n  \nbadBreakfast\n.\nbacon\n \n=\n \n5\n;\n\n  \nbadBreakfast\n.\ndrink\n \n=\n \nnull\n;\n\n\n  \nerror\n \n=\n \nbadBreakfast\n.\nvalidateSync\n();\n\n  \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\ndrink\n].\nmessage\n,\n \nPath `drink` is required.\n);\n\n\n  \nbadBreakfast\n.\nbacon\n \n=\n \nnull\n;\n\n  \nerror\n \n=\n \nbadBreakfast\n.\nvalidateSync\n();\n\n  \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\nbacon\n].\nmessage\n,\n \nWhy no bacon?\n);\n\n\n\n\n\nunique\n\n\n\u5bf9\u4e8e\u521d\u5b66\u8005\u6765\u8bf4\uff0c\u4e00\u4e2a\u5e38\u89c1\u7684\u95ee\u9898\u662f\u6a21\u5f0f\u7684\nunique\n\u9009\u9879\u4e0d\u662f\u9a8c\u8bc1\u5668\u3002 \u8fd9\u662f\u6784\u5efa\nMongoDB\u72ec\u7279\u7d22\u5f15\n\u7684\u4fbf\u5229\u5e2e\u624b\u3002 \u8bf7\u53c2\u9605\n\u5e38\u89c1\u95ee\u9898\n\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002\n\n\n  \nvar\n \nuniqueUsernameSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nusername\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n      \nunique\n:\n \ntrue\n\n    \n}\n\n  \n});\n\n  \nvar\n \nU1\n \n=\n \ndb\n.\nmodel\n(\nU1\n,\n \nuniqueUsernameSchema\n);\n\n  \nvar\n \nU2\n \n=\n \ndb\n.\nmodel\n(\nU2\n,\n \nuniqueUsernameSchema\n);\n\n\n  \nvar\n \ndup\n \n=\n \n[{\n \nusername\n:\n \nVal\n \n},\n \n{\n \nusername\n:\n \nVal\n \n}];\n\n  \nU1\n.\ncreate\n(\ndup\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n  \n});\n\n\n  \nU2\n.\nonce\n(\nindex\n,\n \nfunction\n(\nerror\n)\n \n{\n\n    \nassert\n.\nifError\n(\nerror\n);\n\n    \nU2\n.\ncreate\n(\ndup\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n      \nassert\n.\nok\n(\nerror\n);\n\n      \nassert\n.\nok\n(\n!\nerror\n.\nerrors\n);\n\n      \nassert\n.\nok\n(\nerror\n.\nmessage\n.\nindexOf\n(\nduplicate key error\n)\n \n!==\n \n-\n1\n);\n\n    \n});\n\n  \n});\n\n\n  \nU2\n.\ninit\n().\nthen\n(\nfunction\n()\n \n{\n\n    \nU2\n.\ncreate\n(\ndup\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n      \nassert\n.\nok\n(\nerror\n);\n\n      \nassert\n.\nok\n(\n!\nerror\n.\nerrors\n);\n\n      \nassert\n.\nok\n(\nerror\n.\nmessage\n.\nindexOf\n(\nduplicate key error\n)\n \n!==\n \n-\n1\n);\n\n    \n});\n\n  \n});\n\n\n\n\n\n\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\n\n\n\u5982\u679c\u5185\u7f6e\u7684\u9a8c\u8bc1\u5668\u662f\u4e0d\u591f\u7684, \u60a8\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4ee5\u6ee1\u8db3\u60a8\u7684\u9700\u6c42.\n\n\n\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u662f\u901a\u8fc7\u4f20\u9012\u9a8c\u8bc1\u51fd\u6570\u6765\u58f0\u660e\u7684. \u4f60\u53ef\u4ee5\u627e\u5230\u8be6\u7ec6\u7684\u8bf4\u660e \u5173\u4e8e\u5982\u4f55\u5728\nSchemaType\uff03validate()API\u6587\u6863\n\u4e2d\u505a\u5230\u8fd9\u4e00\u70b9.\n\n\n  \nvar\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nphone\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n      \nvalidate\n:\n \n{\n\n        \nvalidator\n:\n \nfunction\n(\nv\n)\n \n{\n\n          \nreturn\n \n/d{3}-d{3}-d{4}/\n.\ntest\n(\nv\n);\n\n        \n},\n\n        \nmessage\n:\n \n{VALUE} is not a valid phone number!\n\n      \n},\n\n      \nrequired\n:\n \n[\ntrue\n,\n \nUser phone number required\n]\n\n    \n}\n\n  \n});\n\n\n  \nvar\n \nUser\n \n=\n \ndb\n.\nmodel\n(\nuser\n,\n \nuserSchema\n);\n\n  \nvar\n \nuser\n \n=\n \nnew\n \nUser\n();\n\n  \nvar\n \nerror\n;\n\n\n  \nuser\n.\nphone\n \n=\n \n555.0123\n;\n\n  \nerror\n \n=\n \nuser\n.\nvalidateSync\n();\n\n  \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\nphone\n].\nmessage\n,\n\n    \n555.0123 is not a valid phone number!\n);\n\n\n  \nuser\n.\nphone\n \n=\n \n;\n\n  \nerror\n \n=\n \nuser\n.\nvalidateSync\n();\n\n  \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\nphone\n].\nmessage\n,\n\n    \nUser phone number required\n);\n\n\n  \nuser\n.\nphone\n \n=\n \n201-555-0123\n;\n\n\n  \nerror\n \n=\n \nuser\n.\nvalidateSync\n();\n\n  \nassert\n.\nequal\n(\nerror\n,\n \nnull\n);\n\n\n\n\n\n\u56de\u8c03\n\n\n\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e5f\u53ef\u4ee5\u662f\u5f02\u6b65\u7684\u3002\u5982\u679c\u4f60\u7684\u9a8c\u8bc1\u5668\u51fd\u6570\u6709\u4e24\u4e2a\u53c2\u6570\uff0c\u732b\u9f2c\u4f1a\u5047\u8bbe\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u56de\u8c03\u3002\n\n\n\u5373\u4f7f\u4f60\u4e0d\u60f3\u4f7f\u7528\u5f02\u6b65\u9a8c\u8bc1\u5668\uff0c\u4e5f\u8981\u5c0f\u5fc3\uff0c\u56e0\u4e3amongoose 4\u4f1a\u5047\u8bbe**\u6240\u6709\u5e26\u67092\u4e2a\u53c2\u6570\u7684\u51fd\u6570\u90fd\u662f\u5f02\u6b65\u7684\uff0c\u6bd4\u5982\nvalidator.isEmail\n\u51fd\u6570\n\u3002 \u8fd9\u79cd\u884c\u4e3a\u4ece4.9.0\u5f00\u59cb\u88ab\u89c6\u4e3a\u5f03\u7528\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e0a\u6307\u5b9a\u201cisAsync\uff1afalse\u201d\u6765\u5173\u95ed\u5b83\u3002\n\n\n  \nvar\n \nuserSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nphone\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n      \nvalidate\n:\n \n{\n\n\n        \nisAsync\n:\n \ntrue\n,\n\n        \nvalidator\n:\n \nfunction\n(\nv\n,\n \ncb\n)\n \n{\n\n          \nsetTimeout\n(\nfunction\n()\n \n{\n\n            \nvar\n \nphoneRegex\n \n=\n \n/d{3}-d{3}-d{4}/\n;\n\n            \nvar\n \nmsg\n \n=\n \nv\n \n+\n \n is not a valid phone number!\n;\n\n\n            \ncb\n(\nphoneRegex\n.\ntest\n(\nv\n),\n \nmsg\n);\n\n          \n},\n \n5\n);\n\n        \n},\n\n\n        \nmessage\n:\n \nDefault error message\n\n      \n},\n\n      \nrequired\n:\n \n[\ntrue\n,\n \nUser phone number required\n]\n\n    \n},\n\n    \nname\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n\n      \nvalidate\n:\n \nfunction\n(\nv\n)\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n(\nfunction\n(\nresolve\n,\n \nreject\n)\n \n{\n\n          \nsetTimeout\n(\nfunction\n()\n \n{\n\n            \nresolve\n(\nfalse\n);\n\n          \n},\n \n5\n);\n\n        \n});\n\n      \n}\n\n    \n}\n\n  \n});\n\n\n  \nvar\n \nUser\n \n=\n \ndb\n.\nmodel\n(\nUser\n,\n \nuserSchema\n);\n\n  \nvar\n \nuser\n \n=\n \nnew\n \nUser\n();\n\n  \nvar\n \nerror\n;\n\n\n  \nuser\n.\nphone\n \n=\n \n555.0123\n;\n\n  \nuser\n.\nname\n \n=\n \ntest\n;\n\n  \nuser\n.\nvalidate\n(\nfunction\n(\nerror\n)\n \n{\n\n    \nassert\n.\nok\n(\nerror\n);\n\n    \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\nphone\n].\nmessage\n,\n\n      \n555.0123 is not a valid phone number!\n);\n\n    \nassert\n.\nequal\n(\nerror\n.\nerrors\n[\nname\n].\nmessage\n,\n\n      \nValidator failed for path `name` with value `test`\n);\n\n  \n});\n\n\n\n\n\n\u8fd4\u56de\u9519\u8bef\n\n\n\u9a8c\u8bc1\u5931\u8d25\u540e\u8fd4\u56de\u7684\u9519\u8bef\u5305\u542b\nerror\n\u5bf9\u8c61\uff0c\u5176\u503c\u662f\nValidatorError\n\u5bf9\u8c61\u3002 \u6bcf\u4e2a\nValidatorError\n\u90fd\u6709\nkind\n\uff0c\npath\n\uff0c\nvalue\n, \u548c \nmessage\n \u5c5e\u6027. \u4e00\u4e2a\nValidatorError\n\u4e5f\u53ef\u80fd\u6709\u4e00\u4e2a\nreason\n\u5c5e\u6027\u3002 \u5982\u679c\u5728\u9a8c\u8bc1\u5668\u4e2d\u53d1\u751f\u9519\u8bef\uff0c \u8fd9\u4e2a\u5c5e\u6027\u5c06\u5305\u542b\u629b\u51fa\u7684\u9519\u8bef\u3002\n\n\n  \nvar\n \ntoySchema\n \n=\n \nnew\n \nSchema\n({\n\n    \ncolor\n:\n \nString\n,\n\n    \nname\n:\n \nString\n\n  \n});\n\n\n  \nvar\n \nvalidator\n \n=\n \nfunction\n(\nvalue\n)\n \n{\n\n    \nreturn\n \n/red|white|gold/i\n.\ntest\n(\nvalue\n);\n\n  \n};\n\n  \ntoySchema\n.\npath\n(\ncolor\n).\nvalidate\n(\nvalidator\n,\n\n    \nColor `{VALUE}` not valid\n,\n \nInvalid color\n);\n\n  \ntoySchema\n.\npath\n(\nname\n).\nvalidate\n(\nfunction\n(\nv\n)\n \n{\n\n    \nif\n \n(\nv\n \n!==\n \nTurbo Man\n)\n \n{\n\n      \nthrow\n \nnew\n \nError\n(\nNeed to get a Turbo Man for Christmas\n);\n\n    \n}\n\n    \nreturn\n \ntrue\n;\n\n  \n},\n \nName `{VALUE}` is not valid\n);\n\n\n  \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nToy\n,\n \ntoySchema\n);\n\n\n  \nvar\n \ntoy\n \n=\n \nnew\n \nToy\n({\n \ncolor\n:\n \nGreen\n,\n \nname\n:\n \nPower Ranger\n \n});\n\n\n  \ntoy\n.\nsave\n(\nfunction\n \n(\nerr\n)\n \n{\n\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\ncolor\n.\nmessage\n,\n \nColor `Green` not valid\n);\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\ncolor\n.\nkind\n,\n \nInvalid color\n);\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\ncolor\n.\npath\n,\n \ncolor\n);\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\ncolor\n.\nvalue\n,\n \nGreen\n);\n\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\nname\n.\nmessage\n,\n\n      \nNeed to get a Turbo Man for Christmas\n);\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\nname\n.\nvalue\n,\n \nPower Ranger\n);\n\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\nname\n.\nreason\n.\nmessage\n,\n\n      \nNeed to get a Turbo Man for Christmas\n);\n\n\n    \nassert\n.\nequal\n(\nerr\n.\nname\n,\n \nValidationError\n);\n\n  \n});\n\n\n\n\n\n\u5d4c\u5957\u5bf9\u8c61\n\n\n\u5728\u732b\u9f2c\u7684\u5d4c\u5957\u5bf9\u8c61\u5b9a\u4e49\u9a8c\u8bc1\u662f\u68d8\u624b\u7684\uff0c \u56e0\u4e3a\u5d4c\u5957\u7684\u5bf9\u8c61\u4e0d\u662f\u5b8c\u5168\u6210\u719f\u7684\u8def\u5f84\u3002\n\n\n  \nvar\n \npersonSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nname\n:\n \n{\n\n      \nfirst\n:\n \nString\n,\n\n      \nlast\n:\n \nString\n\n    \n}\n\n  \n});\n\n\n  \nassert\n.\nthrows\n(\nfunction\n()\n \n{\n\n\n    \npersonSchema\n.\npath\n(\nname\n).\nrequired\n(\ntrue\n);\n\n  \n},\n \n/Cannot.*\nrequired\n/\n);\n\n\n  \nvar\n \nnameSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nfirst\n:\n \nString\n,\n\n    \nlast\n:\n \nString\n\n  \n});\n\n\n  \npersonSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nname\n:\n \n{\n\n      \ntype\n:\n \nnameSchema\n,\n\n      \nrequired\n:\n \ntrue\n\n    \n}\n\n  \n});\n\n\n  \nvar\n \nPerson\n \n=\n \ndb\n.\nmodel\n(\nPerson\n,\n \npersonSchema\n);\n\n\n  \nvar\n \nperson\n \n=\n \nnew\n \nPerson\n();\n\n  \nvar\n \nerror\n \n=\n \nperson\n.\nvalidateSync\n();\n\n  \nassert\n.\nok\n(\nerror\n.\nerrors\n[\nname\n]);\n\n\n\n\n\n\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u60a8\u4e86\u89e3\u4e86\u6587\u6863\u9a8c\u8bc1\u3002 Mongoose also supports validation for \nupdate()\n and \nfindOneAndUpdate()\n operations. In Mongoose 4.x, update validators are off by default - you need to specify the \nrunValidators\n option.\n\n\n\u8981\u6253\u5f00\u66f4\u65b0\u9a8c\u8bc1\u5668\uff0c\u4e3a\nupdate\uff08\uff09\n\u6216\nfindOneAndUpdate\uff08\uff09\n\u8bbe\u7f6e\nrunValidators\n\u9009\u9879\u3002 \u5c0f\u5fc3\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u9ed8\u8ba4\u5173\u95ed\uff0c\u56e0\u4e3a\u4ed6\u4eec\u6709\u51e0\u4e2a\u8b66\u544a\u3002\n\n\n  \nvar\n \ntoySchema\n \n=\n \nnew\n \nSchema\n({\n\n    \ncolor\n:\n \nString\n,\n\n    \nname\n:\n \nString\n\n  \n});\n\n\n  \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nToys\n,\n \ntoySchema\n);\n\n\n  \nToy\n.\nschema\n.\npath\n(\ncolor\n).\nvalidate\n(\nfunction\n \n(\nvalue\n)\n \n{\n\n    \nreturn\n \n/blue|green|white|red|orange|periwinkle/i\n.\ntest\n(\nvalue\n);\n\n  \n},\n \nInvalid color\n);\n\n\n  \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n};\n\n  \nToy\n.\nupdate\n({},\n \n{\n \ncolor\n:\n \nbacon\n \n},\n \nopts\n,\n \nfunction\n \n(\nerr\n)\n \n{\n\n    \nassert\n.\nequal\n(\nerr\n.\nerrors\n.\ncolor\n.\nmessage\n,\n\n      \nInvalid color\n);\n\n  \n});\n\n\n\n\n\n\u66f4\u65b0\u9a8c\u8bc1\u5668\u548c\u6587\u6863\u9a8c\u8bc1\u5668\u4e4b\u95f4\u6709\u51e0\u4e2a\u5173\u952e\u7684\u533a\u522b\u3002 \u5728\u4e0a\u9762\u7684\u989c\u8272\u9a8c\u8bc1\u529f\u80fd\u4e2d\uff0c \nthis\n\u662f\u6307\u5728\u4f7f\u7528\u6587\u6863\u9a8c\u8bc1\u65f6\u6b63\u5728\u9a8c\u8bc1\u7684\u6587\u6863\u3002 \u4f46\u662f\uff0c\u5f53\u8fd0\u884c\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c \u6b63\u5728\u66f4\u65b0\u7684\u6587\u6863\u53ef\u80fd\u4e0d\u5728\u670d\u52a1\u5668\u7684\u5185\u5b58\u4e2d\uff0c\u6240\u4ee5\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u201cthis\u201d\u7684\u503c\u6ca1\u6709\u88ab\u5b9a\u4e49\u3002\n\n\n  \nvar\n \ntoySchema\n \n=\n \nnew\n \nSchema\n({\n\n    \ncolor\n:\n \nString\n,\n\n    \nname\n:\n \nString\n\n  \n});\n\n\n  \ntoySchema\n.\npath\n(\ncolor\n).\nvalidate\n(\nfunction\n(\nvalue\n)\n \n{\n\n\n    \nif\n \n(\nthis\n.\nname\n.\ntoLowerCase\n().\nindexOf\n(\nred\n)\n \n!==\n \n-\n1\n)\n \n{\n\n      \nreturn\n \nvalue\n \n!==\n \nred\n;\n\n    \n}\n\n    \nreturn\n \ntrue\n;\n\n  \n});\n\n\n  \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nActionFigure\n,\n \ntoySchema\n);\n\n\n  \nvar\n \ntoy\n \n=\n \nnew\n \nToy\n({\n \ncolor\n:\n \nred\n,\n \nname\n:\n \nRed Power Ranger\n \n});\n\n  \nvar\n \nerror\n \n=\n \ntoy\n.\nvalidateSync\n();\n\n  \nassert\n.\nok\n(\nerror\n.\nerrors\n[\ncolor\n]);\n\n\n  \nvar\n \nupdate\n \n=\n \n{\n \ncolor\n:\n \nred\n,\n \nname\n:\n \nRed Power Ranger\n \n};\n\n  \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n};\n\n\n  \nToy\n.\nupdate\n({},\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n    \nassert\n.\nok\n(\nerror\n);\n\n  \n});\n\n\n\n\n\ncontext\n\n\ncontext\n\u9009\u9879\u53ef\u4ee5\u8ba9\u4f60\u5728\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e2d\u5c06\nthis\n\u7684\u503c\u8bbe\u7f6e\u4e3a\u5e95\u5c42\u67e5\u8be2\u3002\n\n\n  \ntoySchema\n.\npath\n(\ncolor\n).\nvalidate\n(\nfunction\n(\nvalue\n)\n \n{\n\n\n    \nif\n \n(\nthis\n.\ngetUpdate\n().\n$set\n.\nname\n.\ntoLowerCase\n().\nindexOf\n(\nred\n)\n \n!==\n \n-\n1\n)\n \n{\n\n      \nreturn\n \nvalue\n \n===\n \nred\n;\n\n    \n}\n\n    \nreturn\n \ntrue\n;\n\n  \n});\n\n\n  \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nFigure\n,\n \ntoySchema\n);\n\n\n  \nvar\n \nupdate\n \n=\n \n{\n \ncolor\n:\n \nblue\n,\n \nname\n:\n \nRed Power Ranger\n \n};\n\n\n  \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n,\n \ncontext\n:\n \nquery\n \n};\n\n\n  \nToy\n.\nupdate\n({},\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n    \nassert\n.\nok\n(\nerror\n.\nerrors\n[\ncolor\n]);\n\n  \n});\n\n\n\n\n\n$unset\n\n\n\u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f\u7684\u53e6\u4e00\u4e2a\u5173\u952e\u533a\u522b\u4ec5\u5728\u66f4\u65b0\u4e2d\u6307\u5b9a\u7684\u8def\u5f84\u4e0a\u8fd0\u884c\u3002 \u4f8b\u5982\uff0c\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a\u66f4\u65b0\u64cd\u4f5c\u4e2d\u6ca1\u6709\u6307\u5b9a\u201cname\u201d\uff0c\u6240\u4ee5\u66f4\u65b0\u9a8c\u8bc1\u5c06\u6210\u529f\u3002\n\n\n\u5f53\u4f7f\u7528\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c\u53ea\u6709\u5f53\u60a8\u8bd5\u56fe\u663e\u5f0f\u5730\u4f7f\u7528\n$unset\n\u65f6\uff0c\u6240\u9700\u7684\u9a8c\u8bc1\u5668**\u5931\u8d25\u3002\n\n\n  \nvar\n \nkittenSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nrequired\n:\n \ntrue\n \n},\n\n    \nage\n:\n \nNumber\n\n  \n});\n\n\n  \nvar\n \nKitten\n \n=\n \ndb\n.\nmodel\n(\nKitten\n,\n \nkittenSchema\n);\n\n\n  \nvar\n \nupdate\n \n=\n \n{\n \ncolor\n:\n \nblue\n \n};\n\n  \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n};\n\n  \nKitten\n.\nupdate\n({},\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerr\n)\n \n{\n\n\n  \n});\n\n\n  \nvar\n \nunset\n \n=\n \n{\n \n$unset\n:\n \n{\n \nname\n:\n \n1\n \n}\n \n};\n\n  \nKitten\n.\nupdate\n({},\n \nunset\n,\n \nopts\n,\n \nfunction\n(\nerr\n)\n \n{\n\n\n    \nassert\n.\nok\n(\nerr\n);\n\n    \nassert\n.\nok\n(\nerr\n.\nerrors\n[\nname\n]);\n\n  \n});\n\n\n\n\n\n\u6700\u540e\u4e00\u4e2a\u7ec6\u8282\u503c\u5f97\u6ce8\u610f\uff1a\u4ec5\u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f**\u8fd0\u884c\u5728\u4ee5\u4e0b\u66f4\u65b0\u64cd\u4f5c\u7b26\u4e0a\uff1a\n\n\n\n\n$set\n * \n$unset\n * \n$push\n (\n= 4.8.0) * \n$addToSet\n (\n= 4.8.0) * \n$pull\n (\n= 4.12.0) * \n$pullAll\n (\n= 4.12.0)\n\n\n\n\n\u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u66f4\u65b0\u4f1a\u6210\u529f\uff0c\u4e0d\u7ba1\nnumber\n\u7684\u503c\u662f\u4ec0\u4e48\uff0c\u56e0\u4e3aupdate\u9a8c\u8bc1\u5668\u5ffd\u7565\u4e86\n$inc\n\u3002 \u53e6\u5916\uff0c\n$push\n\uff0c\n$addToSet\n\uff0c\n$pull\n\u548c\n$pullAll\n\u9a8c\u8bc1\u4e0d\u4f1a**\u5728\u6570\u7ec4\u672c\u8eab\u4e0a\u8fd0\u884c\u4efb\u4f55\u9a8c\u8bc1\uff0c \u53ea\u6709\u6570\u7ec4\u7684\u5355\u4e2a\u5143\u7d20\u3002\n\n\n  \nvar\n \ntestSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nnumber\n:\n \n{\n \ntype\n:\n \nNumber\n,\n \nmax\n:\n \n0\n \n},\n\n    \narr\n:\n \n[{\n \nmessage\n:\n \n{\n \ntype\n:\n \nString\n,\n \nmaxLength\n:\n \n10\n \n}\n \n}]\n\n  \n});\n\n\n  \ntestSchema\n.\npath\n(\narr\n).\nvalidate\n(\nfunction\n(\nv\n)\n \n{\n\n    \nreturn\n \nv\n.\nlength\n \n \n2\n;\n\n  \n});\n\n\n  \nvar\n \nTest\n \n=\n \ndb\n.\nmodel\n(\nTest\n,\n \ntestSchema\n);\n\n\n  \nvar\n \nupdate\n \n=\n \n{\n \n$inc\n:\n \n{\n \nnumber\n:\n \n1\n \n}\n \n};\n\n  \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n};\n\n  \nTest\n.\nupdate\n({},\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n    \nupdate\n \n=\n \n{\n \n$push\n:\n \n[{\n \nmessage\n:\n \nhello\n \n},\n \n{\n \nmessage\n:\n \nworld\n \n}]\n \n};\n\n    \nTest\n.\nupdate\n({},\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n    \n});\n\n  \n});\n\n\n\n\n\n$push\n\u548c\n$addToSet\n\n\n4.8.0\u4e2d\u7684\u65b0\u589e\u529f\u80fd\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e5f\u5728\n$push\n\u548c\n$addToSet\n\u4e0a\u8fd0\u884c\n\n\n  \nvar\n \ntestSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nnumbers\n:\n \n[{\n \ntype\n:\n \nNumber\n,\n \nmax\n:\n \n0\n \n}],\n\n    \ndocs\n:\n \n[{\n\n      \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nrequired\n:\n \ntrue\n \n}\n\n    \n}]\n\n  \n});\n\n\n  \nvar\n \nTest\n \n=\n \ndb\n.\nmodel\n(\nTestPush\n,\n \ntestSchema\n);\n\n\n  \nvar\n \nupdate\n \n=\n \n{\n\n    \n$push\n:\n \n{\n\n      \nnumbers\n:\n \n1\n,\n\n      \ndocs\n:\n \n{\n \nname\n:\n \nnull\n \n}\n\n    \n}\n\n  \n};\n\n  \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n};\n\n  \nTest\n.\nupdate\n({},\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n    \nassert\n.\nok\n(\nerror\n.\nerrors\n[\nnumbers\n]);\n\n    \nassert\n.\nok\n(\nerror\n.\nerrors\n[\ndocs\n]);\n\n  \n});", 
            "title": "\u9a8c\u8bc1"
        }, 
        {
            "location": "/guide/Validation/#_1", 
            "text": "Source", 
            "title": "\u9a8c\u8bc1"
        }, 
        {
            "location": "/guide/Validation/#_2", 
            "text": "\u9a8c\u8bc1\u5728 SchemaType \u4e2d\u5b9a\u4e49  \u9a8c\u8bc1\u662f \u4e2d\u95f4\u4ef6 . \u5728\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cMongoose\u5c06\u9a8c\u8bc1\u6ce8\u518c\u4e3a\u6bcf\u4e2a\u6a21\u5f0f\u7684\u201cpre\u201d\uff08'save'\uff09`\u94a9\u5b50\u3002  \u60a8\u53ef\u4ee5\u4f7f\u7528 doc.validate\uff08callback\uff09 \u6216 doc.validateSync\uff08\uff09 \u624b\u52a8\u8fd0\u884c\u9a8c\u8bc1  \u9a8c\u8bc1\u5668\u4e0d\u5728\u672a\u5b9a\u4e49\u7684\u503c\u4e0a\u8fd0\u884c\u3002 \u552f\u4e00\u7684\u4f8b\u5916\u662f required  validator \u3002  \u9a8c\u8bc1\u662f\u5f02\u6b65\u9012\u5f52\u7684; \u5f53\u4f60\u8c03\u7528 Model\uff03save , \u5b50\u6587\u6863\u9a8c\u8bc1\u4e5f\u88ab\u6267\u884c. \u5982\u679c\u53d1\u751f\u9519\u8bef\uff0c\u4f60\u7684 Model\uff03save \u56de\u8c03\u63a5\u6536\u5230\u5b83  \u9a8c\u8bc1\u662f\u53ef\u5b9a\u5236\u7684      var   schema   =   new   Schema ({ \n     name :   { \n       type :   String , \n       required :   true \n     } \n   }); \n   var   Cat   =   db . model ( Cat ,   schema ); \n\n   var   cat   =   new   Cat (); \n   cat . save ( function ( error )   { \n     assert . equal ( error . errors [ name ]. message , \n       Path `name` is required. ); \n\n     error   =   cat . validateSync (); \n     assert . equal ( error . errors [ name ]. message , \n       Path `name` is required. ); \n   });", 
            "title": "\u9a8c\u8bc1\u8bed\u6cd5\u89c4\u5219"
        }, 
        {
            "location": "/guide/Validation/#_3", 
            "text": "\u6240\u6709\u7684 SchemaTypes \u90fd\u6709\u5185\u7f6e\u7684 required \u9a8c\u8bc1\u5668. \u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f\u4f7f\u7528 SchemaType \u7684 checkRequired() \u51fd\u6570\u6765\u786e\u5b9a\u8be5\u503c\u662f\u5426\u6ee1\u8db3\u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f  Numbers  \u6709  min  \u548c  max  \u9a8c\u8bc1\u5668.  Strings  \u6709  enum ,  match ,  maxlength  \u4f55  minlength  \u9a8c\u8bc1\u5668.   \u4e0a\u9762\u7684\u6bcf\u4e2a\u9a8c\u8bc1\u5668\u94fe\u63a5\u90fd\u63d0\u4f9b\u4e86\u6709\u5173\u5982\u4f55\u542f\u7528\u5b83\u4eec\u5e76\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u66f4\u591a\u4fe1\u606f.     var   breakfastSchema   =   new   Schema ({ \n     eggs :   { \n       type :   Number , \n       min :   [ 6 ,   Too few eggs ], \n       max :   12 \n     }, \n     bacon :   { \n       type :   Number , \n       required :   [ true ,   Why no bacon? ] \n     }, \n     drink :   { \n       type :   String , \n       enum :   [ Coffee ,   Tea ], \n       required :   function ()   { \n         return   this . bacon     3 ; \n       } \n     } \n   }); \n   var   Breakfast   =   db . model ( Breakfast ,   breakfastSchema ); \n\n   var   badBreakfast   =   new   Breakfast ({ \n     eggs :   2 , \n     bacon :   0 , \n     drink :   Milk \n   }); \n   var   error   =   badBreakfast . validateSync (); \n   assert . equal ( error . errors [ eggs ]. message , \n     Too few eggs ); \n   assert . ok ( ! error . errors [ bacon ]); \n   assert . equal ( error . errors [ drink ]. message , \n     `Milk` is not a valid enum value for path `drink`. ); \n\n   badBreakfast . bacon   =   5 ; \n   badBreakfast . drink   =   null ; \n\n   error   =   badBreakfast . validateSync (); \n   assert . equal ( error . errors [ drink ]. message ,   Path `drink` is required. ); \n\n   badBreakfast . bacon   =   null ; \n   error   =   badBreakfast . validateSync (); \n   assert . equal ( error . errors [ bacon ]. message ,   Why no bacon? );", 
            "title": "\u5185\u7f6e\u9a8c\u8bc1\u5668"
        }, 
        {
            "location": "/guide/Validation/#unique", 
            "text": "\u5bf9\u4e8e\u521d\u5b66\u8005\u6765\u8bf4\uff0c\u4e00\u4e2a\u5e38\u89c1\u7684\u95ee\u9898\u662f\u6a21\u5f0f\u7684 unique \u9009\u9879\u4e0d\u662f\u9a8c\u8bc1\u5668\u3002 \u8fd9\u662f\u6784\u5efa MongoDB\u72ec\u7279\u7d22\u5f15 \u7684\u4fbf\u5229\u5e2e\u624b\u3002 \u8bf7\u53c2\u9605 \u5e38\u89c1\u95ee\u9898 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002     var   uniqueUsernameSchema   =   new   Schema ({ \n     username :   { \n       type :   String , \n       unique :   true \n     } \n   }); \n   var   U1   =   db . model ( U1 ,   uniqueUsernameSchema ); \n   var   U2   =   db . model ( U2 ,   uniqueUsernameSchema ); \n\n   var   dup   =   [{   username :   Val   },   {   username :   Val   }]; \n   U1 . create ( dup ,   function ( error )   { \n\n   }); \n\n   U2 . once ( index ,   function ( error )   { \n     assert . ifError ( error ); \n     U2 . create ( dup ,   function ( error )   { \n\n       assert . ok ( error ); \n       assert . ok ( ! error . errors ); \n       assert . ok ( error . message . indexOf ( duplicate key error )   !==   - 1 ); \n     }); \n   }); \n\n   U2 . init (). then ( function ()   { \n     U2 . create ( dup ,   function ( error )   { \n\n       assert . ok ( error ); \n       assert . ok ( ! error . errors ); \n       assert . ok ( error . message . indexOf ( duplicate key error )   !==   - 1 ); \n     }); \n   });", 
            "title": "unique"
        }, 
        {
            "location": "/guide/Validation/#_4", 
            "text": "\u5982\u679c\u5185\u7f6e\u7684\u9a8c\u8bc1\u5668\u662f\u4e0d\u591f\u7684, \u60a8\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4ee5\u6ee1\u8db3\u60a8\u7684\u9700\u6c42.  \u81ea\u5b9a\u4e49\u9a8c\u8bc1\u662f\u901a\u8fc7\u4f20\u9012\u9a8c\u8bc1\u51fd\u6570\u6765\u58f0\u660e\u7684. \u4f60\u53ef\u4ee5\u627e\u5230\u8be6\u7ec6\u7684\u8bf4\u660e \u5173\u4e8e\u5982\u4f55\u5728 SchemaType\uff03validate()API\u6587\u6863 \u4e2d\u505a\u5230\u8fd9\u4e00\u70b9.     var   userSchema   =   new   Schema ({ \n     phone :   { \n       type :   String , \n       validate :   { \n         validator :   function ( v )   { \n           return   /d{3}-d{3}-d{4}/ . test ( v ); \n         }, \n         message :   {VALUE} is not a valid phone number! \n       }, \n       required :   [ true ,   User phone number required ] \n     } \n   }); \n\n   var   User   =   db . model ( user ,   userSchema ); \n   var   user   =   new   User (); \n   var   error ; \n\n   user . phone   =   555.0123 ; \n   error   =   user . validateSync (); \n   assert . equal ( error . errors [ phone ]. message , \n     555.0123 is not a valid phone number! ); \n\n   user . phone   =   ; \n   error   =   user . validateSync (); \n   assert . equal ( error . errors [ phone ]. message , \n     User phone number required ); \n\n   user . phone   =   201-555-0123 ; \n\n   error   =   user . validateSync (); \n   assert . equal ( error ,   null );", 
            "title": "\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668"
        }, 
        {
            "location": "/guide/Validation/#_5", 
            "text": "\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e5f\u53ef\u4ee5\u662f\u5f02\u6b65\u7684\u3002\u5982\u679c\u4f60\u7684\u9a8c\u8bc1\u5668\u51fd\u6570\u6709\u4e24\u4e2a\u53c2\u6570\uff0c\u732b\u9f2c\u4f1a\u5047\u8bbe\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u56de\u8c03\u3002  \u5373\u4f7f\u4f60\u4e0d\u60f3\u4f7f\u7528\u5f02\u6b65\u9a8c\u8bc1\u5668\uff0c\u4e5f\u8981\u5c0f\u5fc3\uff0c\u56e0\u4e3amongoose 4\u4f1a\u5047\u8bbe**\u6240\u6709\u5e26\u67092\u4e2a\u53c2\u6570\u7684\u51fd\u6570\u90fd\u662f\u5f02\u6b65\u7684\uff0c\u6bd4\u5982 validator.isEmail \u51fd\u6570 \u3002 \u8fd9\u79cd\u884c\u4e3a\u4ece4.9.0\u5f00\u59cb\u88ab\u89c6\u4e3a\u5f03\u7528\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e0a\u6307\u5b9a\u201cisAsync\uff1afalse\u201d\u6765\u5173\u95ed\u5b83\u3002     var   userSchema   =   new   Schema ({ \n     phone :   { \n       type :   String , \n       validate :   { \n\n         isAsync :   true , \n         validator :   function ( v ,   cb )   { \n           setTimeout ( function ()   { \n             var   phoneRegex   =   /d{3}-d{3}-d{4}/ ; \n             var   msg   =   v   +    is not a valid phone number! ; \n\n             cb ( phoneRegex . test ( v ),   msg ); \n           },   5 ); \n         }, \n\n         message :   Default error message \n       }, \n       required :   [ true ,   User phone number required ] \n     }, \n     name :   { \n       type :   String , \n\n       validate :   function ( v )   { \n         return   new   Promise ( function ( resolve ,   reject )   { \n           setTimeout ( function ()   { \n             resolve ( false ); \n           },   5 ); \n         }); \n       } \n     } \n   }); \n\n   var   User   =   db . model ( User ,   userSchema ); \n   var   user   =   new   User (); \n   var   error ; \n\n   user . phone   =   555.0123 ; \n   user . name   =   test ; \n   user . validate ( function ( error )   { \n     assert . ok ( error ); \n     assert . equal ( error . errors [ phone ]. message , \n       555.0123 is not a valid phone number! ); \n     assert . equal ( error . errors [ name ]. message , \n       Validator failed for path `name` with value `test` ); \n   });", 
            "title": "\u56de\u8c03"
        }, 
        {
            "location": "/guide/Validation/#_6", 
            "text": "\u9a8c\u8bc1\u5931\u8d25\u540e\u8fd4\u56de\u7684\u9519\u8bef\u5305\u542b error \u5bf9\u8c61\uff0c\u5176\u503c\u662f ValidatorError \u5bf9\u8c61\u3002 \u6bcf\u4e2a ValidatorError \u90fd\u6709 kind \uff0c path \uff0c value , \u548c  message  \u5c5e\u6027. \u4e00\u4e2a ValidatorError \u4e5f\u53ef\u80fd\u6709\u4e00\u4e2a reason \u5c5e\u6027\u3002 \u5982\u679c\u5728\u9a8c\u8bc1\u5668\u4e2d\u53d1\u751f\u9519\u8bef\uff0c \u8fd9\u4e2a\u5c5e\u6027\u5c06\u5305\u542b\u629b\u51fa\u7684\u9519\u8bef\u3002     var   toySchema   =   new   Schema ({ \n     color :   String , \n     name :   String \n   }); \n\n   var   validator   =   function ( value )   { \n     return   /red|white|gold/i . test ( value ); \n   }; \n   toySchema . path ( color ). validate ( validator , \n     Color `{VALUE}` not valid ,   Invalid color ); \n   toySchema . path ( name ). validate ( function ( v )   { \n     if   ( v   !==   Turbo Man )   { \n       throw   new   Error ( Need to get a Turbo Man for Christmas ); \n     } \n     return   true ; \n   },   Name `{VALUE}` is not valid ); \n\n   var   Toy   =   db . model ( Toy ,   toySchema ); \n\n   var   toy   =   new   Toy ({   color :   Green ,   name :   Power Ranger   }); \n\n   toy . save ( function   ( err )   { \n\n     assert . equal ( err . errors . color . message ,   Color `Green` not valid ); \n     assert . equal ( err . errors . color . kind ,   Invalid color ); \n     assert . equal ( err . errors . color . path ,   color ); \n     assert . equal ( err . errors . color . value ,   Green ); \n\n     assert . equal ( err . errors . name . message , \n       Need to get a Turbo Man for Christmas ); \n     assert . equal ( err . errors . name . value ,   Power Ranger ); \n\n     assert . equal ( err . errors . name . reason . message , \n       Need to get a Turbo Man for Christmas ); \n\n     assert . equal ( err . name ,   ValidationError ); \n   });", 
            "title": "\u8fd4\u56de\u9519\u8bef"
        }, 
        {
            "location": "/guide/Validation/#_7", 
            "text": "\u5728\u732b\u9f2c\u7684\u5d4c\u5957\u5bf9\u8c61\u5b9a\u4e49\u9a8c\u8bc1\u662f\u68d8\u624b\u7684\uff0c \u56e0\u4e3a\u5d4c\u5957\u7684\u5bf9\u8c61\u4e0d\u662f\u5b8c\u5168\u6210\u719f\u7684\u8def\u5f84\u3002     var   personSchema   =   new   Schema ({ \n     name :   { \n       first :   String , \n       last :   String \n     } \n   }); \n\n   assert . throws ( function ()   { \n\n     personSchema . path ( name ). required ( true ); \n   },   /Cannot.* required / ); \n\n   var   nameSchema   =   new   Schema ({ \n     first :   String , \n     last :   String \n   }); \n\n   personSchema   =   new   Schema ({ \n     name :   { \n       type :   nameSchema , \n       required :   true \n     } \n   }); \n\n   var   Person   =   db . model ( Person ,   personSchema ); \n\n   var   person   =   new   Person (); \n   var   error   =   person . validateSync (); \n   assert . ok ( error . errors [ name ]);   \u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u60a8\u4e86\u89e3\u4e86\u6587\u6863\u9a8c\u8bc1\u3002 Mongoose also supports validation for  update()  and  findOneAndUpdate()  operations. In Mongoose 4.x, update validators are off by default - you need to specify the  runValidators  option.  \u8981\u6253\u5f00\u66f4\u65b0\u9a8c\u8bc1\u5668\uff0c\u4e3a update\uff08\uff09 \u6216 findOneAndUpdate\uff08\uff09 \u8bbe\u7f6e runValidators \u9009\u9879\u3002 \u5c0f\u5fc3\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u9ed8\u8ba4\u5173\u95ed\uff0c\u56e0\u4e3a\u4ed6\u4eec\u6709\u51e0\u4e2a\u8b66\u544a\u3002     var   toySchema   =   new   Schema ({ \n     color :   String , \n     name :   String \n   }); \n\n   var   Toy   =   db . model ( Toys ,   toySchema ); \n\n   Toy . schema . path ( color ). validate ( function   ( value )   { \n     return   /blue|green|white|red|orange|periwinkle/i . test ( value ); \n   },   Invalid color ); \n\n   var   opts   =   {   runValidators :   true   }; \n   Toy . update ({},   {   color :   bacon   },   opts ,   function   ( err )   { \n     assert . equal ( err . errors . color . message , \n       Invalid color ); \n   });   \u66f4\u65b0\u9a8c\u8bc1\u5668\u548c\u6587\u6863\u9a8c\u8bc1\u5668\u4e4b\u95f4\u6709\u51e0\u4e2a\u5173\u952e\u7684\u533a\u522b\u3002 \u5728\u4e0a\u9762\u7684\u989c\u8272\u9a8c\u8bc1\u529f\u80fd\u4e2d\uff0c  this \u662f\u6307\u5728\u4f7f\u7528\u6587\u6863\u9a8c\u8bc1\u65f6\u6b63\u5728\u9a8c\u8bc1\u7684\u6587\u6863\u3002 \u4f46\u662f\uff0c\u5f53\u8fd0\u884c\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c \u6b63\u5728\u66f4\u65b0\u7684\u6587\u6863\u53ef\u80fd\u4e0d\u5728\u670d\u52a1\u5668\u7684\u5185\u5b58\u4e2d\uff0c\u6240\u4ee5\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u201cthis\u201d\u7684\u503c\u6ca1\u6709\u88ab\u5b9a\u4e49\u3002     var   toySchema   =   new   Schema ({ \n     color :   String , \n     name :   String \n   }); \n\n   toySchema . path ( color ). validate ( function ( value )   { \n\n     if   ( this . name . toLowerCase (). indexOf ( red )   !==   - 1 )   { \n       return   value   !==   red ; \n     } \n     return   true ; \n   }); \n\n   var   Toy   =   db . model ( ActionFigure ,   toySchema ); \n\n   var   toy   =   new   Toy ({   color :   red ,   name :   Red Power Ranger   }); \n   var   error   =   toy . validateSync (); \n   assert . ok ( error . errors [ color ]); \n\n   var   update   =   {   color :   red ,   name :   Red Power Ranger   }; \n   var   opts   =   {   runValidators :   true   }; \n\n   Toy . update ({},   update ,   opts ,   function ( error )   { \n\n     assert . ok ( error ); \n   });", 
            "title": "\u5d4c\u5957\u5bf9\u8c61"
        }, 
        {
            "location": "/guide/Validation/#context", 
            "text": "context \u9009\u9879\u53ef\u4ee5\u8ba9\u4f60\u5728\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e2d\u5c06 this \u7684\u503c\u8bbe\u7f6e\u4e3a\u5e95\u5c42\u67e5\u8be2\u3002     toySchema . path ( color ). validate ( function ( value )   { \n\n     if   ( this . getUpdate (). $set . name . toLowerCase (). indexOf ( red )   !==   - 1 )   { \n       return   value   ===   red ; \n     } \n     return   true ; \n   }); \n\n   var   Toy   =   db . model ( Figure ,   toySchema ); \n\n   var   update   =   {   color :   blue ,   name :   Red Power Ranger   }; \n\n   var   opts   =   {   runValidators :   true ,   context :   query   }; \n\n   Toy . update ({},   update ,   opts ,   function ( error )   { \n     assert . ok ( error . errors [ color ]); \n   });", 
            "title": "context"
        }, 
        {
            "location": "/guide/Validation/#unset", 
            "text": "\u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f\u7684\u53e6\u4e00\u4e2a\u5173\u952e\u533a\u522b\u4ec5\u5728\u66f4\u65b0\u4e2d\u6307\u5b9a\u7684\u8def\u5f84\u4e0a\u8fd0\u884c\u3002 \u4f8b\u5982\uff0c\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a\u66f4\u65b0\u64cd\u4f5c\u4e2d\u6ca1\u6709\u6307\u5b9a\u201cname\u201d\uff0c\u6240\u4ee5\u66f4\u65b0\u9a8c\u8bc1\u5c06\u6210\u529f\u3002  \u5f53\u4f7f\u7528\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c\u53ea\u6709\u5f53\u60a8\u8bd5\u56fe\u663e\u5f0f\u5730\u4f7f\u7528 $unset \u65f6\uff0c\u6240\u9700\u7684\u9a8c\u8bc1\u5668**\u5931\u8d25\u3002     var   kittenSchema   =   new   Schema ({ \n     name :   {   type :   String ,   required :   true   }, \n     age :   Number \n   }); \n\n   var   Kitten   =   db . model ( Kitten ,   kittenSchema ); \n\n   var   update   =   {   color :   blue   }; \n   var   opts   =   {   runValidators :   true   }; \n   Kitten . update ({},   update ,   opts ,   function ( err )   { \n\n   }); \n\n   var   unset   =   {   $unset :   {   name :   1   }   }; \n   Kitten . update ({},   unset ,   opts ,   function ( err )   { \n\n     assert . ok ( err ); \n     assert . ok ( err . errors [ name ]); \n   });   \u6700\u540e\u4e00\u4e2a\u7ec6\u8282\u503c\u5f97\u6ce8\u610f\uff1a\u4ec5\u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f**\u8fd0\u884c\u5728\u4ee5\u4e0b\u66f4\u65b0\u64cd\u4f5c\u7b26\u4e0a\uff1a   $set  *  $unset  *  $push  ( = 4.8.0) *  $addToSet  ( = 4.8.0) *  $pull  ( = 4.12.0) *  $pullAll  ( = 4.12.0)   \u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u66f4\u65b0\u4f1a\u6210\u529f\uff0c\u4e0d\u7ba1 number \u7684\u503c\u662f\u4ec0\u4e48\uff0c\u56e0\u4e3aupdate\u9a8c\u8bc1\u5668\u5ffd\u7565\u4e86 $inc \u3002 \u53e6\u5916\uff0c $push \uff0c $addToSet \uff0c $pull \u548c $pullAll \u9a8c\u8bc1\u4e0d\u4f1a**\u5728\u6570\u7ec4\u672c\u8eab\u4e0a\u8fd0\u884c\u4efb\u4f55\u9a8c\u8bc1\uff0c \u53ea\u6709\u6570\u7ec4\u7684\u5355\u4e2a\u5143\u7d20\u3002     var   testSchema   =   new   Schema ({ \n     number :   {   type :   Number ,   max :   0   }, \n     arr :   [{   message :   {   type :   String ,   maxLength :   10   }   }] \n   }); \n\n   testSchema . path ( arr ). validate ( function ( v )   { \n     return   v . length     2 ; \n   }); \n\n   var   Test   =   db . model ( Test ,   testSchema ); \n\n   var   update   =   {   $inc :   {   number :   1   }   }; \n   var   opts   =   {   runValidators :   true   }; \n   Test . update ({},   update ,   opts ,   function ( error )   { \n\n     update   =   {   $push :   [{   message :   hello   },   {   message :   world   }]   }; \n     Test . update ({},   update ,   opts ,   function ( error )   { \n\n     }); \n   });", 
            "title": "$unset"
        }, 
        {
            "location": "/guide/Validation/#pushaddtoset", 
            "text": "4.8.0\u4e2d\u7684\u65b0\u589e\u529f\u80fd\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e5f\u5728 $push \u548c $addToSet \u4e0a\u8fd0\u884c     var   testSchema   =   new   Schema ({ \n     numbers :   [{   type :   Number ,   max :   0   }], \n     docs :   [{ \n       name :   {   type :   String ,   required :   true   } \n     }] \n   }); \n\n   var   Test   =   db . model ( TestPush ,   testSchema ); \n\n   var   update   =   { \n     $push :   { \n       numbers :   1 , \n       docs :   {   name :   null   } \n     } \n   }; \n   var   opts   =   {   runValidators :   true   }; \n   Test . update ({},   update ,   opts ,   function ( error )   { \n     assert . ok ( error . errors [ numbers ]); \n     assert . ok ( error . errors [ docs ]); \n   });", 
            "title": "$push\u548c$addToSet"
        }, 
        {
            "location": "/guide/Middleware/", 
            "text": "\u4e2d\u95f4\u4ef6\n\n\nSource\n\n\nMiddleware (also called pre and post \nhooks\n) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing \nplugins\n. Mongoose 4.x has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware. Document middleware is supported for the following document functions. In document middleware functions, \nthis\n refers to the document.\n\n\nQuery middleware is supported for the following Model and Query functions. In query middleware functions, \nthis\n refers to the query.\n\n\nAggregate middleware is for \nMyModel.aggregate()\n. Aggregate middleware executes when you call \nexec()\n on an aggregate object. In aggregate middleware, \nthis\n refers to the \naggregation object\n.\n\n\nModel middleware is supported for the following model functions. In model middleware functions, \nthis\n refers to the model.\n\n\nAll middleware types support pre and post hooks. How pre and post hooks work is described in more detail below.\n\n\nNote:\n There is no query hook for \nremove()\n, only for documents. If you set a 'remove' hook, it will be fired when you call \nmyDoc.remove()\n, not when you call \nMyModel.remove()\n. \nNote:\n The \ncreate()\n function fires \nsave()\n hooks.\n\n\nPre\n\n\nThere are two types of \npre\n hooks, serial and parallel.\n\n\n\u4e32\u884c\n\n\nSerial middleware functions are executed one after another, when each middleware calls \nnext\n.\n\n\nvar schema = new Schema(..);\nschema.pre(\nsave\n, function(next) {\n\n  next();\n});\n\n\n\n\n\nThe \nnext()\n call does \nnot\n stop the rest of the code in your middleware function from executing. Use \nthe early \nreturn\n pattern\n to prevent the rest of your middleware function from running when you call \nnext()\n.\n\n\nvar schema = new Schema(..);\nschema.pre(\nsave\n, function(next) {\n  if (foo()) {\n    console.log(\ncalling next!\n);\n\n     next();\n  }\n\n  console.log(\nafter next\n);\n});\n\n\n\n\n\n\u5e73\u884c\n\n\nParallel middleware offer more fine-grained flow control.\n\n\nvar schema = new Schema(..);\n\nschema.pre(\nsave\n, true, function(next, done) {\n\n  next();\n  setTimeout(done, 100);\n});\n\n\n\n\n\nThe hooked method, in this case \nsave\n, will not be executed until \ndone\n is called by each middleware.\n\n\n\u7528\u4f8b\n\n\nMiddleware are useful for atomizing model logic. Here are some other ideas:\n\n\n\n\ncomplex validation\n\n\nremoving dependent documents (removing a user removes all his blogposts)\n\n\nasynchronous defaults\n\n\nasynchronous tasks that a certain action triggers\n\n\n\n\n\u9519\u8bef\u5904\u7406\n\n\nIf any middleware calls \nnext\n or \ndone\n with a parameter of type \nError\n, the flow is interrupted, and the error is passed to the callback.\n\n\nschema.pre(\nsave\n, function(next) {\n  var err = new Error(\nsomething went wrong\n);\n  next(err);\n});\n\nmyDoc.save(function(err) {\n  console.log(err.message)\n});\n\n\n\n\n\n\u53d1\u5e03\u4e2d\u95f4\u4ef6\n\n\npost\n middleware are executed \nafter\n the hooked method and all of its \npre\n middleware have completed.\n\n\nschema.post(\ninit\n, function(doc) {\n  console.log(\n%s has been initialized from the db\n, doc._id);\n});\nschema.post(\nvalidate\n, function(doc) {\n  console.log(\n%s has been validated (but not saved yet)\n, doc._id);\n});\nschema.post(\nsave\n, function(doc) {\n  console.log(\n%s has been saved\n, doc._id);\n});\nschema.post(\nremove\n, function(doc) {\n  console.log(\n%s has been removed\n, doc._id);\n});\n\n\n\n\n\n\u5f02\u6b65\u53d1\u5e03\u94a9\n\n\nIf your post hook function takes at least 2 parameters, mongoose will assume the second parameter is a \nnext()\n function that you will call to trigger the next middleware in the sequence.\n\n\nschema.post(\nsave\n, function(doc, next) {\n  setTimeout(function() {\n    console.log(\npost1\n);\n\n    next();\n  }, 10);\n});\n\nschema.post(\nsave\n, function(doc, next) {\n  console.log(\npost2\n);\n  next();\n});\n\n\n\n\n\n\u4fdd\u5b58/\u9a8c\u8bc1\u94a9\u5b50\n\n\nThe \nsave()\n function triggers \nvalidate()\n hooks, because mongoose has a built-in \npre('save')\n hook that calls \nvalidate()\n. This means that all \npre('validate')\n and \npost('validate')\n hooks get called \nbefore\n any \npre('save')\n hooks.\n\n\nschema.pre(\nvalidate\n, function() {\n  console.log(\nthis gets printed first\n);\n});\nschema.post(\nvalidate\n, function() {\n  console.log(\nthis gets printed second\n);\n});\nschema.pre(\nsave\n, function() {\n  console.log(\nthis gets printed third\n);\n});\nschema.post(\nsave\n, function() {\n  console.log(\nthis gets printed fourth\n);\n});\n\n\n\n\n\nfindAndUpdate\uff08\uff09\u548c\u67e5\u8be2\u4e2d\u95f4\u4ef6\u7684\u6ce8\u91ca\n\n\nPre and post \nsave()\n hooks are \nnot\n executed on \nupdate()\n, \nfindOneAndUpdate()\n, etc. You can see a more detailed discussion why in \nthis GitHub issue\n. Mongoose 4.0 introduced distinct hooks for these functions.\n\n\nschema.pre(\nfind\n, function() {\n  console.log(this instanceof mongoose.Query);\n  this.start = Date.now();\n});\n\nschema.post(\nfind\n, function(result) {\n  console.log(this instanceof mongoose.Query);\n\n  console.log(\nfind() returned \n + JSON.stringify(result));\n\n  console.log(\nfind() took \n + (Date.now() - this.start) + \n millis\n);\n});\n\n\n\n\n\nQuery middleware differs from document middleware in a subtle but important way: in document middleware, \nthis\n refers to the document being updated. In query middleware, mongoose doesn't necessarily have a reference to the document being updated, so \nthis\n refers to the \nquery\n object rather than the document being updated.\n\n\nFor instance, if you wanted to add an \nupdatedAt\n timestamp to every \nupdate()\n call, you would use the following pre hook.\n\n\nschema\n.\npre\n(\nupdate\n,\n \nfunction\n()\n \n{\n\n  \nthis.update({\n}\n,\n{\n \n$\nset\n:\n \n{\n \nupdatedAt\n:\n \nnew\n \nDate\n()\n \n}\n \n}\n);\n\n\n}\n);\n\n\n\n\n\n\n\u9519\u8bef\u5904\u7406\u4e2d\u95f4\u4ef6\n\n\nNew in 4.5.0\n\n\nMiddleware execution normally stops the first time a piece of middleware calls \nnext()\n with an error. However, there is a special kind of post middleware called \"error handling middleware\" that executes specifically when an error occurs.\n\n\nError handling middleware is defined as middleware that takes one extra parameter: the 'error' that occurred as the first parameter to the function. Error handling middleware can then transform the error however you want.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n\n    \nunique\n:\n \ntrue\n\n  \n}\n\n\n}\n);\n\n\n\nschema\n.\npost\n(\nsave\n,\n \nfunction\n(\nerror\n,\n \ndoc\n,\n \nnext\n)\n \n{\n\n  \nif\n \n(error.name\n \n===\n \nMongoError\n \n \nerror.code\n \n===\n \n11000)\n \n{\n\n    \nnext(new\n \nError(\nThere\n \nwas\n \na\n \nduplicate\n \nkey\n \nerror\n))\n;\n\n  \n}\n \nelse\n \n{\n\n    \nnext(error)\n;\n\n  \n}\n\n\n}\n);\n\n\n\nPerson\n.\ncreate\n(\n[\n{\n \nname\n:\n \nAxl Rose\n \n},\n \n{\n \nname\n:\n \nAxl Rose\n \n}\n]\n);\n\n\n\n\n\n\nError handling middleware also works with query middleware. You can also define a post \nupdate()\n hook that will catch MongoDB duplicate key errors.\n\n\nschema\n.\npost\n(\nupdate\n,\n \nfunction\n(\nerror\n,\n \nres\n,\n \nnext\n)\n \n{\n\n  \nif\n \n(error.name\n \n===\n \nMongoError\n \n \nerror.code\n \n===\n \n11000)\n \n{\n\n    \nnext(new\n \nError(\nThere\n \nwas\n \na\n \nduplicate\n \nkey\n \nerror\n))\n;\n\n  \n}\n \nelse\n \n{\n\n    \nnext(error)\n;\n\n  \n}\n\n\n}\n);\n\n\n\nvar\n \npeople\n \n=\n \n[\n{\n \nname\n:\n \nAxl Rose\n \n},\n \n{\n \nname\n:\n \nSlash\n \n}\n]\n;\n\n\nPerson\n.\ncreate\n(\npeople\n,\n \nfunction\n(\nerror\n)\n \n{\n\n  \nPerson.update({\n \nname\n:\n \nSlash\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \nname\n:\n \nAxl Rose\n \n}\n \n}\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n  \n}\n);\n\n\n}\n);\n\n\n\n\n\n\n\u63a5\u4e0b\u6765\n\n\nNow that we've covered middleware, let's take a look at Mongoose's approach to faking JOINs with its query \npopulation\n helper.", 
            "title": "\u4e2d\u95f4\u4ef6"
        }, 
        {
            "location": "/guide/Middleware/#_1", 
            "text": "Source  Middleware (also called pre and post  hooks ) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing  plugins . Mongoose 4.x has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware. Document middleware is supported for the following document functions. In document middleware functions,  this  refers to the document.  Query middleware is supported for the following Model and Query functions. In query middleware functions,  this  refers to the query.  Aggregate middleware is for  MyModel.aggregate() . Aggregate middleware executes when you call  exec()  on an aggregate object. In aggregate middleware,  this  refers to the  aggregation object .  Model middleware is supported for the following model functions. In model middleware functions,  this  refers to the model.  All middleware types support pre and post hooks. How pre and post hooks work is described in more detail below.  Note:  There is no query hook for  remove() , only for documents. If you set a 'remove' hook, it will be fired when you call  myDoc.remove() , not when you call  MyModel.remove() .  Note:  The  create()  function fires  save()  hooks.", 
            "title": "\u4e2d\u95f4\u4ef6"
        }, 
        {
            "location": "/guide/Middleware/#pre", 
            "text": "There are two types of  pre  hooks, serial and parallel.", 
            "title": "Pre"
        }, 
        {
            "location": "/guide/Middleware/#_2", 
            "text": "Serial middleware functions are executed one after another, when each middleware calls  next .  var schema = new Schema(..);\nschema.pre( save , function(next) {\n\n  next();\n});  The  next()  call does  not  stop the rest of the code in your middleware function from executing. Use  the early  return  pattern  to prevent the rest of your middleware function from running when you call  next() .  var schema = new Schema(..);\nschema.pre( save , function(next) {\n  if (foo()) {\n    console.log( calling next! );\n\n     next();\n  }\n\n  console.log( after next );\n});", 
            "title": "\u4e32\u884c"
        }, 
        {
            "location": "/guide/Middleware/#_3", 
            "text": "Parallel middleware offer more fine-grained flow control.  var schema = new Schema(..);\n\nschema.pre( save , true, function(next, done) {\n\n  next();\n  setTimeout(done, 100);\n});  The hooked method, in this case  save , will not be executed until  done  is called by each middleware.", 
            "title": "\u5e73\u884c"
        }, 
        {
            "location": "/guide/Middleware/#_4", 
            "text": "Middleware are useful for atomizing model logic. Here are some other ideas:   complex validation  removing dependent documents (removing a user removes all his blogposts)  asynchronous defaults  asynchronous tasks that a certain action triggers", 
            "title": "\u7528\u4f8b"
        }, 
        {
            "location": "/guide/Middleware/#_5", 
            "text": "If any middleware calls  next  or  done  with a parameter of type  Error , the flow is interrupted, and the error is passed to the callback.  schema.pre( save , function(next) {\n  var err = new Error( something went wrong );\n  next(err);\n});\n\nmyDoc.save(function(err) {\n  console.log(err.message)\n});", 
            "title": "\u9519\u8bef\u5904\u7406"
        }, 
        {
            "location": "/guide/Middleware/#_6", 
            "text": "post  middleware are executed  after  the hooked method and all of its  pre  middleware have completed.  schema.post( init , function(doc) {\n  console.log( %s has been initialized from the db , doc._id);\n});\nschema.post( validate , function(doc) {\n  console.log( %s has been validated (but not saved yet) , doc._id);\n});\nschema.post( save , function(doc) {\n  console.log( %s has been saved , doc._id);\n});\nschema.post( remove , function(doc) {\n  console.log( %s has been removed , doc._id);\n});", 
            "title": "\u53d1\u5e03\u4e2d\u95f4\u4ef6"
        }, 
        {
            "location": "/guide/Middleware/#_7", 
            "text": "If your post hook function takes at least 2 parameters, mongoose will assume the second parameter is a  next()  function that you will call to trigger the next middleware in the sequence.  schema.post( save , function(doc, next) {\n  setTimeout(function() {\n    console.log( post1 );\n\n    next();\n  }, 10);\n});\n\nschema.post( save , function(doc, next) {\n  console.log( post2 );\n  next();\n});", 
            "title": "\u5f02\u6b65\u53d1\u5e03\u94a9"
        }, 
        {
            "location": "/guide/Middleware/#_8", 
            "text": "The  save()  function triggers  validate()  hooks, because mongoose has a built-in  pre('save')  hook that calls  validate() . This means that all  pre('validate')  and  post('validate')  hooks get called  before  any  pre('save')  hooks.  schema.pre( validate , function() {\n  console.log( this gets printed first );\n});\nschema.post( validate , function() {\n  console.log( this gets printed second );\n});\nschema.pre( save , function() {\n  console.log( this gets printed third );\n});\nschema.post( save , function() {\n  console.log( this gets printed fourth );\n});", 
            "title": "\u4fdd\u5b58/\u9a8c\u8bc1\u94a9\u5b50"
        }, 
        {
            "location": "/guide/Middleware/#findandupdate", 
            "text": "Pre and post  save()  hooks are  not  executed on  update() ,  findOneAndUpdate() , etc. You can see a more detailed discussion why in  this GitHub issue . Mongoose 4.0 introduced distinct hooks for these functions.  schema.pre( find , function() {\n  console.log(this instanceof mongoose.Query);\n  this.start = Date.now();\n});\n\nschema.post( find , function(result) {\n  console.log(this instanceof mongoose.Query);\n\n  console.log( find() returned   + JSON.stringify(result));\n\n  console.log( find() took   + (Date.now() - this.start) +   millis );\n});  Query middleware differs from document middleware in a subtle but important way: in document middleware,  this  refers to the document being updated. In query middleware, mongoose doesn't necessarily have a reference to the document being updated, so  this  refers to the  query  object rather than the document being updated.  For instance, if you wanted to add an  updatedAt  timestamp to every  update()  call, you would use the following pre hook.  schema . pre ( update ,   function ()   { \n   this.update({ } , {   $ set :   {   updatedAt :   new   Date ()   }   } );  } );", 
            "title": "findAndUpdate\uff08\uff09\u548c\u67e5\u8be2\u4e2d\u95f4\u4ef6\u7684\u6ce8\u91ca"
        }, 
        {
            "location": "/guide/Middleware/#_9", 
            "text": "New in 4.5.0  Middleware execution normally stops the first time a piece of middleware calls  next()  with an error. However, there is a special kind of post middleware called \"error handling middleware\" that executes specifically when an error occurs.  Error handling middleware is defined as middleware that takes one extra parameter: the 'error' that occurred as the first parameter to the function. Error handling middleware can then transform the error however you want.  var   schema   =   new   Schema ( { \n   name :   { \n     type :   String , \n\n     unique :   true \n   }  } );  schema . post ( save ,   function ( error ,   doc ,   next )   { \n   if   (error.name   ===   MongoError     error.code   ===   11000)   { \n     next(new   Error( There   was   a   duplicate   key   error )) ; \n   }   else   { \n     next(error) ; \n   }  } );  Person . create ( [ {   name :   Axl Rose   },   {   name :   Axl Rose   } ] );   Error handling middleware also works with query middleware. You can also define a post  update()  hook that will catch MongoDB duplicate key errors.  schema . post ( update ,   function ( error ,   res ,   next )   { \n   if   (error.name   ===   MongoError     error.code   ===   11000)   { \n     next(new   Error( There   was   a   duplicate   key   error )) ; \n   }   else   { \n     next(error) ; \n   }  } );  var   people   =   [ {   name :   Axl Rose   },   {   name :   Slash   } ] ;  Person . create ( people ,   function ( error )   { \n   Person.update({   name :   Slash   } ,   {   $ set :   {   name :   Axl Rose   }   } ,   function ( error )   { \n\n   } );  } );", 
            "title": "\u9519\u8bef\u5904\u7406\u4e2d\u95f4\u4ef6"
        }, 
        {
            "location": "/guide/Middleware/#_10", 
            "text": "Now that we've covered middleware, let's take a look at Mongoose's approach to faking JOINs with its query  population  helper.", 
            "title": "\u63a5\u4e0b\u6765"
        }, 
        {
            "location": "/guide/Populate/", 
            "text": "\u586b\u5145\n\n\n\u8d44\u6e90\n\n\nMongoDB has the join-like \n$lookup\n aggregation operator in versions \n= 3.2. Mongoose has a more powerful alternative called \npopulate()\n, which lets you reference documents in other collections.\n\n\nPopulation is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples.\n\n\nvar mongoose = require(\nmongoose\n);\nvar Schema = mongoose.Schema;\n\nvar personSchema = Schema({\n  _id: Schema.Types.ObjectId,\n  name: String,\n  age: Number,\n  stories: [{ type: Schema.Types.ObjectId, ref: \nStory\n }]\n});\n\nvar storySchema = Schema({\n  author: { type: Schema.Types.ObjectId, ref: \nPerson\n },\n  title: String,\n  fans: [{ type: Schema.Types.ObjectId, ref: \nPerson\n }]\n});\n\nvar Story = mongoose.model(\nStory\n, storySchema);\nvar Person = mongoose.model(\nPerson\n, personSchema);\n\n\n\n\n\nSo far we've created two \nModels\n. Our \nPerson\n model has its \nstories\n field set to an array of \nObjectId\ns. The \nref\n option is what tells Mongoose which model to use during population, in our case the \nStory\n model. All \n_id\ns we store here must be document \n_id\ns from the \nStory\n model.\n\n\nNote\n: \nObjectId\n, \nNumber\n, \nString\n, and \nBuffer\n are valid for use as refs. However, you should use \nObjectId\n unless you are an advanced user and have a good reason for doing so.\n\n\n\u4fdd\u5b58\u53c2\u8003\n\n\nSaving refs to other documents works the same way you normally save properties, just assign the \n_id\n value:\n\n\nvar author = new Person({\n  _id: new mongoose.Types.ObjectId(),\n  name: \nIan Fleming\n,\n  age: 50\n});\n\nauthor.save(function (err) {\n  if (err) return handleError(err);\n\n  var story1 = new Story({\n    title: \nCasino Royale\n,\n    author: author._id\n  });\n\n  story1.save(function (err) {\n    if (err) return handleError(err);\n\n  });\n});\n\n\n\n\n\nPopulation\n\n\nSo far we haven't done anything much different. We've merely created a \nPerson\n and a \nStory\n. Now let's take a look at populating our story's \nauthor\n using the query builder:\n\n\nStory.\n  findOne({ title: \nCasino Royale\n }).\n  populate(\nauthor\n).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n    console.log(\nThe author is %s\n, story.author.name);\n\n  });\n\n\n\n\n\nPopulated paths are no longer set to their original \n_id\n , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results.\n\n\nArrays of refs work the same way. Just call the \npopulate\n method on the query and an array of documents will be returned \nin place\n of the original \n_id\ns.\n\n\n\u8bbe\u7f6e\u586b\u5145\u7684\u5b57\u6bb5\n\n\nIn Mongoose \n= 4.0, you can manually populate a field as well.\n\n\nStory.findOne({ title: \nCasino Royale\n }, function(error, story) {\n  if (error) {\n    return handleError(error);\n  }\n  story.author = author;\n  console.log(story.author.name);\n});\n\n\n\n\n\n\u5b57\u6bb5\u9009\u62e9\n\n\nWhat if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual \nfield name syntax\n as the second argument to the populate method:\n\n\nStory.\n  findOne({ title: /casino royale/i }).\n  populate(\nauthor\n, \nname\n).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n\n    console.log(\nThe author is %s\n, story.author.name);\n\n    console.log(\nThe authors age is %s\n, story.author.age);\n\n  });\n\n\n\n\n\n\u586b\u5145\u591a\u4e2a\u8def\u5f84\n\n\nWhat if we wanted to populate multiple paths at the same time?\n\n\nStory.\n  find(...).\n  populate(\nfans\n).\n  populate(\nauthor\n).\n  exec();\n\n\n\n\n\nIf you call \npopulate()\n multiple times with the same path, only the last one will take effect.\n\n\nStory\n.\n\n  \nfind\n().\n\n  \npopulate\n(\n{\n \npath\n:\n \nfans\n,\n \nselect\n:\n \nname\n \n}\n).\n\n  \npopulate\n(\n{\n \npath\n:\n \nfans\n,\n \nselect\n:\n \nemail\n \n}\n);\n\n\n\nStory\n.\nfind\n()\n.\npopulate\n(\n{\n \npath\n:\n \nfans\n,\n \nselect\n:\n \nemail\n \n}\n);\n\n\n\n\n\n\n\u67e5\u8be2\u6761\u4ef6\u548c\u5176\u4ed6\u9009\u9879\n\n\nWhat if we wanted to populate our fans array based on their age, select just their names, and return at most, any 5 of them?\n\n\nStory.\n  find(...).\n  populate({\n    path: \nfans\n,\n    match: { age: { $gte: 21 }},\n\n    select: \nname -_id\n,\n    options: { limit: 5 }\n  }).\n  exec();\n\n\n\n\n\nRefs to children\n\n\nWe may find however, if we use the \nauthor\n object, we are unable to get a list of the stories. This is because no \nstory\n objects were ever 'pushed' onto \nauthor.stories\n.\n\n\nThere are two perspectives here. First, you may want the \nauthor\n know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can \npush()\n documents onto the array as shown below.\n\n\nauthor.stories.push(story1);\nauthor.save(callback);\n\n\n\n\n\nThis allows us to perform a \nfind\n and \npopulate\n combo:\n\n\nPerson.\n  findOne({ name: \nIan Fleming\n }).\n  populate(\nstories\n).\n  exec(function (err, person) {\n    if (err) return handleError(err);\n    console.log(person);\n  });\n\n\n\n\n\nIt is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly \nfind()\n the stories we are interested in.\n\n\nStory\n.\n\n  \nfind\n(\n{\n \nauthor\n:\n \nauthor\n.\n_id\n \n}\n).\n\n  \nexec\n(\nfunction\n \n(\nerr\n,\n \nstories\n)\n \n{\n\n    \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n    \nconsole.log(\nThe\n \nstories\n \nare\n \nan\n \narray\n:\n \n,\n \nstories\n);\n\n  \n}\n);\n\n\n\n\n\n\nThe documents returned from \nquery population\n become fully functional, \nremove\nable, \nsave\nable documents unless the \nlean\n option is specified. Do not confuse them with \nsub docs\n. Take caution when calling its remove method because you'll be removing it from the database, not just the array.\n\n\n\u586b\u5145\u73b0\u6709\u7684\u6587\u6863\n\n\nIf we have an existing mongoose document and want to populate some of its paths, \nmongoose \n= 3.6\n supports the \ndocument#populate()\n method.\n\n\n\u586b\u5145\u591a\u4e2a\u73b0\u6709\u7684\u6587\u4ef6\n\n\nIf we have one or many mongoose documents or even plain objects (\nlike \nmapReduce\n output\n), we may populate them using the \nModel.populate()\n method available in \nmongoose \n= 3.6\n. This is what \ndocument#populate()\n and \nquery#populate()\n use to populate documents.\n\n\n\u586b\u5145\u591a\u4e2a\u7ea7\u522b\n\n\nSay you have a user schema which keeps track of the user's friends.\n\n\nvar userSchema = new Schema({\n  name: String,\n  friends: [{ type: ObjectId, ref: \nUser\n }]\n});\n\n\n\n\n\nPopulate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the \npopulate\n option to tell mongoose to populate the \nfriends\n array of all the user's friends:\n\n\nUser.\n  findOne({ name: \nVal\n }).\n  populate({\n    path: \nfriends\n,\n\n    populate: { path: \nfriends\n }\n  });\n\n\n\n\n\n\u586b\u5145\u6570\u636e\u5e93\n\n\nLet's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread.\n\n\nvar eventSchema = new Schema({\n  name: String,\n\n  conversation: ObjectId\n});\nvar conversationSchema = new Schema({\n  numMessages: Number\n});\n\n\n\n\n\nAlso, suppose that events and conversations are stored in separate MongoDB instances.\n\n\nvar\n \ndb1\n \n=\n \nmongoose\n.\ncreateConnection\n(\nlocalhost:27000/db1\n);\n\n\nvar\n \ndb2\n \n=\n \nmongoose\n.\ncreateConnection\n(\nlocalhost:27001/db2\n);\n\n\n\nvar\n \nEvent\n \n=\n \ndb1\n.\nmodel\n(\nEvent\n,\n \neventSchema\n);\n\n\nvar\n \nConversation\n \n=\n \ndb2\n.\nmodel\n(\nConversation\n,\n \nconversationSchema\n);\n\n\n\n\n\n\nIn this situation, you will \nnot\n be able to \npopulate()\n normally. The \nconversation\n field will always be null, because \npopulate()\n doesn't know which model to use. However, \nyou can specify the model explicitly\n.\n\n\nEvent.\n  find().\n  populate({ path: \nconversation\n, model: Conversation }).\n  exec(function(error, docs) {  });\n\n\n\n\n\nThis is known as a \"cross-database populate,\" because it enables you to populate across MongoDB databases and even across MongoDB instances.\n\n\n\u52a8\u6001\u53c2\u8003\n\n\nMongoose can also populate from multiple collections at the same time. Let's say you have a user schema that has an array of \"connections\" - a user can be connected to either other users or an organization.\n\n\nvar\n \nuserSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \nString\n,\n\n  \nconnections\n:\n \n[\n{\n\n    \nkind\n:\n \nString\n,\n\n    \nitem\n:\n \n{\n \ntype\n:\n \nObjectId\n,\n \nrefPath\n:\n \nconnections.kind\n \n}\n\n  \n}\n]\n\n\n}\n);\n\n\n\nvar\n \norganizationSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \nkind\n:\n \nString\n \n}\n);\n\n\n\nvar\n \nUser\n \n=\n \nmongoose\n.\nmodel\n(\nUser\n,\n \nuserSchema\n);\n\n\nvar\n \nOrganization\n \n=\n \nmongoose\n.\nmodel\n(\nOrganization\n,\n \norganizationSchema\n);\n\n\n\n\n\n\nThe \nrefPath\n property above means that mongoose will look at the \nconnections.kind\n path to determine which model to use for \npopulate()\n. In other words, the \nrefPath\n property enables you to make the \nref\n property dynamic.\n\n\nUser.\n  findOne({ name: \nAxl Rose\n }).\n  populate(\nconnections.item\n).\n  exec(function(error, doc) {\n\n  });\n\n\n\n\n\n\u586b\u5145\u865a\u62df\u673a\n\n\nNew in 4.5.0\n\n\nSo far you've only populated based on the \n_id\n field. However, that's sometimes not the right choice. In particular, \narrays that grow without bound are a MongoDB anti-pattern\n. Using mongoose virtuals, you can define more sophisticated relationships between documents.\n\n\nvar PersonSchema = new Schema({\n  name: String,\n  band: String\n});\n\nvar BandSchema = new Schema({\n  name: String\n});\nBandSchema.virtual(\nmembers\n, {\n  ref: \nPerson\n,\n  localField: \nname\n,\n  foreignField: \nband\n,\n\n  justOne: false\n});\n\nvar Person = mongoose.model(\nPerson\n, PersonSchema);\nvar Band = mongoose.model(\nBand\n, BandSchema);\n\nBand.find({}).populate(\nmembers\n).exec(function(error, bands) {\n\n});\n\n\n\n\n\nKeep in mind that virtuals are \nnot\n included in \ntoJSON()\n output by\n\n\ndefault. If you want populate virtuals to show up when using functions that rely on \nJSON.stringify()\n, like Express' \nres.json()\n function\n, set the \nvirtuals: true\n option on your schema's \ntoJSON\n options.\n\n\nvar\n \nBandSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \nString\n\n\n}\n,\n \n{\n \ntoJSON\n:\n \n{\n \nvirtuals\n:\n \ntrue\n \n}\n \n}\n);\n\n\n\n\n\n\nIf you're using populate projections, make sure \nforeignField\n is included in the projection.\n\n\nBand.\n  find({}).\n  populate({ path: \nmembers\n, select: \nname\n }).\n  exec(function(error, bands) {\n\n  });\n\nBand.\n  find({}).\n  populate({ path: \nmembers\n, select: \nname band\n }).\n  exec(function(error, bands) {\n\n  });\n\n\n\n\n\n\u63a5\u4e0b\u6765\n\n\n\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\npopulate\uff08\uff09\n\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\n\u9274\u522b\u5668\n\u3002", 
            "title": "\u586b\u5145"
        }, 
        {
            "location": "/guide/Populate/#_1", 
            "text": "\u8d44\u6e90  MongoDB has the join-like  $lookup  aggregation operator in versions  = 3.2. Mongoose has a more powerful alternative called  populate() , which lets you reference documents in other collections.  Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples.  var mongoose = require( mongoose );\nvar Schema = mongoose.Schema;\n\nvar personSchema = Schema({\n  _id: Schema.Types.ObjectId,\n  name: String,\n  age: Number,\n  stories: [{ type: Schema.Types.ObjectId, ref:  Story  }]\n});\n\nvar storySchema = Schema({\n  author: { type: Schema.Types.ObjectId, ref:  Person  },\n  title: String,\n  fans: [{ type: Schema.Types.ObjectId, ref:  Person  }]\n});\n\nvar Story = mongoose.model( Story , storySchema);\nvar Person = mongoose.model( Person , personSchema);  So far we've created two  Models . Our  Person  model has its  stories  field set to an array of  ObjectId s. The  ref  option is what tells Mongoose which model to use during population, in our case the  Story  model. All  _id s we store here must be document  _id s from the  Story  model.  Note :  ObjectId ,  Number ,  String , and  Buffer  are valid for use as refs. However, you should use  ObjectId  unless you are an advanced user and have a good reason for doing so.", 
            "title": "\u586b\u5145"
        }, 
        {
            "location": "/guide/Populate/#_2", 
            "text": "Saving refs to other documents works the same way you normally save properties, just assign the  _id  value:  var author = new Person({\n  _id: new mongoose.Types.ObjectId(),\n  name:  Ian Fleming ,\n  age: 50\n});\n\nauthor.save(function (err) {\n  if (err) return handleError(err);\n\n  var story1 = new Story({\n    title:  Casino Royale ,\n    author: author._id\n  });\n\n  story1.save(function (err) {\n    if (err) return handleError(err);\n\n  });\n});", 
            "title": "\u4fdd\u5b58\u53c2\u8003"
        }, 
        {
            "location": "/guide/Populate/#population", 
            "text": "So far we haven't done anything much different. We've merely created a  Person  and a  Story . Now let's take a look at populating our story's  author  using the query builder:  Story.\n  findOne({ title:  Casino Royale  }).\n  populate( author ).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n    console.log( The author is %s , story.author.name);\n\n  });  Populated paths are no longer set to their original  _id  , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results.  Arrays of refs work the same way. Just call the  populate  method on the query and an array of documents will be returned  in place  of the original  _id s.", 
            "title": "Population"
        }, 
        {
            "location": "/guide/Populate/#_3", 
            "text": "In Mongoose  = 4.0, you can manually populate a field as well.  Story.findOne({ title:  Casino Royale  }, function(error, story) {\n  if (error) {\n    return handleError(error);\n  }\n  story.author = author;\n  console.log(story.author.name);\n});", 
            "title": "\u8bbe\u7f6e\u586b\u5145\u7684\u5b57\u6bb5"
        }, 
        {
            "location": "/guide/Populate/#_4", 
            "text": "What if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual  field name syntax  as the second argument to the populate method:  Story.\n  findOne({ title: /casino royale/i }).\n  populate( author ,  name ).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n\n    console.log( The author is %s , story.author.name);\n\n    console.log( The authors age is %s , story.author.age);\n\n  });", 
            "title": "\u5b57\u6bb5\u9009\u62e9"
        }, 
        {
            "location": "/guide/Populate/#_5", 
            "text": "What if we wanted to populate multiple paths at the same time?  Story.\n  find(...).\n  populate( fans ).\n  populate( author ).\n  exec();  If you call  populate()  multiple times with the same path, only the last one will take effect.  Story . \n   find (). \n   populate ( {   path :   fans ,   select :   name   } ). \n   populate ( {   path :   fans ,   select :   email   } );  Story . find () . populate ( {   path :   fans ,   select :   email   } );", 
            "title": "\u586b\u5145\u591a\u4e2a\u8def\u5f84"
        }, 
        {
            "location": "/guide/Populate/#_6", 
            "text": "What if we wanted to populate our fans array based on their age, select just their names, and return at most, any 5 of them?  Story.\n  find(...).\n  populate({\n    path:  fans ,\n    match: { age: { $gte: 21 }},\n\n    select:  name -_id ,\n    options: { limit: 5 }\n  }).\n  exec();", 
            "title": "\u67e5\u8be2\u6761\u4ef6\u548c\u5176\u4ed6\u9009\u9879"
        }, 
        {
            "location": "/guide/Populate/#refs-to-children", 
            "text": "We may find however, if we use the  author  object, we are unable to get a list of the stories. This is because no  story  objects were ever 'pushed' onto  author.stories .  There are two perspectives here. First, you may want the  author  know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can  push()  documents onto the array as shown below.  author.stories.push(story1);\nauthor.save(callback);  This allows us to perform a  find  and  populate  combo:  Person.\n  findOne({ name:  Ian Fleming  }).\n  populate( stories ).\n  exec(function (err, person) {\n    if (err) return handleError(err);\n    console.log(person);\n  });  It is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly  find()  the stories we are interested in.  Story . \n   find ( {   author :   author . _id   } ). \n   exec ( function   ( err ,   stories )   { \n     if   (err)   return   handleError(err) ; \n     console.log( The   stories   are   an   array :   ,   stories ); \n   } );   The documents returned from  query population  become fully functional,  remove able,  save able documents unless the  lean  option is specified. Do not confuse them with  sub docs . Take caution when calling its remove method because you'll be removing it from the database, not just the array.", 
            "title": "Refs to children"
        }, 
        {
            "location": "/guide/Populate/#_7", 
            "text": "If we have an existing mongoose document and want to populate some of its paths,  mongoose  = 3.6  supports the  document#populate()  method.", 
            "title": "\u586b\u5145\u73b0\u6709\u7684\u6587\u6863"
        }, 
        {
            "location": "/guide/Populate/#_8", 
            "text": "If we have one or many mongoose documents or even plain objects ( like  mapReduce  output ), we may populate them using the  Model.populate()  method available in  mongoose  = 3.6 . This is what  document#populate()  and  query#populate()  use to populate documents.", 
            "title": "\u586b\u5145\u591a\u4e2a\u73b0\u6709\u7684\u6587\u4ef6"
        }, 
        {
            "location": "/guide/Populate/#_9", 
            "text": "Say you have a user schema which keeps track of the user's friends.  var userSchema = new Schema({\n  name: String,\n  friends: [{ type: ObjectId, ref:  User  }]\n});  Populate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the  populate  option to tell mongoose to populate the  friends  array of all the user's friends:  User.\n  findOne({ name:  Val  }).\n  populate({\n    path:  friends ,\n\n    populate: { path:  friends  }\n  });", 
            "title": "\u586b\u5145\u591a\u4e2a\u7ea7\u522b"
        }, 
        {
            "location": "/guide/Populate/#_10", 
            "text": "Let's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread.  var eventSchema = new Schema({\n  name: String,\n\n  conversation: ObjectId\n});\nvar conversationSchema = new Schema({\n  numMessages: Number\n});  Also, suppose that events and conversations are stored in separate MongoDB instances.  var   db1   =   mongoose . createConnection ( localhost:27000/db1 );  var   db2   =   mongoose . createConnection ( localhost:27001/db2 );  var   Event   =   db1 . model ( Event ,   eventSchema );  var   Conversation   =   db2 . model ( Conversation ,   conversationSchema );   In this situation, you will  not  be able to  populate()  normally. The  conversation  field will always be null, because  populate()  doesn't know which model to use. However,  you can specify the model explicitly .  Event.\n  find().\n  populate({ path:  conversation , model: Conversation }).\n  exec(function(error, docs) {  });  This is known as a \"cross-database populate,\" because it enables you to populate across MongoDB databases and even across MongoDB instances.", 
            "title": "\u586b\u5145\u6570\u636e\u5e93"
        }, 
        {
            "location": "/guide/Populate/#_11", 
            "text": "Mongoose can also populate from multiple collections at the same time. Let's say you have a user schema that has an array of \"connections\" - a user can be connected to either other users or an organization.  var   userSchema   =   new   Schema ( { \n   name :   String , \n   connections :   [ { \n     kind :   String , \n     item :   {   type :   ObjectId ,   refPath :   connections.kind   } \n   } ]  } );  var   organizationSchema   =   new   Schema ( {   name :   String ,   kind :   String   } );  var   User   =   mongoose . model ( User ,   userSchema );  var   Organization   =   mongoose . model ( Organization ,   organizationSchema );   The  refPath  property above means that mongoose will look at the  connections.kind  path to determine which model to use for  populate() . In other words, the  refPath  property enables you to make the  ref  property dynamic.  User.\n  findOne({ name:  Axl Rose  }).\n  populate( connections.item ).\n  exec(function(error, doc) {\n\n  });", 
            "title": "\u52a8\u6001\u53c2\u8003"
        }, 
        {
            "location": "/guide/Populate/#_12", 
            "text": "New in 4.5.0  So far you've only populated based on the  _id  field. However, that's sometimes not the right choice. In particular,  arrays that grow without bound are a MongoDB anti-pattern . Using mongoose virtuals, you can define more sophisticated relationships between documents.  var PersonSchema = new Schema({\n  name: String,\n  band: String\n});\n\nvar BandSchema = new Schema({\n  name: String\n});\nBandSchema.virtual( members , {\n  ref:  Person ,\n  localField:  name ,\n  foreignField:  band ,\n\n  justOne: false\n});\n\nvar Person = mongoose.model( Person , PersonSchema);\nvar Band = mongoose.model( Band , BandSchema);\n\nBand.find({}).populate( members ).exec(function(error, bands) {\n\n});  Keep in mind that virtuals are  not  included in  toJSON()  output by  default. If you want populate virtuals to show up when using functions that rely on  JSON.stringify() , like Express'  res.json()  function , set the  virtuals: true  option on your schema's  toJSON  options.  var   BandSchema   =   new   Schema ( { \n   name :   String  } ,   {   toJSON :   {   virtuals :   true   }   } );   If you're using populate projections, make sure  foreignField  is included in the projection.  Band.\n  find({}).\n  populate({ path:  members , select:  name  }).\n  exec(function(error, bands) {\n\n  });\n\nBand.\n  find({}).\n  populate({ path:  members , select:  name band  }).\n  exec(function(error, bands) {\n\n  });", 
            "title": "\u586b\u5145\u865a\u62df\u673a"
        }, 
        {
            "location": "/guide/Populate/#_13", 
            "text": "\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 populate\uff08\uff09 \uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b \u9274\u522b\u5668 \u3002", 
            "title": "\u63a5\u4e0b\u6765"
        }, 
        {
            "location": "/guide/Discriminators/", 
            "text": "\u9274\u522b\u5668\n\n\n\u8d44\u6e90\n\n\n\u9274\u522b\u5668\u662f\u4e00\u4e2a\u6a21\u5f0f\u7ee7\u627f\u673a\u5236\u3002 \u5b83\u4eec\u4f7f\u60a8\u80fd\u591f\u5728\u76f8\u540c\u7684\u57fa\u7840MongoDB\u96c6\u5408\u4e4b\u4e0a\u62e5\u6709\u591a\u4e2a\u5177\u6709\u91cd\u53e0\u6a21\u5f0f\u7684\u6a21\u578b\u3002\n\n\n\u5047\u8bbe\u60a8\u60f3\u8981\u5728\u5355\u4e2a\u96c6\u5408\u4e2d\u8ddf\u8e2a\u4e0d\u540c\u7c7b\u578b\u7684\u4e8b\u4ef6\u3002 \u6bcf\u4e2a\u4e8b\u4ef6\u90fd\u4f1a\u6709\u4e00\u4e2a\u65f6\u95f4\u6233\uff0c\u4f46\u4ee3\u8868\u70b9\u51fb\u94fe\u63a5\u200b\u200b\u7684\u4e8b\u4ef6\u5e94\u8be5\u6709\u4e00\u4e2aURL\u3002 \u4f60\u53ef\u4ee5\u4f7f\u7528\nmodel.discriminator\uff08\uff09\n\u51fd\u6570\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u3002 \u8be5\u529f\u80fd\u9700\u89812\u4e2a\u53c2\u6570\uff0c \u4e00\u4e2a\u6a21\u578b\u540d\u79f0\u548c\u4e00\u4e2a\u9274\u522b\u5668\u6a21\u5f0f \u5b83\u8fd4\u56de\u4e00\u4e2a\u6a21\u5f0f\uff0c\u5176\u6a21\u5f0f\u662f\u57fa\u672c\u6a21\u5f0f\u548c\u9274\u522b\u5668\u6a21\u5f0f\u7684\u8054\u5408\u3002\n\n\n  \nvar\n \noptions\n \n=\n \n{\ndiscriminatorKey\n:\n \nkind\n};\n\n  \nvar\n \neventSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\ntime\n:\n \nDate\n},\n \noptions\n);\n\n  \nvar\n \nEvent\n \n=\n \nmongoose\n.\nmodel\n(\nEvent\n,\n \neventSchema\n);\n\n  \nvar\n \nClickedLinkEvent\n \n=\n \nEvent\n.\ndiscriminator\n(\nClickedLink\n,\n \nnew\n \nmongoose\n.\nSchema\n({\nurl\n:\n \nString\n},\n \noptions\n));\n\n  \nvar\n \ngenericEvent\n \n=\n \nnew\n \nEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n});\n\n  \nassert\n.\nok\n(\n!\ngenericEvent\n.\nurl\n);\n\n  \nvar\n \nclickedEvent\n \n=\n \nnew\n \nClickedLinkEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n});\n\n  \nassert\n.\nok\n(\nclickedEvent\n.\nurl\n);\n\n\n\n\n\n\u5047\u8bbe\u60a8\u521b\u5efa\u4e86\u53e6\u4e00\u4e2a\u9274\u522b\u5668\u6765\u8ddf\u8e2a\u65b0\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002\u8fd9\u4e9b\nSignedUpEvent\n\u5b9e\u4f8b\u5c06\u88ab\u5b58\u50a8\u5728\u4e0e\u901a\u7528\u4e8b\u4ef6\u548c\nClickedLinkEvent\n\u5b9e\u4f8b\u76f8\u540c\u7684\u96c6\u5408\u4e2d\u3002\n\n\n  \nvar\n \nevent1\n \n=\n \nnew\n \nEvent\n({\ntime\n:\n \nDate\n.\nnow\n()});\n\n  \nvar\n \nevent2\n \n=\n \nnew\n \nClickedLinkEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n});\n\n  \nvar\n \nevent3\n \n=\n \nnew\n \nSignedUpEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nuser\n:\n \ntestuser\n});\n\n\n  \nvar\n \nsave\n \n=\n \nfunction\n \n(\ndoc\n,\n \ncallback\n)\n \n{\n\n    \ndoc\n.\nsave\n(\nfunction\n \n(\nerror\n,\n \ndoc\n)\n \n{\n\n      \ncallback\n(\nerror\n,\n \ndoc\n);\n\n    \n});\n\n  \n};\n\n\n  \nasync\n.\nmap\n([\nevent1\n,\n \nevent2\n,\n \nevent3\n],\n \nsave\n,\n \nfunction\n \n(\nerror\n)\n \n{\n\n\n    \nEvent\n.\ncount\n({},\n \nfunction\n \n(\nerror\n,\n \ncount\n)\n \n{\n\n      \nassert\n.\nequal\n(\ncount\n,\n \n3\n);\n\n    \n});\n\n  \n});\n\n\n\n\n\n\u732b\u9f2c\u7684\u65b9\u5f0f\u544a\u8bc9\u4e0d\u540c\u7684\u9274\u522b\u5668\u6a21\u578b\u4e4b\u95f4\u7684\u5dee\u5f02\u662f\u7531\u201c\u9274\u522b\u94a5\u5319\u201d, \u9ed8\u8ba4\u662f\n__t\n\u3002 ,Mongoose\u5c06\u4e00\u4e2a\u540d\u4e3a\n__t\n\u7684String\u8def\u5f84\u6dfb\u52a0\u5230\u60a8\u7684\u6a21\u5f0f\u4e2d\uff0c\u7528\u4e8e\u8ddf\u8e2a\u8be5\u6587\u6863\u662f\u54ea\u4e2a\u9274\u522b\u5668\u7684\u5b9e\u4f8b\u3002\n\n\n  \nvar\n \nevent1\n \n=\n \nnew\n \nEvent\n({\ntime\n:\n \nDate\n.\nnow\n()});\n\n  \nvar\n \nevent2\n \n=\n \nnew\n \nClickedLinkEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n});\n\n  \nvar\n \nevent3\n \n=\n \nnew\n \nSignedUpEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nuser\n:\n \ntestuser\n});\n\n\n  \nassert\n.\nok\n(\n!\nevent1\n.\n__t\n);\n\n  \nassert\n.\nequal\n(\nevent2\n.\n__t\n,\n \nClickedLink\n);\n\n  \nassert\n.\nequal\n(\nevent3\n.\n__t\n,\n \nSignedUp\n);\n\n\n\n\n\n\u8fa8\u522b\u5668\u6a21\u578b\u662f\u7279\u6b8a\u7684;\u4ed6\u4eec\u5c06\u9274\u522b\u952e\u9644\u52a0\u5230\u67e5\u8be2\u3002 \u6362\u4e00\u79cd\u8bf4\u6cd5\uff0c \nfind()\n, \ncount()\n, \naggregate()\n, \u7b49\u7b49\u90fd\u8db3\u591f\u806a\u660e\u6765\u89e3\u91ca\u9274\u522b\u8005\u3002\n\n\n  \nvar\n \nevent1\n \n=\n \nnew\n \nEvent\n({\ntime\n:\n \nDate\n.\nnow\n()});\n\n  \nvar\n \nevent2\n \n=\n \nnew\n \nClickedLinkEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n});\n\n  \nvar\n \nevent3\n \n=\n \nnew\n \nSignedUpEvent\n({\ntime\n:\n \nDate\n.\nnow\n(),\n \nuser\n:\n \ntestuser\n});\n\n\n  \nvar\n \nsave\n \n=\n \nfunction\n \n(\ndoc\n,\n \ncallback\n)\n \n{\n\n    \ndoc\n.\nsave\n(\nfunction\n \n(\nerror\n,\n \ndoc\n)\n \n{\n\n      \ncallback\n(\nerror\n,\n \ndoc\n);\n\n    \n});\n\n  \n};\n\n\n  \nasync\n.\nmap\n([\nevent1\n,\n \nevent2\n,\n \nevent3\n],\n \nsave\n,\n \nfunction\n \n(\nerror\n)\n \n{\n\n\n    \nClickedLinkEvent\n.\nfind\n({},\n \nfunction\n \n(\nerror\n,\n \ndocs\n)\n \n{\n\n      \nassert\n.\nequal\n(\ndocs\n.\nlength\n,\n \n1\n);\n\n      \nassert\n.\nequal\n(\ndocs\n[\n0\n].\n_id\n.\ntoString\n(),\n \nevent2\n.\n_id\n.\ntoString\n());\n\n      \nassert\n.\nequal\n(\ndocs\n[\n0\n].\nurl\n,\n \ngoogle.com\n);\n\n    \n});\n\n  \n});\n\n\n\n\n\n\u9274\u522b\u8005\u4e5f\u91c7\u53d6\u4ed6\u4eec\u7684\u57fa\u672c\u6a21\u5f0f\u7684\u524d\u540e\u4e2d\u95f4\u4ef6\u3002 \u4f46\u662f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u5c06\u4e2d\u95f4\u4ef6\u9644\u52a0\u5230\u9274\u522b\u5668\u6a21\u5f0f\uff0c\u800c\u4e0d\u4f1a\u5f71\u54cd\u57fa\u672c\u6a21\u5f0f\u3002\n\n\n  \nvar\n \noptions\n \n=\n \n{\ndiscriminatorKey\n:\n \nkind\n};\n\n\n  \nvar\n \neventSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\ntime\n:\n \nDate\n},\n \noptions\n);\n\n  \nvar\n \neventSchemaCalls\n \n=\n \n0\n;\n\n  \neventSchema\n.\npre\n(\nvalidate\n,\n \nfunction\n \n(\nnext\n)\n \n{\n\n    \n++\neventSchemaCalls\n;\n\n    \nnext\n();\n\n  \n});\n\n  \nvar\n \nEvent\n \n=\n \nmongoose\n.\nmodel\n(\nGenericEvent\n,\n \neventSchema\n);\n\n\n  \nvar\n \nclickedLinkSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\nurl\n:\n \nString\n},\n \noptions\n);\n\n  \nvar\n \nclickedSchemaCalls\n \n=\n \n0\n;\n\n  \nclickedLinkSchema\n.\npre\n(\nvalidate\n,\n \nfunction\n \n(\nnext\n)\n \n{\n\n    \n++\nclickedSchemaCalls\n;\n\n    \nnext\n();\n\n  \n});\n\n  \nvar\n \nClickedLinkEvent\n \n=\n \nEvent\n.\ndiscriminator\n(\nClickedLinkEvent\n,\n\n    \nclickedLinkSchema\n);\n\n\n  \nvar\n \nevent1\n \n=\n \nnew\n \nClickedLinkEvent\n();\n\n  \nevent1\n.\nvalidate\n(\nfunction\n()\n \n{\n\n    \nassert\n.\nequal\n(\neventSchemaCalls\n,\n \n1\n);\n\n    \nassert\n.\nequal\n(\nclickedSchemaCalls\n,\n \n1\n);\n\n\n    \nvar\n \ngeneric\n \n=\n \nnew\n \nEvent\n();\n\n    \ngeneric\n.\nvalidate\n(\nfunction\n()\n \n{\n\n      \nassert\n.\nequal\n(\neventSchemaCalls\n,\n \n2\n);\n\n      \nassert\n.\nequal\n(\nclickedSchemaCalls\n,\n \n1\n);\n\n    \n});\n\n  \n});\n\n\n\n\n\n\u9274\u522b\u5668\u7684\u5b57\u6bb5\u662f\u57fa\u672c\u6a21\u5f0f\u5b57\u6bb5\u548c\u9274\u522b\u5668\u6a21\u5f0f\u5b57\u6bb5\u7684\u8054\u5408\uff0c \u5e76\u4e14\u9274\u522b\u5668\u6a21\u5f0f\u7684\u5b57\u6bb5\u4f18\u5148\u3002,\u6709\u4e00\u4e2a\u4f8b\u5916\uff1a\u9ed8\u8ba4\u7684\n_id\n\u5b57\u6bb5\u3002\n\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u9274\u522b\u5668\u6a21\u5f0f\u4e2d\u5c06_id\u9009\u9879\u8bbe\u7f6e\u4e3afalse\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5982\u4e0b\u6240\u793a\u3002\n\n\n  \nvar\n \noptions\n \n=\n \n{\ndiscriminatorKey\n:\n \nkind\n};\n\n\n  \nvar\n \neventSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\n_id\n:\n \nString\n,\n \ntime\n:\n \nDate\n},\n\n    \noptions\n);\n\n  \nvar\n \nEvent\n \n=\n \nmongoose\n.\nmodel\n(\nBaseEvent\n,\n \neventSchema\n);\n\n\n  \nvar\n \nclickedLinkSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\n\n    \nurl\n:\n \nString\n,\n\n    \ntime\n:\n \nString\n\n  \n},\n \noptions\n);\n\n\n  \nassert\n.\nok\n(\nclickedLinkSchema\n.\npath\n(\n_id\n));\n\n  \nassert\n.\nequal\n(\nclickedLinkSchema\n.\npath\n(\n_id\n).\ninstance\n,\n \nObjectID\n);\n\n  \nvar\n \nClickedLinkEvent\n \n=\n \nEvent\n.\ndiscriminator\n(\nChildEventBad\n,\n\n    \nclickedLinkSchema\n);\n\n\n  \nvar\n \nevent1\n \n=\n \nnew\n \nClickedLinkEvent\n({\n \n_id\n:\n \ncustom id\n,\n \ntime\n:\n \n4pm\n \n});\n\n\n  \nassert\n.\nok\n(\ntypeof\n \nevent1\n.\n_id\n \n===\n \nstring\n);\n\n  \nassert\n.\nok\n(\ntypeof\n \nevent1\n.\ntime\n \n===\n \nstring\n);\n\n\n\n\n\n\u5f53\u4f60\u4f7f\u7528\nModel.create\uff08\uff09\n\u65f6\uff0c\u732b\u9f2c\u4f1a\u4ece\u4f60\u7684\u9274\u522b\u5668\u952e\u4e2d\u53d6\u51fa\u6b63\u786e\u7684\u7c7b\u578b\u3002\n\n\n  \nvar\n \nSchema\n \n=\n \nmongoose\n.\nSchema\n;\n\n  \nvar\n \nshapeSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nname\n:\n \nString\n\n  \n},\n \n{\n \ndiscriminatorKey\n:\n \nkind\n \n});\n\n\n  \nvar\n \nShape\n \n=\n \ndb\n.\nmodel\n(\nShape\n,\n \nshapeSchema\n);\n\n\n  \nvar\n \nCircle\n \n=\n \nShape\n.\ndiscriminator\n(\nCircle\n,\n\n    \nnew\n \nSchema\n({\n \nradius\n:\n \nNumber\n \n}));\n\n  \nvar\n \nSquare\n \n=\n \nShape\n.\ndiscriminator\n(\nSquare\n,\n\n    \nnew\n \nSchema\n({\n \nside\n:\n \nNumber\n \n}));\n\n\n  \nvar\n \nshapes\n \n=\n \n[\n\n    \n{\n \nname\n:\n \nTest\n \n},\n\n    \n{\n \nkind\n:\n \nCircle\n,\n \nradius\n:\n \n5\n \n},\n\n    \n{\n \nkind\n:\n \nSquare\n,\n \nside\n:\n \n10\n \n}\n\n  \n];\n\n  \nShape\n.\ncreate\n(\nshapes\n,\n \nfunction\n(\nerror\n,\n \nshapes\n)\n \n{\n\n    \nassert\n.\nifError\n(\nerror\n);\n\n    \nassert\n.\nok\n(\nshapes\n[\n0\n]\n \ninstanceof\n \nShape\n);\n\n    \nassert\n.\nok\n(\nshapes\n[\n1\n]\n \ninstanceof\n \nCircle\n);\n\n    \nassert\n.\nequal\n(\nshapes\n[\n1\n].\nradius\n,\n \n5\n);\n\n    \nassert\n.\nok\n(\nshapes\n[\n2\n]\n \ninstanceof\n \nSquare\n);\n\n    \nassert\n.\nequal\n(\nshapes\n[\n2\n].\nside\n,\n \n10\n);\n\n  \n});\n\n\n\n\n\n\u60a8\u4e5f\u53ef\u4ee5\u5728\u5d4c\u5165\u5f0f\u6587\u6863\u6570\u7ec4\u4e0a\u5b9a\u4e49\u9274\u522b\u5668\u3002 \u5d4c\u5165\u5f0f\u9274\u522b\u5668\u662f\u4e0d\u540c\u7684\uff0c\u56e0\u4e3a\u4e0d\u540c\u7684\u9274\u522b\u5668\u7c7b\u578b\u5b58\u50a8\u5728\u76f8\u540c\u7684\u6587\u6863\u6570\u7ec4\uff08\u5728\u6587\u6863\u4e2d\uff09\u800c\u4e0d\u662f\u76f8\u540c\u7684\u96c6\u5408\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5d4c\u5165\u5f0f\u9274\u522b\u5668\u53ef\u8ba9\u60a8\u5c06\u4e0e\u4e0d\u540c\u6a21\u5f0f\u5339\u914d\u7684\u5b50\u6587\u6863\u5b58\u50a8\u5728\u540c\u4e00\u4e2a\u6570\u7ec4\u4e2d\u3002\n\n\n\u4f5c\u4e3a\u4e00\u4e2a\u901a\u7528\u7684\u6700\u4f73\u5b9e\u8df5\uff0c\u786e\u4fdd\u4f60\u5728\u4f7f\u7528\u5b83\u4eec\u4e4b\u524d\uff0c\u5728\u6a21\u5f0f**\u4e0a\u58f0\u660e\u4efb\u4f55\u94a9\u5b50\u3002 \u5728\u8c03\u7528discriminator\uff08\uff09\u4e4b\u540e\uff0c\u4f60\u4e0d\u5e94\u8be5\u8c03\u7528\npre\uff08\uff09\n\u6216\npost\uff08\uff09\n\n\n  \nvar\n \neventSchema\n \n=\n \nnew\n \nSchema\n({\n \nmessage\n:\n \nString\n \n},\n\n    \n{\n \ndiscriminatorKey\n:\n \nkind\n,\n \n_id\n:\n \nfalse\n \n});\n\n\n  \nvar\n \nbatchSchema\n \n=\n \nnew\n \nSchema\n({\n \nevents\n:\n \n[\neventSchema\n]\n \n});\n\n\n  \nvar\n \ndocArray\n \n=\n \nbatchSchema\n.\npath\n(\nevents\n);\n\n\n  \nvar\n \nclickedSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nelement\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n      \nrequired\n:\n \ntrue\n\n    \n}\n\n  \n},\n \n{\n \n_id\n:\n \nfalse\n \n});\n\n\n  \nvar\n \nClicked\n \n=\n \ndocArray\n.\ndiscriminator\n(\nClicked\n,\n \nclickedSchema\n);\n\n\n  \nvar\n \nPurchased\n \n=\n \ndocArray\n.\ndiscriminator\n(\nPurchased\n,\n \nnew\n \nSchema\n({\n\n    \nproduct\n:\n \n{\n\n      \ntype\n:\n \nString\n,\n\n      \nrequired\n:\n \ntrue\n\n    \n}\n\n  \n},\n \n{\n \n_id\n:\n \nfalse\n \n}));\n\n\n  \nvar\n \nBatch\n \n=\n \ndb\n.\nmodel\n(\nEventBatch\n,\n \nbatchSchema\n);\n\n\n  \nvar\n \nbatch\n \n=\n \n{\n\n    \nevents\n:\n \n[\n\n      \n{\n \nkind\n:\n \nClicked\n,\n \nelement\n:\n \n#hero\n,\n \nmessage\n:\n \nhello\n \n},\n\n      \n{\n \nkind\n:\n \nPurchased\n,\n \nproduct\n:\n \naction-figure-1\n,\n \nmessage\n:\n \nworld\n \n}\n\n    \n]\n\n  \n};\n\n\n  \nBatch\n.\ncreate\n(\nbatch\n).\n\n    \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n.\nlength\n,\n \n2\n);\n\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n0\n].\nelement\n,\n \n#hero\n);\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n0\n].\nmessage\n,\n \nhello\n);\n\n      \nassert\n.\nok\n(\ndoc\n.\nevents\n[\n0\n]\n \ninstanceof\n \nClicked\n);\n\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n1\n].\nproduct\n,\n \naction-figure-1\n);\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n1\n].\nmessage\n,\n \nworld\n);\n\n      \nassert\n.\nok\n(\ndoc\n.\nevents\n[\n1\n]\n \ninstanceof\n \nPurchased\n);\n\n\n      \ndoc\n.\nevents\n.\npush\n({\n \nkind\n:\n \nPurchased\n,\n \nproduct\n:\n \naction-figure-2\n \n});\n\n      \nreturn\n \ndoc\n.\nsave\n();\n\n    \n}).\n\n    \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n.\nlength\n,\n \n3\n);\n\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n2\n].\nproduct\n,\n \naction-figure-2\n);\n\n      \nassert\n.\nok\n(\ndoc\n.\nevents\n[\n2\n]\n \ninstanceof\n \nPurchased\n);\n\n\n      \ndone\n();\n\n    \n}).\n\n    \ncatch\n(\ndone\n);\n\n\n\n\n\n\u5d4c\u5165\u5f0f\u9012\u5f52\u9274\u522b\u5668\n\n\n  \nvar\n \nsingleEventSchema\n \n=\n \nnew\n \nSchema\n({\n \nmessage\n:\n \nString\n \n},\n\n    \n{\n \ndiscriminatorKey\n:\n \nkind\n,\n \n_id\n:\n \nfalse\n \n});\n\n\n  \nvar\n \neventListSchema\n \n=\n \nnew\n \nSchema\n({\n \nevents\n:\n \n[\nsingleEventSchema\n]\n \n});\n\n\n  \nvar\n \nsubEventSchema\n \n=\n \nnew\n \nSchema\n({\n\n      \nsub_events\n:\n \n[\nsingleEventSchema\n]\n\n  \n},\n \n{\n \n_id\n:\n \nfalse\n \n});\n\n\n  \nvar\n \nSubEvent\n \n=\n \nsubEventSchema\n.\npath\n(\nsub_events\n).\ndiscriminator\n(\nSubEvent\n,\n \nsubEventSchema\n)\n\n  \neventListSchema\n.\npath\n(\nevents\n).\ndiscriminator\n(\nSubEvent\n,\n \nsubEventSchema\n);\n\n\n  \nvar\n \nEventlist\n \n=\n \ndb\n.\nmodel\n(\nEventList\n,\n \neventListSchema\n);\n\n\n  \nvar\n \nlist\n \n=\n \n{\n\n    \nevents\n:\n \n[\n\n      \n{\n \nkind\n:\n \nSubEvent\n,\n \nsub_events\n:\n \n[{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[],\n \nmessage\n:\ntest1\n}],\n \nmessage\n:\n \nhello\n \n},\n\n      \n{\n \nkind\n:\n \nSubEvent\n,\n \nsub_events\n:\n \n[{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[],\n \nmessage\n:\ntest3\n}],\n \nmessage\n:\ntest2\n}],\n \nmessage\n:\n \nworld\n \n}\n\n    \n]\n\n  \n};\n\n\n  \nEventlist\n.\ncreate\n(\nlist\n).\n\n    \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n.\nlength\n,\n \n2\n);\n\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n0\n].\nsub_events\n[\n0\n].\nmessage\n,\n \ntest1\n);\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n0\n].\nmessage\n,\n \nhello\n);\n\n      \nassert\n.\nok\n(\ndoc\n.\nevents\n[\n0\n].\nsub_events\n[\n0\n]\n \ninstanceof\n \nSubEvent\n);\n\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n1\n].\nsub_events\n[\n0\n].\nsub_events\n[\n0\n].\nmessage\n,\n \ntest3\n);\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n1\n].\nmessage\n,\n \nworld\n);\n\n      \nassert\n.\nok\n(\ndoc\n.\nevents\n[\n1\n].\nsub_events\n[\n0\n].\nsub_events\n[\n0\n]\n \ninstanceof\n \nSubEvent\n);\n\n\n      \ndoc\n.\nevents\n.\npush\n({\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[],\n \nmessage\n:\ntest4\n}],\n \nmessage\n:\npushed\n});\n\n      \nreturn\n \ndoc\n.\nsave\n();\n\n    \n}).\n\n    \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n.\nlength\n,\n \n3\n);\n\n\n      \nassert\n.\nequal\n(\ndoc\n.\nevents\n[\n2\n].\nmessage\n,\n \npushed\n);\n\n      \nassert\n.\nok\n(\ndoc\n.\nevents\n[\n2\n].\nsub_events\n[\n0\n]\n \ninstanceof\n \nSubEvent\n);\n\n\n      \ndone\n();\n\n    \n}).\n\n    \ncatch\n(\ndone\n);", 
            "title": "\u9274\u522b\u5668"
        }, 
        {
            "location": "/guide/Discriminators/#_1", 
            "text": "\u8d44\u6e90  \u9274\u522b\u5668\u662f\u4e00\u4e2a\u6a21\u5f0f\u7ee7\u627f\u673a\u5236\u3002 \u5b83\u4eec\u4f7f\u60a8\u80fd\u591f\u5728\u76f8\u540c\u7684\u57fa\u7840MongoDB\u96c6\u5408\u4e4b\u4e0a\u62e5\u6709\u591a\u4e2a\u5177\u6709\u91cd\u53e0\u6a21\u5f0f\u7684\u6a21\u578b\u3002  \u5047\u8bbe\u60a8\u60f3\u8981\u5728\u5355\u4e2a\u96c6\u5408\u4e2d\u8ddf\u8e2a\u4e0d\u540c\u7c7b\u578b\u7684\u4e8b\u4ef6\u3002 \u6bcf\u4e2a\u4e8b\u4ef6\u90fd\u4f1a\u6709\u4e00\u4e2a\u65f6\u95f4\u6233\uff0c\u4f46\u4ee3\u8868\u70b9\u51fb\u94fe\u63a5\u200b\u200b\u7684\u4e8b\u4ef6\u5e94\u8be5\u6709\u4e00\u4e2aURL\u3002 \u4f60\u53ef\u4ee5\u4f7f\u7528 model.discriminator\uff08\uff09 \u51fd\u6570\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u3002 \u8be5\u529f\u80fd\u9700\u89812\u4e2a\u53c2\u6570\uff0c \u4e00\u4e2a\u6a21\u578b\u540d\u79f0\u548c\u4e00\u4e2a\u9274\u522b\u5668\u6a21\u5f0f \u5b83\u8fd4\u56de\u4e00\u4e2a\u6a21\u5f0f\uff0c\u5176\u6a21\u5f0f\u662f\u57fa\u672c\u6a21\u5f0f\u548c\u9274\u522b\u5668\u6a21\u5f0f\u7684\u8054\u5408\u3002     var   options   =   { discriminatorKey :   kind }; \n   var   eventSchema   =   new   mongoose . Schema ({ time :   Date },   options ); \n   var   Event   =   mongoose . model ( Event ,   eventSchema ); \n   var   ClickedLinkEvent   =   Event . discriminator ( ClickedLink ,   new   mongoose . Schema ({ url :   String },   options )); \n   var   genericEvent   =   new   Event ({ time :   Date . now (),   url :   google.com }); \n   assert . ok ( ! genericEvent . url ); \n   var   clickedEvent   =   new   ClickedLinkEvent ({ time :   Date . now (),   url :   google.com }); \n   assert . ok ( clickedEvent . url );   \u5047\u8bbe\u60a8\u521b\u5efa\u4e86\u53e6\u4e00\u4e2a\u9274\u522b\u5668\u6765\u8ddf\u8e2a\u65b0\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002\u8fd9\u4e9b SignedUpEvent \u5b9e\u4f8b\u5c06\u88ab\u5b58\u50a8\u5728\u4e0e\u901a\u7528\u4e8b\u4ef6\u548c ClickedLinkEvent \u5b9e\u4f8b\u76f8\u540c\u7684\u96c6\u5408\u4e2d\u3002     var   event1   =   new   Event ({ time :   Date . now ()}); \n   var   event2   =   new   ClickedLinkEvent ({ time :   Date . now (),   url :   google.com }); \n   var   event3   =   new   SignedUpEvent ({ time :   Date . now (),   user :   testuser }); \n\n   var   save   =   function   ( doc ,   callback )   { \n     doc . save ( function   ( error ,   doc )   { \n       callback ( error ,   doc ); \n     }); \n   }; \n\n   async . map ([ event1 ,   event2 ,   event3 ],   save ,   function   ( error )   { \n\n     Event . count ({},   function   ( error ,   count )   { \n       assert . equal ( count ,   3 ); \n     }); \n   });   \u732b\u9f2c\u7684\u65b9\u5f0f\u544a\u8bc9\u4e0d\u540c\u7684\u9274\u522b\u5668\u6a21\u578b\u4e4b\u95f4\u7684\u5dee\u5f02\u662f\u7531\u201c\u9274\u522b\u94a5\u5319\u201d, \u9ed8\u8ba4\u662f __t \u3002 ,Mongoose\u5c06\u4e00\u4e2a\u540d\u4e3a __t \u7684String\u8def\u5f84\u6dfb\u52a0\u5230\u60a8\u7684\u6a21\u5f0f\u4e2d\uff0c\u7528\u4e8e\u8ddf\u8e2a\u8be5\u6587\u6863\u662f\u54ea\u4e2a\u9274\u522b\u5668\u7684\u5b9e\u4f8b\u3002     var   event1   =   new   Event ({ time :   Date . now ()}); \n   var   event2   =   new   ClickedLinkEvent ({ time :   Date . now (),   url :   google.com }); \n   var   event3   =   new   SignedUpEvent ({ time :   Date . now (),   user :   testuser }); \n\n   assert . ok ( ! event1 . __t ); \n   assert . equal ( event2 . __t ,   ClickedLink ); \n   assert . equal ( event3 . __t ,   SignedUp );   \u8fa8\u522b\u5668\u6a21\u578b\u662f\u7279\u6b8a\u7684;\u4ed6\u4eec\u5c06\u9274\u522b\u952e\u9644\u52a0\u5230\u67e5\u8be2\u3002 \u6362\u4e00\u79cd\u8bf4\u6cd5\uff0c  find() ,  count() ,  aggregate() , \u7b49\u7b49\u90fd\u8db3\u591f\u806a\u660e\u6765\u89e3\u91ca\u9274\u522b\u8005\u3002     var   event1   =   new   Event ({ time :   Date . now ()}); \n   var   event2   =   new   ClickedLinkEvent ({ time :   Date . now (),   url :   google.com }); \n   var   event3   =   new   SignedUpEvent ({ time :   Date . now (),   user :   testuser }); \n\n   var   save   =   function   ( doc ,   callback )   { \n     doc . save ( function   ( error ,   doc )   { \n       callback ( error ,   doc ); \n     }); \n   }; \n\n   async . map ([ event1 ,   event2 ,   event3 ],   save ,   function   ( error )   { \n\n     ClickedLinkEvent . find ({},   function   ( error ,   docs )   { \n       assert . equal ( docs . length ,   1 ); \n       assert . equal ( docs [ 0 ]. _id . toString (),   event2 . _id . toString ()); \n       assert . equal ( docs [ 0 ]. url ,   google.com ); \n     }); \n   });   \u9274\u522b\u8005\u4e5f\u91c7\u53d6\u4ed6\u4eec\u7684\u57fa\u672c\u6a21\u5f0f\u7684\u524d\u540e\u4e2d\u95f4\u4ef6\u3002 \u4f46\u662f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u5c06\u4e2d\u95f4\u4ef6\u9644\u52a0\u5230\u9274\u522b\u5668\u6a21\u5f0f\uff0c\u800c\u4e0d\u4f1a\u5f71\u54cd\u57fa\u672c\u6a21\u5f0f\u3002     var   options   =   { discriminatorKey :   kind }; \n\n   var   eventSchema   =   new   mongoose . Schema ({ time :   Date },   options ); \n   var   eventSchemaCalls   =   0 ; \n   eventSchema . pre ( validate ,   function   ( next )   { \n     ++ eventSchemaCalls ; \n     next (); \n   }); \n   var   Event   =   mongoose . model ( GenericEvent ,   eventSchema ); \n\n   var   clickedLinkSchema   =   new   mongoose . Schema ({ url :   String },   options ); \n   var   clickedSchemaCalls   =   0 ; \n   clickedLinkSchema . pre ( validate ,   function   ( next )   { \n     ++ clickedSchemaCalls ; \n     next (); \n   }); \n   var   ClickedLinkEvent   =   Event . discriminator ( ClickedLinkEvent , \n     clickedLinkSchema ); \n\n   var   event1   =   new   ClickedLinkEvent (); \n   event1 . validate ( function ()   { \n     assert . equal ( eventSchemaCalls ,   1 ); \n     assert . equal ( clickedSchemaCalls ,   1 ); \n\n     var   generic   =   new   Event (); \n     generic . validate ( function ()   { \n       assert . equal ( eventSchemaCalls ,   2 ); \n       assert . equal ( clickedSchemaCalls ,   1 ); \n     }); \n   });   \u9274\u522b\u5668\u7684\u5b57\u6bb5\u662f\u57fa\u672c\u6a21\u5f0f\u5b57\u6bb5\u548c\u9274\u522b\u5668\u6a21\u5f0f\u5b57\u6bb5\u7684\u8054\u5408\uff0c \u5e76\u4e14\u9274\u522b\u5668\u6a21\u5f0f\u7684\u5b57\u6bb5\u4f18\u5148\u3002,\u6709\u4e00\u4e2a\u4f8b\u5916\uff1a\u9ed8\u8ba4\u7684 _id \u5b57\u6bb5\u3002  \u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u9274\u522b\u5668\u6a21\u5f0f\u4e2d\u5c06_id\u9009\u9879\u8bbe\u7f6e\u4e3afalse\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5982\u4e0b\u6240\u793a\u3002     var   options   =   { discriminatorKey :   kind }; \n\n   var   eventSchema   =   new   mongoose . Schema ({ _id :   String ,   time :   Date }, \n     options ); \n   var   Event   =   mongoose . model ( BaseEvent ,   eventSchema ); \n\n   var   clickedLinkSchema   =   new   mongoose . Schema ({ \n     url :   String , \n     time :   String \n   },   options ); \n\n   assert . ok ( clickedLinkSchema . path ( _id )); \n   assert . equal ( clickedLinkSchema . path ( _id ). instance ,   ObjectID ); \n   var   ClickedLinkEvent   =   Event . discriminator ( ChildEventBad , \n     clickedLinkSchema ); \n\n   var   event1   =   new   ClickedLinkEvent ({   _id :   custom id ,   time :   4pm   }); \n\n   assert . ok ( typeof   event1 . _id   ===   string ); \n   assert . ok ( typeof   event1 . time   ===   string );   \u5f53\u4f60\u4f7f\u7528 Model.create\uff08\uff09 \u65f6\uff0c\u732b\u9f2c\u4f1a\u4ece\u4f60\u7684\u9274\u522b\u5668\u952e\u4e2d\u53d6\u51fa\u6b63\u786e\u7684\u7c7b\u578b\u3002     var   Schema   =   mongoose . Schema ; \n   var   shapeSchema   =   new   Schema ({ \n     name :   String \n   },   {   discriminatorKey :   kind   }); \n\n   var   Shape   =   db . model ( Shape ,   shapeSchema ); \n\n   var   Circle   =   Shape . discriminator ( Circle , \n     new   Schema ({   radius :   Number   })); \n   var   Square   =   Shape . discriminator ( Square , \n     new   Schema ({   side :   Number   })); \n\n   var   shapes   =   [ \n     {   name :   Test   }, \n     {   kind :   Circle ,   radius :   5   }, \n     {   kind :   Square ,   side :   10   } \n   ]; \n   Shape . create ( shapes ,   function ( error ,   shapes )   { \n     assert . ifError ( error ); \n     assert . ok ( shapes [ 0 ]   instanceof   Shape ); \n     assert . ok ( shapes [ 1 ]   instanceof   Circle ); \n     assert . equal ( shapes [ 1 ]. radius ,   5 ); \n     assert . ok ( shapes [ 2 ]   instanceof   Square ); \n     assert . equal ( shapes [ 2 ]. side ,   10 ); \n   });   \u60a8\u4e5f\u53ef\u4ee5\u5728\u5d4c\u5165\u5f0f\u6587\u6863\u6570\u7ec4\u4e0a\u5b9a\u4e49\u9274\u522b\u5668\u3002 \u5d4c\u5165\u5f0f\u9274\u522b\u5668\u662f\u4e0d\u540c\u7684\uff0c\u56e0\u4e3a\u4e0d\u540c\u7684\u9274\u522b\u5668\u7c7b\u578b\u5b58\u50a8\u5728\u76f8\u540c\u7684\u6587\u6863\u6570\u7ec4\uff08\u5728\u6587\u6863\u4e2d\uff09\u800c\u4e0d\u662f\u76f8\u540c\u7684\u96c6\u5408\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5d4c\u5165\u5f0f\u9274\u522b\u5668\u53ef\u8ba9\u60a8\u5c06\u4e0e\u4e0d\u540c\u6a21\u5f0f\u5339\u914d\u7684\u5b50\u6587\u6863\u5b58\u50a8\u5728\u540c\u4e00\u4e2a\u6570\u7ec4\u4e2d\u3002  \u4f5c\u4e3a\u4e00\u4e2a\u901a\u7528\u7684\u6700\u4f73\u5b9e\u8df5\uff0c\u786e\u4fdd\u4f60\u5728\u4f7f\u7528\u5b83\u4eec\u4e4b\u524d\uff0c\u5728\u6a21\u5f0f**\u4e0a\u58f0\u660e\u4efb\u4f55\u94a9\u5b50\u3002 \u5728\u8c03\u7528discriminator\uff08\uff09\u4e4b\u540e\uff0c\u4f60\u4e0d\u5e94\u8be5\u8c03\u7528 pre\uff08\uff09 \u6216 post\uff08\uff09     var   eventSchema   =   new   Schema ({   message :   String   }, \n     {   discriminatorKey :   kind ,   _id :   false   }); \n\n   var   batchSchema   =   new   Schema ({   events :   [ eventSchema ]   }); \n\n   var   docArray   =   batchSchema . path ( events ); \n\n   var   clickedSchema   =   new   Schema ({ \n     element :   { \n       type :   String , \n       required :   true \n     } \n   },   {   _id :   false   }); \n\n   var   Clicked   =   docArray . discriminator ( Clicked ,   clickedSchema ); \n\n   var   Purchased   =   docArray . discriminator ( Purchased ,   new   Schema ({ \n     product :   { \n       type :   String , \n       required :   true \n     } \n   },   {   _id :   false   })); \n\n   var   Batch   =   db . model ( EventBatch ,   batchSchema ); \n\n   var   batch   =   { \n     events :   [ \n       {   kind :   Clicked ,   element :   #hero ,   message :   hello   }, \n       {   kind :   Purchased ,   product :   action-figure-1 ,   message :   world   } \n     ] \n   }; \n\n   Batch . create ( batch ). \n     then ( function ( doc )   { \n       assert . equal ( doc . events . length ,   2 ); \n\n       assert . equal ( doc . events [ 0 ]. element ,   #hero ); \n       assert . equal ( doc . events [ 0 ]. message ,   hello ); \n       assert . ok ( doc . events [ 0 ]   instanceof   Clicked ); \n\n       assert . equal ( doc . events [ 1 ]. product ,   action-figure-1 ); \n       assert . equal ( doc . events [ 1 ]. message ,   world ); \n       assert . ok ( doc . events [ 1 ]   instanceof   Purchased ); \n\n       doc . events . push ({   kind :   Purchased ,   product :   action-figure-2   }); \n       return   doc . save (); \n     }). \n     then ( function ( doc )   { \n       assert . equal ( doc . events . length ,   3 ); \n\n       assert . equal ( doc . events [ 2 ]. product ,   action-figure-2 ); \n       assert . ok ( doc . events [ 2 ]   instanceof   Purchased ); \n\n       done (); \n     }). \n     catch ( done );   \u5d4c\u5165\u5f0f\u9012\u5f52\u9274\u522b\u5668     var   singleEventSchema   =   new   Schema ({   message :   String   }, \n     {   discriminatorKey :   kind ,   _id :   false   }); \n\n   var   eventListSchema   =   new   Schema ({   events :   [ singleEventSchema ]   }); \n\n   var   subEventSchema   =   new   Schema ({ \n       sub_events :   [ singleEventSchema ] \n   },   {   _id :   false   }); \n\n   var   SubEvent   =   subEventSchema . path ( sub_events ). discriminator ( SubEvent ,   subEventSchema ) \n   eventListSchema . path ( events ). discriminator ( SubEvent ,   subEventSchema ); \n\n   var   Eventlist   =   db . model ( EventList ,   eventListSchema ); \n\n   var   list   =   { \n     events :   [ \n       {   kind :   SubEvent ,   sub_events :   [{ kind : SubEvent ,   sub_events : [],   message : test1 }],   message :   hello   }, \n       {   kind :   SubEvent ,   sub_events :   [{ kind : SubEvent ,   sub_events : [{ kind : SubEvent ,   sub_events : [],   message : test3 }],   message : test2 }],   message :   world   } \n     ] \n   }; \n\n   Eventlist . create ( list ). \n     then ( function ( doc )   { \n       assert . equal ( doc . events . length ,   2 ); \n\n       assert . equal ( doc . events [ 0 ]. sub_events [ 0 ]. message ,   test1 ); \n       assert . equal ( doc . events [ 0 ]. message ,   hello ); \n       assert . ok ( doc . events [ 0 ]. sub_events [ 0 ]   instanceof   SubEvent ); \n\n       assert . equal ( doc . events [ 1 ]. sub_events [ 0 ]. sub_events [ 0 ]. message ,   test3 ); \n       assert . equal ( doc . events [ 1 ]. message ,   world ); \n       assert . ok ( doc . events [ 1 ]. sub_events [ 0 ]. sub_events [ 0 ]   instanceof   SubEvent ); \n\n       doc . events . push ({ kind : SubEvent ,   sub_events : [{ kind : SubEvent ,   sub_events : [],   message : test4 }],   message : pushed }); \n       return   doc . save (); \n     }). \n     then ( function ( doc )   { \n       assert . equal ( doc . events . length ,   3 ); \n\n       assert . equal ( doc . events [ 2 ]. message ,   pushed ); \n       assert . ok ( doc . events [ 2 ]. sub_events [ 0 ]   instanceof   SubEvent ); \n\n       done (); \n     }). \n     catch ( done );", 
            "title": "\u9274\u522b\u5668"
        }, 
        {
            "location": "/guide/Plugins/", 
            "text": "\u63d2\u4ef6\n\n\n\u8d44\u6e90\n\n\nSchemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature.\n\n\nSuppose that we have several collections in our database and want to add last-modified functionality to each one. With plugins this is easy. Just create a plugin once and apply it to each \nSchema\n:\n\n\nmodule\n.\nexports\n \n=\n \nexports\n \n=\n \nfunction\n \nlastModifiedPlugin\n \n(\nschema\n,\n \noptions\n)\n \n{\n\n  \nschema.add({\n \nlastMod\n:\n \nDate\n \n}\n);\n\n\n  \nschema\n.\npre\n(\nsave\n,\n \nfunction\n \n(\nnext\n)\n \n{\n\n    \nthis.lastMod\n \n=\n \nnew\n \nDate()\n;\n\n    \nnext()\n;\n\n  \n}\n);\n\n\n  \nif\n \n(\noptions\n \n \noptions\n.\nindex\n)\n \n{\n\n    \nschema.path(\nlastMod\n).index(options.index)\n;\n\n  \n}\n\n\n}\n\n\n\n\nvar\n \nlastMod\n \n=\n \nrequire\n(\n./lastMod\n);\n\n\nvar\n \nGame\n \n=\n \nnew\n \nSchema\n(\n{\n \n...\n \n}\n);\n\n\nGame\n.\nplugin\n(\nlastMod\n,\n \n{\n \nindex\n:\n \ntrue\n \n}\n);\n\n\n\n\nvar\n \nlastMod\n \n=\n \nrequire\n(\n./lastMod\n);\n\n\nvar\n \nPlayer\n \n=\n \nnew\n \nSchema\n(\n{\n \n...\n \n}\n);\n\n\nPlayer\n.\nplugin\n(\nlastMod\n);\n\n\n\n\n\n\nWe just added last-modified behavior to both our \nGame\n and \nPlayer\n schemas and declared an index on the \nlastMod\n path of our Games to boot. Not bad for a few lines of code.\n\n\n\u5168\u7403\u63d2\u4ef6\n\n\nWant to register a plugin for all schemas? The mongoose singleton has a \n.plugin()\n function that registers a plugin for every schema. For example:\n\n\nvar mongoose = require(\nmongoose\n);\nmongoose.plugin(require(\n./lastMod\n));\n\nvar gameSchema = new Schema({ ... });\nvar playerSchema = new Schema({ ... });\n\nvar Game = mongoose.model(\nGame\n, gameSchema);\nvar Player = mongoose.model(\nPlayer\n, playerSchema);\n\n\n\n\n\nNot only can you re-use schema functionality in your own projects but you also reap the benefits of the Mongoose community as well. Any plugin published to \nnpm\n and \ntagged\n with \nmongoose\n will show up on our \nsearch results\n page.", 
            "title": "\u63d2\u4ef6"
        }, 
        {
            "location": "/guide/Plugins/#_1", 
            "text": "\u8d44\u6e90  Schemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature.  Suppose that we have several collections in our database and want to add last-modified functionality to each one. With plugins this is easy. Just create a plugin once and apply it to each  Schema :  module . exports   =   exports   =   function   lastModifiedPlugin   ( schema ,   options )   { \n   schema.add({   lastMod :   Date   } ); \n\n   schema . pre ( save ,   function   ( next )   { \n     this.lastMod   =   new   Date() ; \n     next() ; \n   } ); \n\n   if   ( options     options . index )   { \n     schema.path( lastMod ).index(options.index) ; \n   }  }  var   lastMod   =   require ( ./lastMod );  var   Game   =   new   Schema ( {   ...   } );  Game . plugin ( lastMod ,   {   index :   true   } );  var   lastMod   =   require ( ./lastMod );  var   Player   =   new   Schema ( {   ...   } );  Player . plugin ( lastMod );   We just added last-modified behavior to both our  Game  and  Player  schemas and declared an index on the  lastMod  path of our Games to boot. Not bad for a few lines of code.", 
            "title": "\u63d2\u4ef6"
        }, 
        {
            "location": "/guide/Plugins/#_2", 
            "text": "Want to register a plugin for all schemas? The mongoose singleton has a  .plugin()  function that registers a plugin for every schema. For example:  var mongoose = require( mongoose );\nmongoose.plugin(require( ./lastMod ));\n\nvar gameSchema = new Schema({ ... });\nvar playerSchema = new Schema({ ... });\n\nvar Game = mongoose.model( Game , gameSchema);\nvar Player = mongoose.model( Player , playerSchema);  Not only can you re-use schema functionality in your own projects but you also reap the benefits of the Mongoose community as well. Any plugin published to  npm  and  tagged  with  mongoose  will show up on our  search results  page.", 
            "title": "\u5168\u7403\u63d2\u4ef6"
        }, 
        {
            "location": "/api/Aggregate/", 
            "text": "\u805a\u5408\n\n\nAggregate()\n\n\n\u53c2\u6570\n\n\n\n\n[pipeline] \u00abArray\u00bb aggregation pipeline as an array of objects\n\n\n\n\nAggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use [Model.aggregate() instead.\n\n\n\u793a\u4f8b\n\n\nconst aggregate = Model.aggregate([\n  { $project: { a: 1, b: 1 } },\n  { $skip: 5 }\n]);\n\nModel.\n  aggregate({ $match: { age: { $gte: 21 }}}).\n  unwind(\ntags\n).\n  exec(callback);\n\n\n\n\n\n\u6ce8\u91ca\n\n\n\n\nThe documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n\n\n\n\nMongoose does \nnot\n cast pipeline stages. The below will \nnot\n work unless \n_id\n is a string in the database\n\n\nnew Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n  // Do this instead to cast to an ObjectId\n  new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n\n\n\n\n\n\nAggregate.prototype.model()\n\n\n\u53c2\u6570\n\n\n\n\nmodel \u00abModel\u00bb the model to which the aggregate is to be bound\n\n\n\n\n\u8fd4\u56de\n\n\nBinds this aggregate to a model.\n\n\nAggregate.prototype.append()\n\n\n\u53c2\u6570\n\n\n\n\nops \u00abObject\u00bb operator(s) to append\n\n\n\n\n\u8fd4\u56de\n\n\nAppends new operators to this aggregate pipeline\n\n\n\u793a\u4f8b\n\n\naggregate\n.\nappend\n(\n{\n \n$\nproject\n:\n \n{\n \nfield\n:\n \n1\n \n}\n}\n,\n \n{\n \n$\nlimit\n:\n \n2\n \n}\n);\n\n\n\nvar\n \npipeline\n \n=\n \n[\n{\n \n$match\n:\n \n{\n \ndaw\n:\n \nLogic Audio X\n \n}}\n \n]\n;\n\n\naggregate\n.\nappend\n(\npipeline\n);\n\n\n\n\n\n\nAggregate.prototype.addFields()\n\n\n\u53c2\u6570\n\n\n\n\narg \u00abObject\u00bb field specification\n\n\n\n\n\u8fd4\u56de\n\n\nAppends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work\n\n\n\u793a\u4f8b\n\n\naggregate\n.\naddFields\n(\n{\n\n    \nnewField\n:\n \n$b.nested\n\n  \n,\n \nplusTen\n:\n \n{\n \n$\nadd\n:\n \n[\n$val\n,\n \n10\n]\n}\n\n  \n,\n \nsub\n:\n \n{\n\n       \nname\n:\n \n$a\n\n    \n}\n\n\n}\n)\n\n\n\naggregate\n.\naddFields\n(\n{\n \nsalary_k\n:\n \n{\n \n$\ndivide\n:\n \n[\n \n$salary\n,\n \n1000\n \n]\n \n}\n \n}\n);\n\n\n\n\n\n\nAggregate.prototype.project()\n\n\n\u53c2\u6570\n\n\n\n\narg \u00abObject,String\u00bb field specification\n\n\n\n\n\u8fd4\u56de\n\n\nAppends a new $project operator to this aggregate pipeline.\n\n\nMongoose query [selection syntax is also supported.\n\n\n\u793a\u4f8b\n\n\naggregate\n.\nproject\n(\na b -_id\n);\n\n\n\naggregate\n.\nproject\n(\n{\na\n:\n \n1\n,\n \nb\n:\n \n1\n,\n \n_id\n:\n \n0\n}\n);\n\n\n\naggregate\n.\nproject\n(\n{\n\n    \nnewField\n:\n \n$b.nested\n\n  \n,\n \nplusTen\n:\n \n{\n \n$\nadd\n:\n \n[\n$val\n,\n \n10\n]\n}\n\n  \n,\n \nsub\n:\n \n{\n\n       \nname\n:\n \n$a\n\n    \n}\n\n\n}\n)\n\n\n\naggregate\n.\nproject\n(\n{\n \nsalary_k\n:\n \n{\n \n$\ndivide\n:\n \n[\n \n$salary\n,\n \n1000\n \n]\n \n}\n \n}\n);\n\n\n\n\n\n\nAggregate.prototype.group()\n\n\n\u53c2\u6570\n\n\n\n\narg \u00abObject\u00bb $group operator contents\n\n\n\n\n\u8fd4\u56de\n\n\nAppends a new custom $group operator to this aggregate pipeline.\n\n\n\u793a\u4f8b\n\n\naggregate\n.\ngroup\n(\n{\n \n_id\n:\n \n$department\n \n}\n);\n\n\n\n\n\n\nAggregate.prototype.match()\n\n\n\u53c2\u6570\n\n\n\n\narg \u00abObject\u00bb $match operator contents\n\n\n\n\n\u8fd4\u56de\n\n\nAppends a new custom $match operator to this aggregate pipeline.\n\n\n\u793a\u4f8b\n\n\naggregate\n.\nmatch\n(\n{\n \ndepartment\n:\n \n{\n \n$\nin\n:\n \n[\n \nsales\n,\n \nengineering\n \n]\n \n}\n \n}\n);\n\n\n\n\n\n\nAggregate.prototype.skip()\n\n\n\u53c2\u6570\n\n\n\n\nnum \u00abNumber\u00bb number of records to skip before next stage\n\n\n\n\n\u8fd4\u56de\n\n\nAppends a new $skip operator to this aggregate pipeline.\n\n\n\u793a\u4f8b\n\n\naggregate.skip(10);\n\n\n\n\n\nAggregate.prototype.limit()\n\n\n\u53c2\u6570\n\n\n\n\nnum \u00abNumber\u00bb maximum number of records to pass to the next stage\n\n\n\n\n\u8fd4\u56de\n\n\nAppends a new $limit operator to this aggregate pipeline.\n\n\n\u793a\u4f8b\n\n\naggregate.limit(10);\n\n\n\n\n\nAggregate.prototype.near()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nAppends a new $geoNear operator to this aggregate pipeline.\n\n\n\u6ce8\u91ca\n\n\nMUST\n be used as the first operator in the pipeline.\n\n\n\u793a\u4f8b\n\n\naggregate.near({\n  near: [40.724, -73.997],\n  distanceField: \ndist.calculated\n,\n  maxDistance: 0.008,\n  query: { type: \npublic\n },\n  includeLocs: \ndist.location\n,\n  uniqueDocs: true,\n  num: 5\n});\n\n\n\n\n\nAggregate.prototype.unwind()\n\n\n\u53c2\u6570\n\n\n\n\nfields \u00abString\u00bb the field(s) to unwind\n\n\n\n\n\u8fd4\u56de\n\n\nAppends new custom $unwind operator(s) to this aggregate pipeline.\n\n\nNote that the \n$unwind\n operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'.\n\n\n\u793a\u4f8b\n\n\naggregate.unwind(\ntags\n);\naggregate.unwind(\na\n, \nb\n, \nc\n);\n\n\n\n\n\nAggregate.prototype.lookup()\n\n\n\u53c2\u6570\n\n\n\n\noptions \u00abObject\u00bb to $lookup as described in the above link\n\n\n\n\n\u8fd4\u56de\n\n\nAppends new custom $lookup operator(s) to this aggregate pipeline.\n\n\n\u793a\u4f8b\n\n\naggregate\n.\nlookup\n(\n{\n \nfrom\n:\n \nusers\n,\n \nlocalField\n:\n \nuserId\n,\n \nforeignField\n:\n \n_id\n,\n \nas\n:\n \nusers\n \n}\n);\n\n\n\n\n\n\nAggregate.prototype.graphLookup()\n\n\n\u53c2\u6570\n\n\n\n\noptions \u00abObject\u00bb to $graphLookup as described in the above link\n\n\n\n\n\u8fd4\u56de\n\n\nAppends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n\n\nNote that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if \n{ allowDiskUse: true }\n is specified.\n\n\n\u793a\u4f8b\n\n\n aggregate.graphLookup({ from: \ncourses\n, startWith: \n$prerequisite\n, connectFromField: \nprerequisite\n, connectToField: \nname\n, as: \nprerequisites\n, maxDepth: 3 })\n\n\n\n\n\nAggregate.prototype.sample()\n\n\n\u53c2\u6570\n\n\n\n\nsize \u00abNumber\u00bb number of random documents to pick\n\n\n\n\n\u8fd4\u56de\n\n\nAppepnds new custom $sample operator(s) to this aggregate pipeline.\n\n\n\u793a\u4f8b\n\n\naggregate.sample(3);\n\n\n\n\n\nAggregate.prototype.sort()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nAppends a new $sort operator to this aggregate pipeline.\n\n\nIf an object is passed, values allowed are \nasc\n, \ndesc\n, \nascending\n, \ndescending\n, \n1\n, and \n-1\n.\n\n\nIf a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with \n-\n which will be treated as descending.\n\n\n\u793a\u4f8b\n\n\naggregate\n.\nsort\n(\n{\n \nfield\n:\n \nasc\n,\n \ntest\n:\n \n-1\n \n}\n);\n\n\naggregate\n.\nsort\n(\nfield -test\n);\n\n\n\n\n\n\nAggregate.prototype.read()\n\n\n\u53c2\u6570\n\n\n\n\n[tags] \u00abArray\u00bb optional tags for this query\n\n\n\n\nSets the readPreference option for the aggregation query.\n\n\n\u793a\u4f8b\n\n\nModel.aggregate(..).read(\nprimaryPreferred\n).exec(callback)\n\n\n\n\n\nAggregate.prototype.explain()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nExecute the aggregation with explain\n\n\n\u793a\u4f8b\n\n\nModel.aggregate(..).explain(callback)\n\n\n\n\n\nAggregate.prototype.allowDiskUse()\n\n\n\u53c2\u6570\n\n\n\n\n[tags] \u00abArray\u00bb optional tags for this query\n\n\n\n\nSets the allowDiskUse option for the aggregation query (ignored for \n 2.6.0)\n\n\n\u793a\u4f8b\n\n\nModel.aggregate(..).allowDiskUse(true).exec(callback)\n\n\n\n\n\nAggregate.prototype.option()\n\n\n\u53c2\u6570\n\n\n\n\nvalue \u00abObject\u00bb keys to merge into current options\n\n\n\n\n\u8fd4\u56de\n\n\nLets you set arbitrary options, for middleware or plugins.\n\n\n\u793a\u4f8b\n\n\nvar\n \nagg\n \n=\n \nModel\n.\naggregate\n(..)\n.\noption\n(\n{\n \nallowDiskUse\n:\n \ntrue\n \n}\n);\n\n\nagg\n.\noptions\n;\n\n\n\n\n\n\nAggregate.prototype.cursor()\n\n\n\u53c2\u6570\n\n\n\n\n[options.useMongooseAggCursor] \u00abBoolean\u00bb use experimental mongoose-specific aggregation cursor (for \neachAsync()\n and other query cursor semantics)\n\n\n\n\nSets the cursor option option for the aggregation query (ignored for \n 2.6.0). Note the different syntax below: .exec() returns a cursor object, and no callback is necessary.\n\n\n\u793a\u4f8b\n\n\nvar\n \ncursor\n \n=\n \nModel\n.\naggregate\n(..)\n.\ncursor\n(\n{\n \nbatchSize\n:\n \n1000\n \n}\n)\n.\nexec\n();\n\n\ncursor\n.\neach\n(\nfunction\n(\nerror\n,\n \ndoc\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nAggregate.prototype.addCursorFlag()\n\n\n\u53c2\u6570\n\n\nAdds a [cursor flag\n\n\n\u793a\u4f8b\n\n\nModel.aggregate(..).addCursorFlag(\nnoCursorTimeout\n, true).exec();\n\n\n\n\n\nAggregate.prototype.collation()\n\n\n\u53c2\u6570\n\n\nAdds a collation\n\n\n\u793a\u4f8b\n\n\nModel\n.\naggregate\n(..)\n.\ncollation\n(\n{\n \nlocale\n:\n \nen_US\n,\n \nstrength\n:\n \n1\n \n}\n)\n.\nexec\n();\n\n\n\n\n\n\nAggregate.prototype.facet()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nCombines multiple aggregation pipelines.\n\n\n\u793a\u4f8b\n\n\nModel.aggregate(...)\n .facet({\n   books: [{ groupBy: \n$author\n }],\n   price: [{ $bucketAuto: { groupBy: \n$price\n, buckets: 2 } }]\n })\n .exec();\n\n\n\n\n\nAggregate.prototype.pipeline()\n\n\n\u8fd4\u56de\n\n\nReturns the current pipeline\n\n\n\u793a\u4f8b\n\n\nMyModel\n.\naggregate\n()\n.\nmatch\n(\n{\n \ntest\n:\n \n1\n \n}\n)\n.\npipeline\n();\n\n\n\n\n\n\nAggregate.prototype.exec()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nExecutes the aggregate pipeline on the currently bound Model.\n\n\n\u793a\u4f8b\n\n\naggregate.exec(callback);\n\nvar promise = aggregate.exec();\npromise.then(..);\n\n\n\n\n\nAggregate.prototype.then()\n\n\n\u53c2\u6570\n\n\n\n\n[reject] \u00abFunction\u00bb errorCallback\n\n\n\n\n\u8fd4\u56de\n\n\nProvides promise for aggregate.\n\n\n\u793a\u4f8b\n\n\nModel.aggregate(..).then(successCallback, errorCallback);", 
            "title": "\u805a\u5408"
        }, 
        {
            "location": "/api/Aggregate/#_1", 
            "text": "", 
            "title": "\u805a\u5408"
        }, 
        {
            "location": "/api/Aggregate/#aggregate", 
            "text": "\u53c2\u6570   [pipeline] \u00abArray\u00bb aggregation pipeline as an array of objects   Aggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use [Model.aggregate() instead.  \u793a\u4f8b  const aggregate = Model.aggregate([\n  { $project: { a: 1, b: 1 } },\n  { $skip: 5 }\n]);\n\nModel.\n  aggregate({ $match: { age: { $gte: 21 }}}).\n  unwind( tags ).\n  exec(callback);  \u6ce8\u91ca   The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).   Mongoose does  not  cast pipeline stages. The below will  not  work unless  _id  is a string in the database  new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n  // Do this instead to cast to an ObjectId\n  new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);", 
            "title": "Aggregate()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypemodel", 
            "text": "\u53c2\u6570   model \u00abModel\u00bb the model to which the aggregate is to be bound   \u8fd4\u56de  Binds this aggregate to a model.", 
            "title": "Aggregate.prototype.model()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeappend", 
            "text": "\u53c2\u6570   ops \u00abObject\u00bb operator(s) to append   \u8fd4\u56de  Appends new operators to this aggregate pipeline  \u793a\u4f8b  aggregate . append ( {   $ project :   {   field :   1   } } ,   {   $ limit :   2   } );  var   pipeline   =   [ {   $match :   {   daw :   Logic Audio X   }}   ] ;  aggregate . append ( pipeline );", 
            "title": "Aggregate.prototype.append()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeaddfields", 
            "text": "\u53c2\u6570   arg \u00abObject\u00bb field specification   \u8fd4\u56de  Appends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work  \u793a\u4f8b  aggregate . addFields ( { \n     newField :   $b.nested \n   ,   plusTen :   {   $ add :   [ $val ,   10 ] } \n   ,   sub :   { \n        name :   $a \n     }  } )  aggregate . addFields ( {   salary_k :   {   $ divide :   [   $salary ,   1000   ]   }   } );", 
            "title": "Aggregate.prototype.addFields()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeproject", 
            "text": "\u53c2\u6570   arg \u00abObject,String\u00bb field specification   \u8fd4\u56de  Appends a new $project operator to this aggregate pipeline.  Mongoose query [selection syntax is also supported.  \u793a\u4f8b  aggregate . project ( a b -_id );  aggregate . project ( { a :   1 ,   b :   1 ,   _id :   0 } );  aggregate . project ( { \n     newField :   $b.nested \n   ,   plusTen :   {   $ add :   [ $val ,   10 ] } \n   ,   sub :   { \n        name :   $a \n     }  } )  aggregate . project ( {   salary_k :   {   $ divide :   [   $salary ,   1000   ]   }   } );", 
            "title": "Aggregate.prototype.project()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypegroup", 
            "text": "\u53c2\u6570   arg \u00abObject\u00bb $group operator contents   \u8fd4\u56de  Appends a new custom $group operator to this aggregate pipeline.  \u793a\u4f8b  aggregate . group ( {   _id :   $department   } );", 
            "title": "Aggregate.prototype.group()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypematch", 
            "text": "\u53c2\u6570   arg \u00abObject\u00bb $match operator contents   \u8fd4\u56de  Appends a new custom $match operator to this aggregate pipeline.  \u793a\u4f8b  aggregate . match ( {   department :   {   $ in :   [   sales ,   engineering   ]   }   } );", 
            "title": "Aggregate.prototype.match()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeskip", 
            "text": "\u53c2\u6570   num \u00abNumber\u00bb number of records to skip before next stage   \u8fd4\u56de  Appends a new $skip operator to this aggregate pipeline.  \u793a\u4f8b  aggregate.skip(10);", 
            "title": "Aggregate.prototype.skip()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypelimit", 
            "text": "\u53c2\u6570   num \u00abNumber\u00bb maximum number of records to pass to the next stage   \u8fd4\u56de  Appends a new $limit operator to this aggregate pipeline.  \u793a\u4f8b  aggregate.limit(10);", 
            "title": "Aggregate.prototype.limit()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypenear", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Appends a new $geoNear operator to this aggregate pipeline.  \u6ce8\u91ca  MUST  be used as the first operator in the pipeline.  \u793a\u4f8b  aggregate.near({\n  near: [40.724, -73.997],\n  distanceField:  dist.calculated ,\n  maxDistance: 0.008,\n  query: { type:  public  },\n  includeLocs:  dist.location ,\n  uniqueDocs: true,\n  num: 5\n});", 
            "title": "Aggregate.prototype.near()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeunwind", 
            "text": "\u53c2\u6570   fields \u00abString\u00bb the field(s) to unwind   \u8fd4\u56de  Appends new custom $unwind operator(s) to this aggregate pipeline.  Note that the  $unwind  operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'.  \u793a\u4f8b  aggregate.unwind( tags );\naggregate.unwind( a ,  b ,  c );", 
            "title": "Aggregate.prototype.unwind()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypelookup", 
            "text": "\u53c2\u6570   options \u00abObject\u00bb to $lookup as described in the above link   \u8fd4\u56de  Appends new custom $lookup operator(s) to this aggregate pipeline.  \u793a\u4f8b  aggregate . lookup ( {   from :   users ,   localField :   userId ,   foreignField :   _id ,   as :   users   } );", 
            "title": "Aggregate.prototype.lookup()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypegraphlookup", 
            "text": "\u53c2\u6570   options \u00abObject\u00bb to $graphLookup as described in the above link   \u8fd4\u56de  Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.  Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if  { allowDiskUse: true }  is specified.  \u793a\u4f8b   aggregate.graphLookup({ from:  courses , startWith:  $prerequisite , connectFromField:  prerequisite , connectToField:  name , as:  prerequisites , maxDepth: 3 })", 
            "title": "Aggregate.prototype.graphLookup()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypesample", 
            "text": "\u53c2\u6570   size \u00abNumber\u00bb number of random documents to pick   \u8fd4\u56de  Appepnds new custom $sample operator(s) to this aggregate pipeline.  \u793a\u4f8b  aggregate.sample(3);", 
            "title": "Aggregate.prototype.sample()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypesort", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Appends a new $sort operator to this aggregate pipeline.  If an object is passed, values allowed are  asc ,  desc ,  ascending ,  descending ,  1 , and  -1 .  If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with  -  which will be treated as descending.  \u793a\u4f8b  aggregate . sort ( {   field :   asc ,   test :   -1   } );  aggregate . sort ( field -test );", 
            "title": "Aggregate.prototype.sort()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototyperead", 
            "text": "\u53c2\u6570   [tags] \u00abArray\u00bb optional tags for this query   Sets the readPreference option for the aggregation query.  \u793a\u4f8b  Model.aggregate(..).read( primaryPreferred ).exec(callback)", 
            "title": "Aggregate.prototype.read()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeexplain", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Execute the aggregation with explain  \u793a\u4f8b  Model.aggregate(..).explain(callback)", 
            "title": "Aggregate.prototype.explain()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeallowdiskuse", 
            "text": "\u53c2\u6570   [tags] \u00abArray\u00bb optional tags for this query   Sets the allowDiskUse option for the aggregation query (ignored for   2.6.0)  \u793a\u4f8b  Model.aggregate(..).allowDiskUse(true).exec(callback)", 
            "title": "Aggregate.prototype.allowDiskUse()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeoption", 
            "text": "\u53c2\u6570   value \u00abObject\u00bb keys to merge into current options   \u8fd4\u56de  Lets you set arbitrary options, for middleware or plugins.  \u793a\u4f8b  var   agg   =   Model . aggregate (..) . option ( {   allowDiskUse :   true   } );  agg . options ;", 
            "title": "Aggregate.prototype.option()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypecursor", 
            "text": "\u53c2\u6570   [options.useMongooseAggCursor] \u00abBoolean\u00bb use experimental mongoose-specific aggregation cursor (for  eachAsync()  and other query cursor semantics)   Sets the cursor option option for the aggregation query (ignored for   2.6.0). Note the different syntax below: .exec() returns a cursor object, and no callback is necessary.  \u793a\u4f8b  var   cursor   =   Model . aggregate (..) . cursor ( {   batchSize :   1000   } ) . exec ();  cursor . each ( function ( error ,   doc )   {  } );", 
            "title": "Aggregate.prototype.cursor()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeaddcursorflag", 
            "text": "\u53c2\u6570  Adds a [cursor flag  \u793a\u4f8b  Model.aggregate(..).addCursorFlag( noCursorTimeout , true).exec();", 
            "title": "Aggregate.prototype.addCursorFlag()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypecollation", 
            "text": "\u53c2\u6570  Adds a collation  \u793a\u4f8b  Model . aggregate (..) . collation ( {   locale :   en_US ,   strength :   1   } ) . exec ();", 
            "title": "Aggregate.prototype.collation()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypefacet", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Combines multiple aggregation pipelines.  \u793a\u4f8b  Model.aggregate(...)\n .facet({\n   books: [{ groupBy:  $author  }],\n   price: [{ $bucketAuto: { groupBy:  $price , buckets: 2 } }]\n })\n .exec();", 
            "title": "Aggregate.prototype.facet()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypepipeline", 
            "text": "\u8fd4\u56de  Returns the current pipeline  \u793a\u4f8b  MyModel . aggregate () . match ( {   test :   1   } ) . pipeline ();", 
            "title": "Aggregate.prototype.pipeline()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypeexec", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Executes the aggregate pipeline on the currently bound Model.  \u793a\u4f8b  aggregate.exec(callback);\n\nvar promise = aggregate.exec();\npromise.then(..);", 
            "title": "Aggregate.prototype.exec()"
        }, 
        {
            "location": "/api/Aggregate/#aggregateprototypethen", 
            "text": "\u53c2\u6570   [reject] \u00abFunction\u00bb errorCallback   \u8fd4\u56de  Provides promise for aggregate.  \u793a\u4f8b  Model.aggregate(..).then(successCallback, errorCallback);", 
            "title": "Aggregate.prototype.then()"
        }, 
        {
            "location": "/api/VirtualType/", 
            "text": "\u865a\u62df\u7c7b\u578b\n\n\nVirtualType()\n\n\nVirtualType constructor\n\n\nThis is what mongoose uses to define virtual attributes via \nSchema.prototype.virtual\n.\n\n\n\u793a\u4f8b\n\n\nvar fullname = schema.virtual(\nfullname\n);\nfullname instanceof mongoose.VirtualType\n\n\n\n\n\nVirtualType.prototype.get()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDefines a getter.\n\n\n\u793a\u4f8b\n\n\nvar virtual = schema.virtual(\nfullname\n);\nvirtual.get(function () {\n  return this.name.first + \n \n + this.name.last;\n});\n\n\n\n\n\nVirtualType.prototype.set()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\nDefines a setter.\n\n\n\u793a\u4f8b\n\n\nvar virtual = schema.virtual(\nfullname\n);\nvirtual.set(function (v) {\n  var parts = v.split(\n \n);\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});\n\n\n\n\n\nVirtualType.prototype.applyGetters()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abany\u00bb the value after applying all getters\n\n\n\n\nApplies getters to \nvalue\n using optional \nscope\n.\n\n\nVirtualType.prototype.applySetters()\n\n\n\u53c2\u6570\n\n\n\u8fd4\u56de\n\n\n\n\n\u00abany\u00bb the value after applying all setters\n\n\n\n\nApplies setters to \nvalue\n using optional \nscope\n.", 
            "title": "\u865a\u62df\u7c7b\u578b"
        }, 
        {
            "location": "/api/VirtualType/#_1", 
            "text": "", 
            "title": "\u865a\u62df\u7c7b\u578b"
        }, 
        {
            "location": "/api/VirtualType/#virtualtype", 
            "text": "VirtualType constructor  This is what mongoose uses to define virtual attributes via  Schema.prototype.virtual .  \u793a\u4f8b  var fullname = schema.virtual( fullname );\nfullname instanceof mongoose.VirtualType", 
            "title": "VirtualType()"
        }, 
        {
            "location": "/api/VirtualType/#virtualtypeprototypeget", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Defines a getter.  \u793a\u4f8b  var virtual = schema.virtual( fullname );\nvirtual.get(function () {\n  return this.name.first +     + this.name.last;\n});", 
            "title": "VirtualType.prototype.get()"
        }, 
        {
            "location": "/api/VirtualType/#virtualtypeprototypeset", 
            "text": "\u53c2\u6570  \u8fd4\u56de  Defines a setter.  \u793a\u4f8b  var virtual = schema.virtual( fullname );\nvirtual.set(function (v) {\n  var parts = v.split(   );\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});", 
            "title": "VirtualType.prototype.set()"
        }, 
        {
            "location": "/api/VirtualType/#virtualtypeprototypeapplygetters", 
            "text": "\u53c2\u6570  \u8fd4\u56de   \u00abany\u00bb the value after applying all getters   Applies getters to  value  using optional  scope .", 
            "title": "VirtualType.prototype.applyGetters()"
        }, 
        {
            "location": "/api/VirtualType/#virtualtypeprototypeapplysetters", 
            "text": "\u53c2\u6570  \u8fd4\u56de   \u00abany\u00bb the value after applying all setters   Applies setters to  value  using optional  scope .", 
            "title": "VirtualType.prototype.applySetters()"
        }, 
        {
            "location": "/api/Error/", 
            "text": "\u9519\u8bef\n\n\nMongooseError()\n\n\n\u53c2\u6570\n\n\n\n\nmsg \u00abString\u00bb Error message\n\n\n\n\nMongooseError constructor\n\n\nMongooseError.messages\n\n\nThe default built-in validator error messages.\n\n\nMongooseError.DocumentNotFoundError\n\n\nAn instance of this error class will be returned when \nsave()\n fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to \nupdate()\n when trying to update the document.\n\n\nMongooseError.CastError\n\n\nAn instance of this error class will be returned when mongoose failed to cast a value.\n\n\nMongooseError.ValidationError\n\n\nAn instance of this error class will be returned when [validation failed.\n\n\nMongooseError.ValidatorError\n\n\nA \nValidationError\n has a hash of \nerrors\n that contain individual \nValidatorError\n instances\n\n\nMongooseError.VersionError\n\n\nAn instance of this error class will be returned when you call \nsave()\n after the document in the database was changed in a potentially unsafe way. See the [\nversionKey\n option for more information.\n\n\nMongooseError.OverwriteModelError\n\n\nMongooseError.MissingSchemaError\n\n\nThrown when you try to access a model that has not been registered yet\n\n\nMongooseError.DivergentArrayError\n\n\nAn instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.", 
            "title": "\u9519\u8bef"
        }, 
        {
            "location": "/api/Error/#_1", 
            "text": "", 
            "title": "\u9519\u8bef"
        }, 
        {
            "location": "/api/Error/#mongooseerror", 
            "text": "\u53c2\u6570   msg \u00abString\u00bb Error message   MongooseError constructor", 
            "title": "MongooseError()"
        }, 
        {
            "location": "/api/Error/#mongooseerrormessages", 
            "text": "The default built-in validator error messages.", 
            "title": "MongooseError.messages"
        }, 
        {
            "location": "/api/Error/#mongooseerrordocumentnotfounderror", 
            "text": "An instance of this error class will be returned when  save()  fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to  update()  when trying to update the document.", 
            "title": "MongooseError.DocumentNotFoundError"
        }, 
        {
            "location": "/api/Error/#mongooseerrorcasterror", 
            "text": "An instance of this error class will be returned when mongoose failed to cast a value.", 
            "title": "MongooseError.CastError"
        }, 
        {
            "location": "/api/Error/#mongooseerrorvalidationerror", 
            "text": "An instance of this error class will be returned when [validation failed.", 
            "title": "MongooseError.ValidationError"
        }, 
        {
            "location": "/api/Error/#mongooseerrorvalidatorerror", 
            "text": "A  ValidationError  has a hash of  errors  that contain individual  ValidatorError  instances", 
            "title": "MongooseError.ValidatorError"
        }, 
        {
            "location": "/api/Error/#mongooseerrorversionerror", 
            "text": "An instance of this error class will be returned when you call  save()  after the document in the database was changed in a potentially unsafe way. See the [ versionKey  option for more information.", 
            "title": "MongooseError.VersionError"
        }, 
        {
            "location": "/api/Error/#mongooseerroroverwritemodelerror", 
            "text": "", 
            "title": "MongooseError.OverwriteModelError"
        }, 
        {
            "location": "/api/Error/#mongooseerrormissingschemaerror", 
            "text": "Thrown when you try to access a model that has not been registered yet", 
            "title": "MongooseError.MissingSchemaError"
        }, 
        {
            "location": "/api/Error/#mongooseerrordivergentarrayerror", 
            "text": "An instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.", 
            "title": "MongooseError.DivergentArrayError"
        }, 
        {
            "location": "/VersionCompatibility/", 
            "text": "MongoDB\u670d\u52a1\u5668\u7248\u672c\u517c\u5bb9\u6027\n\n\n\u6e90\n\n\nMongoose\u4f9d\u9760\nMongoDB Node.js \u9a71\u52a8\u5668\n\u4e0eMongoDB\u8fdb\u884c\u901a\u4fe1\u3002 \u60a8\u53ef\u4ee5\u53c2\u8003\n\u6b64\u8868\n\u83b7\u53d6\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u9a71\u52a8\u7a0b\u5e8f\u652f\u6301\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u7684\u6700\u65b0\u4fe1\u606f\u3002\n\n\n\u4e0b\u9762\u662f\u4ee3\u8868\u54ea\u4e2a\u7248\u672c\u7684mongoose\u4e0e\u5217\u51fa\u7684MongoDB\u7248\u672c\u517c\u5bb9\u7684\nsemver\n\u8303\u56f4\n\n\n\n\nMongoDB \u670d\u52a1\u5668 2.4.x: mongoose \n~3.8\n \u6216\u8005 \n4.x\n\n\nMongoDB \u670d\u52a1\u5668 2.6.x: mongoose \n~3.8.8\n \u6216\u8005 \n4.x\n\n\nMongoDB \u670d\u52a1\u5668 3.0.x: mongoose \n~3.8.22\n, \n4.x\n \u6216\u8005 \n5.x\n\n\nMongoDB \u670d\u52a1\u5668 3.2.x: mongoose \n=4.3.0\n \u6216\u8005 \n5.x\n\n\nMongoDB \u670d\u52a1\u5668 3.4.x: mongoose \n=4.7.3\n \u6216\u8005 \n5.x\n\n\nMongoDB \u670d\u52a1\u5668 3.6.x: mongoose \n5.x\n, \u6216\u8005 \n=4.11.0\n with \nuseMongoClient\n and \nusePushEach", 
            "title": "\u7248\u672c\u517c\u5bb9\u6027"
        }, 
        {
            "location": "/VersionCompatibility/#mongodb", 
            "text": "\u6e90  Mongoose\u4f9d\u9760 MongoDB Node.js \u9a71\u52a8\u5668 \u4e0eMongoDB\u8fdb\u884c\u901a\u4fe1\u3002 \u60a8\u53ef\u4ee5\u53c2\u8003 \u6b64\u8868 \u83b7\u53d6\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u9a71\u52a8\u7a0b\u5e8f\u652f\u6301\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u7684\u6700\u65b0\u4fe1\u606f\u3002  \u4e0b\u9762\u662f\u4ee3\u8868\u54ea\u4e2a\u7248\u672c\u7684mongoose\u4e0e\u5217\u51fa\u7684MongoDB\u7248\u672c\u517c\u5bb9\u7684 semver \u8303\u56f4   MongoDB \u670d\u52a1\u5668 2.4.x: mongoose  ~3.8  \u6216\u8005  4.x  MongoDB \u670d\u52a1\u5668 2.6.x: mongoose  ~3.8.8  \u6216\u8005  4.x  MongoDB \u670d\u52a1\u5668 3.0.x: mongoose  ~3.8.22 ,  4.x  \u6216\u8005  5.x  MongoDB \u670d\u52a1\u5668 3.2.x: mongoose  =4.3.0  \u6216\u8005  5.x  MongoDB \u670d\u52a1\u5668 3.4.x: mongoose  =4.7.3  \u6216\u8005  5.x  MongoDB \u670d\u52a1\u5668 3.6.x: mongoose  5.x , \u6216\u8005  =4.11.0  with  useMongoClient  and  usePushEach", 
            "title": "MongoDB\u670d\u52a1\u5668\u7248\u672c\u517c\u5bb9\u6027"
        }, 
        {
            "location": "/FAQ/", 
            "text": "\u5e38\u89c1\u95ee\u9898\n\n\n\u6e90\n\n\n\u5f53\u6211\u76f4\u63a5\u66f4\u65b0\u6570\u7ec4\u5143\u7d20\u65f6\u200b\u200b\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u66f4\u6539\uff1f\ndoc\n.\narray\n[\n3\n]\n \n=\n \nchanged\n;\n\n\ndoc\n.\nsave\n();\n\n\n\n\n\u7b54\u6848\nMongoose\u4e0d\u4f1a\u4e3a\u6570\u7ec4\u7d22\u5f15\u521b\u5efagetter/setter; \u6ca1\u6709\u4ed6\u4eec\u732b\u9f2c\u4ece\u6765\u6ca1\u6709\u5f97\u5230\u901a\u77e5\u7684\u53d8\u5316\uff0c\u6240\u4ee5\u4e0d\u77e5\u9053\u575a\u6301\u65b0\u7684\u4ef7\u503c\u3002 \u89e3\u51b3\u65b9\u6cd5\u662f\u4f7f\u7528\n Mongoose\n = 3.2.0 \n\u4e2d\u7684\nMongooseArray\uff03set\n\u3002\ndoc\n.\narray\n.\nset\n(\n3\n,\n \nchanged\n);\n\n\ndoc\n.\nsave\n();\n\n\ndoc\n.\narray\n[\n3\n]\n \n=\n \nchanged\n;\n\n\ndoc\n.\nmarkModified\n(\narray\n);\n\n\ndoc\n.\nsave\n();\n\n\n\n\n\u6211\u5b9a\u4e49\u6a21\u5f0f\u5c5e\u6027\u4e3a\u201cunique\u201d\uff0c\u4f46\u6211\u4ecd\u7136\u53ef\u4ee5\u4fdd\u5b58\u4e86\u91cd\u590d\u6570\u636e,\u662f\u4ec0\u4e48\u5bfc\u81f4\u7684\uff1f\n\u7b54\u6848\nMongoose\u672c\u8eab\u5e76\u4e0d\u5904\u7406\nunique\n\uff1a\n{name\uff1a{type\uff1aString\uff0cunique\uff1atrue}}\n\u53ea\u662f\u5728\nname\n\u4e0a\u521b\u5efa\u4e00\u4e2a[MongoDB\u552f\u4e00\u7d22\u5f15]\u7684\u7b80\u5199\n2\n \u4f8b\u5982\uff0c\u5982\u679cMongoDB\u5728\nname\n\u4e0a\u6ca1\u6709\u552f\u4e00\u7684\u7d22\u5f15\uff0c \u5c3d\u7ba1\u201cunique\u201d\u662f\u771f\u5b9e\u7684\uff0c\u4f46\u4e0b\u9762\u7684\u4ee3\u7801\u4e0d\u4f1a\u51fa\u9519\u3002\n    \nvar\n \nschema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\n\n      \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nunique\n:\n \ntrue\n \n}\n\n    \n});\n\n    \nvar\n \nModel\n \n=\n \ndb\n.\nmodel\n(\nTest\n,\n \nschema\n);\n\n\n    \nModel\n.\ncreate\n([{\n \nname\n:\n \nVal\n \n},\n \n{\n \nname\n:\n \nVal\n \n}],\n \nfunction\n(\nerr\n)\n \n{\n\n      \nconsole\n.\nlog\n(\nerr\n);\n\n    \n});\n\n\n\n\n\u7136\u800c\uff0c \u5982\u679c\u60a8\u4f7f\u7528\nModel.on\uff08'index'\uff09\n\u4e8b\u4ef6\u7b49\u5f85\u7d22\u5f15\u5efa\u7acb\uff0c\u5c1d\u8bd5\u4fdd\u5b58\u91cd\u590d\u5c06\u4f1a\u629b\u9519\n    \nvar\n \nschema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\n\n      \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nunique\n:\n \ntrue\n \n}\n\n    \n});\n\n    \nvar\n \nModel\n \n=\n \ndb\n.\nmodel\n(\nTest\n,\n \nschema\n);\n\n\n    \nModel\n.\non\n(\nindex\n,\n \nfunction\n(\nerr\n)\n \n{\n\n      \nassert\n.\nifError\n(\nerr\n);\n\n      \nModel\n.\ncreate\n([{\n \nname\n:\n \nVal\n \n},\n \n{\n \nname\n:\n \nVal\n \n}],\n \nfunction\n(\nerr\n)\n \n{\n\n        \nconsole\n.\nlog\n(\nerr\n);\n\n      \n});\n\n    \n});\n\n\n    \nModel\n.\ninit\n().\nthen\n(\nfunction\n()\n \n{\n\n      \nassert\n.\nifError\n(\nerr\n);\n\n      \nModel\n.\ncreate\n([{\n \nname\n:\n \nVal\n \n},\n \n{\n \nname\n:\n \nVal\n \n}],\n \nfunction\n(\nerr\n)\n \n{\n\n        \nconsole\n.\nlog\n(\nerr\n);\n\n      \n});\n\n    \n});\n\n\n\n\nMongoDB\u575a\u6301\u7d22\u5f15\uff0c \u6240\u4ee5\u4f60\u53ea\u9700\u8981\u91cd\u65b0\u5efa\u7acb\u7d22\u5f15\uff0c\u5982\u679c\u4f60\u5f00\u59cb\u4e00\u4e2a\u65b0\u7684\u6570\u636e\u5e93\uff0c\u6216\u8005\u4f60\u8fd0\u884c\ndb.dropDatabase\uff08\uff09\n\u3002\u5728\u751f\u4ea7\u73af\u5883\u4e2d\uff0c \u4f60\u5e94\u8be5[\u4f7f\u7528MongoDB shell]\uff09\uff08\uff09\u521b\u5efa\u7d22\u5f15\uff0c\u800c\u4e0d\u662f\u4f9d\u9760\u732b\u9f2c\u4e3a\u4f60\u505a\u3002 \u6a21\u5f0f\u7684\nunique\n\u9009\u9879\u65b9\u4fbf\u5f00\u53d1\u548c\u6587\u6863\u5316\uff0c\u4f46\u732b\u9f2c\u4e0d\u662f\u7d22\u5f15\u7ba1\u7406\u89e3\u51b3\u65b9\u6848\n\u5f53\u6211\u5728\u6a21\u5f0f\u4e2d\u6709\u4e00\u4e2a\u5d4c\u5957\u5c5e\u6027\u65f6\uff0cmongoose\u9ed8\u8ba4\u6dfb\u52a0\u7a7a\u5bf9\u8c61,\u4e3a\u4ec0\u4e48\uff1f\nvar\n \nschema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\n\n  \nnested\n:\n \n{\n\n    \nprop\n:\n \nString\n\n  \n}\n\n\n});\n\n\nvar\n \nModel\n \n=\n \ndb\n.\nmodel\n(\nTest\n,\n \nschema\n);\n\n\nconsole\n.\nlog\n(\nnew\n \nModel\n());\n\n\n\n\n\u7b54\u6848\n\u8fd9\u662f\u4e00\u4e2a\u6027\u80fd\u4f18\u5316 \u8fd9\u4e9b\u7a7a\u7684\u5bf9\u8c61\u4e0d\u4f1a\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\uff0c \u4e5f\u4e0d\u662f\u5728\u7ed3\u679c\ntoObject\uff08\uff09\n\u4e2d\uff0c \u9664\u975e\u5173\u95ed\nminimize\n\u9009\u9879\n\uff0c\u5426\u5219\u5b83\u4eec\u4e0d\u4f1a\u51fa\u73b0\u5728\nJSON.stringify\uff08\uff09\n\u8f93\u51fa\u4e2d\u3002\n\u8fd9\u79cd\u884c\u4e3a\u7684\u539f\u56e0\u662fMongoose\u7684\u53d8\u5316\u68c0\u6d4b\u548cgetter / setter\u662f\u57fa\u4e8e\nObject.defineProperty\uff08\uff09\n\u3002\u4e3a\u4e86\u652f\u6301\u5bf9\u5d4c\u5957\u5c5e\u6027\u7684\u66f4\u6539\u68c0\u6d4b\uff0c\u800c\u4e0d\u4f1a\u5728\u6bcf\u6b21\u521b\u5efa\u6587\u6863\u65f6\u62db\u81f4\u8fd0\u884cObject.defineProperty\uff08\uff09\u7684\u5f00\u9500\uff0c mongoose\u5728\u6a21\u578b\u7f16\u8bd1\u65f6\u5b9a\u4e49\nModel\n\u539f\u578b\u7684\u5c5e\u6027\u3002,\u7531\u4e8e\u732b\u9f2c\u9700\u8981\u4e3a\nnested.prop\n\u5b9a\u4e49getter\u548csetter\uff0c \u5fc5\u987b\u59cb\u7ec8\u5c06\u201c\u5d4c\u5957\u201d\u5b9a\u4e49\u4e3a\u732b\u9f2c\u6587\u6863\u4e0a\u7684\u5bf9\u8c61\uff0c \u5373\u4f7f\nnested\n\u5728\u5e95\u5c42\u7684\nPOJO\n\u4e0a\u662f\u672a\u5b9a\u4e49\u7684\u3002\n\u6211\u5728\nvirtual\n\uff0cgetter/setter\u6216\nmethod\n\u4f7f\u7528\u7bad\u5934\u51fd\u6570\uff0cthis\u7684\u503c\u662f\u4e3a\u4ec0\u4e48\u662f\u9519\u8bef\u7684\uff1f\n\u7b54\u6848\n\u7bad\u5934\u51fd\u6570\n\u5904\u7406\nthis\n\u5173\u952e\u5b57\u4e0e\u4f20\u7edf\u51fd\u6570\u5927\u4e0d\u76f8\u540c\n. Mongoose getter/setter\u4f9d\u8d56\nthis\n\u6765\u8ba9\u4f60\u8bbf\u95ee\u4f60\u6b63\u5728\u5199\u7684\u6587\u6863\uff0c\u4f46\u662f\u8fd9\u4e2a\u529f\u80fd\u4e0d\u80fd\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u3002 \u9664\u975e\u4e0d\u6253\u7b97\u8bbf\u95eegetter/setter\u4e2d\u7684\u6587\u6863\uff0c\u5426\u5219\u4e0d\u8981\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u6765\u53d6\u5f97 Mongoose getter/setter\u3002\n    \nvar\n \nschema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n({\n\n      \npropWithGetter\n:\n \n{\n\n        \ntype\n:\n \nString\n,\n\n        \nget\n:\n \nv\n \n=\n \n{\n\n          \nconsole\n.\nlog\n(\nthis\n);\n\n          \nreturn\n \nv\n;\n\n        \n}\n\n      \n}\n\n    \n});\n\n\n    \nschema\n.\nmethod\n.\narrowMethod\n \n=\n \n()\n \n=\n \nthis\n;\n\n    \nschema\n.\nvirtual\n(\nvirtualWithArrow\n).\nget\n(()\n \n=\n \n{\n\n      \nconsole\n.\nlog\n(\nthis\n);\n\n    \n});\n\n\n\n\n\u6211\u6709\u4e00\u4e2a\u540d\u4e3a\ntype\n\u7684\u5d4c\u5165\u5f0f\u5c5e\u6027\u662f\u8fd9\u6837\u7684\uff1a\nconst\n \nholdingSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nasset\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n    \nticker\n:\n \nString\n\n  \n}\n\n\n});\n\n\n\n\n\u4f46mongoose\u7ed9\u4e86\u6211\u4e00\u4e2aCastError\u63d0\u793a\uff0c\u5f53\u6211\u8bd5\u56fe\u7528\u4e00\u4e2a\nasset\n\u5bf9\u8c61\u6765\u4fdd\u5b58\nHolding\n\u65f6\uff0c\u5b83\u4e0d\u80fd\u628a\u4e00\u4e2a\u5bf9\u8c61\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002\n  \nHolding\n.\ncreate\n({\n \nasset\n:\n \n{\n \ntype\n:\n \nstock\n,\n \nticker\n:\n \nMDB\n \n}\n \n}).\ncatch\n(\nerror\n \n=\n \n{\n\n    \nconsole\n.\nerror\n(\nerror\n);\n\n  \n});\n\n\n\n\n\u7b54\u6848\n\u201c\u7c7b\u578b\u201d\u5c5e\u6027\u5728\u732b\u9f2c\u662f\u7279\u522b\u7684\uff0c\u6240\u4ee5\u5f53\u4f60\u8bf4\ntype\uff1aString\n\u65f6\uff0c\u732b\u9f2c\u628a\u5b83\u89e3\u91ca\u4e3a\u4e00\u4e2a\u7c7b\u578b\u58f0\u660e. \u5728\u4e0a\u9762\u7684\u6a21\u5f0f\u4e2d\uff0c\u732b\u9f2c\u8ba4\u4e3a\u201casset\u201d\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5bf9\u8c61\u3002,\u505a\u8fd9\u4e2a\uff0c\u800c\u4e0d\u662f\uff1a\n  \nconst\n \nholdingSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \nasset\n:\n \n{\n\n      \ntype\n:\n \n{\n \ntype\n:\n \nString\n \n},\n\n      \nticker\n:\n \nString\n\n    \n}\n\n  \n});\n\n\n\n\n\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u5bf9\u65e5\u671f\u5bf9\u8c61\uff08\u4f8b\u5982\ndate.setMonth\uff081\uff09;\n\uff09\u8fdb\u884c\u5c31\u5730\u4fee\u6539\uff1f\ndoc\n.\ncreatedAt\n.\nsetDate\n(\n2011\n,\n \n5\n,\n \n1\n);\n\n\ndoc\n.\nsave\n();\n\n\n\n\n\u7b54\u6848\nMongoose\u76ee\u524d\u4e0d\u4f1a\u76d1\u89c6\u65e5\u671f\u5bf9\u8c61\u7684\u5c31\u5730\u66f4\u65b0,\u5982\u679c\u60a8\u9700\u8981\u8fd9\u4e2a\u529f\u80fd\uff0c\u8bf7\u968f\u65f6\u5728\n\u6b64GitHub\u95ee\u9898\n\u4e0a\u8ba8\u8bba\u3002,\u6709\u51e0\u4e2a\u89e3\u51b3\u65b9\u6cd5\uff1a\n    \ndoc\n.\ncreatedAt\n.\nsetDate\n(\n2011\n,\n \n5\n,\n \n1\n);\n\n    \ndoc\n.\nmarkModified\n(\ncreatedAt\n);\n\n    \ndoc\n.\nsave\n();\n\n\n    \ndoc\n.\ncreatedAt\n \n=\n \nnew\n \nDate\n(\n2011\n,\n \n5\n,\n \n1\n).\nsetHours\n(\n4\n);\n\n    \ndoc\n.\nsave\n();\n\n\n\n\n\u6211\u5728\u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u586b\u5145\u6570\u7ec4\u4e0b\u7684\u5d4c\u5957\u5c5e\u6027\uff1a\n  \nnew\n \nSchema\n({\n\n    \narr\n:\n \n[{\n\n      \nchild\n:\n \n{\n \nref\n:\n \nOtherModel\n,\n \ntype\n:\n \nSchema\n.\nTypes\n.\nObjectId\n \n}\n\n    \n}]\n\n  \n});\n\n\n\n\n.populate\uff08{path\uff1a'arr.child'\uff0coptions\uff1a{sort\uff1a'name'}}\uff09\n\u4e0d\u4f1a\u88ab\narr.child.name\n\u6392\u5e8f\n\u7b54\u6848\n\u89c1\n\u8fd9\u4e2aGitHub\u95ee\u9898\n\u3002,\u8fd9\u662f\u4e00\u4e2a\u5df2\u77e5\u7684\u95ee\u9898\uff0c\u4f46\u662f\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u96be\u4ee5\u89e3\u51b3\u7684\u95ee\u9898\n\u6211\u7684\u6a21\u578b\u4e0a\u7684\u6240\u6709\u51fd\u6570\u8c03\u7528\u6302\u8d77\uff0c\u6211\u505a\u9519\u4e86\u4ec0\u4e48\uff1f\n\u7b54\u6848\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmongoose\u4f1a\u7f13\u51b2\u4f60\u7684\u51fd\u6570\u8c03\u7528\uff0c\u76f4\u5230\u5b83\u53ef\u4ee5\u8fde\u63a5\u5230MongoDB\u3002,\u9605\u8bfb\n\u8fde\u63a5\u6587\u6863\u7684\u7f13\u51b2\u90e8\u5206\n\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002\n\u6211\u600e\u6837\u624d\u80fd\u542f\u7528\u8c03\u8bd5\uff1f\n\u7b54\u6848\n\u5c06\ndebug\n\u9009\u9879\u8bbe\u7f6e\u4e3a\ntrue\n  \nmongoose\n.\nset\n(\ndebug\n,\n \ntrue\n)\n\n\n\n\n\u6240\u6709\u6267\u884c\u7684\u6536\u96c6\u65b9\u6cd5\u90fd\u4f1a\u5c06\u5176\u53c2\u6570\u7684\u8f93\u51fa\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002\n\u6211\u7684\nsave\uff08\uff09\n\u56de\u8c03\u4ece\u4e0d\u6267\u884c\u3002 \u6211\u7a76\u7adf\u505a\u9519\u4e86\u4ec0\u4e48\uff1f\n\u7b54\u6848\n\u6240\u6709\u7684\u201c\u96c6\u5408\u201d\u64cd\u4f5c\uff08\u63d2\u5165\uff0c\u5220\u9664\uff0c\u67e5\u8be2\u7b49\uff09\u90fd\u88ab\u6392\u961f\uff0c\u76f4\u5230\u201c\u8fde\u63a5\u201d\u6253\u5f00. \u5c1d\u8bd5\u8fde\u63a5\u65f6\u53ef\u80fd\u53d1\u751f\u9519\u8bef\u3002\u5c1d\u8bd5\u6dfb\u52a0\u4e00\u4e2a\u9519\u8bef\u5904\u7406\u7a0b\u5e8f\u5230\u60a8\u7684\u8fde\u63a5\u3002\n    \nmongoose\n.\nconnect\n(..);\n\n    \nmongoose\n.\nconnection\n.\non\n(\nerror\n,\n \nhandleError\n);\n\n\n    \nvar\n \nconn\n \n=\n \nmongoose\n.\ncreateConnection\n(..);\n\n    \nconn\n.\non\n(\nerror\n,\n \nhandleError\n);\n\n\n\n\n\u5982\u679c\u60a8\u60f3\u8981\u5728\u6574\u4e2a\u5e94\u7528\u7a0b\u5e8f\u4e2d\u9009\u62e9\u4e0d\u4f7f\u7528\u732b\u9f2c\u7684\u7f13\u51b2\u673a\u5236\uff0c\u8bf7\u5c06\u5168\u5c40\nbufferCommands\n\u9009\u9879\u8bbe\u7f6e\u4e3afalse\n    \nmongoose\n.\nset\n(\nbufferCommands\n,\n \nfalse\n);\n\n\n\n\n\u6211\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u6570\u636e\u5e93\u64cd\u4f5c\u521b\u5efa/\u9500\u6bc1\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5417\uff1f\n\u7b54\u6848\n\u4e0d\u7528\u3002\u5728\u5e94\u7528\u7a0b\u5e8f\u542f\u52a8\u65f6\u6253\u5f00\u8fde\u63a5\uff0c\u5e76\u4fdd\u6301\u6253\u5f00\u72b6\u6001\uff0c\u76f4\u5230\u5e94\u7528\u7a0b\u5e8f\u5173\u95ed\u3002\n\u4e3a\u4ec0\u4e48\u6211\u5f97\u5230\"OverwriteModelError: Cannot overwrite .. model once compiled\" \u5f53\u6211\u4f7f\u7528nodemon(\u4e00\u4e2a\u6d4b\u8bd5\u6846\u67b6)\uff1f\n\u7b54\u6848\nmongoose.model('ModelName',schema)'\u8981\u6c42\nModelName\n\u662f\u552f\u4e00\u7684\uff0c\n\u6240\u4ee5\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\nmongoose.model('ModelName')\n\u6765\u8bbf\u95ee\u6a21\u578b\u3002\n\u5982\u679c\u4f60\u628amongoose.model('ModelName',schema);\n\u653e\u5728\nmocha\nbeforeEach()\nhook\n\u4e2d\uff0c\n\u6b64\u4ee3\u7801\u5c06\u5c1d\u8bd5\u5728\n\u6bcf\n\u6d4b\u8bd5\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a\u201cModelName\u201d\u7684\u65b0\u6a21\u578b\uff0c \u6240\u4ee5\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u9519\u8bef\u3002\n\u786e\u4fdd\u4f60\u53ea\u7528\u4e00\u4e2a\u7ed9\u5b9a\u7684\u540d\u5b57\nonce\n\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6a21\u578b\u3002\n\u5982\u679c\u60a8\u9700\u8981\u521b\u5efa\u5177\u6709\u76f8\u540c\u540d\u79f0\u7684\u591a\u4e2a\u6a21\u578b\uff0c\u8bf7\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5e76\u5c06\u6a21\u578b\u7ed1\u5b9a\u5230\u8fde\u63a5\u3002\n    \nvar\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n    \nvar\n \nconnection\n \n=\n \nmongoose\n.\ncreateConnection\n(..);\n\n    \nvar\n \nkittySchema\n \n=\n \nmongoose\n.\nSchema\n({\n \nname\n:\n \nString\n \n});\n\n    \nvar\n \nKitten\n \n=\n \nconnection\n.\nmodel\n(\nKitten\n,\n \nkittySchema\n);\n\n\n\n\n\u8981\u6dfb\u52a0\u7684\u4e1c\u897f?\n\n\n\u5982\u679c\u60a8\u60f3\u8d21\u732e\u6b64\u9875\u9762\uff0c\u8bf7\u5728github\u4e0a\n\u8bbf\u95ee\u5b83\n\uff0c\u5e76\u4f7f\u7528\n\u7f16\u8f91\n\u6309\u94ae\u53d1\u9001\u62c9\u53d6\u8bf7\u6c42\u3002", 
            "title": "\u5e38\u95ee\u95ee\u9898"
        }, 
        {
            "location": "/FAQ/#_1", 
            "text": "\u6e90  \u5f53\u6211\u76f4\u63a5\u66f4\u65b0\u6570\u7ec4\u5143\u7d20\u65f6\u200b\u200b\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u66f4\u6539\uff1f doc . array [ 3 ]   =   changed ;  doc . save ();   \u7b54\u6848 Mongoose\u4e0d\u4f1a\u4e3a\u6570\u7ec4\u7d22\u5f15\u521b\u5efagetter/setter; \u6ca1\u6709\u4ed6\u4eec\u732b\u9f2c\u4ece\u6765\u6ca1\u6709\u5f97\u5230\u901a\u77e5\u7684\u53d8\u5316\uff0c\u6240\u4ee5\u4e0d\u77e5\u9053\u575a\u6301\u65b0\u7684\u4ef7\u503c\u3002 \u89e3\u51b3\u65b9\u6cd5\u662f\u4f7f\u7528  Mongoose  = 3.2.0  \u4e2d\u7684 MongooseArray\uff03set \u3002 doc . array . set ( 3 ,   changed );  doc . save ();  doc . array [ 3 ]   =   changed ;  doc . markModified ( array );  doc . save ();   \u6211\u5b9a\u4e49\u6a21\u5f0f\u5c5e\u6027\u4e3a\u201cunique\u201d\uff0c\u4f46\u6211\u4ecd\u7136\u53ef\u4ee5\u4fdd\u5b58\u4e86\u91cd\u590d\u6570\u636e,\u662f\u4ec0\u4e48\u5bfc\u81f4\u7684\uff1f \u7b54\u6848 Mongoose\u672c\u8eab\u5e76\u4e0d\u5904\u7406 unique \uff1a {name\uff1a{type\uff1aString\uff0cunique\uff1atrue}} \u53ea\u662f\u5728 name \u4e0a\u521b\u5efa\u4e00\u4e2a[MongoDB\u552f\u4e00\u7d22\u5f15]\u7684\u7b80\u5199 2  \u4f8b\u5982\uff0c\u5982\u679cMongoDB\u5728 name \u4e0a\u6ca1\u6709\u552f\u4e00\u7684\u7d22\u5f15\uff0c \u5c3d\u7ba1\u201cunique\u201d\u662f\u771f\u5b9e\u7684\uff0c\u4f46\u4e0b\u9762\u7684\u4ee3\u7801\u4e0d\u4f1a\u51fa\u9519\u3002      var   schema   =   new   mongoose . Schema ({ \n       name :   {   type :   String ,   unique :   true   } \n     }); \n     var   Model   =   db . model ( Test ,   schema ); \n\n     Model . create ([{   name :   Val   },   {   name :   Val   }],   function ( err )   { \n       console . log ( err ); \n     });   \u7136\u800c\uff0c \u5982\u679c\u60a8\u4f7f\u7528 Model.on\uff08'index'\uff09 \u4e8b\u4ef6\u7b49\u5f85\u7d22\u5f15\u5efa\u7acb\uff0c\u5c1d\u8bd5\u4fdd\u5b58\u91cd\u590d\u5c06\u4f1a\u629b\u9519      var   schema   =   new   mongoose . Schema ({ \n       name :   {   type :   String ,   unique :   true   } \n     }); \n     var   Model   =   db . model ( Test ,   schema ); \n\n     Model . on ( index ,   function ( err )   { \n       assert . ifError ( err ); \n       Model . create ([{   name :   Val   },   {   name :   Val   }],   function ( err )   { \n         console . log ( err ); \n       }); \n     }); \n\n     Model . init (). then ( function ()   { \n       assert . ifError ( err ); \n       Model . create ([{   name :   Val   },   {   name :   Val   }],   function ( err )   { \n         console . log ( err ); \n       }); \n     });   MongoDB\u575a\u6301\u7d22\u5f15\uff0c \u6240\u4ee5\u4f60\u53ea\u9700\u8981\u91cd\u65b0\u5efa\u7acb\u7d22\u5f15\uff0c\u5982\u679c\u4f60\u5f00\u59cb\u4e00\u4e2a\u65b0\u7684\u6570\u636e\u5e93\uff0c\u6216\u8005\u4f60\u8fd0\u884c db.dropDatabase\uff08\uff09 \u3002\u5728\u751f\u4ea7\u73af\u5883\u4e2d\uff0c \u4f60\u5e94\u8be5[\u4f7f\u7528MongoDB shell]\uff09\uff08\uff09\u521b\u5efa\u7d22\u5f15\uff0c\u800c\u4e0d\u662f\u4f9d\u9760\u732b\u9f2c\u4e3a\u4f60\u505a\u3002 \u6a21\u5f0f\u7684 unique \u9009\u9879\u65b9\u4fbf\u5f00\u53d1\u548c\u6587\u6863\u5316\uff0c\u4f46\u732b\u9f2c\u4e0d\u662f\u7d22\u5f15\u7ba1\u7406\u89e3\u51b3\u65b9\u6848 \u5f53\u6211\u5728\u6a21\u5f0f\u4e2d\u6709\u4e00\u4e2a\u5d4c\u5957\u5c5e\u6027\u65f6\uff0cmongoose\u9ed8\u8ba4\u6dfb\u52a0\u7a7a\u5bf9\u8c61,\u4e3a\u4ec0\u4e48\uff1f var   schema   =   new   mongoose . Schema ({ \n   nested :   { \n     prop :   String \n   }  });  var   Model   =   db . model ( Test ,   schema );  console . log ( new   Model ());   \u7b54\u6848 \u8fd9\u662f\u4e00\u4e2a\u6027\u80fd\u4f18\u5316 \u8fd9\u4e9b\u7a7a\u7684\u5bf9\u8c61\u4e0d\u4f1a\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\uff0c \u4e5f\u4e0d\u662f\u5728\u7ed3\u679c toObject\uff08\uff09 \u4e2d\uff0c \u9664\u975e\u5173\u95ed minimize \u9009\u9879 \uff0c\u5426\u5219\u5b83\u4eec\u4e0d\u4f1a\u51fa\u73b0\u5728 JSON.stringify\uff08\uff09 \u8f93\u51fa\u4e2d\u3002 \u8fd9\u79cd\u884c\u4e3a\u7684\u539f\u56e0\u662fMongoose\u7684\u53d8\u5316\u68c0\u6d4b\u548cgetter / setter\u662f\u57fa\u4e8e Object.defineProperty\uff08\uff09 \u3002\u4e3a\u4e86\u652f\u6301\u5bf9\u5d4c\u5957\u5c5e\u6027\u7684\u66f4\u6539\u68c0\u6d4b\uff0c\u800c\u4e0d\u4f1a\u5728\u6bcf\u6b21\u521b\u5efa\u6587\u6863\u65f6\u62db\u81f4\u8fd0\u884cObject.defineProperty\uff08\uff09\u7684\u5f00\u9500\uff0c mongoose\u5728\u6a21\u578b\u7f16\u8bd1\u65f6\u5b9a\u4e49 Model \u539f\u578b\u7684\u5c5e\u6027\u3002,\u7531\u4e8e\u732b\u9f2c\u9700\u8981\u4e3a nested.prop \u5b9a\u4e49getter\u548csetter\uff0c \u5fc5\u987b\u59cb\u7ec8\u5c06\u201c\u5d4c\u5957\u201d\u5b9a\u4e49\u4e3a\u732b\u9f2c\u6587\u6863\u4e0a\u7684\u5bf9\u8c61\uff0c \u5373\u4f7f nested \u5728\u5e95\u5c42\u7684 POJO \u4e0a\u662f\u672a\u5b9a\u4e49\u7684\u3002 \u6211\u5728 virtual \uff0cgetter/setter\u6216 method \u4f7f\u7528\u7bad\u5934\u51fd\u6570\uff0cthis\u7684\u503c\u662f\u4e3a\u4ec0\u4e48\u662f\u9519\u8bef\u7684\uff1f \u7b54\u6848 \u7bad\u5934\u51fd\u6570 \u5904\u7406 this \u5173\u952e\u5b57\u4e0e\u4f20\u7edf\u51fd\u6570\u5927\u4e0d\u76f8\u540c . Mongoose getter/setter\u4f9d\u8d56 this \u6765\u8ba9\u4f60\u8bbf\u95ee\u4f60\u6b63\u5728\u5199\u7684\u6587\u6863\uff0c\u4f46\u662f\u8fd9\u4e2a\u529f\u80fd\u4e0d\u80fd\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u3002 \u9664\u975e\u4e0d\u6253\u7b97\u8bbf\u95eegetter/setter\u4e2d\u7684\u6587\u6863\uff0c\u5426\u5219\u4e0d\u8981\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u6765\u53d6\u5f97 Mongoose getter/setter\u3002      var   schema   =   new   mongoose . Schema ({ \n       propWithGetter :   { \n         type :   String , \n         get :   v   =   { \n           console . log ( this ); \n           return   v ; \n         } \n       } \n     }); \n\n     schema . method . arrowMethod   =   ()   =   this ; \n     schema . virtual ( virtualWithArrow ). get (()   =   { \n       console . log ( this ); \n     });   \u6211\u6709\u4e00\u4e2a\u540d\u4e3a type \u7684\u5d4c\u5165\u5f0f\u5c5e\u6027\u662f\u8fd9\u6837\u7684\uff1a const   holdingSchema   =   new   Schema ({ \n   asset :   { \n     type :   String , \n     ticker :   String \n   }  });   \u4f46mongoose\u7ed9\u4e86\u6211\u4e00\u4e2aCastError\u63d0\u793a\uff0c\u5f53\u6211\u8bd5\u56fe\u7528\u4e00\u4e2a asset \u5bf9\u8c61\u6765\u4fdd\u5b58 Holding \u65f6\uff0c\u5b83\u4e0d\u80fd\u628a\u4e00\u4e2a\u5bf9\u8c61\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002    Holding . create ({   asset :   {   type :   stock ,   ticker :   MDB   }   }). catch ( error   =   { \n     console . error ( error ); \n   });   \u7b54\u6848 \u201c\u7c7b\u578b\u201d\u5c5e\u6027\u5728\u732b\u9f2c\u662f\u7279\u522b\u7684\uff0c\u6240\u4ee5\u5f53\u4f60\u8bf4 type\uff1aString \u65f6\uff0c\u732b\u9f2c\u628a\u5b83\u89e3\u91ca\u4e3a\u4e00\u4e2a\u7c7b\u578b\u58f0\u660e. \u5728\u4e0a\u9762\u7684\u6a21\u5f0f\u4e2d\uff0c\u732b\u9f2c\u8ba4\u4e3a\u201casset\u201d\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5bf9\u8c61\u3002,\u505a\u8fd9\u4e2a\uff0c\u800c\u4e0d\u662f\uff1a    const   holdingSchema   =   new   Schema ({ \n     asset :   { \n       type :   {   type :   String   }, \n       ticker :   String \n     } \n   });   \u4e3a\u4ec0\u4e48\u4e0d\u80fd\u5bf9\u65e5\u671f\u5bf9\u8c61\uff08\u4f8b\u5982 date.setMonth\uff081\uff09; \uff09\u8fdb\u884c\u5c31\u5730\u4fee\u6539\uff1f doc . createdAt . setDate ( 2011 ,   5 ,   1 );  doc . save ();   \u7b54\u6848 Mongoose\u76ee\u524d\u4e0d\u4f1a\u76d1\u89c6\u65e5\u671f\u5bf9\u8c61\u7684\u5c31\u5730\u66f4\u65b0,\u5982\u679c\u60a8\u9700\u8981\u8fd9\u4e2a\u529f\u80fd\uff0c\u8bf7\u968f\u65f6\u5728 \u6b64GitHub\u95ee\u9898 \u4e0a\u8ba8\u8bba\u3002,\u6709\u51e0\u4e2a\u89e3\u51b3\u65b9\u6cd5\uff1a      doc . createdAt . setDate ( 2011 ,   5 ,   1 ); \n     doc . markModified ( createdAt ); \n     doc . save (); \n\n     doc . createdAt   =   new   Date ( 2011 ,   5 ,   1 ). setHours ( 4 ); \n     doc . save ();   \u6211\u5728\u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u586b\u5145\u6570\u7ec4\u4e0b\u7684\u5d4c\u5957\u5c5e\u6027\uff1a    new   Schema ({ \n     arr :   [{ \n       child :   {   ref :   OtherModel ,   type :   Schema . Types . ObjectId   } \n     }] \n   });   .populate\uff08{path\uff1a'arr.child'\uff0coptions\uff1a{sort\uff1a'name'}}\uff09 \u4e0d\u4f1a\u88ab arr.child.name \u6392\u5e8f \u7b54\u6848 \u89c1 \u8fd9\u4e2aGitHub\u95ee\u9898 \u3002,\u8fd9\u662f\u4e00\u4e2a\u5df2\u77e5\u7684\u95ee\u9898\uff0c\u4f46\u662f\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u96be\u4ee5\u89e3\u51b3\u7684\u95ee\u9898 \u6211\u7684\u6a21\u578b\u4e0a\u7684\u6240\u6709\u51fd\u6570\u8c03\u7528\u6302\u8d77\uff0c\u6211\u505a\u9519\u4e86\u4ec0\u4e48\uff1f \u7b54\u6848 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmongoose\u4f1a\u7f13\u51b2\u4f60\u7684\u51fd\u6570\u8c03\u7528\uff0c\u76f4\u5230\u5b83\u53ef\u4ee5\u8fde\u63a5\u5230MongoDB\u3002,\u9605\u8bfb \u8fde\u63a5\u6587\u6863\u7684\u7f13\u51b2\u90e8\u5206 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 \u6211\u600e\u6837\u624d\u80fd\u542f\u7528\u8c03\u8bd5\uff1f \u7b54\u6848 \u5c06 debug \u9009\u9879\u8bbe\u7f6e\u4e3a true    mongoose . set ( debug ,   true )   \u6240\u6709\u6267\u884c\u7684\u6536\u96c6\u65b9\u6cd5\u90fd\u4f1a\u5c06\u5176\u53c2\u6570\u7684\u8f93\u51fa\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002 \u6211\u7684 save\uff08\uff09 \u56de\u8c03\u4ece\u4e0d\u6267\u884c\u3002 \u6211\u7a76\u7adf\u505a\u9519\u4e86\u4ec0\u4e48\uff1f \u7b54\u6848 \u6240\u6709\u7684\u201c\u96c6\u5408\u201d\u64cd\u4f5c\uff08\u63d2\u5165\uff0c\u5220\u9664\uff0c\u67e5\u8be2\u7b49\uff09\u90fd\u88ab\u6392\u961f\uff0c\u76f4\u5230\u201c\u8fde\u63a5\u201d\u6253\u5f00. \u5c1d\u8bd5\u8fde\u63a5\u65f6\u53ef\u80fd\u53d1\u751f\u9519\u8bef\u3002\u5c1d\u8bd5\u6dfb\u52a0\u4e00\u4e2a\u9519\u8bef\u5904\u7406\u7a0b\u5e8f\u5230\u60a8\u7684\u8fde\u63a5\u3002      mongoose . connect (..); \n     mongoose . connection . on ( error ,   handleError ); \n\n     var   conn   =   mongoose . createConnection (..); \n     conn . on ( error ,   handleError );   \u5982\u679c\u60a8\u60f3\u8981\u5728\u6574\u4e2a\u5e94\u7528\u7a0b\u5e8f\u4e2d\u9009\u62e9\u4e0d\u4f7f\u7528\u732b\u9f2c\u7684\u7f13\u51b2\u673a\u5236\uff0c\u8bf7\u5c06\u5168\u5c40 bufferCommands \u9009\u9879\u8bbe\u7f6e\u4e3afalse      mongoose . set ( bufferCommands ,   false );   \u6211\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u6570\u636e\u5e93\u64cd\u4f5c\u521b\u5efa/\u9500\u6bc1\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5417\uff1f \u7b54\u6848 \u4e0d\u7528\u3002\u5728\u5e94\u7528\u7a0b\u5e8f\u542f\u52a8\u65f6\u6253\u5f00\u8fde\u63a5\uff0c\u5e76\u4fdd\u6301\u6253\u5f00\u72b6\u6001\uff0c\u76f4\u5230\u5e94\u7528\u7a0b\u5e8f\u5173\u95ed\u3002 \u4e3a\u4ec0\u4e48\u6211\u5f97\u5230\"OverwriteModelError: Cannot overwrite .. model once compiled\" \u5f53\u6211\u4f7f\u7528nodemon(\u4e00\u4e2a\u6d4b\u8bd5\u6846\u67b6)\uff1f \u7b54\u6848 mongoose.model('ModelName',schema)'\u8981\u6c42 ModelName \u662f\u552f\u4e00\u7684\uff0c\n\u6240\u4ee5\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 mongoose.model('ModelName') \u6765\u8bbf\u95ee\u6a21\u578b\u3002\n\u5982\u679c\u4f60\u628amongoose.model('ModelName',schema); \u653e\u5728 mocha beforeEach() hook \u4e2d\uff0c\n\u6b64\u4ee3\u7801\u5c06\u5c1d\u8bd5\u5728 \u6bcf \u6d4b\u8bd5\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a\u201cModelName\u201d\u7684\u65b0\u6a21\u578b\uff0c \u6240\u4ee5\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u9519\u8bef\u3002\n\u786e\u4fdd\u4f60\u53ea\u7528\u4e00\u4e2a\u7ed9\u5b9a\u7684\u540d\u5b57 once \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6a21\u578b\u3002\n\u5982\u679c\u60a8\u9700\u8981\u521b\u5efa\u5177\u6709\u76f8\u540c\u540d\u79f0\u7684\u591a\u4e2a\u6a21\u578b\uff0c\u8bf7\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5e76\u5c06\u6a21\u578b\u7ed1\u5b9a\u5230\u8fde\u63a5\u3002      var   mongoose   =   require ( mongoose ); \n     var   connection   =   mongoose . createConnection (..); \n     var   kittySchema   =   mongoose . Schema ({   name :   String   }); \n     var   Kitten   =   connection . model ( Kitten ,   kittySchema );   \u8981\u6dfb\u52a0\u7684\u4e1c\u897f?  \u5982\u679c\u60a8\u60f3\u8d21\u732e\u6b64\u9875\u9762\uff0c\u8bf7\u5728github\u4e0a \u8bbf\u95ee\u5b83 \uff0c\u5e76\u4f7f\u7528 \u7f16\u8f91 \u6309\u94ae\u53d1\u9001\u62c9\u53d6\u8bf7\u6c42\u3002", 
            "title": "\u5e38\u89c1\u95ee\u9898"
        }
    ]
}