{
    "docs": [
        {
            "location": "/", 
            "text": "mongoose\n\n\n\u4e3anode.js\u4f18\u96c5\u7684mongodb\u5bf9\u8c61\u5efa\u6a21\n\n\n\u9605\u8bfb\u6587\u6863\n\n\n\u53d1\u73b0\u63d2\u4ef6\n\n\nVersion 5.0.1\n\n\n\u9762\u5bf9\u73b0\u5b9e\u5427,\n\u7f16\u5199MongoDB\u9a8c\u8bc1\uff0c\u94f8\u9020\u548c\u4e1a\u52a1\u903b\u8f91\u6837\u677f\u662f\u4e00\u4e2a\u62d6\u7d2f\n. \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u5199\u4e86mongoose.\n\n\nconst\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/test\n);\n\n\n\nconst\n \nCat\n \n=\n \nmongoose\n.\nmodel\n(\nCat\n,\n \n{\n \nname\n:\n \nString\n \n});\n\n\n\nconst\n \nkitty\n \n=\n \nnew\n \nCat\n({\n \nname\n:\n \nZildjian\n \n});\n\n\nkitty\n.\nsave\n().\nthen\n(()\n \n=\n \nconsole\n.\nlog\n(\nmeow\n));\n\n\n\n\n\nMongoose\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\uff0c\u57fa\u4e8e\u6a21\u5f0f\u7684\u89e3\u51b3\u65b9\u6848\u6765\u5efa\u6a21\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6570\u636e\u3002\u5b83\u5305\u62ec\u5185\u7f6e\u7684\u7c7b\u578b\u8f6c\u6362\uff0c\u9a8c\u8bc1\uff0c\u67e5\u8be2\u6784\u5efa\uff0c\u4e1a\u52a1\u903b\u8f91\u94a9\u5b50\u7b49\u7b49\u3002\n\n\n\u5165\u95e8\n\n\n\u5feb\u901f\u5165\u95e8\u6307\u5357\n\n\n\u652f\u6301\n\n\n\n\n\u5806\u6808\u6ea2\u51fa\n\n\nGitHub\u95ee\u9898\n\n\n\u683c\u5b50\u804a\u5929\n\n\nMongoDB\u652f\u6301\n\n\n\n\n\u65b0\u95fb\n\n\n\u63a8\u7279\n\n\n\u66f4\u65b0\u65e5\u5fd7\n\n\n\u66f4\u65b0\u65e5\u5fd7\n\n\n\u8d5e\u52a9\u5546\n\n\n\n\n\u5728OpenCollective\u4e0a\u8d5e\u52a9Mongoose\u4ee5\u83b7\u5f97\u60a8\u516c\u53f8\u7684\u6807\u8bc6\uff01", 
            "title": "\u524d\u8a00"
        }, 
        {
            "location": "/#mongoose", 
            "text": "\u4e3anode.js\u4f18\u96c5\u7684mongodb\u5bf9\u8c61\u5efa\u6a21  \u9605\u8bfb\u6587\u6863  \u53d1\u73b0\u63d2\u4ef6  Version 5.0.1  \u9762\u5bf9\u73b0\u5b9e\u5427, \u7f16\u5199MongoDB\u9a8c\u8bc1\uff0c\u94f8\u9020\u548c\u4e1a\u52a1\u903b\u8f91\u6837\u677f\u662f\u4e00\u4e2a\u62d6\u7d2f . \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u5199\u4e86mongoose.  const   mongoose   =   require ( mongoose );  mongoose . connect ( mongodb://localhost/test );  const   Cat   =   mongoose . model ( Cat ,   {   name :   String   });  const   kitty   =   new   Cat ({   name :   Zildjian   });  kitty . save (). then (()   =   console . log ( meow ));   Mongoose\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\uff0c\u57fa\u4e8e\u6a21\u5f0f\u7684\u89e3\u51b3\u65b9\u6848\u6765\u5efa\u6a21\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6570\u636e\u3002\u5b83\u5305\u62ec\u5185\u7f6e\u7684\u7c7b\u578b\u8f6c\u6362\uff0c\u9a8c\u8bc1\uff0c\u67e5\u8be2\u6784\u5efa\uff0c\u4e1a\u52a1\u903b\u8f91\u94a9\u5b50\u7b49\u7b49\u3002", 
            "title": "mongoose"
        }, 
        {
            "location": "/#_1", 
            "text": "\u5feb\u901f\u5165\u95e8\u6307\u5357", 
            "title": "\u5165\u95e8"
        }, 
        {
            "location": "/#_2", 
            "text": "\u5806\u6808\u6ea2\u51fa  GitHub\u95ee\u9898  \u683c\u5b50\u804a\u5929  MongoDB\u652f\u6301", 
            "title": "\u652f\u6301"
        }, 
        {
            "location": "/#_3", 
            "text": "\u63a8\u7279", 
            "title": "\u65b0\u95fb"
        }, 
        {
            "location": "/#_4", 
            "text": "\u66f4\u65b0\u65e5\u5fd7", 
            "title": "\u66f4\u65b0\u65e5\u5fd7"
        }, 
        {
            "location": "/#_5", 
            "text": "\u5728OpenCollective\u4e0a\u8d5e\u52a9Mongoose\u4ee5\u83b7\u5f97\u60a8\u516c\u53f8\u7684\u6807\u8bc6\uff01", 
            "title": "\u8d5e\u52a9\u5546"
        }, 
        {
            "location": "/QuickStart/", 
            "text": "Mongoose v5.0.1: Getting Started\n\n\nSource\n\n\nGetting Started\n\n\nFirst be sure you have \nMongoDB\n and \nNode.js\n installed.\n\n\nNext install Mongoose from the command line using \nnpm\n:\n\n\n$ npm install mongoose\n\n\n\n\n\nNow say we like fuzzy kittens and want to record every kitten we ever meet in MongoDB. The first thing we need to do is include mongoose in our project and open a connection to the \ntest\n database on our locally running instance of MongoDB.\n\n\nvar\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/test\n);\n\n\n\n\n\n\nWe have a pending connection to the test database running on localhost. We now need to get notified if we connect successfully or if a connection error occurs:\n\n\nvar\n \ndb\n \n=\n \nmongoose\n.\nconnection\n;\n\n\ndb\n.\non\n(\nerror\n,\n \nconsole\n.\nerror\n.\nbind\n(\nconsole\n,\n \nconnection error:\n));\n\n\ndb\n.\nonce\n(\nopen\n,\n \nfunction\n()\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nOnce our connection opens, our callback will be called. For brevity, let's assume that all following code is within this callback.\n\n\nWith Mongoose, everything is derived from a \nSchema\n. Let's get a reference to it and define our kittens.\n\n\nvar kittySchema = mongoose.Schema({\n  name: String\n});\n\n\n\n\n\nSo far so good. We've got a schema with one property, \nname\n, which will be a \nString\n. The next step is compiling our schema into a \nModel\n.\n\n\nvar Kitten = mongoose.model(\nKitten\n, kittySchema);\n\n\n\n\n\nA model is a class with which we construct documents. In this case, each document will be a kitten with properties and behaviors as declared in our schema. Let's create a kitten document representing the little guy we just met on the sidewalk outside:\n\n\nvar\n \nsilence\n \n=\n \nnew\n \nKitten\n(\n{\n \nname\n:\n \nSilence\n \n}\n);\n\n\nconsole\n.\nlog\n(\nsilence\n.\nname\n);\n\n\n\n\n\n\nKittens can meow, so let's take a look at how to add \"speak\" functionality to our documents:\n\n\nkittySchema.methods.speak = function () {\n  var greeting = this.name\n    ? \nMeow name is \n + this.name\n    : \nI don\nt have a name\n;\n  console.log(greeting);\n}\n\nvar Kitten = mongoose.model(\nKitten\n, kittySchema);\n\n\n\n\n\nFunctions added to the \nmethods\n property of a schema get compiled into the \nModel\n prototype and exposed on each document instance:\n\n\nvar\n \nfluffy\n \n=\n \nnew\n \nKitten\n(\n{\n \nname\n:\n \nfluffy\n \n}\n);\n\n\nfluffy\n.\nspeak\n();\n\n\n\n\n\n\nWe have talking kittens! But we still haven't saved anything to MongoDB. Each document can be saved to the database by calling its \nsave\n method. The first argument to the callback will be an error if any occured.\n\n\n  fluffy.save(function (err, fluffy) {\n    if (err) return console.error(err);\n    fluffy.speak();\n  });\n\n\n\n\n\nSay time goes by and we want to display all the kittens we've seen. We can access all of the kitten documents through our Kitten \nmodel\n.\n\n\nKitten.find(function (err, kittens) {\n  if (err) return console.error(err);\n  console.log(kittens);\n})\n\n\n\n\n\nWe just logged all of the kittens in our db to the console. If we want to filter our kittens by name, Mongoose supports MongoDBs rich \nquerying\n syntax.\n\n\nKitten\n.\nfind\n(\n{\n \nname\n:\n \n/^\nfluff\n/\n \n}\n,\n \ncallback\n);\n\n\n\n\n\n\nThis performs a search for all documents with a name property that begins with \"Fluff\" and returns the result as an array of kittens to the callback.\n\n\nCongratulations\n\n\nThat's the end of our quick start. We created a schema, added a custom document method, saved and queried kittens in MongoDB using Mongoose. Head over to the \nguide\n, or \nAPI docs\n for more.", 
            "title": "\u5feb\u901f\u5f00\u59cb"
        }, 
        {
            "location": "/QuickStart/#mongoose-v501-getting-started", 
            "text": "Source", 
            "title": "Mongoose v5.0.1: Getting Started"
        }, 
        {
            "location": "/QuickStart/#getting-started", 
            "text": "First be sure you have  MongoDB  and  Node.js  installed.  Next install Mongoose from the command line using  npm :  $ npm install mongoose  Now say we like fuzzy kittens and want to record every kitten we ever meet in MongoDB. The first thing we need to do is include mongoose in our project and open a connection to the  test  database on our locally running instance of MongoDB.  var   mongoose   =   require ( mongoose );  mongoose . connect ( mongodb://localhost/test );   We have a pending connection to the test database running on localhost. We now need to get notified if we connect successfully or if a connection error occurs:  var   db   =   mongoose . connection ;  db . on ( error ,   console . error . bind ( console ,   connection error: ));  db . once ( open ,   function ()   {  } );   Once our connection opens, our callback will be called. For brevity, let's assume that all following code is within this callback.  With Mongoose, everything is derived from a  Schema . Let's get a reference to it and define our kittens.  var kittySchema = mongoose.Schema({\n  name: String\n});  So far so good. We've got a schema with one property,  name , which will be a  String . The next step is compiling our schema into a  Model .  var Kitten = mongoose.model( Kitten , kittySchema);  A model is a class with which we construct documents. In this case, each document will be a kitten with properties and behaviors as declared in our schema. Let's create a kitten document representing the little guy we just met on the sidewalk outside:  var   silence   =   new   Kitten ( {   name :   Silence   } );  console . log ( silence . name );   Kittens can meow, so let's take a look at how to add \"speak\" functionality to our documents:  kittySchema.methods.speak = function () {\n  var greeting = this.name\n    ?  Meow name is   + this.name\n    :  I don t have a name ;\n  console.log(greeting);\n}\n\nvar Kitten = mongoose.model( Kitten , kittySchema);  Functions added to the  methods  property of a schema get compiled into the  Model  prototype and exposed on each document instance:  var   fluffy   =   new   Kitten ( {   name :   fluffy   } );  fluffy . speak ();   We have talking kittens! But we still haven't saved anything to MongoDB. Each document can be saved to the database by calling its  save  method. The first argument to the callback will be an error if any occured.    fluffy.save(function (err, fluffy) {\n    if (err) return console.error(err);\n    fluffy.speak();\n  });  Say time goes by and we want to display all the kittens we've seen. We can access all of the kitten documents through our Kitten  model .  Kitten.find(function (err, kittens) {\n  if (err) return console.error(err);\n  console.log(kittens);\n})  We just logged all of the kittens in our db to the console. If we want to filter our kittens by name, Mongoose supports MongoDBs rich  querying  syntax.  Kitten . find ( {   name :   /^ fluff /   } ,   callback );   This performs a search for all documents with a name property that begins with \"Fluff\" and returns the result as an array of kittens to the callback.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/QuickStart/#congratulations", 
            "text": "That's the end of our quick start. We created a schema, added a custom document method, saved and queried kittens in MongoDB using Mongoose. Head over to the  guide , or  API docs  for more.", 
            "title": "Congratulations"
        }, 
        {
            "location": "/guide/Schemas/", 
            "text": "\u6a21\u5f0f\n\n\nSource\n\n\nIf you haven't yet done so, please take a minute to read the \nquickstart\n to get an idea of how Mongoose works. If you are migrating from 4.x to 5.x please take a moment to read the \nmigration guide\n.\n\n\n\u5b9a\u4e49\u4f60\u7684\u6a21\u5f0f\n\n\nEverything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.\n\n\n    \nvar\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n    \nvar\n \nSchema\n \n=\n \nmongoose\n.\nSchema\n;\n\n\n    \nvar\n \nblogSchema\n \n=\n \nnew\n \nSchema\n({\n\n    \ntitle\n:\n  \nString\n,\n\n    \nauthor\n:\n \nString\n,\n\n    \nbody\n:\n   \nString\n,\n\n    \ncomments\n:\n \n[{\n \nbody\n:\n \nString\n,\n \ndate\n:\n \nDate\n \n}],\n\n    \ndate\n:\n \n{\n \ntype\n:\n \nDate\n,\n \ndefault\n:\n \nDate\n.\nnow\n \n},\n\n    \nhidden\n:\n \nBoolean\n,\n\n    \nmeta\n:\n \n{\n\n        \nvotes\n:\n \nNumber\n,\n\n        \nfavs\n:\n  \nNumber\n\n    \n}\n\n    \n});\n\n\n\n\n\nIf you want to add additional keys later, use the \nSchema#add\n method.\n\n\nEach key in our code \nblogSchema\n defines a property in our documents which will be cast to its associated \nSchemaType\n. For example, we've defined a property \ntitle\n which will be cast to the \nString\n SchemaType and property \ndate\n which will be cast to a \nDate\n SchemaType. Keys may also be assigned nested objects containing further key/type definitions like the \nmeta\n property above.\n\n\nThe permitted SchemaTypes are:\n\n\n\n\nString\n\n\nNumber\n\n\nDate\n\n\nBuffer\n\n\nBoolean\n\n\nMixed\n\n\nObjectId\n\n\nArray\n\n\n\n\nRead more about \nSchemaTypes here\n.\n\n\nSchemas not only define the structure of your document and casting of properties, they also define document [instance methods][8], [static Model methods][9], [compound indexes][10], and document lifecycle hooks called \nmiddleware\n\n\n\u521b\u5efa\u4e00\u4e2a\u6a21\u5f0f\n\n\nTo use our schema definition, we need to convert our \nblogSchema\n into a \nModel\n we can work with. To do so, we pass it into \nmongoose.model(modelName, schema)\n:\n\n\n    \nvar\n \nBlog\n \n=\n \nmongoose\n.\nmodel\n(\nBlog\n,\n \nblogSchema\n);\n\n\n\n\n\n\u5b9e\u4f8b\u65b9\u6cd5\n\n\nInstances of \nModels\n are \ndocuments\n. Documents have many of their own \nbuilt-in instance methods\n. We may also define our own custom document instance methods too.\n\n\n  \nvar\n \nanimalSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \ntype\n:\n \nString\n \n}\n);\n\n\n  \nanimalSchema\n.\nmethods\n.\nfindSimilarTypes\n \n=\n \nfunction\n(\ncb\n)\n \n{\n\n    \nreturn\n \nthis.model(\nAnimal\n).find({\n \ntype\n:\n \nthis\n.\ntype\n \n}\n,\n \ncb\n);\n\n  \n}\n;\n\n\n\n\n\n\nNow all of our \nanimal\n instances have a \nfindSimilarTypes\n method available to them.\n\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n  \nvar\n \ndog\n \n=\n \nnew\n \nAnimal\n(\n{\n \ntype\n:\n \ndog\n \n}\n);\n\n\n  \ndog\n.\nfindSimilarTypes\n(\nfunction\n(\nerr\n,\n \ndogs\n)\n \n{\n\n    \nconsole.log(dogs)\n;\n\n  \n}\n);\n\n\n\n\n\n\n\n\nOverwriting a default mongoose document method may lead to unpredictable results. See \nthis\n for more details.\n\n\nDo \nnot\n declare methods using ES6 arrow functions (\n=\n). Arrow functions \nexplicitly prevent binding \nthis\n, so your method will \nnot\n have access to the document and the above examples will not work.\n\n\n\n\n\u9759\u6001\u65b9\u6cd5\n\n\nAdding static methods to a \nModel\n is simple as well. Continuing with our \nanimalSchema\n:\n\n\n  \nanimalSchema\n.\nstatics\n.\nfindByName\n \n=\n \nfunction\n(\nname\n,\n \ncb\n)\n \n{\n\n    \nreturn\n \nthis.find({\n \nname\n:\n \nnew\n \nRegExp\n(\nname\n,\n \ni\n)\n \n}\n,\n \ncb\n);\n\n  \n}\n;\n\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n  \nAnimal\n.\nfindByName\n(\nfido\n,\n \nfunction\n(\nerr\n,\n \nanimals\n)\n \n{\n\n    \nconsole.log(animals)\n;\n\n  \n}\n);\n\n\n\n\n\n\nDo \nnot\n declare statics using ES6 arrow functions (\n=\n). Arrow functions \nexplicitly prevent binding \nthis\n, so the above examples will not work because of the value of \nthis\n.\n\n\n\u67e5\u8be2\u52a9\u624b\n\n\nYou can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's \nchainable query builder API\n.\n\n\n  \nanimalSchema\n.\nquery\n.\nbyName\n \n=\n \nfunction\n(\nname\n)\n \n{\n\n    \nreturn\n \nthis.find({\n \nname\n:\n \nnew\n \nRegExp\n(\nname\n,\n \ni\n)\n \n}\n);\n\n  \n}\n;\n\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n  \nAnimal\n.\nfind\n()\n.\nbyName\n(\nfido\n)\n.\nexec\n(\nfunction\n(\nerr\n,\n \nanimals\n)\n \n{\n\n    \nconsole.log(animals)\n;\n\n  \n}\n);\n\n\n\n\n\n\n\u7d22\u5f15\n\n\nMongoDB supports \nsecondary indexes\n. With mongoose, we define these indexes within our \nSchema\n \nat\n \nthe\n \npath\n \nlevel\n or the \nschema\n level. Defining indexes at the schema level is necessary when creating \ncompound indexes\n.\n\n\n  \nvar\n \nanimalSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n    \nname\n:\n \nString\n,\n\n    \ntype\n:\n \nString\n,\n\n    \ntags\n:\n \n{\n \ntype\n:\n \n[\nString\n]\n,\n \nindex\n:\n \ntrue\n \n}\n\n  \n}\n);\n\n\n  \nanimalSchema\n.\nindex\n(\n{\n \nname\n:\n \n1\n,\n \ntype\n:\n \n-1\n \n}\n);\n\n\n\n\n\n\nWhen your application starts up, Mongoose automatically calls \ncreateIndex\n for each defined index in your schema. Mongoose will call \ncreateIndex\n for each index sequentially, and emit an 'index' event on the model when all the \ncreateIndex\n calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a \nsignificant performance impact\n. Disable the behavior by setting the \nautoIndex\n option of your schema to \nfalse\n, or globally on the connection by setting the option \nautoIndex\n to \nfalse\n.\n\n\n  \nmongoose\n.\nconnect\n(\nmongodb://user:pass@localhost:port/database\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\n  \nmongoose\n.\ncreateConnection\n(\nmongodb://user:pass@localhost:port/database\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\n  \nanimalSchema\n.\nset\n(\nautoIndex\n,\n \nfalse\n);\n\n\n  \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\nMongoose will emit an \nindex\n event on the model when indexes are done building or an error occurred.\n\n\n  \nanimalSchema\n.\nindex\n(\n{\n \n_id\n:\n \n1\n \n}\n,\n \n{\n \nsparse\n:\n \ntrue\n \n}\n);\n\n  \nvar\n \nAnimal\n \n=\n \nmongoose\n.\nmodel\n(\nAnimal\n,\n \nanimalSchema\n);\n\n\n  \nAnimal\n.\non\n(\nindex\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n    \nconsole.log(error.message)\n;\n\n  \n}\n);\n\n\n\n\n\n\nSee also the \nModel#ensureIndexes\n method.\n\n\n\u865a\u62df\u5b57\u6bb5\n\n\nVirtuals\n are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage.\n\n\n  var personSchema = new Schema({\n    name: {\n      first: String,\n      last: String\n    }\n  });\n\n  var Person = mongoose.model(\nPerson\n, personSchema);\n\n  var axl = new Person({\n    name: { first: \nAxl\n, last: \nRose\n }\n  });\n\n\n\n\n\nSuppose you want to print out the person's full name. You could do it yourself:\n\n\nconsole.log(axl.name.first + \n \n + axl.name.last);\n\n\n\n\n\nBut concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like \nremoving diacritics?\n. A \nvirtual property getter\n lets you\n\n\ndefine a \nfullName\n property that won't get persisted to MongoDB.\n\n\npersonSchema.virtual(\nfullName\n).get(function () {\n  return this.name.first + \n \n + this.name.last;\n});\n\n\n\n\n\nNow, mongoose will call your getter function every time you access the \nfullName\n property:\n\n\nconsole.log(axl.fullName);\n\n\n\n\n\nIf you use \ntoJSON()\n or \ntoObject()\n (or use \nJSON.stringify()\n on a mongoose document) mongoose will \nnot\n include virtuals by default. Pass \n{ virtuals: true }\n to either \ntoObject()\n or \ntoJSON()\n.\n\n\nYou can also add a custom setter to your virtual that will let you set both first name and last name via the \nfullName\n virtual.\n\n\npersonSchema.virtual(\nfullName\n).\n  get(function() { return this.name.first + \n \n + this.name.last; }).\n  set(function(v) {\n    this.name.first = v.substr(0, v.indexOf(\n \n));\n    this.name.last = v.substr(v.indexOf(\n \n) + 1);\n  });\n\naxl.fullName = \nWilliam Rose\n;\n\n\n\n\n\nVirtual property setters are applied before other validation. So the example above would still work even if the \nfirst\n and \nlast\n name fields were required.\n\n\nOnly non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.\n\n\n\u522b\u540d\n\n\nAliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability.\n\n\nvar\n \npersonSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nn\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n\n    \nalias\n:\n \nname\n\n  \n}\n\n\n}\n);\n\n\n\nvar\n \nperson\n \n=\n \nnew\n \nPerson\n(\n{\n \nname\n:\n \nVal\n \n}\n);\n\n\nconsole\n.\nlog\n(\nperson\n);\n\n\nconsole\n.\nlog\n(\nperson\n.\ntoObject\n(\n{\n \nvirtuals\n:\n \ntrue\n \n}\n));\n\n\nconsole\n.\nlog\n(\nperson\n.\nname\n);\n\n\n\nperson\n.\nname\n \n=\n \nNot Val\n;\n\n\nconsole\n.\nlog\n(\nperson\n);\n\n\n\n\n\n\n\u9009\u9879\n\n\nSchemas have a few configurable options which can be passed to the constructor or \nset\n directly:\n\n\nnew Schema({..}, options);\n\nvar schema = new Schema({..});\nschema.set(option, value);\n\n\n\n\n\nValid options:\n\n\nautoIndex\n\n\nAt application startup, Mongoose sends a \ncreateIndex\n command\n for each index declared in your \nSchema\n. As of Mongoose v3, indexes are created in the \nbackground\n by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your \nSchema\ns \nautoIndex\n option to \nfalse\n and use the \nensureIndexes\n method on your model.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nautoIndex\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nClock\n \n=\n \nmongoose\n.\nmodel\n(\nClock\n,\n \nschema\n);\n\n\nClock\n.\nensureIndexes\n(\ncallback\n);\n\n\n\n\n\n\nbufferCommands\n\n\nBy default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set \nbufferCommands\n to false.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nbufferCommands\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\nThe schema \nbufferCommands\n option overrides the global \nbufferCommands\n option.\n\n\nmongoose\n.\nset\n(\nbufferCommands\n,\n \ntrue\n);\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nbufferCommands\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\ncapped\n\n\nMongoose supports MongoDBs \ncapped\n collections. To specify the underlying MongoDB collection be \ncapped\n, set the \ncapped\n option to the maximum size of the collection in \nbytes\n.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ncapped\n:\n \n1024\n \n}\n);\n\n\n\n\n\n\nThe \ncapped\n option may also be set to an object if you want to pass additional options like \nmax\n or \nautoIndexId\n. In this case you must explicitly pass the \nsize\n option, which is required.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ncapped\n:\n \n{\n \nsize\n:\n \n1024\n,\n \nmax\n:\n \n1000\n,\n \nautoIndexId\n:\n \ntrue\n \n}\n \n}\n);\n\n\n\n\n\n\ncollection\n\n\nMongoose by default produces a collection name by passing the model name to the \nutils.toCollectionName\n method. This method pluralizes the name. Set this option if you need a different name for your collection.\n\n\nvar\n \ndataSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ncollection\n:\n \ndata\n \n}\n);\n\n\n\n\n\n\nid\n\n\nMongoose assigns each of your schemas an \nid\n virtual getter by default which returns the documents \n_id\n field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an \nid\n getter added to your schema, you may disable it passing this option at schema construction time.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nvar\n \nPage\n \n=\n \nmongoose\n.\nmodel\n(\nPage\n,\n \nschema\n);\n\n\nvar\n \np\n \n=\n \nnew\n \nPage\n(\n{\n \nname\n:\n \nmongodb.org\n \n}\n);\n\n\nconsole\n.\nlog\n(\np\n.\nid\n);\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \nid\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nPage\n \n=\n \nmongoose\n.\nmodel\n(\nPage\n,\n \nschema\n);\n\n\nvar\n \np\n \n=\n \nnew\n \nPage\n(\n{\n \nname\n:\n \nmongodb.org\n \n}\n);\n\n\nconsole\n.\nlog\n(\np\n.\nid\n);\n\n\n\n\n\n\n_id\n\n\nMongoose assigns each of your schemas an \n_id\n field by default if one is not passed into the \nSchema\n constructor. The type assigned is an \nObjectId\n to coincide with MongoDB's default behavior. If you don't want an \n_id\n added to your schema at all, you may disable it using this option.\n\n\nYou can \nonly\n use this option on sub-documents. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an \n_id\n.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nvar\n \nPage\n \n=\n \nmongoose\n.\nmodel\n(\nPage\n,\n \nschema\n);\n\n\nvar\n \np\n \n=\n \nnew\n \nPage\n(\n{\n \nname\n:\n \nmongodb.org\n \n}\n);\n\n\nconsole\n.\nlog\n(\np\n);\n\n\n\nvar\n \nchildSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \n_id\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nparentSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nchildren\n:\n \n[\nchildSchema\n]\n \n}\n);\n\n\n\nvar\n \nModel\n \n=\n \nmongoose\n.\nmodel\n(\nModel\n,\n \nparentSchema\n);\n\n\n\nModel\n.\ncreate\n(\n{\n \nchildren\n:\n \n[\n{\n \nname\n:\n \nLuke\n \n}\n]\n \n}\n,\n \nfunction\n(\nerror\n,\n \ndoc\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nminimize\n\n\nMongoose will, by default, \"minimize\" schemas by removing empty objects.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \ninventory\n:\n \n{\n}\n \n}\n);\n\n\nvar\n \nCharacter\n \n=\n \nmongoose\n.\nmodel\n(\nCharacter\n,\n \nschema\n);\n\n\n\nvar\n \nfrodo\n \n=\n \nnew\n \nCharacter\n(\n{\n \nname\n:\n \nFrodo\n,\n \ninventory\n:\n \n{\n \nringOfPower\n:\n \n1\n \n}\n}\n);\n\n\nCharacter\n.\nfindOne\n(\n{\n \nname\n:\n \nFrodo\n \n}\n,\n \nfunction\n(\nerr\n,\n \ncharacter\n)\n \n{\n\n  \nconsole.log(character)\n;\n\n\n}\n);\n\n\n\nvar\n \nsam\n \n=\n \nnew\n \nCharacter\n(\n{\n \nname\n:\n \nSam\n,\n \ninventory\n:\n \n{\n}\n}\n);\n\n\nCharacter\n.\nfindOne\n(\n{\n \nname\n:\n \nSam\n \n}\n,\n \nfunction\n(\nerr\n,\n \ncharacter\n)\n \n{\n\n  \nconsole.log(character)\n;\n\n\n}\n);\n\n\n\n\n\n\nThis behavior can be overridden by setting \nminimize\n option to \nfalse\n. It will then store empty objects.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \ninventory\n:\n \n{\n}\n \n}\n,\n \n{\n \nminimize\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nCharacter\n \n=\n \nmongoose\n.\nmodel\n(\nCharacter\n,\n \nschema\n);\n\n\n\nvar\n \nsam\n \n=\n \nnew\n \nCharacter\n(\n{\n \nname\n:\n \nSam\n,\n \ninventory\n:\n \n{\n}\n}\n);\n\n\nCharacter\n.\nfindOne\n(\n{\n \nname\n:\n \nSam\n \n}\n,\n \nfunction\n(\nerr\n,\n \ncharacter\n)\n \n{\n\n  \nconsole.log(character)\n;\n\n\n}\n);\n\n\n\n\n\n\nread\n\n\nAllows setting \nquery#read\n options at the schema level, providing us a way to apply default \nReadPreferences\n to all queries derived from a model.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nprimary\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nprimaryPreferred\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nsecondary\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nsecondaryPreferred\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \nnearest\n \n}\n);\n\n\n\n\n\n\nThe alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.\n\n\nThe read option also allows us to specify \ntag sets\n. These tell the \ndriver\n from which members of the replica-set it should attempt to read. Read more about tag sets \nhere\n and \nhere\n.\n\n\nNOTE: you may also specify the driver read pref \nstrategy\n option when connecting:\n\n\nvar\n \noptions\n \n=\n \n{\n \nreplset\n:\n \n{\n \nstrategy\n:\n \nping\n \n}\n}\n;\n\n\nmongoose\n.\nconnect\n(\nuri\n,\n \noptions\n);\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nread\n:\n \n[\nnearest\n,\n \n{\n \ndisk\n:\n \nssd\n \n}\n]\n \n}\n);\n\n\nmongoose\n.\nmodel\n(\nJellyBean\n,\n \nschema\n);\n\n\n\n\n\n\nshardKey\n\n\nThe \nshardKey\n option is used when we have a \nsharded MongoDB architecture\n. Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we'll be all set.\n\n\nnew Schema({ .. }, { shardKey: { tag: 1, name: 1 }})\n\n\n\n\n\nNote that Mongoose does not send the \nshardcollection\n command for you. You must configure your shards yourself.\n\n\nstrict\n\n\nThe strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.\n\n\nvar\n \nthingSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n)\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nthingSchema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \niAmNotInTheSchema\n:\n \ntrue\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\nvar\n \nthingSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \niAmNotInTheSchema\n:\n \ntrue\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\nThis also affects the use of \ndoc.set()\n to set a property value.\n\n\nvar thingSchema = new Schema({..})\nvar Thing = mongoose.model(\nThing\n, thingSchema);\nvar thing = new Thing;\nthing.set(\niAmNotInTheSchema\n, true);\nthing.save();\n\n\n\n\n\nThis value can be overridden at the model instance level by passing a second boolean argument:\n\n\nvar Thing = mongoose.model(\nThing\n);\nvar thing = new Thing(doc, true);\nvar thing = new Thing(doc, false);\n\n\n\n\n\nThe \nstrict\n option may also be set to \n\"throw\"\n which will cause errors to be produced instead of dropping the bad data.\n\n\nNOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.\n\n\nvar thingSchema = new Schema({..})\nvar Thing = mongoose.model(\nThing\n, thingSchema);\nvar thing = new Thing;\nthing.iAmNotInTheSchema = true;\nthing.save();\n\n\n\n\n\ntoJSON\n\n\nExactly the same as the [toObject][60] option but only applies when the documents \ntoJSON\n method is called.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\npath\n(\nname\n)\n.\nget\n(\nfunction\n \n(\nv\n)\n \n{\n\n  \nreturn\n \nv\n \n+\n \n \nis\n \nmy\n \nname\n;\n\n\n}\n);\n\n\nschema\n.\nset\n(\ntoJSON\n,\n \n{\n \ngetters\n:\n \ntrue\n,\n \nvirtuals\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nM\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nschema\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n(\n{\n \nname\n:\n \nMax Headroom\n \n}\n);\n\n\nconsole\n.\nlog\n(\nm\n.\ntoObject\n());\n\n\nconsole\n.\nlog\n(\nm\n.\ntoJSON\n());\n\n\n\nconsole\n.\nlog\n(\nJSON\n.\nstringify\n(\nm\n));\n\n\n\n\n\n\nTo see all available \ntoJSON/toObject\n options, read \nthis\n.\n\n\ntoObject\n\n\nDocuments have a \ntoObject\n method which converts the mongoose document into a plain javascript object. This method accepts a few options. Instead of applying these options on a per-document basis we may declare the options here and have it applied to all of this schemas documents by default.\n\n\nTo have all virtuals show up in your \nconsole.log\n output, set the \ntoObject\n option to \n{ getters: true }\n:\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\npath\n(\nname\n)\n.\nget\n(\nfunction\n \n(\nv\n)\n \n{\n\n  \nreturn\n \nv\n \n+\n \n \nis\n \nmy\n \nname\n;\n\n\n}\n);\n\n\nschema\n.\nset\n(\ntoObject\n,\n \n{\n \ngetters\n:\n \ntrue\n \n}\n);\n\n\nvar\n \nM\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nschema\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n(\n{\n \nname\n:\n \nMax Headroom\n \n}\n);\n\n\nconsole\n.\nlog\n(\nm\n);\n\n\n\n\n\n\nTo see all available \ntoObject\n options, read \nthis\n.\n\n\ntypeKey\n\n\nBy default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \nString\n,\n \ncoordinates\n:\n \n[\nNumber\n]\n \n}\n \n}\n);\n\n\n\n\n\n\nHowever, for applications like \ngeoJSON\n, the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n\n\n  \nloc\n:\n \n{\n \ntype\n:\n \nString\n,\n \ncoordinates\n:\n \n[\nNumber\n]\n \n}\n,\n\n\n  \nname\n:\n \n{\n \n$\ntype\n:\n \nString\n \n}\n\n\n}\n,\n \n{\n \ntypeKey\n:\n \n$type\n \n}\n);\n\n\n\n\n\n\nvalidateBeforeSave\n\n\nBy default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set \nvalidateBeforeSave\n to false.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\nset\n(\nvalidateBeforeSave\n,\n \nfalse\n);\n\n\nschema\n.\npath\n(\nname\n)\n.\nvalidate\n(\nfunction\n \n(\nvalue\n)\n \n{\n\n    \nreturn\n \nv\n \n!=\n \nnull\n;\n\n\n}\n);\n\n\nvar\n \nM\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nschema\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n(\n{\n \nname\n:\n \nnull\n \n}\n);\n\n\nm\n.\nvalidate\n(\nfunction\n(\nerr\n)\n \n{\n\n    \nconsole.log(err)\n;\n\n\n}\n);\n\n\nm\n.\nsave\n();\n\n\n\n\n\n\nversionKey\n\n\nThe \nversionKey\n is a property set on each document when first created by Mongoose. This keys value contains the internal \nrevision\n of the document. The \nversionKey\n option is a string that represents the path to use for versioning. The default is \n__v\n. If this conflicts with your application you can configure as such:\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nstring\n \n}\n);\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nschema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \nname\n:\n \nmongoose v3\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nversionKey\n:\n \n_somethingElse\n \n}\n)\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nschema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \nname\n:\n \nmongoose v3\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\nDocument versioning can also be disabled by setting the \nversionKey\n to \nfalse\n. \nDO NOT disable versioning unless you \nknow what you are doing\n.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nversionKey\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nschema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n(\n{\n \nname\n:\n \nno versioning please\n \n}\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\ncollation\n\n\nSets a default \ncollation\n for every query and aggregation. \nHere's a beginner-friendly overview of collations\n.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \nString\n\n\n}\n,\n \n{\n \ncollation\n:\n \n{\n \nlocale\n:\n \nen_US\n,\n \nstrength\n:\n \n1\n \n}\n \n}\n);\n\n\n\nvar\n \nMyModel\n \n=\n \ndb\n.\nmodel\n(\nMyModel\n,\n \nschema\n);\n\n\n\nMyModel\n.\ncreate\n(\n[\n{\n \nname\n:\n \nval\n \n},\n \n{\n \nname\n:\n \nVal\n \n}\n]\n).\n\n  \nthen\n(\nfunction\n()\n \n{\n\n    \nreturn\n \nMyModel.find({\n \nname\n:\n \nval\n \n}\n);\n\n  \n}\n).\n\n  \nthen\n(\nfunction\n(\ndocs\n)\n \n{\n\n\n  \n}\n);\n\n\n\n\n\n\nskipVersioning\n\n\nskipVersioning\n allows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For sub-documents, include this on the parent document using the fully qualified path.\n\n\nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \nskipVersioning\n:\n \n{\n \ndontVersionMe\n:\n \ntrue\n \n}\n \n}\n);\n\n\nthing\n.\ndontVersionMe\n.\npush\n(\nhey\n);\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\ntimestamps\n\n\nIf set \ntimestamps\n, mongoose assigns \ncreatedAt\n and \nupdatedAt\n fields to your schema, the type assigned is \nDate\n.\n\n\nBy default, the name of two fields are \ncreatedAt\n and \nupdatedAt\n, customize the field name by setting \ntimestamps.createdAt\n and \ntimestamps.updatedAt\n.\n\n\nvar\n \nthingSchema\n \n=\n \nnew\n \nSchema\n(\n{\n..\n}\n,\n \n{\n \ntimestamps\n:\n \n{\n \ncreatedAt\n:\n \ncreated_at\n \n}\n \n}\n);\n\n\nvar\n \nThing\n \n=\n \nmongoose\n.\nmodel\n(\nThing\n,\n \nthingSchema\n);\n\n\nvar\n \nthing\n \n=\n \nnew\n \nThing\n();\n\n\nthing\n.\nsave\n();\n\n\n\n\n\n\nuseNestedStrict\n\n\nIn mongoose 4, \nupdate()\n and \nfindOneAndUpdate()\n only check the top-level schema's strict mode setting.\n\n\nvar\n \nchildSchema\n \n=\n \nnew\n \nSchema\n(\n{}\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nparentSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nchild\n:\n \nchildSchema\n \n}\n,\n \n{\n \nstrict\n:\n \nthrow\n \n}\n);\n\n\nvar\n \nParent\n \n=\n \nmongoose\n.\nmodel\n(\nParent\n,\n \nparentSchema\n);\n\n\nParent\n.\nupdate\n(\n{}\n,\n \n{\n \nchild.name\n:\n \nLuke\n \nSkywalker\n \n}\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\nvar\n \nupdate\n \n=\n \n{\n \nchild.name\n:\n \nLuke\n \nSkywalker\n \n}\n;\n\n\nvar\n \nopts\n \n=\n \n{\n \nstrict\n:\n \nfalse\n \n}\n;\n\n\nParent\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nIf you set \nuseNestedStrict\n to true, mongoose will use the child schema's \nstrict\n option for casting updates.\n\n\nvar\n \nchildSchema\n \n=\n \nnew\n \nSchema\n(\n{}\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\nvar\n \nparentSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nchild\n:\n \nchildSchema\n \n}\n,\n\n  \n{\n \nstrict\n:\n \nthrow\n,\n \nuseNestedStrict\n:\n \ntrue\n \n}\n);\n\n\nvar\n \nParent\n \n=\n \nmongoose\n.\nmodel\n(\nParent\n,\n \nparentSchema\n);\n\n\nParent\n.\nupdate\n(\n{}\n,\n \n{\n \nchild.name\n:\n \nLuke\n \nSkywalker\n \n}\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\n\u53ef\u63d2\u62d4\n\n\nSchema\u4e5f\u662f\n\u53ef\u63d2\u62d4\n\uff0c\u5b83\u5141\u8bb8\u6211\u4eec\u5c06\u53ef\u91cd\u7528\u7684\u7279\u6027\u6253\u5305\u6210\u53ef\u4e0e\u793e\u533a\u5171\u4eab\u6216\u53ea\u5728\u60a8\u7684\u9879\u76ee\u4e4b\u95f4\u5171\u4eab\u7684\u63d2\u4ef6\u3002\n\n\n\u63a5\u4e0b\u6765\n\n\n\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u6a21\u5f0f\uff0c\u6211\u4eec\u6765\u770b\u770b\n\u6a21\u5f0f\u7c7b\u578b\n.", 
            "title": "\u6a21\u5f0f"
        }, 
        {
            "location": "/guide/Schemas/#_1", 
            "text": "Source  If you haven't yet done so, please take a minute to read the  quickstart  to get an idea of how Mongoose works. If you are migrating from 4.x to 5.x please take a moment to read the  migration guide .", 
            "title": "\u6a21\u5f0f"
        }, 
        {
            "location": "/guide/Schemas/#_2", 
            "text": "Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.       var   mongoose   =   require ( mongoose ); \n     var   Schema   =   mongoose . Schema ; \n\n     var   blogSchema   =   new   Schema ({ \n     title :    String , \n     author :   String , \n     body :     String , \n     comments :   [{   body :   String ,   date :   Date   }], \n     date :   {   type :   Date ,   default :   Date . now   }, \n     hidden :   Boolean , \n     meta :   { \n         votes :   Number , \n         favs :    Number \n     } \n     });   If you want to add additional keys later, use the  Schema#add  method.  Each key in our code  blogSchema  defines a property in our documents which will be cast to its associated  SchemaType . For example, we've defined a property  title  which will be cast to the  String  SchemaType and property  date  which will be cast to a  Date  SchemaType. Keys may also be assigned nested objects containing further key/type definitions like the  meta  property above.  The permitted SchemaTypes are:   String  Number  Date  Buffer  Boolean  Mixed  ObjectId  Array   Read more about  SchemaTypes here .  Schemas not only define the structure of your document and casting of properties, they also define document [instance methods][8], [static Model methods][9], [compound indexes][10], and document lifecycle hooks called  middleware", 
            "title": "\u5b9a\u4e49\u4f60\u7684\u6a21\u5f0f"
        }, 
        {
            "location": "/guide/Schemas/#_3", 
            "text": "To use our schema definition, we need to convert our  blogSchema  into a  Model  we can work with. To do so, we pass it into  mongoose.model(modelName, schema) :       var   Blog   =   mongoose . model ( Blog ,   blogSchema );", 
            "title": "\u521b\u5efa\u4e00\u4e2a\u6a21\u5f0f"
        }, 
        {
            "location": "/guide/Schemas/#_4", 
            "text": "Instances of  Models  are  documents . Documents have many of their own  built-in instance methods . We may also define our own custom document instance methods too.     var   animalSchema   =   new   Schema ( {   name :   String ,   type :   String   } ); \n\n   animalSchema . methods . findSimilarTypes   =   function ( cb )   { \n     return   this.model( Animal ).find({   type :   this . type   } ,   cb ); \n   } ;   Now all of our  animal  instances have a  findSimilarTypes  method available to them.     var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n   var   dog   =   new   Animal ( {   type :   dog   } ); \n\n   dog . findSimilarTypes ( function ( err ,   dogs )   { \n     console.log(dogs) ; \n   } );    Overwriting a default mongoose document method may lead to unpredictable results. See  this  for more details.  Do  not  declare methods using ES6 arrow functions ( = ). Arrow functions  explicitly prevent binding  this , so your method will  not  have access to the document and the above examples will not work.", 
            "title": "\u5b9e\u4f8b\u65b9\u6cd5"
        }, 
        {
            "location": "/guide/Schemas/#_5", 
            "text": "Adding static methods to a  Model  is simple as well. Continuing with our  animalSchema :     animalSchema . statics . findByName   =   function ( name ,   cb )   { \n     return   this.find({   name :   new   RegExp ( name ,   i )   } ,   cb ); \n   } ; \n\n   var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n   Animal . findByName ( fido ,   function ( err ,   animals )   { \n     console.log(animals) ; \n   } );   Do  not  declare statics using ES6 arrow functions ( = ). Arrow functions  explicitly prevent binding  this , so the above examples will not work because of the value of  this .", 
            "title": "\u9759\u6001\u65b9\u6cd5"
        }, 
        {
            "location": "/guide/Schemas/#_6", 
            "text": "You can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's  chainable query builder API .     animalSchema . query . byName   =   function ( name )   { \n     return   this.find({   name :   new   RegExp ( name ,   i )   } ); \n   } ; \n\n   var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n   Animal . find () . byName ( fido ) . exec ( function ( err ,   animals )   { \n     console.log(animals) ; \n   } );", 
            "title": "\u67e5\u8be2\u52a9\u624b"
        }, 
        {
            "location": "/guide/Schemas/#_7", 
            "text": "MongoDB supports  secondary indexes . With mongoose, we define these indexes within our  Schema   at   the   path   level  or the  schema  level. Defining indexes at the schema level is necessary when creating  compound indexes .     var   animalSchema   =   new   Schema ( { \n     name :   String , \n     type :   String , \n     tags :   {   type :   [ String ] ,   index :   true   } \n   } ); \n\n   animalSchema . index ( {   name :   1 ,   type :   -1   } );   When your application starts up, Mongoose automatically calls  createIndex  for each defined index in your schema. Mongoose will call  createIndex  for each index sequentially, and emit an 'index' event on the model when all the  createIndex  calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a  significant performance impact . Disable the behavior by setting the  autoIndex  option of your schema to  false , or globally on the connection by setting the option  autoIndex  to  false .     mongoose . connect ( mongodb://user:pass@localhost:port/database ,   {   autoIndex :   false   } ); \n\n   mongoose . createConnection ( mongodb://user:pass@localhost:port/database ,   {   autoIndex :   false   } ); \n\n   animalSchema . set ( autoIndex ,   false ); \n\n   new   Schema ( { .. } ,   {   autoIndex :   false   } );   Mongoose will emit an  index  event on the model when indexes are done building or an error occurred.     animalSchema . index ( {   _id :   1   } ,   {   sparse :   true   } ); \n   var   Animal   =   mongoose . model ( Animal ,   animalSchema ); \n\n   Animal . on ( index ,   function ( error )   { \n\n     console.log(error.message) ; \n   } );   See also the  Model#ensureIndexes  method.", 
            "title": "\u7d22\u5f15"
        }, 
        {
            "location": "/guide/Schemas/#_8", 
            "text": "Virtuals  are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage.    var personSchema = new Schema({\n    name: {\n      first: String,\n      last: String\n    }\n  });\n\n  var Person = mongoose.model( Person , personSchema);\n\n  var axl = new Person({\n    name: { first:  Axl , last:  Rose  }\n  });  Suppose you want to print out the person's full name. You could do it yourself:  console.log(axl.name.first +     + axl.name.last);  But concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like  removing diacritics? . A  virtual property getter  lets you  define a  fullName  property that won't get persisted to MongoDB.  personSchema.virtual( fullName ).get(function () {\n  return this.name.first +     + this.name.last;\n});  Now, mongoose will call your getter function every time you access the  fullName  property:  console.log(axl.fullName);  If you use  toJSON()  or  toObject()  (or use  JSON.stringify()  on a mongoose document) mongoose will  not  include virtuals by default. Pass  { virtuals: true }  to either  toObject()  or  toJSON() .  You can also add a custom setter to your virtual that will let you set both first name and last name via the  fullName  virtual.  personSchema.virtual( fullName ).\n  get(function() { return this.name.first +     + this.name.last; }).\n  set(function(v) {\n    this.name.first = v.substr(0, v.indexOf(   ));\n    this.name.last = v.substr(v.indexOf(   ) + 1);\n  });\n\naxl.fullName =  William Rose ;  Virtual property setters are applied before other validation. So the example above would still work even if the  first  and  last  name fields were required.  Only non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.", 
            "title": "\u865a\u62df\u5b57\u6bb5"
        }, 
        {
            "location": "/guide/Schemas/#_9", 
            "text": "Aliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability.  var   personSchema   =   new   Schema ( { \n   n :   { \n     type :   String , \n\n     alias :   name \n   }  } );  var   person   =   new   Person ( {   name :   Val   } );  console . log ( person );  console . log ( person . toObject ( {   virtuals :   true   } ));  console . log ( person . name );  person . name   =   Not Val ;  console . log ( person );", 
            "title": "\u522b\u540d"
        }, 
        {
            "location": "/guide/Schemas/#_10", 
            "text": "Schemas have a few configurable options which can be passed to the constructor or  set  directly:  new Schema({..}, options);\n\nvar schema = new Schema({..});\nschema.set(option, value);  Valid options:", 
            "title": "\u9009\u9879"
        }, 
        {
            "location": "/guide/Schemas/#autoindex", 
            "text": "At application startup, Mongoose sends a  createIndex  command  for each index declared in your  Schema . As of Mongoose v3, indexes are created in the  background  by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your  Schema s  autoIndex  option to  false  and use the  ensureIndexes  method on your model.  var   schema   =   new   Schema ( { .. } ,   {   autoIndex :   false   } );  var   Clock   =   mongoose . model ( Clock ,   schema );  Clock . ensureIndexes ( callback );", 
            "title": "autoIndex"
        }, 
        {
            "location": "/guide/Schemas/#buffercommands", 
            "text": "By default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set  bufferCommands  to false.  var   schema   =   new   Schema ( { .. } ,   {   bufferCommands :   false   } );   The schema  bufferCommands  option overrides the global  bufferCommands  option.  mongoose . set ( bufferCommands ,   true );  var   schema   =   new   Schema ( { .. } ,   {   bufferCommands :   false   } );", 
            "title": "bufferCommands"
        }, 
        {
            "location": "/guide/Schemas/#capped", 
            "text": "Mongoose supports MongoDBs  capped  collections. To specify the underlying MongoDB collection be  capped , set the  capped  option to the maximum size of the collection in  bytes .  new   Schema ( { .. } ,   {   capped :   1024   } );   The  capped  option may also be set to an object if you want to pass additional options like  max  or  autoIndexId . In this case you must explicitly pass the  size  option, which is required.  new   Schema ( { .. } ,   {   capped :   {   size :   1024 ,   max :   1000 ,   autoIndexId :   true   }   } );", 
            "title": "capped"
        }, 
        {
            "location": "/guide/Schemas/#collection", 
            "text": "Mongoose by default produces a collection name by passing the model name to the  utils.toCollectionName  method. This method pluralizes the name. Set this option if you need a different name for your collection.  var   dataSchema   =   new   Schema ( { .. } ,   {   collection :   data   } );", 
            "title": "collection"
        }, 
        {
            "location": "/guide/Schemas/#id", 
            "text": "Mongoose assigns each of your schemas an  id  virtual getter by default which returns the documents  _id  field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an  id  getter added to your schema, you may disable it passing this option at schema construction time.  var   schema   =   new   Schema ( {   name :   String   } );  var   Page   =   mongoose . model ( Page ,   schema );  var   p   =   new   Page ( {   name :   mongodb.org   } );  console . log ( p . id );  var   schema   =   new   Schema ( {   name :   String   } ,   {   id :   false   } );  var   Page   =   mongoose . model ( Page ,   schema );  var   p   =   new   Page ( {   name :   mongodb.org   } );  console . log ( p . id );", 
            "title": "id"
        }, 
        {
            "location": "/guide/Schemas/#_id", 
            "text": "Mongoose assigns each of your schemas an  _id  field by default if one is not passed into the  Schema  constructor. The type assigned is an  ObjectId  to coincide with MongoDB's default behavior. If you don't want an  _id  added to your schema at all, you may disable it using this option.  You can  only  use this option on sub-documents. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an  _id .  var   schema   =   new   Schema ( {   name :   String   } );  var   Page   =   mongoose . model ( Page ,   schema );  var   p   =   new   Page ( {   name :   mongodb.org   } );  console . log ( p );  var   childSchema   =   new   Schema ( {   name :   String   } ,   {   _id :   false   } );  var   parentSchema   =   new   Schema ( {   children :   [ childSchema ]   } );  var   Model   =   mongoose . model ( Model ,   parentSchema );  Model . create ( {   children :   [ {   name :   Luke   } ]   } ,   function ( error ,   doc )   {  } );", 
            "title": "_id"
        }, 
        {
            "location": "/guide/Schemas/#minimize", 
            "text": "Mongoose will, by default, \"minimize\" schemas by removing empty objects.  var   schema   =   new   Schema ( {   name :   String ,   inventory :   { }   } );  var   Character   =   mongoose . model ( Character ,   schema );  var   frodo   =   new   Character ( {   name :   Frodo ,   inventory :   {   ringOfPower :   1   } } );  Character . findOne ( {   name :   Frodo   } ,   function ( err ,   character )   { \n   console.log(character) ;  } );  var   sam   =   new   Character ( {   name :   Sam ,   inventory :   { } } );  Character . findOne ( {   name :   Sam   } ,   function ( err ,   character )   { \n   console.log(character) ;  } );   This behavior can be overridden by setting  minimize  option to  false . It will then store empty objects.  var   schema   =   new   Schema ( {   name :   String ,   inventory :   { }   } ,   {   minimize :   false   } );  var   Character   =   mongoose . model ( Character ,   schema );  var   sam   =   new   Character ( {   name :   Sam ,   inventory :   { } } );  Character . findOne ( {   name :   Sam   } ,   function ( err ,   character )   { \n   console.log(character) ;  } );", 
            "title": "minimize"
        }, 
        {
            "location": "/guide/Schemas/#read", 
            "text": "Allows setting  query#read  options at the schema level, providing us a way to apply default  ReadPreferences  to all queries derived from a model.  var   schema   =   new   Schema ( { .. } ,   {   read :   primary   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   primaryPreferred   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   secondary   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   secondaryPreferred   } );  var   schema   =   new   Schema ( { .. } ,   {   read :   nearest   } );   The alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'.  The read option also allows us to specify  tag sets . These tell the  driver  from which members of the replica-set it should attempt to read. Read more about tag sets  here  and  here .  NOTE: you may also specify the driver read pref  strategy  option when connecting:  var   options   =   {   replset :   {   strategy :   ping   } } ;  mongoose . connect ( uri ,   options );  var   schema   =   new   Schema ( { .. } ,   {   read :   [ nearest ,   {   disk :   ssd   } ]   } );  mongoose . model ( JellyBean ,   schema );", 
            "title": "read"
        }, 
        {
            "location": "/guide/Schemas/#shardkey", 
            "text": "The  shardKey  option is used when we have a  sharded MongoDB architecture . Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we'll be all set.  new Schema({ .. }, { shardKey: { tag: 1, name: 1 }})  Note that Mongoose does not send the  shardcollection  command for you. You must configure your shards yourself.", 
            "title": "shardKey"
        }, 
        {
            "location": "/guide/Schemas/#strict", 
            "text": "The strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db.  var   thingSchema   =   new   Schema ( { .. } )  var   Thing   =   mongoose . model ( Thing ,   thingSchema );  var   thing   =   new   Thing ( {   iAmNotInTheSchema :   true   } );  thing . save ();  var   thingSchema   =   new   Schema ( { .. } ,   {   strict :   false   } );  var   thing   =   new   Thing ( {   iAmNotInTheSchema :   true   } );  thing . save ();   This also affects the use of  doc.set()  to set a property value.  var thingSchema = new Schema({..})\nvar Thing = mongoose.model( Thing , thingSchema);\nvar thing = new Thing;\nthing.set( iAmNotInTheSchema , true);\nthing.save();  This value can be overridden at the model instance level by passing a second boolean argument:  var Thing = mongoose.model( Thing );\nvar thing = new Thing(doc, true);\nvar thing = new Thing(doc, false);  The  strict  option may also be set to  \"throw\"  which will cause errors to be produced instead of dropping the bad data.  NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option.  var thingSchema = new Schema({..})\nvar Thing = mongoose.model( Thing , thingSchema);\nvar thing = new Thing;\nthing.iAmNotInTheSchema = true;\nthing.save();", 
            "title": "strict"
        }, 
        {
            "location": "/guide/Schemas/#tojson", 
            "text": "Exactly the same as the [toObject][60] option but only applies when the documents  toJSON  method is called.  var   schema   =   new   Schema ( {   name :   String   } );  schema . path ( name ) . get ( function   ( v )   { \n   return   v   +     is   my   name ;  } );  schema . set ( toJSON ,   {   getters :   true ,   virtuals :   false   } );  var   M   =   mongoose . model ( Person ,   schema );  var   m   =   new   M ( {   name :   Max Headroom   } );  console . log ( m . toObject ());  console . log ( m . toJSON ());  console . log ( JSON . stringify ( m ));   To see all available  toJSON/toObject  options, read  this .", 
            "title": "toJSON"
        }, 
        {
            "location": "/guide/Schemas/#toobject", 
            "text": "Documents have a  toObject  method which converts the mongoose document into a plain javascript object. This method accepts a few options. Instead of applying these options on a per-document basis we may declare the options here and have it applied to all of this schemas documents by default.  To have all virtuals show up in your  console.log  output, set the  toObject  option to  { getters: true } :  var   schema   =   new   Schema ( {   name :   String   } );  schema . path ( name ) . get ( function   ( v )   { \n   return   v   +     is   my   name ;  } );  schema . set ( toObject ,   {   getters :   true   } );  var   M   =   mongoose . model ( Person ,   schema );  var   m   =   new   M ( {   name :   Max Headroom   } );  console . log ( m );   To see all available  toObject  options, read  this .", 
            "title": "toObject"
        }, 
        {
            "location": "/guide/Schemas/#typekey", 
            "text": "By default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration.  var   schema   =   new   Schema ( {   loc :   {   type :   String ,   coordinates :   [ Number ]   }   } );   However, for applications like  geoJSON , the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option.  var   schema   =   new   Schema ( { \n\n   loc :   {   type :   String ,   coordinates :   [ Number ]   } , \n\n   name :   {   $ type :   String   }  } ,   {   typeKey :   $type   } );", 
            "title": "typeKey"
        }, 
        {
            "location": "/guide/Schemas/#validatebeforesave", 
            "text": "By default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set  validateBeforeSave  to false.  var   schema   =   new   Schema ( {   name :   String   } );  schema . set ( validateBeforeSave ,   false );  schema . path ( name ) . validate ( function   ( value )   { \n     return   v   !=   null ;  } );  var   M   =   mongoose . model ( Person ,   schema );  var   m   =   new   M ( {   name :   null   } );  m . validate ( function ( err )   { \n     console.log(err) ;  } );  m . save ();", 
            "title": "validateBeforeSave"
        }, 
        {
            "location": "/guide/Schemas/#versionkey", 
            "text": "The  versionKey  is a property set on each document when first created by Mongoose. This keys value contains the internal  revision  of the document. The  versionKey  option is a string that represents the path to use for versioning. The default is  __v . If this conflicts with your application you can configure as such:  var   schema   =   new   Schema ( {   name :   string   } );  var   Thing   =   mongoose . model ( Thing ,   schema );  var   thing   =   new   Thing ( {   name :   mongoose v3   } );  thing . save ();  new   Schema ( { .. } ,   {   versionKey :   _somethingElse   } )  var   Thing   =   mongoose . model ( Thing ,   schema );  var   thing   =   new   Thing ( {   name :   mongoose v3   } );  thing . save ();   Document versioning can also be disabled by setting the  versionKey  to  false .  DO NOT disable versioning unless you  know what you are doing .  new   Schema ( { .. } ,   {   versionKey :   false   } );  var   Thing   =   mongoose . model ( Thing ,   schema );  var   thing   =   new   Thing ( {   name :   no versioning please   } );  thing . save ();", 
            "title": "versionKey"
        }, 
        {
            "location": "/guide/Schemas/#collation", 
            "text": "Sets a default  collation  for every query and aggregation.  Here's a beginner-friendly overview of collations .  var   schema   =   new   Schema ( { \n   name :   String  } ,   {   collation :   {   locale :   en_US ,   strength :   1   }   } );  var   MyModel   =   db . model ( MyModel ,   schema );  MyModel . create ( [ {   name :   val   },   {   name :   Val   } ] ). \n   then ( function ()   { \n     return   MyModel.find({   name :   val   } ); \n   } ). \n   then ( function ( docs )   { \n\n   } );", 
            "title": "collation"
        }, 
        {
            "location": "/guide/Schemas/#skipversioning", 
            "text": "skipVersioning  allows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For sub-documents, include this on the parent document using the fully qualified path.  new   Schema ( { .. } ,   {   skipVersioning :   {   dontVersionMe :   true   }   } );  thing . dontVersionMe . push ( hey );  thing . save ();", 
            "title": "skipVersioning"
        }, 
        {
            "location": "/guide/Schemas/#timestamps", 
            "text": "If set  timestamps , mongoose assigns  createdAt  and  updatedAt  fields to your schema, the type assigned is  Date .  By default, the name of two fields are  createdAt  and  updatedAt , customize the field name by setting  timestamps.createdAt  and  timestamps.updatedAt .  var   thingSchema   =   new   Schema ( { .. } ,   {   timestamps :   {   createdAt :   created_at   }   } );  var   Thing   =   mongoose . model ( Thing ,   thingSchema );  var   thing   =   new   Thing ();  thing . save ();", 
            "title": "timestamps"
        }, 
        {
            "location": "/guide/Schemas/#usenestedstrict", 
            "text": "In mongoose 4,  update()  and  findOneAndUpdate()  only check the top-level schema's strict mode setting.  var   childSchema   =   new   Schema ( {} ,   {   strict :   false   } );  var   parentSchema   =   new   Schema ( {   child :   childSchema   } ,   {   strict :   throw   } );  var   Parent   =   mongoose . model ( Parent ,   parentSchema );  Parent . update ( {} ,   {   child.name :   Luke   Skywalker   } ,   function ( error )   {  } );  var   update   =   {   child.name :   Luke   Skywalker   } ;  var   opts   =   {   strict :   false   } ;  Parent . update ( {} ,   update ,   opts ,   function ( error )   {  } );   If you set  useNestedStrict  to true, mongoose will use the child schema's  strict  option for casting updates.  var   childSchema   =   new   Schema ( {} ,   {   strict :   false   } );  var   parentSchema   =   new   Schema ( {   child :   childSchema   } , \n   {   strict :   throw ,   useNestedStrict :   true   } );  var   Parent   =   mongoose . model ( Parent ,   parentSchema );  Parent . update ( {} ,   {   child.name :   Luke   Skywalker   } ,   function ( error )   {  } );", 
            "title": "useNestedStrict"
        }, 
        {
            "location": "/guide/Schemas/#_11", 
            "text": "Schema\u4e5f\u662f \u53ef\u63d2\u62d4 \uff0c\u5b83\u5141\u8bb8\u6211\u4eec\u5c06\u53ef\u91cd\u7528\u7684\u7279\u6027\u6253\u5305\u6210\u53ef\u4e0e\u793e\u533a\u5171\u4eab\u6216\u53ea\u5728\u60a8\u7684\u9879\u76ee\u4e4b\u95f4\u5171\u4eab\u7684\u63d2\u4ef6\u3002", 
            "title": "\u53ef\u63d2\u62d4"
        }, 
        {
            "location": "/guide/Schemas/#_12", 
            "text": "\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u6a21\u5f0f\uff0c\u6211\u4eec\u6765\u770b\u770b \u6a21\u5f0f\u7c7b\u578b .", 
            "title": "\u63a5\u4e0b\u6765"
        }, 
        {
            "location": "/guide/Connections/", 
            "text": "Mongoose v5.0.1: Connecting to MongoDB\n\n\nSource\n\n\nYou can connect to MongoDB with the \nmongoose.connect()\n method.\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/myapp\n);\n\n\n\n\n\n\nThis is the minimum needed to connect the \nmyapp\n database running locally on the default port (27017). If the local connection fails then try using 127.0.0.1 instead of localhost. Sometimes issues may arise when the local hostname has been changed.\n\n\nYou can also specify several more parameters in the \nuri\n:\n\n\nmongoose\n.\nconnect\n(\nmongodb://username:password@host:port/database?options...\n);\n\n\n\n\n\n\nSee the \nmongodb connection string spec\n for more detail.\n\n\nOperation Buffering\n\n\nMongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost/myapp\n);\n\n\nvar\n \nMyModel\n \n=\n \nmongoose\n.\nmodel\n(\nTest\n,\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n));\n\n\n\nMyModel\n.\nfindOne\n(\nfunction\n(\nerror\n,\n \nresult\n)\n \n{\n  \n}\n);\n\n\n\n\n\n\nThat's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will \nnot\n throw any errors by default if you use a model without connecting.\n\n\nvar\n \nMyModel\n \n=\n \nmongoose\n.\nmodel\n(\nTest\n,\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n));\n\n\n\nMyModel\n.\nfindOne\n(\nfunction\n(\nerror\n,\n \nresult\n)\n \n{\n  \n}\n);\n\n\n\nsetTimeout\n(\nfunction\n()\n \n{\n\n  \nmongoose.connect(\nmongodb\n:\n//\nlocalhost\n/\nmyapp\n);\n\n\n}\n,\n \n60000\n);\n\n\n\n\n\n\nTo disable buffering, turn off the \nbufferCommands\n option on your schema\n. If you have \nbufferCommands\n on and your connection is hanging, try turning \nbufferCommands\n off to see if you haven't opened a connection properly. You can also disable \nbufferCommands\n globally:\n\n\nmongoose.set(\nbufferCommands\n, false);\n\n\n\n\n\nOptions\n\n\nThe \nconnect\n method also accepts an \noptions\n object which will be passed on to the underlying MongoDB driver.\n\n\nmongoose.connect(uri, options);\n\n\n\n\n\nA full list of options can be found on the \nMongoDB Node.js driver docs for \nconnect()\n. Mongoose passes options to the driver without modification, modulo three exceptions that are explained below.\n\n\n\n\nbufferCommands\n - This is a mongoose-specific option (not passed to the MongoDB driver) that disables \nmongoose's buffering mechanism\n\n\nuser\n/\npass\n - The username and password for authentication. These options are mongoose-specific, they are equivalent to the MongoDB driver's \nauth.user\n and \nauth.password\n options.\n\n\nautoIndex\n - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set \nautoIndex\n to false, mongoose will not automatically build indexes for \nany\n model associated with this connection.\n\n\n\n\nBelow are some of the options that are important for tuning mongoose.\n\n\n\n\nautoReconnect\n - The underlying MongoDB driver will automatically try to reconnect when it loses connection to MongoDB. Unless you are an extremely advanced user that wants to manage their own connection pool, do \nnot\n set this option to \nfalse\n.\n\n\nreconnectTries\n - If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every \nreconnectInterval\n milliseconds for \nreconnectTries\n times, and give up afterward. When the driver gives up, the mongoose connection emits a \nreconnectFailed\n event. This option does nothing for replica set connections.\n\n\nreconnectInterval\n - See \nreconnectTries\n\n\npromiseLibrary\n - sets the \nunderlying driver's promise library\n\n\npoolSize\n - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, \npoolSize\n is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding.\n\n\nbufferMaxEntries\n - The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set \nbufferCommands\n to \nfalse\n on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection.\n\n\n\n\nExample:\n\n\nconst options = {\n  useMongoClient: true,\n  autoIndex: false,\n  reconnectTries: Number.MAX_VALUE,\n  reconnectInterval: 500,\n  poolSize: 10,\n\n  bufferMaxEntries: 0\n};\nmongoose.connect(uri, options);\n\n\n\n\n\nCallback\n\n\nThe \nconnect()\n function also accepts a callback parameter and returns a \npromise\n.\n\n\nmongoose.connect(uri, options, function(error) {\n\n});\n\n\nmongoose.connect(uri, options).then(\n  () =\n {  },\n  err =\n {  }\n);\n\n\n\n\n\nConnection String Options\n\n\nYou can also specify driver options in your connection string as \nparameters in the query string\n portion of the URI. This only applies to options passed to the MongoDB driver. You \ncan't\n set Mongoose-specific options like \nbufferCommands\n in the query string.\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost:27017/test?connectTimeoutMS=1000\nbufferCommands=false\n);\n\n\n\nmongoose\n.\nconnect\n(\nmongodb://localhost:27017/test\n,\n \n{\n\n  \nconnectTimeoutMS\n:\n \n1000\n\n\n\n}\n);\n\n\n\n\n\n\nThe disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for \nsocketTimeoutMS\n, \nconnectTimeoutMS\n, etc. Best practice is to put options that likely differ between development and production, like \nreplicaSet\n or \nssl\n, in the connection string, and options that should remain constant, like \nconnectTimeoutMS\n or \npoolSize\n, in the options object.\n\n\nThe MongoDB docs have a full list of \nsupported connection string options\n\n\nA note about keepAlive\n\n\nFor long running applications, it is often prudent to enable \nkeepAlive\n with a number of milliseconds. Without it, after some period of time you may start to see \n\"connection closed\"\n errors for what seems like no reason. If so, after \nreading this\n, you may decide to enable \nkeepAlive\n:\n\n\nmongoose\n.\nconnect\n(\nuri\n,\n \n{\n \nkeepAlive\n:\n \n120\n \n}\n);\n\n\n\n\n\n\nReplica Set Connections\n\n\nTo connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.\n\n\nmongoose\n.\nconnect\n(\nmongodb://\n[\nusername\n:\npassword\n@\n]\nhost1\n[\n:\nport1\n][\n,\nhost2\n[\n:\nport2\n]\n,...\n[\n,\nhostN\n[\n:\nportN\n]\n]]\n[\n/\n[\ndatabase\n][\n?\noptions\n]\n]\n \n[\n,\n \noptions\n]\n);\n\n\n\n\n\n\nTo connect to a single node replica set, specify the \nreplicaSet\n option.\n\n\nmongoose\n.\nconnect\n(\nmongodb://host1:port1/?replicaSet=rsName\n);\n\n\n\n\n\n\nMulti-mongos support\n\n\nHigh availability over multiple \nmongos\n instances is also supported. Pass a connection string for your \nmongos\n instances and set the \nmongos\n option to \ntrue\n:\n\n\nmongoose\n.\nconnect\n(\nmongodb://mongosA:27501,mongosB:27501\n,\n \n{\n \nmongos\n:\n \ntrue\n \n}\n,\n \ncb\n);\n\n\n\n\n\n\nMultiple connections\n\n\nSo far we've seen how to connect to MongoDB using Mongoose's default connection. At times we may need multiple connections open to Mongo, each with different read/write settings, or maybe just to different databases for example. In these cases we can utilize \nmongoose.createConnection()\n which accepts all the arguments already discussed and returns a fresh connection for you.\n\n\nconst\n \nconn\n \n=\n \nmongoose\n.\ncreateConnection\n(\nmongodb://\n[\nusername\n:\npassword\n@\n]\nhost1\n[\n:\nport1\n][\n,\nhost2\n[\n:\nport2\n]\n,...\n[\n,\nhostN\n[\n:\nportN\n]\n]]\n[\n/\n[\ndatabase\n][\n?\noptions\n]\n]\n,\n \noptions\n);\n\n\n\n\n\n\nThis \nconnection\n object is then used to create and retrieve \nmodels\n. Models are \nalways\n scoped to a single connection.\n\n\nMongoose creates a \ndefault connection\n when you call \nmongoose.connect()\n. You can access the default connection using \nmongoose.connection\n.\n\n\nConnection pools\n\n\nEach \nconnection\n, whether created with \nmongoose.connect\n or \nmongoose.createConnection\n are all backed by an internal configurable connection pool defaulting to a maximum size of 5. Adjust the pool size using your connection options:\n\n\nmongoose\n.\ncreateConnection\n(\nuri\n,\n \n{\n \npoolSize\n:\n \n4\n \n}\n);\n\n\n\nconst\n \nuri\n \n=\n \nmongodb://localhost/test?poolSize=4\n;\n\n\nmongoose\n.\ncreateConnection\n(\nuri\n);\n\n\n\n\n\n\nOption Changes in v5.x\n\n\nYou may see the following deprecation warning if upgrading from 4.x to 5.x and you didn't use the \nuseMongoClient\n option in 4.x:\n\n\nthe server/replset/mongos options are deprecated, all their options are supported at the top level of the options object\n\n\n\n\n\nIn older version of the MongoDB driver you had to specify distinct options for server connections, replica set connections, and mongos connections:\n\n\nmongoose.connect(myUri, {\n  server: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  replset: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  mongos: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  }\n});\n\n\n\n\n\nIn mongoose v5.x you can instead declare these options at the top level, without all that extra nesting. \nHere's the list of all supported options\n.\n\n\nmongoose.connect(myUri, {\n  socketTimeoutMS: 0,\n  keepAlive: true,\n  reconnectTries: 30\n});\n\n\n\n\n\nNext Up\n\n\nNow that we've covered connections, let's take a look at \nmodels\n.", 
            "title": "\u8fde\u63a5"
        }, 
        {
            "location": "/guide/Connections/#mongoose-v501-connecting-to-mongodb", 
            "text": "Source  You can connect to MongoDB with the  mongoose.connect()  method.  mongoose . connect ( mongodb://localhost/myapp );   This is the minimum needed to connect the  myapp  database running locally on the default port (27017). If the local connection fails then try using 127.0.0.1 instead of localhost. Sometimes issues may arise when the local hostname has been changed.  You can also specify several more parameters in the  uri :  mongoose . connect ( mongodb://username:password@host:port/database?options... );   See the  mongodb connection string spec  for more detail.", 
            "title": "Mongoose v5.0.1: Connecting to MongoDB"
        }, 
        {
            "location": "/guide/Connections/#operation-buffering", 
            "text": "Mongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.  mongoose . connect ( mongodb://localhost/myapp );  var   MyModel   =   mongoose . model ( Test ,   new   Schema ( {   name :   String   } ));  MyModel . findOne ( function ( error ,   result )   {    } );   That's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will  not  throw any errors by default if you use a model without connecting.  var   MyModel   =   mongoose . model ( Test ,   new   Schema ( {   name :   String   } ));  MyModel . findOne ( function ( error ,   result )   {    } );  setTimeout ( function ()   { \n   mongoose.connect( mongodb : // localhost / myapp );  } ,   60000 );   To disable buffering, turn off the  bufferCommands  option on your schema . If you have  bufferCommands  on and your connection is hanging, try turning  bufferCommands  off to see if you haven't opened a connection properly. You can also disable  bufferCommands  globally:  mongoose.set( bufferCommands , false);", 
            "title": "Operation Buffering"
        }, 
        {
            "location": "/guide/Connections/#options", 
            "text": "The  connect  method also accepts an  options  object which will be passed on to the underlying MongoDB driver.  mongoose.connect(uri, options);  A full list of options can be found on the  MongoDB Node.js driver docs for  connect() . Mongoose passes options to the driver without modification, modulo three exceptions that are explained below.   bufferCommands  - This is a mongoose-specific option (not passed to the MongoDB driver) that disables  mongoose's buffering mechanism  user / pass  - The username and password for authentication. These options are mongoose-specific, they are equivalent to the MongoDB driver's  auth.user  and  auth.password  options.  autoIndex  - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set  autoIndex  to false, mongoose will not automatically build indexes for  any  model associated with this connection.   Below are some of the options that are important for tuning mongoose.   autoReconnect  - The underlying MongoDB driver will automatically try to reconnect when it loses connection to MongoDB. Unless you are an extremely advanced user that wants to manage their own connection pool, do  not  set this option to  false .  reconnectTries  - If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every  reconnectInterval  milliseconds for  reconnectTries  times, and give up afterward. When the driver gives up, the mongoose connection emits a  reconnectFailed  event. This option does nothing for replica set connections.  reconnectInterval  - See  reconnectTries  promiseLibrary  - sets the  underlying driver's promise library  poolSize  - The maximum number of sockets the MongoDB driver will keep open for this connection. By default,  poolSize  is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding.  bufferMaxEntries  - The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set  bufferCommands  to  false  on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection.   Example:  const options = {\n  useMongoClient: true,\n  autoIndex: false,\n  reconnectTries: Number.MAX_VALUE,\n  reconnectInterval: 500,\n  poolSize: 10,\n\n  bufferMaxEntries: 0\n};\nmongoose.connect(uri, options);", 
            "title": "Options"
        }, 
        {
            "location": "/guide/Connections/#callback", 
            "text": "The  connect()  function also accepts a callback parameter and returns a  promise .  mongoose.connect(uri, options, function(error) {\n\n});\n\n\nmongoose.connect(uri, options).then(\n  () =  {  },\n  err =  {  }\n);", 
            "title": "Callback"
        }, 
        {
            "location": "/guide/Connections/#connection-string-options", 
            "text": "You can also specify driver options in your connection string as  parameters in the query string  portion of the URI. This only applies to options passed to the MongoDB driver. You  can't  set Mongoose-specific options like  bufferCommands  in the query string.  mongoose . connect ( mongodb://localhost:27017/test?connectTimeoutMS=1000 bufferCommands=false );  mongoose . connect ( mongodb://localhost:27017/test ,   { \n   connectTimeoutMS :   1000  } );   The disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for  socketTimeoutMS ,  connectTimeoutMS , etc. Best practice is to put options that likely differ between development and production, like  replicaSet  or  ssl , in the connection string, and options that should remain constant, like  connectTimeoutMS  or  poolSize , in the options object.  The MongoDB docs have a full list of  supported connection string options", 
            "title": "Connection String Options"
        }, 
        {
            "location": "/guide/Connections/#a-note-about-keepalive", 
            "text": "For long running applications, it is often prudent to enable  keepAlive  with a number of milliseconds. Without it, after some period of time you may start to see  \"connection closed\"  errors for what seems like no reason. If so, after  reading this , you may decide to enable  keepAlive :  mongoose . connect ( uri ,   {   keepAlive :   120   } );", 
            "title": "A note about keepAlive"
        }, 
        {
            "location": "/guide/Connections/#replica-set-connections", 
            "text": "To connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.  mongoose . connect ( mongodb:// [ username : password @ ] host1 [ : port1 ][ , host2 [ : port2 ] ,... [ , hostN [ : portN ] ]] [ / [ database ][ ? options ] ]   [ ,   options ] );   To connect to a single node replica set, specify the  replicaSet  option.  mongoose . connect ( mongodb://host1:port1/?replicaSet=rsName );", 
            "title": "Replica Set Connections"
        }, 
        {
            "location": "/guide/Connections/#multi-mongos-support", 
            "text": "High availability over multiple  mongos  instances is also supported. Pass a connection string for your  mongos  instances and set the  mongos  option to  true :  mongoose . connect ( mongodb://mongosA:27501,mongosB:27501 ,   {   mongos :   true   } ,   cb );", 
            "title": "Multi-mongos support"
        }, 
        {
            "location": "/guide/Connections/#multiple-connections", 
            "text": "So far we've seen how to connect to MongoDB using Mongoose's default connection. At times we may need multiple connections open to Mongo, each with different read/write settings, or maybe just to different databases for example. In these cases we can utilize  mongoose.createConnection()  which accepts all the arguments already discussed and returns a fresh connection for you.  const   conn   =   mongoose . createConnection ( mongodb:// [ username : password @ ] host1 [ : port1 ][ , host2 [ : port2 ] ,... [ , hostN [ : portN ] ]] [ / [ database ][ ? options ] ] ,   options );   This  connection  object is then used to create and retrieve  models . Models are  always  scoped to a single connection.  Mongoose creates a  default connection  when you call  mongoose.connect() . You can access the default connection using  mongoose.connection .", 
            "title": "Multiple connections"
        }, 
        {
            "location": "/guide/Connections/#connection-pools", 
            "text": "Each  connection , whether created with  mongoose.connect  or  mongoose.createConnection  are all backed by an internal configurable connection pool defaulting to a maximum size of 5. Adjust the pool size using your connection options:  mongoose . createConnection ( uri ,   {   poolSize :   4   } );  const   uri   =   mongodb://localhost/test?poolSize=4 ;  mongoose . createConnection ( uri );", 
            "title": "Connection pools"
        }, 
        {
            "location": "/guide/Connections/#option-changes-in-v5x", 
            "text": "You may see the following deprecation warning if upgrading from 4.x to 5.x and you didn't use the  useMongoClient  option in 4.x:  the server/replset/mongos options are deprecated, all their options are supported at the top level of the options object  In older version of the MongoDB driver you had to specify distinct options for server connections, replica set connections, and mongos connections:  mongoose.connect(myUri, {\n  server: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  replset: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  },\n  mongos: {\n    socketOptions: {\n      socketTimeoutMS: 0,\n      keepAlive: true\n    },\n    reconnectTries: 30\n  }\n});  In mongoose v5.x you can instead declare these options at the top level, without all that extra nesting.  Here's the list of all supported options .  mongoose.connect(myUri, {\n  socketTimeoutMS: 0,\n  keepAlive: true,\n  reconnectTries: 30\n});", 
            "title": "Option Changes in v5.x"
        }, 
        {
            "location": "/guide/Connections/#next-up", 
            "text": "Now that we've covered connections, let's take a look at  models .", 
            "title": "Next Up"
        }, 
        {
            "location": "/guide/Models/", 
            "text": "Mongoose v5.0.1: Models\n\n\nModels\n\n\nSource\n\n\nModels\n are fancy constructors compiled from our \nSchema\n definitions. Instances of these models represent \ndocuments\n which can be saved and retrieved from our database. All document creation and retrieval from the database is handled by these models.\n\n\nCompiling your first model\n\n\nvar schema = new mongoose.Schema({ name: 'string', size: 'string' }); var Tank = mongoose.model('Tank', schema);\n\n\nThe first argument is the \nsingular\n name of the collection your model is for. \n Mongoose automatically looks for the \nplural\n version of your model name. \n Thus, for the example above, the model Tank is for the \ntanks\n collection in the database. The \n.model()\n function makes a copy of \nschema\n. Make sure that you've added everything you want to \nschema\n before calling \n.model()\n!\n\n\nConstructing documents\n\n\nDocuments\n are instances of our model. Creating them and saving to the database is easy:\n\n\nvar Tank = mongoose.model('Tank', yourSchema); var small = new Tank({ size: 'small' }); small.save(function (err) { if (err) return handleError(err); // saved! }) // or Tank.create({ size: 'small' }, function (err, small) { if (err) return handleError(err); // saved! })\n\n\nNote that no tanks will be created/removed until the connection your model uses is open. Every model has an associated connection. When you use \nmongoose.model()\n, your model will use the default mongoose connection.\n\n\nmongoose.connect('localhost', 'gettingstarted');\n\n\nIf you create a custom connection, use that connection's \nmodel()\n function instead.\n\n\nvar connection = mongoose.createConnection('mongodb://localhost:27017/test'); var Tank = connection.model('Tank', yourSchema);\n\n\nQuerying\n\n\nFinding documents is easy with Mongoose, which supports the \nrich\n query syntax of MongoDB. Documents can be retreived using each \nmodels\n \nfind\n, \nfindById\n, \nfindOne\n, or \nwhere\n static methods.\n\n\nTank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback);\n\n\nSee the chapter on \nquerying\n for more details on how to use the \nQuery\n api.\n\n\nRemoving\n\n\nModels have a static \nremove\n method available for removing all documents matching \nconditions\n.\n\n\nTank.remove({ size: 'large' }, function (err) { if (err) return handleError(err); // removed! });\n\n\nUpdating\n\n\nEach \nmodel\n has its own \nupdate\n method for modifying documents in the database without returning them to your application. See the \nAPI\n docs for more detail.\n\n\nIf you want to update a single document in the db and return it to your application, use \nfindOneAndUpdate\n instead.\n\n\nYet more\n\n\nThe \nAPI docs\n cover many additional methods available like \ncount\n, \nmapReduce\n, \naggregate\n, and \nmore\n.\n\n\nNext Up\n\n\nNow that we've covered \nModels\n, let's take a look at \nDocuments\n.", 
            "title": "\u6977\u6a21"
        }, 
        {
            "location": "/guide/Models/#mongoose-v501-models", 
            "text": "", 
            "title": "Mongoose v5.0.1: Models"
        }, 
        {
            "location": "/guide/Models/#models", 
            "text": "Source  Models  are fancy constructors compiled from our  Schema  definitions. Instances of these models represent  documents  which can be saved and retrieved from our database. All document creation and retrieval from the database is handled by these models.", 
            "title": "Models"
        }, 
        {
            "location": "/guide/Models/#compiling-your-first-model", 
            "text": "var schema = new mongoose.Schema({ name: 'string', size: 'string' }); var Tank = mongoose.model('Tank', schema);  The first argument is the  singular  name of the collection your model is for.   Mongoose automatically looks for the  plural  version of your model name.   Thus, for the example above, the model Tank is for the  tanks  collection in the database. The  .model()  function makes a copy of  schema . Make sure that you've added everything you want to  schema  before calling  .model() !", 
            "title": "Compiling your first model"
        }, 
        {
            "location": "/guide/Models/#constructing-documents", 
            "text": "Documents  are instances of our model. Creating them and saving to the database is easy:  var Tank = mongoose.model('Tank', yourSchema); var small = new Tank({ size: 'small' }); small.save(function (err) { if (err) return handleError(err); // saved! }) // or Tank.create({ size: 'small' }, function (err, small) { if (err) return handleError(err); // saved! })  Note that no tanks will be created/removed until the connection your model uses is open. Every model has an associated connection. When you use  mongoose.model() , your model will use the default mongoose connection.  mongoose.connect('localhost', 'gettingstarted');  If you create a custom connection, use that connection's  model()  function instead.  var connection = mongoose.createConnection('mongodb://localhost:27017/test'); var Tank = connection.model('Tank', yourSchema);", 
            "title": "Constructing documents"
        }, 
        {
            "location": "/guide/Models/#querying", 
            "text": "Finding documents is easy with Mongoose, which supports the  rich  query syntax of MongoDB. Documents can be retreived using each  models   find ,  findById ,  findOne , or  where  static methods.  Tank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback);  See the chapter on  querying  for more details on how to use the  Query  api.", 
            "title": "Querying"
        }, 
        {
            "location": "/guide/Models/#removing", 
            "text": "Models have a static  remove  method available for removing all documents matching  conditions .  Tank.remove({ size: 'large' }, function (err) { if (err) return handleError(err); // removed! });", 
            "title": "Removing"
        }, 
        {
            "location": "/guide/Models/#updating", 
            "text": "Each  model  has its own  update  method for modifying documents in the database without returning them to your application. See the  API  docs for more detail.  If you want to update a single document in the db and return it to your application, use  findOneAndUpdate  instead.", 
            "title": "Updating"
        }, 
        {
            "location": "/guide/Models/#yet-more", 
            "text": "The  API docs  cover many additional methods available like  count ,  mapReduce ,  aggregate , and  more .", 
            "title": "Yet more"
        }, 
        {
            "location": "/guide/Models/#next-up", 
            "text": "Now that we've covered  Models , let's take a look at  Documents .", 
            "title": "Next Up"
        }, 
        {
            "location": "/guide/Documents/", 
            "text": "Mongoose v5.0.1: Documents\n\n\nDocuments\n\n\nSource\n\n\nMongoose \ndocuments\n represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its \nModel\n.\n\n\nRetrieving\n\n\nThere are many ways to retrieve documents from MongoDB. We won't cover that in this section. See the chapter on \nquerying\n for detail.\n\n\nUpdating\n\n\nThere are a number of ways to update documents. We'll first look at a traditional approach using \nfindById\n:\n\n\nTank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  tank.size = \nlarge\n;\n  tank.save(function (err, updatedTank) {\n    if (err) return handleError(err);\n    res.send(updatedTank);\n  });\n});\n\n\n\n\n\nYou can also use \n.set()\n to modify documents. Under the hood, \ntank.size = 'large';\n becomes \ntank.set({ size: 'large' })\n.\n\n\nTank\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \ntank\n)\n \n{\n\n  \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n\n  \ntank.set({\n \nsize\n:\n \nlarge\n \n}\n);\n\n  \ntank\n.\nsave\n(\nfunction\n \n(\nerr\n,\n \nupdatedTank\n)\n \n{\n\n    \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n    \nres.send(updatedTank)\n;\n\n  \n}\n);\n\n\n}\n);\n\n\n\n\n\n\nThis approach involves first retrieving the document from Mongo, then issuing an update command (triggered by calling \nsave\n). However, if we don't need the document returned in our application and merely want to update a property in the database directly, \nModel#update\n is right for us:\n\n\nTank\n.\nupdate\n(\n{\n \n_id\n:\n \nid\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \nsize\n:\n \nlarge\n \n}\n}\n,\n \ncallback\n);\n\n\n\n\n\n\nIf we do need the document returned in our application there is another, often \nbetter\n, option:\n\n\nTank.findByIdAndUpdate(id, { $set: { size: \nlarge\n }}, { new: true }, function (err, tank) {\n  if (err) return handleError(err);\n  res.send(tank);\n});\n\n\n\n\n\nThe \nfindAndUpdate/Remove\n static methods all make a change to at most one document, and return it with just one call to the database. There \nare\n \nseveral\n \nvariations\n on the \nfindAndModify\n theme. Read the \nAPI\n docs for more detail.\n\n\nNote that \nfindAndUpdate/Remove\n do _not\n execute any hooks or validation before making the change in the database. You can use the \nrunValidators\n option\n to access a limited subset of document validation. However, if you need hooks and full document validation, first query for the document and then \nsave()\n it._\n\n\nValidating\n\n\nDocuments are validated before they are saved. Read the \napi\n docs or the \nvalidation\n chapter for detail.\n\n\nOverwriting\n\n\nYou can overwrite an entire document using \n.set()\n. This is handy if you want to change what document is being saved in \nmiddleware\n.\n\n\nTank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  otherTank.set(tank);\n});\n\n\n\n\n\nNext Up\n\n\nNow that we've covered Documents, let's take a look at \nSub-documents\n.", 
            "title": "\u6587\u4ef6"
        }, 
        {
            "location": "/guide/Documents/#mongoose-v501-documents", 
            "text": "", 
            "title": "Mongoose v5.0.1: Documents"
        }, 
        {
            "location": "/guide/Documents/#documents", 
            "text": "Source  Mongoose  documents  represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its  Model .", 
            "title": "Documents"
        }, 
        {
            "location": "/guide/Documents/#retrieving", 
            "text": "There are many ways to retrieve documents from MongoDB. We won't cover that in this section. See the chapter on  querying  for detail.", 
            "title": "Retrieving"
        }, 
        {
            "location": "/guide/Documents/#updating", 
            "text": "There are a number of ways to update documents. We'll first look at a traditional approach using  findById :  Tank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  tank.size =  large ;\n  tank.save(function (err, updatedTank) {\n    if (err) return handleError(err);\n    res.send(updatedTank);\n  });\n});  You can also use  .set()  to modify documents. Under the hood,  tank.size = 'large';  becomes  tank.set({ size: 'large' }) .  Tank . findById ( id ,   function   ( err ,   tank )   { \n   if   (err)   return   handleError(err) ; \n\n   tank.set({   size :   large   } ); \n   tank . save ( function   ( err ,   updatedTank )   { \n     if   (err)   return   handleError(err) ; \n     res.send(updatedTank) ; \n   } );  } );   This approach involves first retrieving the document from Mongo, then issuing an update command (triggered by calling  save ). However, if we don't need the document returned in our application and merely want to update a property in the database directly,  Model#update  is right for us:  Tank . update ( {   _id :   id   } ,   {   $ set :   {   size :   large   } } ,   callback );   If we do need the document returned in our application there is another, often  better , option:  Tank.findByIdAndUpdate(id, { $set: { size:  large  }}, { new: true }, function (err, tank) {\n  if (err) return handleError(err);\n  res.send(tank);\n});  The  findAndUpdate/Remove  static methods all make a change to at most one document, and return it with just one call to the database. There  are   several   variations  on the  findAndModify  theme. Read the  API  docs for more detail.  Note that  findAndUpdate/Remove  do _not  execute any hooks or validation before making the change in the database. You can use the  runValidators  option  to access a limited subset of document validation. However, if you need hooks and full document validation, first query for the document and then  save()  it._", 
            "title": "Updating"
        }, 
        {
            "location": "/guide/Documents/#validating", 
            "text": "Documents are validated before they are saved. Read the  api  docs or the  validation  chapter for detail.", 
            "title": "Validating"
        }, 
        {
            "location": "/guide/Documents/#overwriting", 
            "text": "You can overwrite an entire document using  .set() . This is handy if you want to change what document is being saved in  middleware .  Tank.findById(id, function (err, tank) {\n  if (err) return handleError(err);\n\n  otherTank.set(tank);\n});", 
            "title": "Overwriting"
        }, 
        {
            "location": "/guide/Documents/#next-up", 
            "text": "Now that we've covered Documents, let's take a look at  Sub-documents .", 
            "title": "Next Up"
        }, 
        {
            "location": "/guide/Queries/", 
            "text": "Mongoose v5.0.1: Queries\n\n\nQueries\n\n\nSource\n\n\nDocuments can be retrieved through several static helper methods of \nmodels\n.\n\n\nAny \nmodel\n method which \ninvolves\n \nspecifying\n \nquery\n \nconditions\n can be executed two ways:\n\n\nWhen a \ncallback\n function:\n\n\n\n\nis passed, the operation will be executed immediately with the results passed to the callback.\n\n\nis not passed, an instance of \nQuery\n is returned, which provides a special query builder interface.\n\n\n\n\nA \nQuery\n has a \n.then()\n function, and thus can be used as a promise.\n\n\nWhen executing a query with a \ncallback\n function, you specify your query as a JSON document. The JSON document's syntax is the same as the \nMongoDB shell\n.\n\n\nvar Person = mongoose.model(\nPerson\n, yourSchema);\n\n\nPerson.findOne({ \nname.last\n: \nGhost\n }, \nname occupation\n, function (err, person) {\n  if (err) return handleError(err);\n\n  console.log(\n%s %s is a %s.\n, person.name.first, person.name.last,\n    person.occupation);\n});\n\n\n\n\n\nHere we see that the query was executed immediately and the results passed to our callback. All callbacks in Mongoose use the pattern: \ncallback(error, result)\n. If an error occurs executing the query, the \nerror\n parameter will contain an error document, and \nresult\n will be null. If the query is successful, the \nerror\n parameter will be null, and the \nresult\n will be populated with the results of the query.\n\n\nAnywhere a callback is passed to a query in Mongoose, the callback follows the pattern \ncallback(error, results)\n. What \nresults\n is depends on the operation: For \nfindOne()\n it is a \npotentially-null single document\n, \nfind()\n a \nlist of documents\n, \ncount()\n \nthe number of documents\n, \nupdate()\n the \nnumber of documents affected\n, etc. The \nAPI docs for Models\n provide more detail on what is passed to the callbacks.\n\n\nNow let's look at what happens when no \ncallback\n is passed:\n\n\nvar query = Person.findOne({ \nname.last\n: \nGhost\n });\n\n\nquery.select(\nname occupation\n);\n\n\nquery.exec(function (err, person) {\n  if (err) return handleError(err);\n\n  console.log(\n%s %s is a %s.\n, person.name.first, person.name.last,\n    person.occupation);\n});\n\n\n\n\n\nIn the above code, the \nquery\n variable is of type \nQuery\n. A \nQuery\n enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent.\n\n\nPerson.\n  find({\n    occupation: /host/,\n    \nname.last\n: \nGhost\n,\n    age: { $gt: 17, $lt: 66 },\n    likes: { $in: [\nvaporizing\n, \ntalking\n] }\n  }).\n  limit(10).\n  sort({ occupation: -1 }).\n  select({ name: 1, occupation: 1 }).\n  exec(callback);\n\n\nPerson.\n  find({ occupation: /host/ }).\n  where(\nname.last\n).equals(\nGhost\n).\n  where(\nage\n).gt(17).lt(66).\n  where(\nlikes\n).in([\nvaporizing\n, \ntalking\n]).\n  limit(10).\n  sort(\n-occupation\n).\n  select(\nname occupation\n).\n  exec(callback);\n\n\n\n\n\nA full list of \nQuery helper functions can be found in the API docs\n.\n\n\nReferences to other documents\n\n\nThere are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where \npopulation\n comes in. Read more about how to include documents from other collections in your query results \nhere\n.\n\n\nStreaming\n\n\nYou can \nstream\n query results from MongoDB. You need to call the \nQuery#cursor()\n function to return an instance of \nQueryCursor\n.\n\n\nvar\n \ncursor\n \n=\n \nPerson\n.\nfind\n(\n{\n \noccupation\n:\n \n/\nhost\n/\n \n}\n)\n.\ncursor\n();\n\n\ncursor\n.\non\n(\ndata\n,\n \nfunction\n(\ndoc\n)\n \n{\n\n\n\n}\n);\n\n\ncursor\n.\non\n(\nclose\n,\n \nfunction\n()\n \n{\n\n\n\n}\n);", 
            "title": "\u67e5\u8be2"
        }, 
        {
            "location": "/guide/Queries/#mongoose-v501-queries", 
            "text": "", 
            "title": "Mongoose v5.0.1: Queries"
        }, 
        {
            "location": "/guide/Queries/#queries", 
            "text": "Source  Documents can be retrieved through several static helper methods of  models .  Any  model  method which  involves   specifying   query   conditions  can be executed two ways:  When a  callback  function:   is passed, the operation will be executed immediately with the results passed to the callback.  is not passed, an instance of  Query  is returned, which provides a special query builder interface.   A  Query  has a  .then()  function, and thus can be used as a promise.  When executing a query with a  callback  function, you specify your query as a JSON document. The JSON document's syntax is the same as the  MongoDB shell .  var Person = mongoose.model( Person , yourSchema);\n\n\nPerson.findOne({  name.last :  Ghost  },  name occupation , function (err, person) {\n  if (err) return handleError(err);\n\n  console.log( %s %s is a %s. , person.name.first, person.name.last,\n    person.occupation);\n});  Here we see that the query was executed immediately and the results passed to our callback. All callbacks in Mongoose use the pattern:  callback(error, result) . If an error occurs executing the query, the  error  parameter will contain an error document, and  result  will be null. If the query is successful, the  error  parameter will be null, and the  result  will be populated with the results of the query.  Anywhere a callback is passed to a query in Mongoose, the callback follows the pattern  callback(error, results) . What  results  is depends on the operation: For  findOne()  it is a  potentially-null single document ,  find()  a  list of documents ,  count()   the number of documents ,  update()  the  number of documents affected , etc. The  API docs for Models  provide more detail on what is passed to the callbacks.  Now let's look at what happens when no  callback  is passed:  var query = Person.findOne({  name.last :  Ghost  });\n\n\nquery.select( name occupation );\n\n\nquery.exec(function (err, person) {\n  if (err) return handleError(err);\n\n  console.log( %s %s is a %s. , person.name.first, person.name.last,\n    person.occupation);\n});  In the above code, the  query  variable is of type  Query . A  Query  enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent.  Person.\n  find({\n    occupation: /host/,\n     name.last :  Ghost ,\n    age: { $gt: 17, $lt: 66 },\n    likes: { $in: [ vaporizing ,  talking ] }\n  }).\n  limit(10).\n  sort({ occupation: -1 }).\n  select({ name: 1, occupation: 1 }).\n  exec(callback);\n\n\nPerson.\n  find({ occupation: /host/ }).\n  where( name.last ).equals( Ghost ).\n  where( age ).gt(17).lt(66).\n  where( likes ).in([ vaporizing ,  talking ]).\n  limit(10).\n  sort( -occupation ).\n  select( name occupation ).\n  exec(callback);  A full list of  Query helper functions can be found in the API docs .", 
            "title": "Queries"
        }, 
        {
            "location": "/guide/Queries/#references-to-other-documents", 
            "text": "There are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where  population  comes in. Read more about how to include documents from other collections in your query results  here .", 
            "title": "References to other documents"
        }, 
        {
            "location": "/guide/Queries/#streaming", 
            "text": "You can  stream  query results from MongoDB. You need to call the  Query#cursor()  function to return an instance of  QueryCursor .  var   cursor   =   Person . find ( {   occupation :   / host /   } ) . cursor ();  cursor . on ( data ,   function ( doc )   {  } );  cursor . on ( close ,   function ()   {  } );", 
            "title": "Streaming"
        }, 
        {
            "location": "/guide/Validation/", 
            "text": "Validation\n\n\nSource\n\n\nBefore we get into the specifics of validation syntax, please keep the following rules in mind:\n\n\n\n\nValidation is defined in the \nSchemaType\n\n\nValidation is \nmiddleware\n. Mongoose registers validation as a \npre('save')\n hook on every schema by default.\n\n\nYou can manually run validation using \ndoc.validate(callback)\n or \ndoc.validateSync()\n\n\nValidators are not run on undefined values. The only exception is the \nrequired\n validator\n.\n\n\nValidation is asynchronously recursive; when you call \nModel#save\n, sub-document validation is executed as well. If an error occurs, your \nModel#save\n callback receives it\n\n\nValidation is customizable\nvar schema = new Schema({\n  name: {\n    type: String,\n    required: true\n  }\n});\nvar Cat = db.model(\nCat\n, schema);\n\nvar cat = new Cat();\ncat.save(function(error) {\n  assert.equal(error.errors[\nname\n].message,\n    \nPath `name` is required.\n);\n\n  error = cat.validateSync();\n  assert.equal(error.errors[\nname\n].message,\n    \nPath `name` is required.\n);\n});\n\n\n\n\n\n\n\n\n\nMongoose has several built-in validators.\n\n\nEach of the validator links above provide more information about how to enable them and customize their error messages.\n\n\n    var breakfastSchema = new Schema({\n      eggs: {\n        type: Number,\n        min: [6, \nToo few eggs\n],\n        max: 12\n      },\n      bacon: {\n        type: Number,\n        required: [true, \nWhy no bacon?\n]\n      },\n      drink: {\n        type: String,\n        enum: [\nCoffee\n, \nTea\n],\n        required: function() {\n          return this.bacon \n 3;\n        }\n      }\n    });\n    var Breakfast = db.model(\nBreakfast\n, breakfastSchema);\n\n    var badBreakfast = new Breakfast({\n      eggs: 2,\n      bacon: 0,\n      drink: \nMilk\n\n    });\n    var error = badBreakfast.validateSync();\n    assert.equal(error.errors[\neggs\n].message,\n      \nToo few eggs\n);\n    assert.ok(!error.errors[\nbacon\n]);\n    assert.equal(error.errors[\ndrink\n].message,\n      \n`Milk` is not a valid enum value for path `drink`.\n);\n\n    badBreakfast.bacon = 5;\n    badBreakfast.drink = null;\n\n    error = badBreakfast.validateSync();\n    assert.equal(error.errors[\ndrink\n].message, \nPath `drink` is required.\n);\n\n    badBreakfast.bacon = null;\n    error = badBreakfast.validateSync();\n    assert.equal(error.errors[\nbacon\n].message, \nWhy no bacon?\n);\n\n\n\n\n\nA common gotcha for beginners is that the \nunique\n option for schemas is \nnot\n a validator. It's a convenient helper for building \nMongoDB unique indexes\n. See the \nFAQ\n for more information.\n\n\n    \nvar\n \nuniqueUsernameSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \nusername\n:\n \n{\n\n        \ntype\n:\n \nString\n,\n\n        \nunique\n:\n \ntrue\n\n      \n}\n\n    \n}\n);\n\n    \nvar\n \nU1\n \n=\n \ndb\n.\nmodel\n(\nU1\n,\n \nuniqueUsernameSchema\n);\n\n    \nvar\n \nU2\n \n=\n \ndb\n.\nmodel\n(\nU2\n,\n \nuniqueUsernameSchema\n);\n\n\n    \nvar\n \ndup\n \n=\n \n[\n{\n \nusername\n:\n \nVal\n \n},\n \n{\n \nusername\n:\n \nVal\n \n}\n]\n;\n\n    \nU1\n.\ncreate\n(\ndup\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n    \n}\n);\n\n\n\n\n    \nU2\n.\nonce\n(\nindex\n,\n \nfunction\n(\nerror\n)\n \n{\n\n      \nassert.ifError(error)\n;\n\n      \nU2.create(dup,\n \nfunction(error)\n \n{\n\n\n\n        \nassert.ok(error)\n;\n\n        \nassert.ok(!error.errors)\n;\n\n        \nassert.ok(error.message.indexOf(\nduplicate\n \nkey\n \nerror\n)\n \n!==\n \n-1)\n;\n\n      \n}\n);\n\n    \n}\n);\n\n\n\n\n\n    \nU2\n.\ninit\n()\n.\nthen\n(\nfunction\n()\n \n{\n\n      \nU2.create(dup,\n \nfunction(error)\n \n{\n\n\n\n        \nassert.ok(error)\n;\n\n        \nassert.ok(!error.errors)\n;\n\n        \nassert.ok(error.message.indexOf(\nduplicate\n \nkey\n \nerror\n)\n \n!==\n \n-1)\n;\n\n      \n}\n);\n\n    \n}\n);\n\n\n\n\n\n\nIf the built-in validators aren't enough, you can define custom validators to suit your needs.\n\n\nCustom validation is declared by passing a validation function. You can find detailed instructions on how to do this in the \nSchemaType#validate()\n API docs\n.\n\n\n    var userSchema = new Schema({\n      phone: {\n        type: String,\n        validate: {\n          validator: function(v) {\n            return /d{3}-d{3}-d{4}/.test(v);\n          },\n          message: \n{VALUE} is not a valid phone number!\n\n        },\n        required: [true, \nUser phone number required\n]\n      }\n    });\n\n    var User = db.model(\nuser\n, userSchema);\n    var user = new User();\n    var error;\n\n    user.phone = \n555.0123\n;\n    error = user.validateSync();\n    assert.equal(error.errors[\nphone\n].message,\n      \n555.0123 is not a valid phone number!\n);\n\n    user.phone = \n;\n    error = user.validateSync();\n    assert.equal(error.errors[\nphone\n].message,\n      \nUser phone number required\n);\n\n    user.phone = \n201-555-0123\n;\n\n\n    error = user.validateSync();\n    assert.equal(error, null);\n\n\n\n\n\nCustom validators can also be asynchronous. If your validator function takes 2 arguments, mongoose will assume the 2nd argument is a callback.\n\n\nEven if you don't want to use asynchronous validators, be careful, because mongoose 4 will assume that \nall\n functions that take 2 arguments are asynchronous, like the \nvalidator.isEmail\n function\n. This behavior is considered deprecated as of 4.9.0, and you can shut it off by specifying \nisAsync: false\n on your custom validator.\n\n\n    var userSchema = new Schema({\n      phone: {\n        type: String,\n        validate: {\n\n\n\n          isAsync: true,\n          validator: function(v, cb) {\n            setTimeout(function() {\n              var phoneRegex = /d{3}-d{3}-d{4}/;\n              var msg = v + \n is not a valid phone number!\n;\n\n\n              cb(phoneRegex.test(v), msg);\n            }, 5);\n          },\n\n          message: \nDefault error message\n\n        },\n        required: [true, \nUser phone number required\n]\n      },\n      name: {\n        type: String,\n\n\n        validate: function(v) {\n          return new Promise(function(resolve, reject) {\n            setTimeout(function() {\n              resolve(false);\n            }, 5);\n          });\n        }\n      }\n    });\n\n    var User = db.model(\nUser\n, userSchema);\n    var user = new User();\n    var error;\n\n    user.phone = \n555.0123\n;\n    user.name = \ntest\n;\n    user.validate(function(error) {\n      assert.ok(error);\n      assert.equal(error.errors[\nphone\n].message,\n        \n555.0123 is not a valid phone number!\n);\n      assert.equal(error.errors[\nname\n].message,\n        \nValidator failed for path `name` with value `test`\n);\n    });\n\n\n\n\n\nErrors returned after failed validation contain an \nerrors\n object whose values are \nValidatorError\n objects. Each \nValidatorError\n has \nkind\n, \npath\n, \nvalue\n, and \nmessage\n properties. A ValidatorError also may have a \nreason\n property. If an error was thrown in the validator, this property will contain the error that was thrown.\n\n\n    \nvar\n \ntoySchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \ncolor\n:\n \nString\n,\n\n      \nname\n:\n \nString\n\n    \n}\n);\n\n\n    \nvar\n \nvalidator\n \n=\n \nfunction\n(\nvalue\n)\n \n{\n\n      \nreturn\n \n/red|white|gold/i.test(value)\n;\n\n    \n}\n;\n\n    \ntoySchema\n.\npath\n(\ncolor\n)\n.\nvalidate\n(\nvalidator\n,\n\n      \nColor `{VALUE}` not valid\n,\n \nInvalid color\n);\n\n    \ntoySchema\n.\npath\n(\nname\n)\n.\nvalidate\n(\nfunction\n(\nv\n)\n \n{\n\n      \nif\n \n(v\n \n!==\n \nTurbo\n \nMan\n)\n \n{\n\n        \nthrow\n \nnew\n \nError(\nNeed\n \nto\n \nget\n \na\n \nTurbo\n \nMan\n \nfor\n \nChristmas\n)\n;\n\n      \n}\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n,\n \nName `{VALUE}` is not valid\n);\n\n\n    \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nToy\n,\n \ntoySchema\n);\n\n\n    \nvar\n \ntoy\n \n=\n \nnew\n \nToy\n(\n{\n \ncolor\n:\n \nGreen\n,\n \nname\n:\n \nPower Ranger\n \n}\n);\n\n\n    \ntoy\n.\nsave\n(\nfunction\n \n(\nerr\n)\n \n{\n\n\n\n      \nassert.equal(err.errors.color.message,\n \nColor\n \n`Green`\n \nnot\n \nvalid\n)\n;\n\n      \nassert.equal(err.errors.color.kind,\n \nInvalid\n \ncolor\n)\n;\n\n      \nassert.equal(err.errors.color.path,\n \ncolor\n)\n;\n\n      \nassert.equal(err.errors.color.value,\n \nGreen\n)\n;\n\n\n\n\n\n      \nassert.equal(err.errors.name.message,\n\n        \nNeed\n \nto\n \nget\n \na\n \nTurbo\n \nMan\n \nfor\n \nChristmas\n)\n;\n\n      \nassert.equal(err.errors.name.value,\n \nPower\n \nRanger\n)\n;\n\n\n\n      \nassert.equal(err.errors.name.reason.message,\n\n        \nNeed\n \nto\n \nget\n \na\n \nTurbo\n \nMan\n \nfor\n \nChristmas\n)\n;\n\n\n      \nassert.equal(err.name,\n \nValidationError\n)\n;\n\n    \n}\n);\n\n\n\n\n\n\nDefining validators on nested objects in mongoose is tricky, because nested objects are not fully fledged paths.\n\n\n    var personSchema = new Schema({\n      name: {\n        first: String,\n        last: String\n      }\n    });\n\n    assert.throws(function() {\n\n      personSchema.path(\nname\n).required(true);\n    }, /Cannot.*\nrequired\n/);\n\n\n    var nameSchema = new Schema({\n      first: String,\n      last: String\n    });\n\n    personSchema = new Schema({\n      name: {\n        type: nameSchema,\n        required: true\n      }\n    });\n\n    var Person = db.model(\nPerson\n, personSchema);\n\n    var person = new Person();\n    var error = person.validateSync();\n    assert.ok(error.errors[\nname\n]);\n\n\n\n\n\nIn the above examples, you learned about document validation. Mongoose also supports validation for \nupdate()\n and \nfindOneAndUpdate()\n operations. In Mongoose 4.x, update validators are off by default - you need to specify the \nrunValidators\n option.\n\n\nTo turn on update validators, set the \nrunValidators\n option for \nupdate()\n or \nfindOneAndUpdate()\n. Be careful: update validators are off by default because they have several caveats.\n\n\n    \nvar\n \ntoySchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \ncolor\n:\n \nString\n,\n\n      \nname\n:\n \nString\n\n    \n}\n);\n\n\n    \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nToys\n,\n \ntoySchema\n);\n\n\n    \nToy\n.\nschema\n.\npath\n(\ncolor\n)\n.\nvalidate\n(\nfunction\n \n(\nvalue\n)\n \n{\n\n      \nreturn\n \n/blue|green|white|red|orange|periwinkle/i.test(value)\n;\n\n    \n}\n,\n \nInvalid color\n);\n\n\n    \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n}\n;\n\n    \nToy\n.\nupdate\n(\n{}\n,\n \n{\n \ncolor\n:\n \nbacon\n \n}\n,\n \nopts\n,\n \nfunction\n \n(\nerr\n)\n \n{\n\n      \nassert.equal(err.errors.color.message,\n\n        \nInvalid\n \ncolor\n)\n;\n\n    \n}\n);\n\n\n\n\n\n\nThere are a couple of key differences between update validators and document validators. In the color validation function above, \nthis\n refers to the document being validated when using document validation. However, when running update validators, the document being updated may not be in the server's memory, so by default the value of \nthis\n is not defined.\n\n\n    \nvar\n \ntoySchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \ncolor\n:\n \nString\n,\n\n      \nname\n:\n \nString\n\n    \n}\n);\n\n\n    \ntoySchema\n.\npath\n(\ncolor\n)\n.\nvalidate\n(\nfunction\n(\nvalue\n)\n \n{\n\n\n\n\n      \nif\n \n(this.name.toLowerCase().indexOf(\nred\n)\n \n!==\n \n-1)\n \n{\n\n        \nreturn\n \nvalue\n \n!==\n \nred\n;\n\n      \n}\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n);\n\n\n    \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nActionFigure\n,\n \ntoySchema\n);\n\n\n    \nvar\n \ntoy\n \n=\n \nnew\n \nToy\n(\n{\n \ncolor\n:\n \nred\n,\n \nname\n:\n \nRed Power Ranger\n \n}\n);\n\n    \nvar\n \nerror\n \n=\n \ntoy\n.\nvalidateSync\n();\n\n    \nassert\n.\nok\n(\nerror\n.\nerrors\n[\ncolor\n]\n);\n\n\n    \nvar\n \nupdate\n \n=\n \n{\n \ncolor\n:\n \nred\n,\n \nname\n:\n \nRed Power Ranger\n \n}\n;\n\n    \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n}\n;\n\n\n    \nToy\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n\n\n      \nassert.ok(error)\n;\n\n    \n}\n);\n\n\n\n\n\n\nThe \ncontext\n option lets you set the value of \nthis\n in update validators to the underlying query.\n\n\n    \ntoySchema\n.\npath\n(\ncolor\n)\n.\nvalidate\n(\nfunction\n(\nvalue\n)\n \n{\n\n\n\n      \nif\n \n(this.getUpdate().$set.name.toLowerCase().indexOf(\nred\n)\n \n!==\n \n-1)\n \n{\n\n        \nreturn\n \nvalue\n \n===\n \nred\n;\n\n      \n}\n\n      \nreturn\n \ntrue\n;\n\n    \n}\n);\n\n\n    \nvar\n \nToy\n \n=\n \ndb\n.\nmodel\n(\nFigure\n,\n \ntoySchema\n);\n\n\n    \nvar\n \nupdate\n \n=\n \n{\n \ncolor\n:\n \nblue\n,\n \nname\n:\n \nRed Power Ranger\n \n}\n;\n\n\n    \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n,\n \ncontext\n:\n \nquery\n \n}\n;\n\n\n    \nToy\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n      \nassert.ok(error.errors\n[\ncolor\n]\n)\n;\n\n    \n}\n);\n\n\n\n\n\n\nThe other key difference that update validators only run on the paths specified in the update. For instance, in the below example, because 'name' is not specified in the update operation, update validation will succeed.\n\n\nWhen using update validators, \nrequired\n validators \nonly\n fail when you try to explicitly \n$unset\n the key.\n\n\n    \nvar\n \nkittenSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nrequired\n:\n \ntrue\n \n}\n,\n\n      \nage\n:\n \nNumber\n\n    \n}\n);\n\n\n    \nvar\n \nKitten\n \n=\n \ndb\n.\nmodel\n(\nKitten\n,\n \nkittenSchema\n);\n\n\n    \nvar\n \nupdate\n \n=\n \n{\n \ncolor\n:\n \nblue\n \n}\n;\n\n    \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n}\n;\n\n    \nKitten\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerr\n)\n \n{\n\n\n    \n}\n);\n\n\n    \nvar\n \nunset\n \n=\n \n{\n \n$\nunset\n:\n \n{\n \nname\n:\n \n1\n \n}\n \n}\n;\n\n    \nKitten\n.\nupdate\n(\n{}\n,\n \nunset\n,\n \nopts\n,\n \nfunction\n(\nerr\n)\n \n{\n\n\n      \nassert.ok(err)\n;\n\n      \nassert.ok(err.errors\n[\nname\n]\n)\n;\n\n    \n}\n);\n\n\n\n\n\n\nOne final detail worth noting: update validators \nonly\n run on the following update operators:\n* \n$set\n * \n$unset\n * \n$push\n (\n= 4.8.0) * \n$addToSet\n (\n= 4.8.0) * \n$pull\n (\n= 4.12.0) * \n$pullAll\n (\n= 4.12.0)\n\n\nFor instance, the below update will succeed, regardless of the value of \nnumber\n, because update validators ignore \n$inc\n. Also, \n$push\n, \n$addToSet\n, \n$pull\n, and \n$pullAll\n validation does \nnot\n run any validation on the array itself, only individual elements of the array.\n\n\n    \nvar\n \ntestSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \nnumber\n:\n \n{\n \ntype\n:\n \nNumber\n,\n \nmax\n:\n \n0\n \n}\n,\n\n      \narr\n:\n \n[\n{\n \nmessage\n:\n \n{\n \ntype\n:\n \nString\n,\n \nmaxLength\n:\n \n10\n \n}\n \n}\n]\n\n    \n}\n);\n\n\n\n\n    \ntestSchema\n.\npath\n(\narr\n)\n.\nvalidate\n(\nfunction\n(\nv\n)\n \n{\n\n      \nreturn\n \nv.length\n \n \n2\n;\n\n    \n}\n);\n\n\n    \nvar\n \nTest\n \n=\n \ndb\n.\nmodel\n(\nTest\n,\n \ntestSchema\n);\n\n\n    \nvar\n \nupdate\n \n=\n \n{\n \n$\ninc\n:\n \n{\n \nnumber\n:\n \n1\n \n}\n \n}\n;\n\n    \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n}\n;\n\n    \nTest\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n      \nupdate\n \n=\n \n{\n \n$\npush\n:\n \n[\n{\n \nmessage\n:\n \nhello\n \n},\n \n{\n \nmessage\n:\n \nworld\n \n}\n]\n \n}\n;\n\n      \nTest\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n\n      \n}\n);\n\n    \n}\n);\n\n\n\n\n\n\nNew in 4.8.0: update validators also run on \n$push\n and \n$addToSet\n\n\n    \nvar\n \ntestSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \nnumbers\n:\n \n[\n{\n \ntype\n:\n \nNumber\n,\n \nmax\n:\n \n0\n \n}\n]\n,\n\n      \ndocs\n:\n \n[\n{\n\n        \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nrequired\n:\n \ntrue\n \n}\n\n      \n}\n]\n\n    \n}\n);\n\n\n    \nvar\n \nTest\n \n=\n \ndb\n.\nmodel\n(\nTestPush\n,\n \ntestSchema\n);\n\n\n    \nvar\n \nupdate\n \n=\n \n{\n\n      \n$\npush\n:\n \n{\n\n        \nnumbers\n:\n \n1\n,\n\n        \ndocs\n:\n \n{\n \nname\n:\n \nnull\n \n}\n\n      \n}\n\n    \n}\n;\n\n    \nvar\n \nopts\n \n=\n \n{\n \nrunValidators\n:\n \ntrue\n \n}\n;\n\n    \nTest\n.\nupdate\n(\n{}\n,\n \nupdate\n,\n \nopts\n,\n \nfunction\n(\nerror\n)\n \n{\n\n      \nassert.ok(error.errors\n[\nnumbers\n]\n)\n;\n\n      \nassert.ok(error.errors\n[\ndocs\n]\n)\n;\n\n    \n}\n);", 
            "title": "\u9a8c\u8bc1"
        }, 
        {
            "location": "/guide/Validation/#validation", 
            "text": "Source  Before we get into the specifics of validation syntax, please keep the following rules in mind:   Validation is defined in the  SchemaType  Validation is  middleware . Mongoose registers validation as a  pre('save')  hook on every schema by default.  You can manually run validation using  doc.validate(callback)  or  doc.validateSync()  Validators are not run on undefined values. The only exception is the  required  validator .  Validation is asynchronously recursive; when you call  Model#save , sub-document validation is executed as well. If an error occurs, your  Model#save  callback receives it  Validation is customizable var schema = new Schema({\n  name: {\n    type: String,\n    required: true\n  }\n});\nvar Cat = db.model( Cat , schema);\n\nvar cat = new Cat();\ncat.save(function(error) {\n  assert.equal(error.errors[ name ].message,\n     Path `name` is required. );\n\n  error = cat.validateSync();\n  assert.equal(error.errors[ name ].message,\n     Path `name` is required. );\n});    Mongoose has several built-in validators.  Each of the validator links above provide more information about how to enable them and customize their error messages.      var breakfastSchema = new Schema({\n      eggs: {\n        type: Number,\n        min: [6,  Too few eggs ],\n        max: 12\n      },\n      bacon: {\n        type: Number,\n        required: [true,  Why no bacon? ]\n      },\n      drink: {\n        type: String,\n        enum: [ Coffee ,  Tea ],\n        required: function() {\n          return this.bacon   3;\n        }\n      }\n    });\n    var Breakfast = db.model( Breakfast , breakfastSchema);\n\n    var badBreakfast = new Breakfast({\n      eggs: 2,\n      bacon: 0,\n      drink:  Milk \n    });\n    var error = badBreakfast.validateSync();\n    assert.equal(error.errors[ eggs ].message,\n       Too few eggs );\n    assert.ok(!error.errors[ bacon ]);\n    assert.equal(error.errors[ drink ].message,\n       `Milk` is not a valid enum value for path `drink`. );\n\n    badBreakfast.bacon = 5;\n    badBreakfast.drink = null;\n\n    error = badBreakfast.validateSync();\n    assert.equal(error.errors[ drink ].message,  Path `drink` is required. );\n\n    badBreakfast.bacon = null;\n    error = badBreakfast.validateSync();\n    assert.equal(error.errors[ bacon ].message,  Why no bacon? );  A common gotcha for beginners is that the  unique  option for schemas is  not  a validator. It's a convenient helper for building  MongoDB unique indexes . See the  FAQ  for more information.       var   uniqueUsernameSchema   =   new   Schema ( { \n       username :   { \n         type :   String , \n         unique :   true \n       } \n     } ); \n     var   U1   =   db . model ( U1 ,   uniqueUsernameSchema ); \n     var   U2   =   db . model ( U2 ,   uniqueUsernameSchema ); \n\n     var   dup   =   [ {   username :   Val   },   {   username :   Val   } ] ; \n     U1 . create ( dup ,   function ( error )   { \n\n\n     } ); \n\n\n\n     U2 . once ( index ,   function ( error )   { \n       assert.ifError(error) ; \n       U2.create(dup,   function(error)   { \n\n\n         assert.ok(error) ; \n         assert.ok(!error.errors) ; \n         assert.ok(error.message.indexOf( duplicate   key   error )   !==   -1) ; \n       } ); \n     } ); \n\n\n\n\n     U2 . init () . then ( function ()   { \n       U2.create(dup,   function(error)   { \n\n\n         assert.ok(error) ; \n         assert.ok(!error.errors) ; \n         assert.ok(error.message.indexOf( duplicate   key   error )   !==   -1) ; \n       } ); \n     } );   If the built-in validators aren't enough, you can define custom validators to suit your needs.  Custom validation is declared by passing a validation function. You can find detailed instructions on how to do this in the  SchemaType#validate()  API docs .      var userSchema = new Schema({\n      phone: {\n        type: String,\n        validate: {\n          validator: function(v) {\n            return /d{3}-d{3}-d{4}/.test(v);\n          },\n          message:  {VALUE} is not a valid phone number! \n        },\n        required: [true,  User phone number required ]\n      }\n    });\n\n    var User = db.model( user , userSchema);\n    var user = new User();\n    var error;\n\n    user.phone =  555.0123 ;\n    error = user.validateSync();\n    assert.equal(error.errors[ phone ].message,\n       555.0123 is not a valid phone number! );\n\n    user.phone =  ;\n    error = user.validateSync();\n    assert.equal(error.errors[ phone ].message,\n       User phone number required );\n\n    user.phone =  201-555-0123 ;\n\n\n    error = user.validateSync();\n    assert.equal(error, null);  Custom validators can also be asynchronous. If your validator function takes 2 arguments, mongoose will assume the 2nd argument is a callback.  Even if you don't want to use asynchronous validators, be careful, because mongoose 4 will assume that  all  functions that take 2 arguments are asynchronous, like the  validator.isEmail  function . This behavior is considered deprecated as of 4.9.0, and you can shut it off by specifying  isAsync: false  on your custom validator.      var userSchema = new Schema({\n      phone: {\n        type: String,\n        validate: {\n\n\n\n          isAsync: true,\n          validator: function(v, cb) {\n            setTimeout(function() {\n              var phoneRegex = /d{3}-d{3}-d{4}/;\n              var msg = v +   is not a valid phone number! ;\n\n\n              cb(phoneRegex.test(v), msg);\n            }, 5);\n          },\n\n          message:  Default error message \n        },\n        required: [true,  User phone number required ]\n      },\n      name: {\n        type: String,\n\n\n        validate: function(v) {\n          return new Promise(function(resolve, reject) {\n            setTimeout(function() {\n              resolve(false);\n            }, 5);\n          });\n        }\n      }\n    });\n\n    var User = db.model( User , userSchema);\n    var user = new User();\n    var error;\n\n    user.phone =  555.0123 ;\n    user.name =  test ;\n    user.validate(function(error) {\n      assert.ok(error);\n      assert.equal(error.errors[ phone ].message,\n         555.0123 is not a valid phone number! );\n      assert.equal(error.errors[ name ].message,\n         Validator failed for path `name` with value `test` );\n    });  Errors returned after failed validation contain an  errors  object whose values are  ValidatorError  objects. Each  ValidatorError  has  kind ,  path ,  value , and  message  properties. A ValidatorError also may have a  reason  property. If an error was thrown in the validator, this property will contain the error that was thrown.       var   toySchema   =   new   Schema ( { \n       color :   String , \n       name :   String \n     } ); \n\n     var   validator   =   function ( value )   { \n       return   /red|white|gold/i.test(value) ; \n     } ; \n     toySchema . path ( color ) . validate ( validator , \n       Color `{VALUE}` not valid ,   Invalid color ); \n     toySchema . path ( name ) . validate ( function ( v )   { \n       if   (v   !==   Turbo   Man )   { \n         throw   new   Error( Need   to   get   a   Turbo   Man   for   Christmas ) ; \n       } \n       return   true ; \n     } ,   Name `{VALUE}` is not valid ); \n\n     var   Toy   =   db . model ( Toy ,   toySchema ); \n\n     var   toy   =   new   Toy ( {   color :   Green ,   name :   Power Ranger   } ); \n\n     toy . save ( function   ( err )   { \n\n\n       assert.equal(err.errors.color.message,   Color   `Green`   not   valid ) ; \n       assert.equal(err.errors.color.kind,   Invalid   color ) ; \n       assert.equal(err.errors.color.path,   color ) ; \n       assert.equal(err.errors.color.value,   Green ) ; \n\n\n\n\n       assert.equal(err.errors.name.message, \n         Need   to   get   a   Turbo   Man   for   Christmas ) ; \n       assert.equal(err.errors.name.value,   Power   Ranger ) ; \n\n\n       assert.equal(err.errors.name.reason.message, \n         Need   to   get   a   Turbo   Man   for   Christmas ) ; \n\n       assert.equal(err.name,   ValidationError ) ; \n     } );   Defining validators on nested objects in mongoose is tricky, because nested objects are not fully fledged paths.      var personSchema = new Schema({\n      name: {\n        first: String,\n        last: String\n      }\n    });\n\n    assert.throws(function() {\n\n      personSchema.path( name ).required(true);\n    }, /Cannot.* required /);\n\n\n    var nameSchema = new Schema({\n      first: String,\n      last: String\n    });\n\n    personSchema = new Schema({\n      name: {\n        type: nameSchema,\n        required: true\n      }\n    });\n\n    var Person = db.model( Person , personSchema);\n\n    var person = new Person();\n    var error = person.validateSync();\n    assert.ok(error.errors[ name ]);  In the above examples, you learned about document validation. Mongoose also supports validation for  update()  and  findOneAndUpdate()  operations. In Mongoose 4.x, update validators are off by default - you need to specify the  runValidators  option.  To turn on update validators, set the  runValidators  option for  update()  or  findOneAndUpdate() . Be careful: update validators are off by default because they have several caveats.       var   toySchema   =   new   Schema ( { \n       color :   String , \n       name :   String \n     } ); \n\n     var   Toy   =   db . model ( Toys ,   toySchema ); \n\n     Toy . schema . path ( color ) . validate ( function   ( value )   { \n       return   /blue|green|white|red|orange|periwinkle/i.test(value) ; \n     } ,   Invalid color ); \n\n     var   opts   =   {   runValidators :   true   } ; \n     Toy . update ( {} ,   {   color :   bacon   } ,   opts ,   function   ( err )   { \n       assert.equal(err.errors.color.message, \n         Invalid   color ) ; \n     } );   There are a couple of key differences between update validators and document validators. In the color validation function above,  this  refers to the document being validated when using document validation. However, when running update validators, the document being updated may not be in the server's memory, so by default the value of  this  is not defined.       var   toySchema   =   new   Schema ( { \n       color :   String , \n       name :   String \n     } ); \n\n     toySchema . path ( color ) . validate ( function ( value )   { \n\n\n\n       if   (this.name.toLowerCase().indexOf( red )   !==   -1)   { \n         return   value   !==   red ; \n       } \n       return   true ; \n     } ); \n\n     var   Toy   =   db . model ( ActionFigure ,   toySchema ); \n\n     var   toy   =   new   Toy ( {   color :   red ,   name :   Red Power Ranger   } ); \n     var   error   =   toy . validateSync (); \n     assert . ok ( error . errors [ color ] ); \n\n     var   update   =   {   color :   red ,   name :   Red Power Ranger   } ; \n     var   opts   =   {   runValidators :   true   } ; \n\n     Toy . update ( {} ,   update ,   opts ,   function ( error )   { \n\n\n\n\n       assert.ok(error) ; \n     } );   The  context  option lets you set the value of  this  in update validators to the underlying query.       toySchema . path ( color ) . validate ( function ( value )   { \n\n\n       if   (this.getUpdate().$set.name.toLowerCase().indexOf( red )   !==   -1)   { \n         return   value   ===   red ; \n       } \n       return   true ; \n     } ); \n\n     var   Toy   =   db . model ( Figure ,   toySchema ); \n\n     var   update   =   {   color :   blue ,   name :   Red Power Ranger   } ; \n\n     var   opts   =   {   runValidators :   true ,   context :   query   } ; \n\n     Toy . update ( {} ,   update ,   opts ,   function ( error )   { \n       assert.ok(error.errors [ color ] ) ; \n     } );   The other key difference that update validators only run on the paths specified in the update. For instance, in the below example, because 'name' is not specified in the update operation, update validation will succeed.  When using update validators,  required  validators  only  fail when you try to explicitly  $unset  the key.       var   kittenSchema   =   new   Schema ( { \n       name :   {   type :   String ,   required :   true   } , \n       age :   Number \n     } ); \n\n     var   Kitten   =   db . model ( Kitten ,   kittenSchema ); \n\n     var   update   =   {   color :   blue   } ; \n     var   opts   =   {   runValidators :   true   } ; \n     Kitten . update ( {} ,   update ,   opts ,   function ( err )   { \n\n     } ); \n\n     var   unset   =   {   $ unset :   {   name :   1   }   } ; \n     Kitten . update ( {} ,   unset ,   opts ,   function ( err )   { \n\n       assert.ok(err) ; \n       assert.ok(err.errors [ name ] ) ; \n     } );   One final detail worth noting: update validators  only  run on the following update operators:\n*  $set  *  $unset  *  $push  ( = 4.8.0) *  $addToSet  ( = 4.8.0) *  $pull  ( = 4.12.0) *  $pullAll  ( = 4.12.0)  For instance, the below update will succeed, regardless of the value of  number , because update validators ignore  $inc . Also,  $push ,  $addToSet ,  $pull , and  $pullAll  validation does  not  run any validation on the array itself, only individual elements of the array.       var   testSchema   =   new   Schema ( { \n       number :   {   type :   Number ,   max :   0   } , \n       arr :   [ {   message :   {   type :   String ,   maxLength :   10   }   } ] \n     } ); \n\n\n\n     testSchema . path ( arr ) . validate ( function ( v )   { \n       return   v.length     2 ; \n     } ); \n\n     var   Test   =   db . model ( Test ,   testSchema ); \n\n     var   update   =   {   $ inc :   {   number :   1   }   } ; \n     var   opts   =   {   runValidators :   true   } ; \n     Test . update ( {} ,   update ,   opts ,   function ( error )   { \n\n       update   =   {   $ push :   [ {   message :   hello   },   {   message :   world   } ]   } ; \n       Test . update ( {} ,   update ,   opts ,   function ( error )   { \n\n\n       } ); \n     } );   New in 4.8.0: update validators also run on  $push  and  $addToSet       var   testSchema   =   new   Schema ( { \n       numbers :   [ {   type :   Number ,   max :   0   } ] , \n       docs :   [ { \n         name :   {   type :   String ,   required :   true   } \n       } ] \n     } ); \n\n     var   Test   =   db . model ( TestPush ,   testSchema ); \n\n     var   update   =   { \n       $ push :   { \n         numbers :   1 , \n         docs :   {   name :   null   } \n       } \n     } ; \n     var   opts   =   {   runValidators :   true   } ; \n     Test . update ( {} ,   update ,   opts ,   function ( error )   { \n       assert.ok(error.errors [ numbers ] ) ; \n       assert.ok(error.errors [ docs ] ) ; \n     } );", 
            "title": "Validation"
        }, 
        {
            "location": "/guide/Middleware/", 
            "text": "Mongoose v5.0.1: Middleware\n\n\nMiddleware\n\n\nSource\n\n\nMiddleware (also called pre and post \nhooks\n) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing \nplugins\n. Mongoose 4.x has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware. Document middleware is supported for the following document functions. In document middleware functions, \nthis\n refers to the document.\n\n\nQuery middleware is supported for the following Model and Query functions. In query middleware functions, \nthis\n refers to the query.\n\n\nAggregate middleware is for \nMyModel.aggregate()\n. Aggregate middleware executes when you call \nexec()\n on an aggregate object. In aggregate middleware, \nthis\n refers to the \naggregation object\n.\n\n\nModel middleware is supported for the following model functions. In model middleware functions, \nthis\n refers to the model.\n\n\nAll middleware types support pre and post hooks. How pre and post hooks work is described in more detail below.\n\n\nNote:\n There is no query hook for \nremove()\n, only for documents. If you set a 'remove' hook, it will be fired when you call \nmyDoc.remove()\n, not when you call \nMyModel.remove()\n. \nNote:\n The \ncreate()\n function fires \nsave()\n hooks.\n\n\nPre\n\n\nThere are two types of \npre\n hooks, serial and parallel.\n\n\nSerial\n\n\nSerial middleware functions are executed one after another, when each middleware calls \nnext\n.\n\n\nvar schema = new Schema(..);\nschema.pre(\nsave\n, function(next) {\n\n  next();\n});\n\n\n\n\n\nThe \nnext()\n call does \nnot\n stop the rest of the code in your middleware function from executing. Use \nthe early \nreturn\n pattern\n to prevent the rest of your middleware function from running when you call \nnext()\n.\n\n\nvar schema = new Schema(..);\nschema.pre(\nsave\n, function(next) {\n  if (foo()) {\n    console.log(\ncalling next!\n);\n\n     next();\n  }\n\n  console.log(\nafter next\n);\n});\n\n\n\n\n\nParallel\n\n\nParallel middleware offer more fine-grained flow control.\n\n\nvar schema = new Schema(..);\n\n\n\nschema.pre(\nsave\n, true, function(next, done) {\n\n  next();\n  setTimeout(done, 100);\n});\n\n\n\n\n\nThe hooked method, in this case \nsave\n, will not be executed until \ndone\n is called by each middleware.\n\n\nUse Cases\n\n\nMiddleware are useful for atomizing model logic. Here are some other ideas:\n\n\n\n\ncomplex validation\n\n\nremoving dependent documents (removing a user removes all his blogposts)\n\n\nasynchronous defaults\n\n\nasynchronous tasks that a certain action triggers\n\n\n\n\nError handling\n\n\nIf any middleware calls \nnext\n or \ndone\n with a parameter of type \nError\n, the flow is interrupted, and the error is passed to the callback.\n\n\nschema.pre(\nsave\n, function(next) {\n  var err = new Error(\nsomething went wrong\n);\n  next(err);\n});\n\n\n\nmyDoc.save(function(err) {\n  console.log(err.message)\n});\n\n\n\n\n\nPost middleware\n\n\npost\n middleware are executed \nafter\n the hooked method and all of its \npre\n middleware have completed.\n\n\nschema.post(\ninit\n, function(doc) {\n  console.log(\n%s has been initialized from the db\n, doc._id);\n});\nschema.post(\nvalidate\n, function(doc) {\n  console.log(\n%s has been validated (but not saved yet)\n, doc._id);\n});\nschema.post(\nsave\n, function(doc) {\n  console.log(\n%s has been saved\n, doc._id);\n});\nschema.post(\nremove\n, function(doc) {\n  console.log(\n%s has been removed\n, doc._id);\n});\n\n\n\n\n\nAsynchronous Post Hooks\n\n\nIf your post hook function takes at least 2 parameters, mongoose will assume the second parameter is a \nnext()\n function that you will call to trigger the next middleware in the sequence.\n\n\nschema.post(\nsave\n, function(doc, next) {\n  setTimeout(function() {\n    console.log(\npost1\n);\n\n    next();\n  }, 10);\n});\n\n\nschema.post(\nsave\n, function(doc, next) {\n  console.log(\npost2\n);\n  next();\n});\n\n\n\n\n\nSave/Validate Hooks\n\n\nThe \nsave()\n function triggers \nvalidate()\n hooks, because mongoose has a built-in \npre('save')\n hook that calls \nvalidate()\n. This means that all \npre('validate')\n and \npost('validate')\n hooks get called \nbefore\n any \npre('save')\n hooks.\n\n\nschema.pre(\nvalidate\n, function() {\n  console.log(\nthis gets printed first\n);\n});\nschema.post(\nvalidate\n, function() {\n  console.log(\nthis gets printed second\n);\n});\nschema.pre(\nsave\n, function() {\n  console.log(\nthis gets printed third\n);\n});\nschema.post(\nsave\n, function() {\n  console.log(\nthis gets printed fourth\n);\n});\n\n\n\n\n\nNotes on findAndUpdate() and Query Middleware\n\n\nPre and post \nsave()\n hooks are \nnot\n executed on \nupdate()\n, \nfindOneAndUpdate()\n, etc. You can see a more detailed discussion why in \nthis GitHub issue\n. Mongoose 4.0 introduced distinct hooks for these functions.\n\n\nschema.pre(\nfind\n, function() {\n  console.log(this instanceof mongoose.Query);\n  this.start = Date.now();\n});\n\nschema.post(\nfind\n, function(result) {\n  console.log(this instanceof mongoose.Query);\n\n  console.log(\nfind() returned \n + JSON.stringify(result));\n\n  console.log(\nfind() took \n + (Date.now() - this.start) + \n millis\n);\n});\n\n\n\n\n\nQuery middleware differs from document middleware in a subtle but important way: in document middleware, \nthis\n refers to the document being updated. In query middleware, mongoose doesn't necessarily have a reference to the document being updated, so \nthis\n refers to the \nquery\n object rather than the document being updated.\n\n\nFor instance, if you wanted to add an \nupdatedAt\n timestamp to every \nupdate()\n call, you would use the following pre hook.\n\n\nschema\n.\npre\n(\nupdate\n,\n \nfunction\n()\n \n{\n\n  \nthis.update({\n}\n,\n{\n \n$\nset\n:\n \n{\n \nupdatedAt\n:\n \nnew\n \nDate\n()\n \n}\n \n}\n);\n\n\n}\n);\n\n\n\n\n\n\nError Handling Middleware\n\n\nNew in 4.5.0\n\n\nMiddleware execution normally stops the first time a piece of middleware calls \nnext()\n with an error. However, there is a special kind of post middleware called \"error handling middleware\" that executes specifically when an error occurs.\n\n\nError handling middleware is defined as middleware that takes one extra parameter: the 'error' that occurred as the first parameter to the function. Error handling middleware can then transform the error however you want.\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n\n\n    \nunique\n:\n \ntrue\n\n  \n}\n\n\n}\n);\n\n\n\n\n\nschema\n.\npost\n(\nsave\n,\n \nfunction\n(\nerror\n,\n \ndoc\n,\n \nnext\n)\n \n{\n\n  \nif\n \n(error.name\n \n===\n \nMongoError\n \n \nerror.code\n \n===\n \n11000)\n \n{\n\n    \nnext(new\n \nError(\nThere\n \nwas\n \na\n \nduplicate\n \nkey\n \nerror\n))\n;\n\n  \n}\n \nelse\n \n{\n\n    \nnext(error)\n;\n\n  \n}\n\n\n}\n);\n\n\n\n\nPerson\n.\ncreate\n(\n[\n{\n \nname\n:\n \nAxl Rose\n \n},\n \n{\n \nname\n:\n \nAxl Rose\n \n}\n]\n);\n\n\n\n\n\n\nError handling middleware also works with query middleware. You can also define a post \nupdate()\n hook that will catch MongoDB duplicate key errors.\n\n\nschema\n.\npost\n(\nupdate\n,\n \nfunction\n(\nerror\n,\n \nres\n,\n \nnext\n)\n \n{\n\n  \nif\n \n(error.name\n \n===\n \nMongoError\n \n \nerror.code\n \n===\n \n11000)\n \n{\n\n    \nnext(new\n \nError(\nThere\n \nwas\n \na\n \nduplicate\n \nkey\n \nerror\n))\n;\n\n  \n}\n \nelse\n \n{\n\n    \nnext(error)\n;\n\n  \n}\n\n\n}\n);\n\n\n\nvar\n \npeople\n \n=\n \n[\n{\n \nname\n:\n \nAxl Rose\n \n},\n \n{\n \nname\n:\n \nSlash\n \n}\n]\n;\n\n\nPerson\n.\ncreate\n(\npeople\n,\n \nfunction\n(\nerror\n)\n \n{\n\n  \nPerson.update({\n \nname\n:\n \nSlash\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \nname\n:\n \nAxl Rose\n \n}\n \n}\n,\n \nfunction\n(\nerror\n)\n \n{\n\n\n  \n}\n);\n\n\n}\n);\n\n\n\n\n\n\nNext Up\n\n\nNow that we've covered middleware, let's take a look at Mongoose's approach to faking JOINs with its query \npopulation\n helper.", 
            "title": "\u4e2d\u95f4\u4ef6"
        }, 
        {
            "location": "/guide/Middleware/#mongoose-v501-middleware", 
            "text": "", 
            "title": "Mongoose v5.0.1: Middleware"
        }, 
        {
            "location": "/guide/Middleware/#middleware", 
            "text": "Source  Middleware (also called pre and post  hooks ) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing  plugins . Mongoose 4.x has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware. Document middleware is supported for the following document functions. In document middleware functions,  this  refers to the document.  Query middleware is supported for the following Model and Query functions. In query middleware functions,  this  refers to the query.  Aggregate middleware is for  MyModel.aggregate() . Aggregate middleware executes when you call  exec()  on an aggregate object. In aggregate middleware,  this  refers to the  aggregation object .  Model middleware is supported for the following model functions. In model middleware functions,  this  refers to the model.  All middleware types support pre and post hooks. How pre and post hooks work is described in more detail below.  Note:  There is no query hook for  remove() , only for documents. If you set a 'remove' hook, it will be fired when you call  myDoc.remove() , not when you call  MyModel.remove() .  Note:  The  create()  function fires  save()  hooks.", 
            "title": "Middleware"
        }, 
        {
            "location": "/guide/Middleware/#pre", 
            "text": "There are two types of  pre  hooks, serial and parallel.", 
            "title": "Pre"
        }, 
        {
            "location": "/guide/Middleware/#serial", 
            "text": "Serial middleware functions are executed one after another, when each middleware calls  next .  var schema = new Schema(..);\nschema.pre( save , function(next) {\n\n  next();\n});  The  next()  call does  not  stop the rest of the code in your middleware function from executing. Use  the early  return  pattern  to prevent the rest of your middleware function from running when you call  next() .  var schema = new Schema(..);\nschema.pre( save , function(next) {\n  if (foo()) {\n    console.log( calling next! );\n\n     next();\n  }\n\n  console.log( after next );\n});", 
            "title": "Serial"
        }, 
        {
            "location": "/guide/Middleware/#parallel", 
            "text": "Parallel middleware offer more fine-grained flow control.  var schema = new Schema(..);\n\n\n\nschema.pre( save , true, function(next, done) {\n\n  next();\n  setTimeout(done, 100);\n});  The hooked method, in this case  save , will not be executed until  done  is called by each middleware.", 
            "title": "Parallel"
        }, 
        {
            "location": "/guide/Middleware/#use-cases", 
            "text": "Middleware are useful for atomizing model logic. Here are some other ideas:   complex validation  removing dependent documents (removing a user removes all his blogposts)  asynchronous defaults  asynchronous tasks that a certain action triggers", 
            "title": "Use Cases"
        }, 
        {
            "location": "/guide/Middleware/#error-handling", 
            "text": "If any middleware calls  next  or  done  with a parameter of type  Error , the flow is interrupted, and the error is passed to the callback.  schema.pre( save , function(next) {\n  var err = new Error( something went wrong );\n  next(err);\n});\n\n\n\nmyDoc.save(function(err) {\n  console.log(err.message)\n});", 
            "title": "Error handling"
        }, 
        {
            "location": "/guide/Middleware/#post-middleware", 
            "text": "post  middleware are executed  after  the hooked method and all of its  pre  middleware have completed.  schema.post( init , function(doc) {\n  console.log( %s has been initialized from the db , doc._id);\n});\nschema.post( validate , function(doc) {\n  console.log( %s has been validated (but not saved yet) , doc._id);\n});\nschema.post( save , function(doc) {\n  console.log( %s has been saved , doc._id);\n});\nschema.post( remove , function(doc) {\n  console.log( %s has been removed , doc._id);\n});", 
            "title": "Post middleware"
        }, 
        {
            "location": "/guide/Middleware/#asynchronous-post-hooks", 
            "text": "If your post hook function takes at least 2 parameters, mongoose will assume the second parameter is a  next()  function that you will call to trigger the next middleware in the sequence.  schema.post( save , function(doc, next) {\n  setTimeout(function() {\n    console.log( post1 );\n\n    next();\n  }, 10);\n});\n\n\nschema.post( save , function(doc, next) {\n  console.log( post2 );\n  next();\n});", 
            "title": "Asynchronous Post Hooks"
        }, 
        {
            "location": "/guide/Middleware/#savevalidate-hooks", 
            "text": "The  save()  function triggers  validate()  hooks, because mongoose has a built-in  pre('save')  hook that calls  validate() . This means that all  pre('validate')  and  post('validate')  hooks get called  before  any  pre('save')  hooks.  schema.pre( validate , function() {\n  console.log( this gets printed first );\n});\nschema.post( validate , function() {\n  console.log( this gets printed second );\n});\nschema.pre( save , function() {\n  console.log( this gets printed third );\n});\nschema.post( save , function() {\n  console.log( this gets printed fourth );\n});", 
            "title": "Save/Validate Hooks"
        }, 
        {
            "location": "/guide/Middleware/#notes-on-findandupdate-and-query-middleware", 
            "text": "Pre and post  save()  hooks are  not  executed on  update() ,  findOneAndUpdate() , etc. You can see a more detailed discussion why in  this GitHub issue . Mongoose 4.0 introduced distinct hooks for these functions.  schema.pre( find , function() {\n  console.log(this instanceof mongoose.Query);\n  this.start = Date.now();\n});\n\nschema.post( find , function(result) {\n  console.log(this instanceof mongoose.Query);\n\n  console.log( find() returned   + JSON.stringify(result));\n\n  console.log( find() took   + (Date.now() - this.start) +   millis );\n});  Query middleware differs from document middleware in a subtle but important way: in document middleware,  this  refers to the document being updated. In query middleware, mongoose doesn't necessarily have a reference to the document being updated, so  this  refers to the  query  object rather than the document being updated.  For instance, if you wanted to add an  updatedAt  timestamp to every  update()  call, you would use the following pre hook.  schema . pre ( update ,   function ()   { \n   this.update({ } , {   $ set :   {   updatedAt :   new   Date ()   }   } );  } );", 
            "title": "Notes on findAndUpdate() and Query Middleware"
        }, 
        {
            "location": "/guide/Middleware/#error-handling-middleware", 
            "text": "New in 4.5.0  Middleware execution normally stops the first time a piece of middleware calls  next()  with an error. However, there is a special kind of post middleware called \"error handling middleware\" that executes specifically when an error occurs.  Error handling middleware is defined as middleware that takes one extra parameter: the 'error' that occurred as the first parameter to the function. Error handling middleware can then transform the error however you want.  var   schema   =   new   Schema ( { \n   name :   { \n     type :   String , \n\n\n     unique :   true \n   }  } );  schema . post ( save ,   function ( error ,   doc ,   next )   { \n   if   (error.name   ===   MongoError     error.code   ===   11000)   { \n     next(new   Error( There   was   a   duplicate   key   error )) ; \n   }   else   { \n     next(error) ; \n   }  } );  Person . create ( [ {   name :   Axl Rose   },   {   name :   Axl Rose   } ] );   Error handling middleware also works with query middleware. You can also define a post  update()  hook that will catch MongoDB duplicate key errors.  schema . post ( update ,   function ( error ,   res ,   next )   { \n   if   (error.name   ===   MongoError     error.code   ===   11000)   { \n     next(new   Error( There   was   a   duplicate   key   error )) ; \n   }   else   { \n     next(error) ; \n   }  } );  var   people   =   [ {   name :   Axl Rose   },   {   name :   Slash   } ] ;  Person . create ( people ,   function ( error )   { \n   Person.update({   name :   Slash   } ,   {   $ set :   {   name :   Axl Rose   }   } ,   function ( error )   { \n\n   } );  } );", 
            "title": "Error Handling Middleware"
        }, 
        {
            "location": "/guide/Middleware/#next-up", 
            "text": "Now that we've covered middleware, let's take a look at Mongoose's approach to faking JOINs with its query  population  helper.", 
            "title": "Next Up"
        }, 
        {
            "location": "/guide/Populate/", 
            "text": "Mongoose v5.0.1: Query Population\n\n\nPopulate\n\n\nSource\n\n\nMongoDB has the join-like \n$lookup\n aggregation operator in versions \n= 3.2. Mongoose has a more powerful alternative called \npopulate()\n, which lets you reference documents in other collections.\n\n\nPopulation is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples.\n\n\nvar mongoose = require(\nmongoose\n);\nvar Schema = mongoose.Schema;\n\nvar personSchema = Schema({\n  _id: Schema.Types.ObjectId,\n  name: String,\n  age: Number,\n  stories: [{ type: Schema.Types.ObjectId, ref: \nStory\n }]\n});\n\nvar storySchema = Schema({\n  author: { type: Schema.Types.ObjectId, ref: \nPerson\n },\n  title: String,\n  fans: [{ type: Schema.Types.ObjectId, ref: \nPerson\n }]\n});\n\nvar Story = mongoose.model(\nStory\n, storySchema);\nvar Person = mongoose.model(\nPerson\n, personSchema);\n\n\n\n\n\nSo far we've created two \nModels\n. Our \nPerson\n model has its \nstories\n field set to an array of \nObjectId\ns. The \nref\n option is what tells Mongoose which model to use during population, in our case the \nStory\n model. All \n_id\ns we store here must be document \n_id\ns from the \nStory\n model.\n\n\nNote\n: \nObjectId\n, \nNumber\n, \nString\n, and \nBuffer\n are valid for use as refs. However, you should use \nObjectId\n unless you are an advanced user and have a good reason for doing so.\n\n\nSaving refs\n\n\nSaving refs to other documents works the same way you normally save properties, just assign the \n_id\n value:\n\n\nvar author = new Person({\n  _id: new mongoose.Types.ObjectId(),\n  name: \nIan Fleming\n,\n  age: 50\n});\n\nauthor.save(function (err) {\n  if (err) return handleError(err);\n\n  var story1 = new Story({\n    title: \nCasino Royale\n,\n    author: author._id\n  });\n\n  story1.save(function (err) {\n    if (err) return handleError(err);\n\n  });\n});\n\n\n\n\n\nPopulation\n\n\nSo far we haven't done anything much different. We've merely created a \nPerson\n and a \nStory\n. Now let's take a look at populating our story's \nauthor\n using the query builder:\n\n\nStory.\n  findOne({ title: \nCasino Royale\n }).\n  populate(\nauthor\n).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n    console.log(\nThe author is %s\n, story.author.name);\n\n  });\n\n\n\n\n\nPopulated paths are no longer set to their original \n_id\n , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results.\n\n\nArrays of refs work the same way. Just call the \npopulate\n method on the query and an array of documents will be returned \nin place\n of the original \n_id\ns.\n\n\nSetting Populated Fields\n\n\nIn Mongoose \n= 4.0, you can manually populate a field as well.\n\n\nStory.findOne({ title: \nCasino Royale\n }, function(error, story) {\n  if (error) {\n    return handleError(error);\n  }\n  story.author = author;\n  console.log(story.author.name);\n});\n\n\n\n\n\nField Selection\n\n\nWhat if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual \nfield name syntax\n as the second argument to the populate method:\n\n\nStory.\n  findOne({ title: /casino royale/i }).\n  populate(\nauthor\n, \nname\n).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n\n    console.log(\nThe author is %s\n, story.author.name);\n\n\n    console.log(\nThe authors age is %s\n, story.author.age);\n\n  });\n\n\n\n\n\nPopulating Multiple Paths\n\n\nWhat if we wanted to populate multiple paths at the same time?\n\n\nStory.\n  find(...).\n  populate(\nfans\n).\n  populate(\nauthor\n).\n  exec();\n\n\n\n\n\nIf you call \npopulate()\n multiple times with the same path, only the last one will take effect.\n\n\nStory\n.\n\n  \nfind\n().\n\n  \npopulate\n(\n{\n \npath\n:\n \nfans\n,\n \nselect\n:\n \nname\n \n}\n).\n\n  \npopulate\n(\n{\n \npath\n:\n \nfans\n,\n \nselect\n:\n \nemail\n \n}\n);\n\n\n\nStory\n.\nfind\n()\n.\npopulate\n(\n{\n \npath\n:\n \nfans\n,\n \nselect\n:\n \nemail\n \n}\n);\n\n\n\n\n\n\nQuery conditions and other options\n\n\nWhat if we wanted to populate our fans array based on their age, select just their names, and return at most, any 5 of them?\n\n\nStory.\n  find(...).\n  populate({\n    path: \nfans\n,\n    match: { age: { $gte: 21 }},\n\n    select: \nname -_id\n,\n    options: { limit: 5 }\n  }).\n  exec();\n\n\n\n\n\nRefs to children\n\n\nWe may find however, if we use the \nauthor\n object, we are unable to get a list of the stories. This is because no \nstory\n objects were ever 'pushed' onto \nauthor.stories\n.\n\n\nThere are two perspectives here. First, you may want the \nauthor\n know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can \npush()\n documents onto the array as shown below.\n\n\nauthor.stories.push(story1);\nauthor.save(callback);\n\n\n\n\n\nThis allows us to perform a \nfind\n and \npopulate\n combo:\n\n\nPerson.\n  findOne({ name: \nIan Fleming\n }).\n  populate(\nstories\n).\n  exec(function (err, person) {\n    if (err) return handleError(err);\n    console.log(person);\n  });\n\n\n\n\n\nIt is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly \nfind()\n the stories we are interested in.\n\n\nStory\n.\n\n  \nfind\n(\n{\n \nauthor\n:\n \nauthor\n.\n_id\n \n}\n).\n\n  \nexec\n(\nfunction\n \n(\nerr\n,\n \nstories\n)\n \n{\n\n    \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n    \nconsole.log(\nThe\n \nstories\n \nare\n \nan\n \narray\n:\n \n,\n \nstories\n);\n\n  \n}\n);\n\n\n\n\n\n\nThe documents returned from \nquery population\n become fully functional, \nremove\nable, \nsave\nable documents unless the \nlean\n option is specified. Do not confuse them with \nsub docs\n. Take caution when calling its remove method because you'll be removing it from the database, not just the array.\n\n\nPopulating an existing document\n\n\nIf we have an existing mongoose document and want to populate some of its paths, \nmongoose \n= 3.6\n supports the \ndocument#populate()\n method.\n\n\nPopulating multiple existing documents\n\n\nIf we have one or many mongoose documents or even plain objects (\nlike \nmapReduce\n output\n), we may populate them using the \nModel.populate()\n method available in \nmongoose \n= 3.6\n. This is what \ndocument#populate()\n and \nquery#populate()\n use to populate documents.\n\n\nPopulating across multiple levels\n\n\nSay you have a user schema which keeps track of the user's friends.\n\n\nvar userSchema = new Schema({\n  name: String,\n  friends: [{ type: ObjectId, ref: \nUser\n }]\n});\n\n\n\n\n\nPopulate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the \npopulate\n option to tell mongoose to populate the \nfriends\n array of all the user's friends:\n\n\nUser.\n  findOne({ name: \nVal\n }).\n  populate({\n    path: \nfriends\n,\n\n    populate: { path: \nfriends\n }\n  });\n\n\n\n\n\nPopulating across Databases\n\n\nLet's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread.\n\n\nvar eventSchema = new Schema({\n  name: String,\n\n\n  conversation: ObjectId\n});\nvar conversationSchema = new Schema({\n  numMessages: Number\n});\n\n\n\n\n\nAlso, suppose that events and conversations are stored in separate MongoDB instances.\n\n\nvar\n \ndb1\n \n=\n \nmongoose\n.\ncreateConnection\n(\nlocalhost:27000/db1\n);\n\n\nvar\n \ndb2\n \n=\n \nmongoose\n.\ncreateConnection\n(\nlocalhost:27001/db2\n);\n\n\n\nvar\n \nEvent\n \n=\n \ndb1\n.\nmodel\n(\nEvent\n,\n \neventSchema\n);\n\n\nvar\n \nConversation\n \n=\n \ndb2\n.\nmodel\n(\nConversation\n,\n \nconversationSchema\n);\n\n\n\n\n\n\nIn this situation, you will \nnot\n be able to \npopulate()\n normally. The \nconversation\n field will always be null, because \npopulate()\n doesn't know which model to use. However, \nyou can specify the model explicitly\n.\n\n\nEvent.\n  find().\n  populate({ path: \nconversation\n, model: Conversation }).\n  exec(function(error, docs) {  });\n\n\n\n\n\nThis is known as a \"cross-database populate,\" because it enables you to populate across MongoDB databases and even across MongoDB instances.\n\n\nDynamic References\n\n\nMongoose can also populate from multiple collections at the same time. Let's say you have a user schema that has an array of \"connections\" - a user can be connected to either other users or an organization.\n\n\nvar\n \nuserSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \nString\n,\n\n  \nconnections\n:\n \n[\n{\n\n    \nkind\n:\n \nString\n,\n\n    \nitem\n:\n \n{\n \ntype\n:\n \nObjectId\n,\n \nrefPath\n:\n \nconnections.kind\n \n}\n\n  \n}\n]\n\n\n}\n);\n\n\n\nvar\n \norganizationSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \nkind\n:\n \nString\n \n}\n);\n\n\n\nvar\n \nUser\n \n=\n \nmongoose\n.\nmodel\n(\nUser\n,\n \nuserSchema\n);\n\n\nvar\n \nOrganization\n \n=\n \nmongoose\n.\nmodel\n(\nOrganization\n,\n \norganizationSchema\n);\n\n\n\n\n\n\nThe \nrefPath\n property above means that mongoose will look at the \nconnections.kind\n path to determine which model to use for \npopulate()\n. In other words, the \nrefPath\n property enables you to make the \nref\n property dynamic.\n\n\nUser.\n  findOne({ name: \nAxl Rose\n }).\n  populate(\nconnections.item\n).\n  exec(function(error, doc) {\n\n\n  });\n\n\n\n\n\nPopulate Virtuals\n\n\nNew in 4.5.0\n\n\nSo far you've only populated based on the \n_id\n field. However, that's sometimes not the right choice. In particular, \narrays that grow without bound are a MongoDB anti-pattern\n. Using mongoose virtuals, you can define more sophisticated relationships between documents.\n\n\nvar PersonSchema = new Schema({\n  name: String,\n  band: String\n});\n\nvar BandSchema = new Schema({\n  name: String\n});\nBandSchema.virtual(\nmembers\n, {\n  ref: \nPerson\n,\n  localField: \nname\n,\n  foreignField: \nband\n,\n\n\n  justOne: false\n});\n\nvar Person = mongoose.model(\nPerson\n, PersonSchema);\nvar Band = mongoose.model(\nBand\n, BandSchema);\n\n\nBand.find({}).populate(\nmembers\n).exec(function(error, bands) {\n\n});\n\n\n\n\n\nKeep in mind that virtuals are \nnot\n included in \ntoJSON()\n output by\n\n\ndefault. If you want populate virtuals to show up when using functions that rely on \nJSON.stringify()\n, like Express' \nres.json()\n function\n, set the \nvirtuals: true\n option on your schema's \ntoJSON\n options.\n\n\nvar\n \nBandSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nname\n:\n \nString\n\n\n}\n,\n \n{\n \ntoJSON\n:\n \n{\n \nvirtuals\n:\n \ntrue\n \n}\n \n}\n);\n\n\n\n\n\n\nIf you're using populate projections, make sure \nforeignField\n is included in the projection.\n\n\nBand.\n  find({}).\n  populate({ path: \nmembers\n, select: \nname\n }).\n  exec(function(error, bands) {\n\n  });\n\nBand.\n  find({}).\n  populate({ path: \nmembers\n, select: \nname band\n }).\n  exec(function(error, bands) {\n\n  });\n\n\n\n\n\nNext Up\n\n\nNow that we've covered \npopulate()\n, let's take a look at \ndiscriminators\n.", 
            "title": "\u586b\u5145"
        }, 
        {
            "location": "/guide/Populate/#mongoose-v501-query-population", 
            "text": "", 
            "title": "Mongoose v5.0.1: Query Population"
        }, 
        {
            "location": "/guide/Populate/#populate", 
            "text": "Source  MongoDB has the join-like  $lookup  aggregation operator in versions  = 3.2. Mongoose has a more powerful alternative called  populate() , which lets you reference documents in other collections.  Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples.  var mongoose = require( mongoose );\nvar Schema = mongoose.Schema;\n\nvar personSchema = Schema({\n  _id: Schema.Types.ObjectId,\n  name: String,\n  age: Number,\n  stories: [{ type: Schema.Types.ObjectId, ref:  Story  }]\n});\n\nvar storySchema = Schema({\n  author: { type: Schema.Types.ObjectId, ref:  Person  },\n  title: String,\n  fans: [{ type: Schema.Types.ObjectId, ref:  Person  }]\n});\n\nvar Story = mongoose.model( Story , storySchema);\nvar Person = mongoose.model( Person , personSchema);  So far we've created two  Models . Our  Person  model has its  stories  field set to an array of  ObjectId s. The  ref  option is what tells Mongoose which model to use during population, in our case the  Story  model. All  _id s we store here must be document  _id s from the  Story  model.  Note :  ObjectId ,  Number ,  String , and  Buffer  are valid for use as refs. However, you should use  ObjectId  unless you are an advanced user and have a good reason for doing so.", 
            "title": "Populate"
        }, 
        {
            "location": "/guide/Populate/#saving-refs", 
            "text": "Saving refs to other documents works the same way you normally save properties, just assign the  _id  value:  var author = new Person({\n  _id: new mongoose.Types.ObjectId(),\n  name:  Ian Fleming ,\n  age: 50\n});\n\nauthor.save(function (err) {\n  if (err) return handleError(err);\n\n  var story1 = new Story({\n    title:  Casino Royale ,\n    author: author._id\n  });\n\n  story1.save(function (err) {\n    if (err) return handleError(err);\n\n  });\n});", 
            "title": "Saving refs"
        }, 
        {
            "location": "/guide/Populate/#population", 
            "text": "So far we haven't done anything much different. We've merely created a  Person  and a  Story . Now let's take a look at populating our story's  author  using the query builder:  Story.\n  findOne({ title:  Casino Royale  }).\n  populate( author ).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n    console.log( The author is %s , story.author.name);\n\n  });  Populated paths are no longer set to their original  _id  , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results.  Arrays of refs work the same way. Just call the  populate  method on the query and an array of documents will be returned  in place  of the original  _id s.", 
            "title": "Population"
        }, 
        {
            "location": "/guide/Populate/#setting-populated-fields", 
            "text": "In Mongoose  = 4.0, you can manually populate a field as well.  Story.findOne({ title:  Casino Royale  }, function(error, story) {\n  if (error) {\n    return handleError(error);\n  }\n  story.author = author;\n  console.log(story.author.name);\n});", 
            "title": "Setting Populated Fields"
        }, 
        {
            "location": "/guide/Populate/#field-selection", 
            "text": "What if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual  field name syntax  as the second argument to the populate method:  Story.\n  findOne({ title: /casino royale/i }).\n  populate( author ,  name ).\n  exec(function (err, story) {\n    if (err) return handleError(err);\n\n    console.log( The author is %s , story.author.name);\n\n\n    console.log( The authors age is %s , story.author.age);\n\n  });", 
            "title": "Field Selection"
        }, 
        {
            "location": "/guide/Populate/#populating-multiple-paths", 
            "text": "What if we wanted to populate multiple paths at the same time?  Story.\n  find(...).\n  populate( fans ).\n  populate( author ).\n  exec();  If you call  populate()  multiple times with the same path, only the last one will take effect.  Story . \n   find (). \n   populate ( {   path :   fans ,   select :   name   } ). \n   populate ( {   path :   fans ,   select :   email   } );  Story . find () . populate ( {   path :   fans ,   select :   email   } );", 
            "title": "Populating Multiple Paths"
        }, 
        {
            "location": "/guide/Populate/#query-conditions-and-other-options", 
            "text": "What if we wanted to populate our fans array based on their age, select just their names, and return at most, any 5 of them?  Story.\n  find(...).\n  populate({\n    path:  fans ,\n    match: { age: { $gte: 21 }},\n\n    select:  name -_id ,\n    options: { limit: 5 }\n  }).\n  exec();", 
            "title": "Query conditions and other options"
        }, 
        {
            "location": "/guide/Populate/#refs-to-children", 
            "text": "We may find however, if we use the  author  object, we are unable to get a list of the stories. This is because no  story  objects were ever 'pushed' onto  author.stories .  There are two perspectives here. First, you may want the  author  know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can  push()  documents onto the array as shown below.  author.stories.push(story1);\nauthor.save(callback);  This allows us to perform a  find  and  populate  combo:  Person.\n  findOne({ name:  Ian Fleming  }).\n  populate( stories ).\n  exec(function (err, person) {\n    if (err) return handleError(err);\n    console.log(person);\n  });  It is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly  find()  the stories we are interested in.  Story . \n   find ( {   author :   author . _id   } ). \n   exec ( function   ( err ,   stories )   { \n     if   (err)   return   handleError(err) ; \n     console.log( The   stories   are   an   array :   ,   stories ); \n   } );   The documents returned from  query population  become fully functional,  remove able,  save able documents unless the  lean  option is specified. Do not confuse them with  sub docs . Take caution when calling its remove method because you'll be removing it from the database, not just the array.", 
            "title": "Refs to children"
        }, 
        {
            "location": "/guide/Populate/#populating-an-existing-document", 
            "text": "If we have an existing mongoose document and want to populate some of its paths,  mongoose  = 3.6  supports the  document#populate()  method.", 
            "title": "Populating an existing document"
        }, 
        {
            "location": "/guide/Populate/#populating-multiple-existing-documents", 
            "text": "If we have one or many mongoose documents or even plain objects ( like  mapReduce  output ), we may populate them using the  Model.populate()  method available in  mongoose  = 3.6 . This is what  document#populate()  and  query#populate()  use to populate documents.", 
            "title": "Populating multiple existing documents"
        }, 
        {
            "location": "/guide/Populate/#populating-across-multiple-levels", 
            "text": "Say you have a user schema which keeps track of the user's friends.  var userSchema = new Schema({\n  name: String,\n  friends: [{ type: ObjectId, ref:  User  }]\n});  Populate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the  populate  option to tell mongoose to populate the  friends  array of all the user's friends:  User.\n  findOne({ name:  Val  }).\n  populate({\n    path:  friends ,\n\n    populate: { path:  friends  }\n  });", 
            "title": "Populating across multiple levels"
        }, 
        {
            "location": "/guide/Populate/#populating-across-databases", 
            "text": "Let's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread.  var eventSchema = new Schema({\n  name: String,\n\n\n  conversation: ObjectId\n});\nvar conversationSchema = new Schema({\n  numMessages: Number\n});  Also, suppose that events and conversations are stored in separate MongoDB instances.  var   db1   =   mongoose . createConnection ( localhost:27000/db1 );  var   db2   =   mongoose . createConnection ( localhost:27001/db2 );  var   Event   =   db1 . model ( Event ,   eventSchema );  var   Conversation   =   db2 . model ( Conversation ,   conversationSchema );   In this situation, you will  not  be able to  populate()  normally. The  conversation  field will always be null, because  populate()  doesn't know which model to use. However,  you can specify the model explicitly .  Event.\n  find().\n  populate({ path:  conversation , model: Conversation }).\n  exec(function(error, docs) {  });  This is known as a \"cross-database populate,\" because it enables you to populate across MongoDB databases and even across MongoDB instances.", 
            "title": "Populating across Databases"
        }, 
        {
            "location": "/guide/Populate/#dynamic-references", 
            "text": "Mongoose can also populate from multiple collections at the same time. Let's say you have a user schema that has an array of \"connections\" - a user can be connected to either other users or an organization.  var   userSchema   =   new   Schema ( { \n   name :   String , \n   connections :   [ { \n     kind :   String , \n     item :   {   type :   ObjectId ,   refPath :   connections.kind   } \n   } ]  } );  var   organizationSchema   =   new   Schema ( {   name :   String ,   kind :   String   } );  var   User   =   mongoose . model ( User ,   userSchema );  var   Organization   =   mongoose . model ( Organization ,   organizationSchema );   The  refPath  property above means that mongoose will look at the  connections.kind  path to determine which model to use for  populate() . In other words, the  refPath  property enables you to make the  ref  property dynamic.  User.\n  findOne({ name:  Axl Rose  }).\n  populate( connections.item ).\n  exec(function(error, doc) {\n\n\n  });", 
            "title": "Dynamic References"
        }, 
        {
            "location": "/guide/Populate/#populate-virtuals", 
            "text": "New in 4.5.0  So far you've only populated based on the  _id  field. However, that's sometimes not the right choice. In particular,  arrays that grow without bound are a MongoDB anti-pattern . Using mongoose virtuals, you can define more sophisticated relationships between documents.  var PersonSchema = new Schema({\n  name: String,\n  band: String\n});\n\nvar BandSchema = new Schema({\n  name: String\n});\nBandSchema.virtual( members , {\n  ref:  Person ,\n  localField:  name ,\n  foreignField:  band ,\n\n\n  justOne: false\n});\n\nvar Person = mongoose.model( Person , PersonSchema);\nvar Band = mongoose.model( Band , BandSchema);\n\n\nBand.find({}).populate( members ).exec(function(error, bands) {\n\n});  Keep in mind that virtuals are  not  included in  toJSON()  output by  default. If you want populate virtuals to show up when using functions that rely on  JSON.stringify() , like Express'  res.json()  function , set the  virtuals: true  option on your schema's  toJSON  options.  var   BandSchema   =   new   Schema ( { \n   name :   String  } ,   {   toJSON :   {   virtuals :   true   }   } );   If you're using populate projections, make sure  foreignField  is included in the projection.  Band.\n  find({}).\n  populate({ path:  members , select:  name  }).\n  exec(function(error, bands) {\n\n  });\n\nBand.\n  find({}).\n  populate({ path:  members , select:  name band  }).\n  exec(function(error, bands) {\n\n  });", 
            "title": "Populate Virtuals"
        }, 
        {
            "location": "/guide/Populate/#next-up", 
            "text": "Now that we've covered  populate() , let's take a look at  discriminators .", 
            "title": "Next Up"
        }, 
        {
            "location": "/guide/Discriminators/", 
            "text": "Mongoose v5.0.1: Discriminators\n\n\nSource\n\n\nDiscriminators are a schema inheritance mechanism. They enable you to have multiple models with overlapping schemas on top of the same underlying MongoDB collection.\n\n\nSuppose you wanted to track different types of events in a single collection. Every event will have a timestamp, but events that represent clicked links should have a URL. You can achieve this using the \nmodel.discriminator()\n function. This function takes 2 parameters, a model name and a discriminator schema. It returns a model whose schema is the union of the base schema and the discriminator schema.\n\n\n    \nvar\n \noptions\n \n=\n \n{\ndiscriminatorKey\n:\n \nkind\n}\n;\n\n\n    \nvar\n \neventSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n(\n{\ntime\n:\n \nDate\n}\n,\n \noptions\n);\n\n    \nvar\n \nEvent\n \n=\n \nmongoose\n.\nmodel\n(\nEvent\n,\n \neventSchema\n);\n\n\n\n\n    \nvar\n \nClickedLinkEvent\n \n=\n \nEvent\n.\ndiscriminator\n(\nClickedLink\n,\n\n      \nnew\n \nmongoose\n.\nSchema\n(\n{\nurl\n:\n \nString\n}\n,\n \noptions\n));\n\n\n\n    \nvar\n \ngenericEvent\n \n=\n \nnew\n \nEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n}\n);\n\n    \nassert\n.\nok\n(!\ngenericEvent\n.\nurl\n);\n\n\n\n    \nvar\n \nclickedEvent\n \n=\n\n      \nnew\n \nClickedLinkEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n}\n);\n\n    \nassert\n.\nok\n(\nclickedEvent\n.\nurl\n);\n\n\n\n\n\n\nSuppose you created another discriminator to track events where a new user registered. These \nSignedUpEvent\n instances will be stored in the same collection as generic events and \nClickedLinkEvent\n instances.\n\n\n    \nvar\n \nevent1\n \n=\n \nnew\n \nEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n()}\n);\n\n    \nvar\n \nevent2\n \n=\n \nnew\n \nClickedLinkEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n}\n);\n\n    \nvar\n \nevent3\n \n=\n \nnew\n \nSignedUpEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nuser\n:\n \ntestuser\n}\n);\n\n\n    \nvar\n \nsave\n \n=\n \nfunction\n \n(\ndoc\n,\n \ncallback\n)\n \n{\n\n      \ndoc.save(function\n \n(error,\n \ndoc)\n \n{\n\n        \ncallback(error,\n \ndoc)\n;\n\n      \n}\n);\n\n    \n}\n;\n\n\n    \nasync\n.\nmap\n(\n[\nevent1\n,\n \nevent2\n,\n \nevent3\n]\n,\n \nsave\n,\n \nfunction\n \n(\nerror\n)\n \n{\n\n\n      \nEvent.count({\n}\n,\n \nfunction\n \n(\nerror\n,\n \ncount\n)\n \n{\n\n        \nassert.equal(count,\n \n3)\n;\n\n      \n}\n);\n\n    \n}\n);\n\n\n\n\n\n\nThe way mongoose tells the difference between the different discriminator models is by the 'discriminator key', which is \n__t\n by default. Mongoose adds a String path called \n__t\n to your schemas that it uses to track which discriminator this document is an instance of.\n\n\n    \nvar\n \nevent1\n \n=\n \nnew\n \nEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n()}\n);\n\n    \nvar\n \nevent2\n \n=\n \nnew\n \nClickedLinkEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n}\n);\n\n    \nvar\n \nevent3\n \n=\n \nnew\n \nSignedUpEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nuser\n:\n \ntestuser\n}\n);\n\n\n    \nassert\n.\nok\n(!\nevent1\n.\n__t\n);\n\n    \nassert\n.\nequal\n(\nevent2\n.\n__t\n,\n \nClickedLink\n);\n\n    \nassert\n.\nequal\n(\nevent3\n.\n__t\n,\n \nSignedUp\n);\n\n\n\n\n\n\nDiscriminator models are special; they attach the discriminator key to queries. In other words, \nfind()\n, \ncount()\n, \naggregate()\n, etc. are smart enough to account for discriminators.\n\n\n    \nvar\n \nevent1\n \n=\n \nnew\n \nEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n()}\n);\n\n    \nvar\n \nevent2\n \n=\n \nnew\n \nClickedLinkEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nurl\n:\n \ngoogle.com\n}\n);\n\n    \nvar\n \nevent3\n \n=\n \nnew\n \nSignedUpEvent\n(\n{\ntime\n:\n \nDate\n.\nnow\n(),\n \nuser\n:\n \ntestuser\n}\n);\n\n\n    \nvar\n \nsave\n \n=\n \nfunction\n \n(\ndoc\n,\n \ncallback\n)\n \n{\n\n      \ndoc.save(function\n \n(error,\n \ndoc)\n \n{\n\n        \ncallback(error,\n \ndoc)\n;\n\n      \n}\n);\n\n    \n}\n;\n\n\n    \nasync\n.\nmap\n(\n[\nevent1\n,\n \nevent2\n,\n \nevent3\n]\n,\n \nsave\n,\n \nfunction\n \n(\nerror\n)\n \n{\n\n\n      \nClickedLinkEvent.find({\n}\n,\n \nfunction\n \n(\nerror\n,\n \ndocs\n)\n \n{\n\n        \nassert.equal(docs.length,\n \n1)\n;\n\n        \nassert.equal(docs\n[\n0\n]\n._id.toString(),\n \nevent2._id.toString())\n;\n\n        \nassert.equal(docs\n[\n0\n]\n.url,\n \ngoogle.com\n)\n;\n\n      \n}\n);\n\n    \n}\n);\n\n\n\n\n\n\nDiscriminators also take their base schema's pre and post middleware. However, you can also attach middleware to the discriminator schema without affecting the base schema.\n\n\n    \nvar\n \noptions\n \n=\n \n{\ndiscriminatorKey\n:\n \nkind\n}\n;\n\n\n    \nvar\n \neventSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n(\n{\ntime\n:\n \nDate\n}\n,\n \noptions\n);\n\n    \nvar\n \neventSchemaCalls\n \n=\n \n0\n;\n\n    \neventSchema\n.\npre\n(\nvalidate\n,\n \nfunction\n \n(\nnext\n)\n \n{\n\n      \n++eventSchemaCalls\n;\n\n      \nnext()\n;\n\n    \n}\n);\n\n    \nvar\n \nEvent\n \n=\n \nmongoose\n.\nmodel\n(\nGenericEvent\n,\n \neventSchema\n);\n\n\n    \nvar\n \nclickedLinkSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n(\n{\nurl\n:\n \nString\n}\n,\n \noptions\n);\n\n    \nvar\n \nclickedSchemaCalls\n \n=\n \n0\n;\n\n    \nclickedLinkSchema\n.\npre\n(\nvalidate\n,\n \nfunction\n \n(\nnext\n)\n \n{\n\n      \n++clickedSchemaCalls\n;\n\n      \nnext()\n;\n\n    \n}\n);\n\n    \nvar\n \nClickedLinkEvent\n \n=\n \nEvent\n.\ndiscriminator\n(\nClickedLinkEvent\n,\n\n      \nclickedLinkSchema\n);\n\n\n    \nvar\n \nevent1\n \n=\n \nnew\n \nClickedLinkEvent\n();\n\n    \nevent1\n.\nvalidate\n(\nfunction\n()\n \n{\n\n      \nassert.equal(eventSchemaCalls,\n \n1)\n;\n\n      \nassert.equal(clickedSchemaCalls,\n \n1)\n;\n\n\n      \nvar\n \ngeneric\n \n=\n \nnew\n \nEvent()\n;\n\n      \ngeneric.validate(function()\n \n{\n\n        \nassert.equal(eventSchemaCalls,\n \n2)\n;\n\n        \nassert.equal(clickedSchemaCalls,\n \n1)\n;\n\n      \n}\n);\n\n    \n}\n);\n\n\n\n\n\n\nA discriminator's fields are the union of the base schema's fields and the discriminator schema's fields, and the discriminator schema's fields take precedence. There is one exception: the default \n_id\n field.\n\n\nYou can work around this by setting the \n_id\n option to false in the discriminator schema as shown below.\n\n\n    \nvar\n \noptions\n \n=\n \n{\ndiscriminatorKey\n:\n \nkind\n}\n;\n\n\n\n    \nvar\n \neventSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n(\n{\n_id\n:\n \nString\n,\n \ntime\n:\n \nDate\n}\n,\n\n      \noptions\n);\n\n    \nvar\n \nEvent\n \n=\n \nmongoose\n.\nmodel\n(\nBaseEvent\n,\n \neventSchema\n);\n\n\n    \nvar\n \nclickedLinkSchema\n \n=\n \nnew\n \nmongoose\n.\nSchema\n(\n{\n\n      \nurl\n:\n \nString\n,\n\n      \ntime\n:\n \nString\n\n    \n}\n,\n \noptions\n);\n\n\n\n    \nassert\n.\nok\n(\nclickedLinkSchema\n.\npath\n(\n_id\n));\n\n    \nassert\n.\nequal\n(\nclickedLinkSchema\n.\npath\n(\n_id\n)\n.\ninstance\n,\n \nObjectID\n);\n\n    \nvar\n \nClickedLinkEvent\n \n=\n \nEvent\n.\ndiscriminator\n(\nChildEventBad\n,\n\n      \nclickedLinkSchema\n);\n\n\n    \nvar\n \nevent1\n \n=\n \nnew\n \nClickedLinkEvent\n(\n{\n \n_id\n:\n \ncustom id\n,\n \ntime\n:\n \n4pm\n \n}\n);\n\n\n\n    \nassert\n.\nok\n(\ntypeof\n \nevent1\n.\n_id\n \n===\n \nstring\n);\n\n    \nassert\n.\nok\n(\ntypeof\n \nevent1\n.\ntime\n \n===\n \nstring\n);\n\n\n\n\n\n\nWhen you use \nModel.create()\n, mongoose will pull the correct type from the discriminator key for you.\n\n\n    \nvar\n \nSchema\n \n=\n \nmongoose\n.\nSchema\n;\n\n    \nvar\n \nshapeSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \nname\n:\n \nString\n\n    \n}\n,\n \n{\n \ndiscriminatorKey\n:\n \nkind\n \n}\n);\n\n\n    \nvar\n \nShape\n \n=\n \ndb\n.\nmodel\n(\nShape\n,\n \nshapeSchema\n);\n\n\n    \nvar\n \nCircle\n \n=\n \nShape\n.\ndiscriminator\n(\nCircle\n,\n\n      \nnew\n \nSchema\n(\n{\n \nradius\n:\n \nNumber\n \n}\n));\n\n    \nvar\n \nSquare\n \n=\n \nShape\n.\ndiscriminator\n(\nSquare\n,\n\n      \nnew\n \nSchema\n(\n{\n \nside\n:\n \nNumber\n \n}\n));\n\n\n    \nvar\n \nshapes\n \n=\n \n[\n\n      \n{\n \nname\n:\n \nTest\n \n},\n\n      \n{\n \nkind\n:\n \nCircle\n,\n \nradius\n:\n \n5\n \n},\n\n      \n{\n \nkind\n:\n \nSquare\n,\n \nside\n:\n \n10\n \n}\n\n    \n]\n;\n\n    \nShape\n.\ncreate\n(\nshapes\n,\n \nfunction\n(\nerror\n,\n \nshapes\n)\n \n{\n\n      \nassert.ifError(error)\n;\n\n      \nassert.ok(shapes\n[\n0\n]\n \ninstanceof\n \nShape)\n;\n\n      \nassert.ok(shapes\n[\n1\n]\n \ninstanceof\n \nCircle)\n;\n\n      \nassert.equal(shapes\n[\n1\n]\n.radius,\n \n5)\n;\n\n      \nassert.ok(shapes\n[\n2\n]\n \ninstanceof\n \nSquare)\n;\n\n      \nassert.equal(shapes\n[\n2\n]\n.side,\n \n10)\n;\n\n    \n}\n);\n\n\n\n\n\n\nYou can also define discriminators on embedded document arrays. Embedded discriminators are different because the different discriminator types are stored in the same document array (within a document) rather than the same collection. In other words, embedded discriminators let you store subdocuments matching different schemas in the same array.\n\n\nAs a general best practice, make sure you declare any hooks on your schemas \nbefore\n you use them. You should \nnot\n call \npre()\n or \npost()\n after calling \ndiscriminator()\n\n\n    \nvar\n \neventSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nmessage\n:\n \nString\n \n}\n,\n\n      \n{\n \ndiscriminatorKey\n:\n \nkind\n,\n \n_id\n:\n \nfalse\n \n}\n);\n\n\n    \nvar\n \nbatchSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nevents\n:\n \n[\neventSchema\n]\n \n}\n);\n\n\n\n    \nvar\n \ndocArray\n \n=\n \nbatchSchema\n.\npath\n(\nevents\n);\n\n\n\n\n    \nvar\n \nclickedSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n      \nelement\n:\n \n{\n\n        \ntype\n:\n \nString\n,\n\n        \nrequired\n:\n \ntrue\n\n      \n}\n\n    \n}\n,\n \n{\n \n_id\n:\n \nfalse\n \n}\n);\n\n\n\n    \nvar\n \nClicked\n \n=\n \ndocArray\n.\ndiscriminator\n(\nClicked\n,\n \nclickedSchema\n);\n\n\n\n    \nvar\n \nPurchased\n \n=\n \ndocArray\n.\ndiscriminator\n(\nPurchased\n,\n \nnew\n \nSchema\n(\n{\n\n      \nproduct\n:\n \n{\n\n        \ntype\n:\n \nString\n,\n\n        \nrequired\n:\n \ntrue\n\n      \n}\n\n    \n}\n,\n \n{\n \n_id\n:\n \nfalse\n \n}\n));\n\n\n    \nvar\n \nBatch\n \n=\n \ndb\n.\nmodel\n(\nEventBatch\n,\n \nbatchSchema\n);\n\n\n\n    \nvar\n \nbatch\n \n=\n \n{\n\n      \nevents\n:\n \n[\n\n        \n{\n \nkind\n:\n \nClicked\n,\n \nelement\n:\n \n#hero\n,\n \nmessage\n:\n \nhello\n \n},\n\n        \n{\n \nkind\n:\n \nPurchased\n,\n \nproduct\n:\n \naction-figure-1\n,\n \nmessage\n:\n \nworld\n \n}\n\n      \n]\n\n    \n}\n;\n\n\n    \nBatch\n.\ncreate\n(\nbatch\n).\n\n      \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n        \nassert.equal(doc.events.length,\n \n2)\n;\n\n\n        \nassert.equal(doc.events\n[\n0\n]\n.element,\n \n#hero\n)\n;\n\n        \nassert.equal(doc.events\n[\n0\n]\n.message,\n \nhello\n)\n;\n\n        \nassert.ok(doc.events\n[\n0\n]\n \ninstanceof\n \nClicked)\n;\n\n\n        \nassert.equal(doc.events\n[\n1\n]\n.product,\n \naction-figure-1\n)\n;\n\n        \nassert.equal(doc.events\n[\n1\n]\n.message,\n \nworld\n)\n;\n\n        \nassert.ok(doc.events\n[\n1\n]\n \ninstanceof\n \nPurchased)\n;\n\n\n        \ndoc.events.push({\n \nkind\n:\n \nPurchased\n,\n \nproduct\n:\n \naction-figure-2\n \n}\n);\n\n        \nreturn\n \ndoc\n.\nsave\n();\n\n      \n}\n).\n\n      \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n        \nassert.equal(doc.events.length,\n \n3)\n;\n\n\n        \nassert.equal(doc.events\n[\n2\n]\n.product,\n \naction-figure-2\n)\n;\n\n        \nassert.ok(doc.events\n[\n2\n]\n \ninstanceof\n \nPurchased)\n;\n\n\n        \ndone()\n;\n\n      \n}\n).\n\n      \ncatch\n(\ndone\n);\n\n\n\n\n\n\nRecursive embedded discriminators\n\n\n    \nvar\n \nsingleEventSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nmessage\n:\n \nString\n \n}\n,\n\n      \n{\n \ndiscriminatorKey\n:\n \nkind\n,\n \n_id\n:\n \nfalse\n \n}\n);\n\n\n    \nvar\n \neventListSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nevents\n:\n \n[\nsingleEventSchema\n]\n \n}\n);\n\n\n    \nvar\n \nsubEventSchema\n \n=\n \nnew\n \nSchema\n(\n{\n\n       \nsub_events\n:\n \n[\nsingleEventSchema\n]\n\n    \n}\n,\n \n{\n \n_id\n:\n \nfalse\n \n}\n);\n\n\n    \nvar\n \nSubEvent\n \n=\n \nsubEventSchema\n.\npath\n(\nsub_events\n)\n.\ndiscriminator\n(\nSubEvent\n,\n \nsubEventSchema\n)\n\n    \neventListSchema\n.\npath\n(\nevents\n)\n.\ndiscriminator\n(\nSubEvent\n,\n \nsubEventSchema\n);\n\n\n    \nvar\n \nEventlist\n \n=\n \ndb\n.\nmodel\n(\nEventList\n,\n \neventListSchema\n);\n\n\n\n    \nvar\n \nlist\n \n=\n \n{\n\n      \nevents\n:\n \n[\n\n        \n{\n \nkind\n:\n \nSubEvent\n,\n \nsub_events\n:\n \n[\n{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[\n]\n,\n \nmessage\n:\ntest1\n}\n],\n \nmessage\n:\n \nhello\n \n}\n,\n\n        \n{\n \nkind\n:\n \nSubEvent\n,\n \nsub_events\n:\n \n[\n{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[\n{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[\n]\n,\n \nmessage\n:\ntest3\n}\n],\n \nmessage\n:\ntest2\n}\n],\n \nmessage\n:\n \nworld\n \n}\n\n      \n]\n\n    \n}\n;\n\n\n    \nEventlist\n.\ncreate\n(\nlist\n).\n\n      \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n        \nassert.equal(doc.events.length,\n \n2)\n;\n\n\n        \nassert.equal(doc.events\n[\n0\n]\n.sub_events\n[\n0\n]\n.message,\n \ntest1\n)\n;\n\n        \nassert.equal(doc.events\n[\n0\n]\n.message,\n \nhello\n)\n;\n\n        \nassert.ok(doc.events\n[\n0\n]\n.sub_events\n[\n0\n]\n \ninstanceof\n \nSubEvent)\n;\n\n\n        \nassert.equal(doc.events\n[\n1\n]\n.sub_events\n[\n0\n]\n.sub_events\n[\n0\n]\n.message,\n \ntest3\n)\n;\n\n        \nassert.equal(doc.events\n[\n1\n]\n.message,\n \nworld\n)\n;\n\n        \nassert.ok(doc.events\n[\n1\n]\n.sub_events\n[\n0\n]\n.sub_events\n[\n0\n]\n \ninstanceof\n \nSubEvent)\n;\n\n\n        \ndoc.events.push({\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[\n{\nkind\n:\nSubEvent\n,\n \nsub_events\n:\n[\n]\n,\n \nmessage\n:\ntest4\n}\n],\n \nmessage\n:\npushed\n}\n);\n\n        \nreturn\n \ndoc\n.\nsave\n();\n\n      \n}\n).\n\n      \nthen\n(\nfunction\n(\ndoc\n)\n \n{\n\n        \nassert.equal(doc.events.length,\n \n3)\n;\n\n\n        \nassert.equal(doc.events\n[\n2\n]\n.message,\n \npushed\n)\n;\n\n        \nassert.ok(doc.events\n[\n2\n]\n.sub_events\n[\n0\n]\n \ninstanceof\n \nSubEvent)\n;\n\n\n        \ndone()\n;\n\n      \n}\n).\n\n      \ncatch\n(\ndone\n);", 
            "title": "\u9274"
        }, 
        {
            "location": "/guide/Discriminators/#mongoose-v501-discriminators", 
            "text": "Source  Discriminators are a schema inheritance mechanism. They enable you to have multiple models with overlapping schemas on top of the same underlying MongoDB collection.  Suppose you wanted to track different types of events in a single collection. Every event will have a timestamp, but events that represent clicked links should have a URL. You can achieve this using the  model.discriminator()  function. This function takes 2 parameters, a model name and a discriminator schema. It returns a model whose schema is the union of the base schema and the discriminator schema.       var   options   =   { discriminatorKey :   kind } ; \n\n     var   eventSchema   =   new   mongoose . Schema ( { time :   Date } ,   options ); \n     var   Event   =   mongoose . model ( Event ,   eventSchema ); \n\n\n\n     var   ClickedLinkEvent   =   Event . discriminator ( ClickedLink , \n       new   mongoose . Schema ( { url :   String } ,   options )); \n\n\n     var   genericEvent   =   new   Event ( { time :   Date . now (),   url :   google.com } ); \n     assert . ok (! genericEvent . url ); \n\n\n     var   clickedEvent   = \n       new   ClickedLinkEvent ( { time :   Date . now (),   url :   google.com } ); \n     assert . ok ( clickedEvent . url );   Suppose you created another discriminator to track events where a new user registered. These  SignedUpEvent  instances will be stored in the same collection as generic events and  ClickedLinkEvent  instances.       var   event1   =   new   Event ( { time :   Date . now ()} ); \n     var   event2   =   new   ClickedLinkEvent ( { time :   Date . now (),   url :   google.com } ); \n     var   event3   =   new   SignedUpEvent ( { time :   Date . now (),   user :   testuser } ); \n\n     var   save   =   function   ( doc ,   callback )   { \n       doc.save(function   (error,   doc)   { \n         callback(error,   doc) ; \n       } ); \n     } ; \n\n     async . map ( [ event1 ,   event2 ,   event3 ] ,   save ,   function   ( error )   { \n\n       Event.count({ } ,   function   ( error ,   count )   { \n         assert.equal(count,   3) ; \n       } ); \n     } );   The way mongoose tells the difference between the different discriminator models is by the 'discriminator key', which is  __t  by default. Mongoose adds a String path called  __t  to your schemas that it uses to track which discriminator this document is an instance of.       var   event1   =   new   Event ( { time :   Date . now ()} ); \n     var   event2   =   new   ClickedLinkEvent ( { time :   Date . now (),   url :   google.com } ); \n     var   event3   =   new   SignedUpEvent ( { time :   Date . now (),   user :   testuser } ); \n\n     assert . ok (! event1 . __t ); \n     assert . equal ( event2 . __t ,   ClickedLink ); \n     assert . equal ( event3 . __t ,   SignedUp );   Discriminator models are special; they attach the discriminator key to queries. In other words,  find() ,  count() ,  aggregate() , etc. are smart enough to account for discriminators.       var   event1   =   new   Event ( { time :   Date . now ()} ); \n     var   event2   =   new   ClickedLinkEvent ( { time :   Date . now (),   url :   google.com } ); \n     var   event3   =   new   SignedUpEvent ( { time :   Date . now (),   user :   testuser } ); \n\n     var   save   =   function   ( doc ,   callback )   { \n       doc.save(function   (error,   doc)   { \n         callback(error,   doc) ; \n       } ); \n     } ; \n\n     async . map ( [ event1 ,   event2 ,   event3 ] ,   save ,   function   ( error )   { \n\n       ClickedLinkEvent.find({ } ,   function   ( error ,   docs )   { \n         assert.equal(docs.length,   1) ; \n         assert.equal(docs [ 0 ] ._id.toString(),   event2._id.toString()) ; \n         assert.equal(docs [ 0 ] .url,   google.com ) ; \n       } ); \n     } );   Discriminators also take their base schema's pre and post middleware. However, you can also attach middleware to the discriminator schema without affecting the base schema.       var   options   =   { discriminatorKey :   kind } ; \n\n     var   eventSchema   =   new   mongoose . Schema ( { time :   Date } ,   options ); \n     var   eventSchemaCalls   =   0 ; \n     eventSchema . pre ( validate ,   function   ( next )   { \n       ++eventSchemaCalls ; \n       next() ; \n     } ); \n     var   Event   =   mongoose . model ( GenericEvent ,   eventSchema ); \n\n     var   clickedLinkSchema   =   new   mongoose . Schema ( { url :   String } ,   options ); \n     var   clickedSchemaCalls   =   0 ; \n     clickedLinkSchema . pre ( validate ,   function   ( next )   { \n       ++clickedSchemaCalls ; \n       next() ; \n     } ); \n     var   ClickedLinkEvent   =   Event . discriminator ( ClickedLinkEvent , \n       clickedLinkSchema ); \n\n     var   event1   =   new   ClickedLinkEvent (); \n     event1 . validate ( function ()   { \n       assert.equal(eventSchemaCalls,   1) ; \n       assert.equal(clickedSchemaCalls,   1) ; \n\n       var   generic   =   new   Event() ; \n       generic.validate(function()   { \n         assert.equal(eventSchemaCalls,   2) ; \n         assert.equal(clickedSchemaCalls,   1) ; \n       } ); \n     } );   A discriminator's fields are the union of the base schema's fields and the discriminator schema's fields, and the discriminator schema's fields take precedence. There is one exception: the default  _id  field.  You can work around this by setting the  _id  option to false in the discriminator schema as shown below.       var   options   =   { discriminatorKey :   kind } ; \n\n\n     var   eventSchema   =   new   mongoose . Schema ( { _id :   String ,   time :   Date } , \n       options ); \n     var   Event   =   mongoose . model ( BaseEvent ,   eventSchema ); \n\n     var   clickedLinkSchema   =   new   mongoose . Schema ( { \n       url :   String , \n       time :   String \n     } ,   options ); \n\n\n     assert . ok ( clickedLinkSchema . path ( _id )); \n     assert . equal ( clickedLinkSchema . path ( _id ) . instance ,   ObjectID ); \n     var   ClickedLinkEvent   =   Event . discriminator ( ChildEventBad , \n       clickedLinkSchema ); \n\n     var   event1   =   new   ClickedLinkEvent ( {   _id :   custom id ,   time :   4pm   } ); \n\n\n     assert . ok ( typeof   event1 . _id   ===   string ); \n     assert . ok ( typeof   event1 . time   ===   string );   When you use  Model.create() , mongoose will pull the correct type from the discriminator key for you.       var   Schema   =   mongoose . Schema ; \n     var   shapeSchema   =   new   Schema ( { \n       name :   String \n     } ,   {   discriminatorKey :   kind   } ); \n\n     var   Shape   =   db . model ( Shape ,   shapeSchema ); \n\n     var   Circle   =   Shape . discriminator ( Circle , \n       new   Schema ( {   radius :   Number   } )); \n     var   Square   =   Shape . discriminator ( Square , \n       new   Schema ( {   side :   Number   } )); \n\n     var   shapes   =   [ \n       {   name :   Test   }, \n       {   kind :   Circle ,   radius :   5   }, \n       {   kind :   Square ,   side :   10   } \n     ] ; \n     Shape . create ( shapes ,   function ( error ,   shapes )   { \n       assert.ifError(error) ; \n       assert.ok(shapes [ 0 ]   instanceof   Shape) ; \n       assert.ok(shapes [ 1 ]   instanceof   Circle) ; \n       assert.equal(shapes [ 1 ] .radius,   5) ; \n       assert.ok(shapes [ 2 ]   instanceof   Square) ; \n       assert.equal(shapes [ 2 ] .side,   10) ; \n     } );   You can also define discriminators on embedded document arrays. Embedded discriminators are different because the different discriminator types are stored in the same document array (within a document) rather than the same collection. In other words, embedded discriminators let you store subdocuments matching different schemas in the same array.  As a general best practice, make sure you declare any hooks on your schemas  before  you use them. You should  not  call  pre()  or  post()  after calling  discriminator()       var   eventSchema   =   new   Schema ( {   message :   String   } , \n       {   discriminatorKey :   kind ,   _id :   false   } ); \n\n     var   batchSchema   =   new   Schema ( {   events :   [ eventSchema ]   } ); \n\n\n     var   docArray   =   batchSchema . path ( events ); \n\n\n\n     var   clickedSchema   =   new   Schema ( { \n       element :   { \n         type :   String , \n         required :   true \n       } \n     } ,   {   _id :   false   } ); \n\n\n     var   Clicked   =   docArray . discriminator ( Clicked ,   clickedSchema ); \n\n\n     var   Purchased   =   docArray . discriminator ( Purchased ,   new   Schema ( { \n       product :   { \n         type :   String , \n         required :   true \n       } \n     } ,   {   _id :   false   } )); \n\n     var   Batch   =   db . model ( EventBatch ,   batchSchema ); \n\n\n     var   batch   =   { \n       events :   [ \n         {   kind :   Clicked ,   element :   #hero ,   message :   hello   }, \n         {   kind :   Purchased ,   product :   action-figure-1 ,   message :   world   } \n       ] \n     } ; \n\n     Batch . create ( batch ). \n       then ( function ( doc )   { \n         assert.equal(doc.events.length,   2) ; \n\n         assert.equal(doc.events [ 0 ] .element,   #hero ) ; \n         assert.equal(doc.events [ 0 ] .message,   hello ) ; \n         assert.ok(doc.events [ 0 ]   instanceof   Clicked) ; \n\n         assert.equal(doc.events [ 1 ] .product,   action-figure-1 ) ; \n         assert.equal(doc.events [ 1 ] .message,   world ) ; \n         assert.ok(doc.events [ 1 ]   instanceof   Purchased) ; \n\n         doc.events.push({   kind :   Purchased ,   product :   action-figure-2   } ); \n         return   doc . save (); \n       } ). \n       then ( function ( doc )   { \n         assert.equal(doc.events.length,   3) ; \n\n         assert.equal(doc.events [ 2 ] .product,   action-figure-2 ) ; \n         assert.ok(doc.events [ 2 ]   instanceof   Purchased) ; \n\n         done() ; \n       } ). \n       catch ( done );   Recursive embedded discriminators       var   singleEventSchema   =   new   Schema ( {   message :   String   } , \n       {   discriminatorKey :   kind ,   _id :   false   } ); \n\n     var   eventListSchema   =   new   Schema ( {   events :   [ singleEventSchema ]   } ); \n\n     var   subEventSchema   =   new   Schema ( { \n        sub_events :   [ singleEventSchema ] \n     } ,   {   _id :   false   } ); \n\n     var   SubEvent   =   subEventSchema . path ( sub_events ) . discriminator ( SubEvent ,   subEventSchema ) \n     eventListSchema . path ( events ) . discriminator ( SubEvent ,   subEventSchema ); \n\n     var   Eventlist   =   db . model ( EventList ,   eventListSchema ); \n\n\n     var   list   =   { \n       events :   [ \n         {   kind :   SubEvent ,   sub_events :   [ { kind : SubEvent ,   sub_events : [ ] ,   message : test1 } ],   message :   hello   } , \n         {   kind :   SubEvent ,   sub_events :   [ { kind : SubEvent ,   sub_events : [ { kind : SubEvent ,   sub_events : [ ] ,   message : test3 } ],   message : test2 } ],   message :   world   } \n       ] \n     } ; \n\n     Eventlist . create ( list ). \n       then ( function ( doc )   { \n         assert.equal(doc.events.length,   2) ; \n\n         assert.equal(doc.events [ 0 ] .sub_events [ 0 ] .message,   test1 ) ; \n         assert.equal(doc.events [ 0 ] .message,   hello ) ; \n         assert.ok(doc.events [ 0 ] .sub_events [ 0 ]   instanceof   SubEvent) ; \n\n         assert.equal(doc.events [ 1 ] .sub_events [ 0 ] .sub_events [ 0 ] .message,   test3 ) ; \n         assert.equal(doc.events [ 1 ] .message,   world ) ; \n         assert.ok(doc.events [ 1 ] .sub_events [ 0 ] .sub_events [ 0 ]   instanceof   SubEvent) ; \n\n         doc.events.push({ kind : SubEvent ,   sub_events : [ { kind : SubEvent ,   sub_events : [ ] ,   message : test4 } ],   message : pushed } ); \n         return   doc . save (); \n       } ). \n       then ( function ( doc )   { \n         assert.equal(doc.events.length,   3) ; \n\n         assert.equal(doc.events [ 2 ] .message,   pushed ) ; \n         assert.ok(doc.events [ 2 ] .sub_events [ 0 ]   instanceof   SubEvent) ; \n\n         done() ; \n       } ). \n       catch ( done );", 
            "title": "Mongoose v5.0.1: Discriminators"
        }, 
        {
            "location": "/guide/Plugins/", 
            "text": "Mongoose v5.0.1: Plugins\n\n\nPlugins\n\n\nSource\n\n\nSchemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature.\n\n\nSuppose that we have several collections in our database and want to add last-modified functionality to each one. With plugins this is easy. Just create a plugin once and apply it to each \nSchema\n:\n\n\nmodule\n.\nexports\n \n=\n \nexports\n \n=\n \nfunction\n \nlastModifiedPlugin\n \n(\nschema\n,\n \noptions\n)\n \n{\n\n  \nschema.add({\n \nlastMod\n:\n \nDate\n \n}\n);\n\n\n  \nschema\n.\npre\n(\nsave\n,\n \nfunction\n \n(\nnext\n)\n \n{\n\n    \nthis.lastMod\n \n=\n \nnew\n \nDate()\n;\n\n    \nnext()\n;\n\n  \n}\n);\n\n\n  \nif\n \n(\noptions\n \n \noptions\n.\nindex\n)\n \n{\n\n    \nschema.path(\nlastMod\n).index(options.index)\n;\n\n  \n}\n\n\n}\n\n\n\n\nvar\n \nlastMod\n \n=\n \nrequire\n(\n./lastMod\n);\n\n\nvar\n \nGame\n \n=\n \nnew\n \nSchema\n(\n{\n \n...\n \n}\n);\n\n\nGame\n.\nplugin\n(\nlastMod\n,\n \n{\n \nindex\n:\n \ntrue\n \n}\n);\n\n\n\n\nvar\n \nlastMod\n \n=\n \nrequire\n(\n./lastMod\n);\n\n\nvar\n \nPlayer\n \n=\n \nnew\n \nSchema\n(\n{\n \n...\n \n}\n);\n\n\nPlayer\n.\nplugin\n(\nlastMod\n);\n\n\n\n\n\n\nWe just added last-modified behavior to both our \nGame\n and \nPlayer\n schemas and declared an index on the \nlastMod\n path of our Games to boot. Not bad for a few lines of code.\n\n\nGlobal Plugins\n\n\nWant to register a plugin for all schemas? The mongoose singleton has a \n.plugin()\n function that registers a plugin for every schema. For example:\n\n\nvar mongoose = require(\nmongoose\n);\nmongoose.plugin(require(\n./lastMod\n));\n\nvar gameSchema = new Schema({ ... });\nvar playerSchema = new Schema({ ... });\n\nvar Game = mongoose.model(\nGame\n, gameSchema);\nvar Player = mongoose.model(\nPlayer\n, playerSchema);\n\n\n\n\n\nNot only can you re-use schema functionality in your own projects but you also reap the benefits of the Mongoose community as well. Any plugin published to \nnpm\n and \ntagged\n with \nmongoose\n will show up on our \nsearch results\n page.", 
            "title": "\u63d2\u4ef6"
        }, 
        {
            "location": "/guide/Plugins/#mongoose-v501-plugins", 
            "text": "", 
            "title": "Mongoose v5.0.1: Plugins"
        }, 
        {
            "location": "/guide/Plugins/#plugins", 
            "text": "Source  Schemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature.  Suppose that we have several collections in our database and want to add last-modified functionality to each one. With plugins this is easy. Just create a plugin once and apply it to each  Schema :  module . exports   =   exports   =   function   lastModifiedPlugin   ( schema ,   options )   { \n   schema.add({   lastMod :   Date   } ); \n\n   schema . pre ( save ,   function   ( next )   { \n     this.lastMod   =   new   Date() ; \n     next() ; \n   } ); \n\n   if   ( options     options . index )   { \n     schema.path( lastMod ).index(options.index) ; \n   }  }  var   lastMod   =   require ( ./lastMod );  var   Game   =   new   Schema ( {   ...   } );  Game . plugin ( lastMod ,   {   index :   true   } );  var   lastMod   =   require ( ./lastMod );  var   Player   =   new   Schema ( {   ...   } );  Player . plugin ( lastMod );   We just added last-modified behavior to both our  Game  and  Player  schemas and declared an index on the  lastMod  path of our Games to boot. Not bad for a few lines of code.", 
            "title": "Plugins"
        }, 
        {
            "location": "/guide/Plugins/#global-plugins", 
            "text": "Want to register a plugin for all schemas? The mongoose singleton has a  .plugin()  function that registers a plugin for every schema. For example:  var mongoose = require( mongoose );\nmongoose.plugin(require( ./lastMod ));\n\nvar gameSchema = new Schema({ ... });\nvar playerSchema = new Schema({ ... });\n\nvar Game = mongoose.model( Game , gameSchema);\nvar Player = mongoose.model( Player , playerSchema);  Not only can you re-use schema functionality in your own projects but you also reap the benefits of the Mongoose community as well. Any plugin published to  npm  and  tagged  with  mongoose  will show up on our  search results  page.", 
            "title": "Global Plugins"
        }, 
        {
            "location": "/api/", 
            "text": "Mongoose v5.0.1: API docs\n\n\nSource\n\n\n\n\n\n\nSchema()\n\n\nParameters\n\n\nSchema constructor.\n\n\nExample:\n\n\nvar\n \nchild\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n,\n \nage\n:\n \nNumber\n,\n \nchildren\n:\n \n[\nchild\n]\n \n}\n);\n\n\nvar\n \nTree\n \n=\n \nmongoose\n.\nmodel\n(\nTree\n,\n \nschema\n);\n\n\n\n\nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \n_id\n:\n \nfalse\n,\n \nautoIndex\n:\n \nfalse\n \n}\n)\n\n\n\n\n\n\nOptions:\n\n\nNote:\n\n\nWhen nesting schemas, (\nchildren\n in the example above), always declare the child schema first before passing it into its parent.\n\n\n\n\nSchema.prototype.childSchemas\n\n\nArray of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: \nschema\n and \nmodel\n.\n\n\nThis property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.\n\n\n\n\nSchema.prototype.obj\n\n\nThe original object passed to the schema constructor\n\n\nExample:\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \na\n:\n \nString\n \n}\n)\n.\nadd\n(\n{\n \nb\n:\n \nString\n \n}\n);\n\n\nschema\n.\nobj\n;\n\n\n\n\n\n\n\n\nSchema.prototype.clone()\n\n\nReturns:\n\n\n\n\n\u00abSchema\u00bb the cloned schema\n\n\n\n\nReturns a deep copy of the schema\n\n\n\n\nSchema.prototype.add()\n\n\nParameters\n\n\nAdds key path / schema type pairs to this schema.\n\n\nExample:\n\n\nvar\n \nToySchema\n \n=\n \nnew\n \nSchema\n;\n\n\nToySchema\n.\nadd\n(\n{\n \nname\n:\n \nstring\n,\n \ncolor\n:\n \nstring\n,\n \nprice\n:\n \nnumber\n \n}\n);\n\n\n\n\n\n\n\n\nSchema.reserved\n\n\nReserved document keys.\n\n\nKeys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.\n\n\non, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject\n\n\n\n\n\nNOTE:\n Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n\n\nvar schema = new Schema(..);\n schema.methods.init = function () {}\n\n\n\n\n\n\n\nSchema.prototype.path()\n\n\nParameters\n\n\nGets/sets schema paths.\n\n\nSets a path (if arity 2) Gets a path (if arity 1)\n\n\nExample\n\n\nschema.path(\nname\n)\nschema.path(\nname\n, Number)\n\n\n\n\n\n\n\nSchema.prototype.eachPath()\n\n\nParameters\n\n\n\n\nfn \u00abFunction\u00bb callback function\n\n\n\n\nReturns:\n\n\nIterates the schemas paths similar to Array#forEach.\n\n\nThe callback is passed the pathname and schemaType as arguments on each iteration.\n\n\n\n\nSchema.prototype.requiredPaths()\n\n\nParameters\n\n\n\n\ninvalidate \u00abBoolean\u00bb refresh the cache\n\n\n\n\nReturns:\n\n\nReturns an Array of path strings that are required by this schema.\n\n\n\n\nSchema.prototype.pathType()\n\n\nParameters\n\n\nReturns:\n\n\nReturns the pathType of \npath\n for this schema.\n\n\nGiven a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n\n\n\n\nSchema.prototype.queue()\n\n\nParameters\n\n\n\n\nargs \u00abArray\u00bb arguments to pass to the method\n\n\n\n\nAdds a method call to the queue.\n\n\n\n\nSchema.prototype.pre()\n\n\nParameters\n\n\nDefines a pre hook for the document.\n\n\nExample\n\n\nvar toySchema = new Schema(..);\n\ntoySchema.pre(\nsave\n, function (next) {\n  if (!this.created) this.created = new Date;\n  next();\n})\n\ntoySchema.pre(\nvalidate\n, function (next) {\n  if (this.name !== \nWoody\n) this.name = \nWoody\n;\n  next();\n})\n\n\n\n\n\n\n\nSchema.prototype.post()\n\n\nParameters\n\n\nDefines a post hook for the document\n\n\nvar schema = new Schema(..);\nschema.post(\nsave\n, function (doc) {\n  console.log(\nthis fired after a document was saved\n);\n});\n\nschema.post(\nfind\n, function(docs) {\n  console.log(\nthis fired after you run a find query\n);\n});\n\nvar Model = mongoose.model(\nModel\n, schema);\n\nvar m = new Model(..);\nm.save(function(err) {\n  console.log(\nthis fires after the `post` hook\n);\n});\n\nm.find(function(err, docs) {\n  console.log(\nthis fires after the post find hook\n);\n});\n\n\n\n\n\n\n\nSchema.prototype.plugin()\n\n\nParameters\n\n\nRegisters a plugin for this schema.\n\n\n\n\nSchema.prototype.method()\n\n\nParameters\n\n\nAdds an instance method to documents constructed from Models compiled from this schema.\n\n\nExample\n\n\nvar schema = kittySchema = new Schema(..);\n\nschema.method(\nmeow\n, function () {\n  console.log(\nmeeeeeoooooooooooow\n);\n})\n\nvar Kitty = mongoose.model(\nKitty\n, schema);\n\nvar fizz = new Kitty;\nfizz.meow();\n\n\n\n\n\nIf a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n\n\nschema.method({\n    purr: function () {}\n  , scratch: function () {}\n});\n\n\nfizz.purr();\nfizz.scratch();\n\n\n\n\n\n\n\nSchema.prototype.static()\n\n\nParameters\n\n\nAdds static \"class\" methods to Models compiled from this schema.\n\n\nExample\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(..);\n\n\nschema\n.\nstatic\n(\nfindByName\n,\n \nfunction\n \n(\nname\n,\n \ncallback\n)\n \n{\n\n  \nreturn\n \nthis.find({\n \nname\n:\n \nname\n \n}\n,\n \ncallback\n);\n\n\n}\n);\n\n\n\nvar\n \nDrink\n \n=\n \nmongoose\n.\nmodel\n(\nDrink\n,\n \nschema\n);\n\n\nDrink\n.\nfindByName\n(\nsanpellegrino\n,\n \nfunction\n \n(\nerr\n,\n \ndrinks\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\nIf a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n\n\n\n\nSchema.prototype.index()\n\n\nParameters\n\n\n\n\n[options.expires=null] \u00abString\u00bb Mongoose-specific syntactic sugar, uses \nms\n to convert \nexpires\n option into seconds for the \nexpireAfterSeconds\n in the above link.\n\n\n\n\nDefines an index (most likely compound) for this schema.\n\n\nExample\n\n\nschema.index({ first: 1, last: -1 })\n\n\n\n\n\n\n\nSchema.prototype.set()\n\n\nParameters\n\n\n\n\n[value] \u00abObject\u00bb if not passed, the current option value is returned\n\n\n\n\nSets/gets a schema option.\n\n\nExample\n\n\nschema.set(\nstrict\n);\nschema.set(\nstrict\n, false);\nschema.set(\nstrict\n);\n\n\n\n\n\n\n\nSchema.prototype.get()\n\n\nParameters\n\n\n\n\nkey \u00abString\u00bb option name\n\n\n\n\n\n\nindexTypes\n\n\n\n\nSchema.prototype.indexes()\n\n\nCompiles indexes from fields and schema-level indexes\n\n\n\n\nSchema.prototype.virtual()\n\n\nParameters\n\n\nReturns:\n\n\nCreates a virtual type with the given name.\n\n\n\n\nSchema.prototype.virtualpath()\n\n\nParameters\n\n\nReturns:\n\n\nReturns the virtual type with the given \nname\n.\n\n\n\n\nSchema.prototype.remove()\n\n\nParameters\n\n\nRemoves the given \npath\n (or [\npaths\n]).\n\n\n\n\nSchema.prototype.loadClass()\n\n\nParameters\n\n\nLoads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.\n\n\n\n\nSchema.Types\n\n\nThe various built-in Mongoose Schema Types.\n\n\nExample:\n\n\nvar mongoose = require(\nmongoose\n);\nvar ObjectId = mongoose.Schema.Types.ObjectId;\n\n\n\n\n\nTypes:\n\n\nUsing this exposed access to the \nMixed\n SchemaType, we can use them in our schema.\n\n\nvar Mixed = mongoose.Schema.Types.Mixed;\nnew mongoose.Schema({ _user: Mixed })\n\n\n\n\n\n\n\n\n\nConnection()\n\n\nParameters\n\n\n\n\nbase \u00abMongoose\u00bb a mongoose instance\n\n\n\n\nConnection constructor\n\n\nFor practical reasons, a Connection equals a Db.\n\n\n\n\nConnection.prototype.readyState\n\n\nConnection ready state\n\n\n\n\n0 = disconnected\n\n\n1 = connected\n\n\n2 = connecting\n\n\n3 = disconnecting\n\n\n\n\nEach state change emits its associated event name.\n\n\nExample\n\n\nconn.on(\nconnected\n, callback);\nconn.on(\ndisconnected\n, callback);\n\n\n\n\n\n\n\nConnection.prototype.collections\n\n\nA hash of the collections associated with this connection\n\n\n\n\nConnection.prototype.db\n\n\nThe mongodb.Db instance, set when the connection is opened\n\n\n\n\nConnection.prototype.config\n\n\nA hash of the global options that are associated with this connection\n\n\n\n\nConnection.prototype.createCollection()\n\n\nParameters\n\n\nReturns:\n\n\n\n\nConnection.prototype.dropCollection()\n\n\nParameters\n\n\nReturns:\n\n\nHelper for \ndropCollection()\n. Will delete the given collection, including all documents and indexes.\n\n\n\n\nConnection.prototype.dropDatabase()\n\n\nParameters\n\n\nReturns:\n\n\nHelper for \ndropDatabase()\n. Deletes the given database, including all collections, documents, and indexes.\n\n\n\n\nConnection.prototype.close()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional\n\n\n\n\nReturns:\n\n\n\n\nConnection.prototype.collection()\n\n\nParameters\n\n\n\n\n[options] \u00abObject\u00bb optional collection options\n\n\n\n\nReturns:\n\n\n\n\n\u00abCollection\u00bb collection instance\n\n\n\n\nRetrieves a collection, creating it if not cached.\n\n\nNot typically needed by applications. Just talk to your collection through your model.\n\n\n\n\nConnection.prototype.model()\n\n\nParameters\n\n\n\n\n[collection] \u00abString\u00bb name of mongodb collection (optional) if not given it will be induced from model name\n\n\n\n\nReturns:\n\n\n\n\n\u00abModel\u00bb The compiled model\n\n\n\n\nDefines or retrieves a model.\n\n\nvar mongoose = require(\nmongoose\n);\nvar db = mongoose.createConnection(..);\ndb.model(\nVenue\n, new Schema(..));\nvar Ticket = db.model(\nTicket\n, new Schema(..));\nvar Venue = db.model(\nVenue\n);\n\n\n\n\n\nWhen no \ncollection\n argument is passed, Mongoose produces a collection name by passing the model \nname\n to the \nutils.toCollectionName\n method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.\n\n\nExample:\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \ncollection\n:\n \nactor\n \n}\n);\n\n\n\n\n\nschema\n.\nset\n(\ncollection\n,\n \nactor\n);\n\n\n\n\n\nvar\n \ncollectionName\n \n=\n \nactor\n\n\nvar\n \nM\n \n=\n \nconn\n.\nmodel\n(\nActor\n,\n \nschema\n,\n \ncollectionName\n)\n\n\n\n\n\n\n\n\nConnection.prototype.modelNames()\n\n\nReturns:\n\n\nReturns an array of model names created on this connection.\n\n\n\n\n\n\nDocument.prototype.schema\n\n\n\n\nDocument.prototype.isNew\n\n\nBoolean flag specifying if the document is new.\n\n\n\n\nDocument.prototype.id\n\n\nThe string version of this documents _id.\n\n\nNote:\n\n\nThis getter exists on all documents by default. The getter can be disabled by setting the \nid\n \noption\n of its \nSchema\n to false at construction time.\n\n\nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n,\n \n{\n \nid\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\n\n\nDocument.prototype.errors\n\n\nHash containing current validation errors.\n\n\n\n\nDocument.prototype.init()\n\n\nParameters\n\n\n\n\ndoc \u00abObject\u00bb document returned by mongo\n\n\n\n\nInitializes the document without setters or marking anything modified.\n\n\nCalled internally after a document is returned from mongodb.\n\n\n\n\nDocument.prototype.update()\n\n\nParameters\n\n\nReturns:\n\n\nSends an update command with this document \n_id\n as the query selector.\n\n\nExample:\n\n\nweirdCar\n.\nupdate\n(\n{\n$\ninc\n:\n \n{\nwheels\n:\n1\n}\n}\n,\n \n{\n \nw\n:\n \n1\n \n}\n,\n \ncallback\n);\n\n\n\n\n\n\nValid options:\n\n\n\n\nDocument.prototype.$set()\n\n\nParameters\n\n\n\n\n[options] \u00abObject\u00bb optionally specify options that modify the behavior of the set\n\n\n\n\nAlias for \nset()\n, used internally to avoid conflicts\n\n\n\n\nDocument.prototype.set()\n\n\nParameters\n\n\n\n\n[options] \u00abObject\u00bb optionally specify options that modify the behavior of the set\n\n\n\n\nSets the value of a path, or many paths.\n\n\nExample:\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n)\n\n\n\n\ndoc\n.\nset\n(\n{\n\n    \npath\n  \n:\n \nvalue\n\n  \n,\n \npath2\n \n:\n \n{\n\n       \npath\n  \n:\n \nvalue\n\n    \n}\n\n\n}\n)\n\n\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n,\n \nNumber\n)\n\n\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n,\n \nString\n)\n\n\n\n\ndoc\n.\nset\n(\npath\n,\n \nvalue\n,\n \n{\n \nstrict\n:\n \nfalse\n \n}\n);\n\n\n\n\n\n\n\n\nDocument.prototype.get()\n\n\nParameters\n\n\n\n\n[type] \u00abSchema,String,Number,Buffer,*\u00bb optionally specify a type for on-the-fly attributes\n\n\n\n\nReturns the value of a path.\n\n\nExample\n\n\ndoc.get(\nage\n)\n\n\ndoc.get(\nage\n, String)\n\n\n\n\n\n\n\nDocument.prototype.markModified()\n\n\nParameters\n\n\n\n\n[scope] \u00abDocument\u00bb the scope to run validators with\n\n\n\n\nMarks the path as having pending changes to write to the db.\n\n\nVery helpful when using \nMixed\n types.\n\n\nExample:\n\n\ndoc.mixed.type = \nchanged\n;\ndoc.markModified(\nmixed.type\n);\ndoc.save()\n\n\n\n\n\n\n\nDocument.prototype.unmarkModified()\n\n\nParameters\n\n\n\n\npath \u00abString\u00bb the path to unmark modified\n\n\n\n\nClears the modified state on the specified path.\n\n\nExample:\n\n\ndoc.foo = \nbar\n;\ndoc.unmarkModified(\nfoo\n);\ndoc.save()\n\n\n\n\n\n\n\nDocument.prototype.$ignore()\n\n\nParameters\n\n\n\n\npath \u00abString\u00bb the path to ignore\n\n\n\n\nDon't run validation on this path or persist changes to this path.\n\n\nExample:\n\n\ndoc.foo = null;\ndoc.$ignore(\nfoo\n);\ndoc.save()\n\n\n\n\n\n\n\nDocument.prototype.modifiedPaths()\n\n\nReturns:\n\n\nReturns the list of paths that have been modified.\n\n\n\n\nDocument.prototype.isModified()\n\n\nParameters\n\n\n\n\n[path] \u00abString\u00bb optional\n\n\n\n\nReturns:\n\n\nReturns true if this document was modified, else false.\n\n\nIf \npath\n is given, checks if a path or any full path containing \npath\n as part of its path chain has been modified.\n\n\nExample\n\n\ndoc.set(\ndocuments.0.title\n, \nchanged\n);\ndoc.isModified()\ndoc.isModified(\ndocuments\n)\ndoc.isModified(\ndocuments.0.title\n)\ndoc.isModified(\ndocuments otherProp\n)\ndoc.isDirectModified(\ndocuments\n)\n\n\n\n\n\n\n\nDocument.prototype.$isDefault()\n\n\nParameters\n\n\nReturns:\n\n\nChecks if a path is set to its default.\n\n\nExample\n\n\nMyModel\n \n=\n \nmongoose\n.\nmodel\n(\ntest\n,\n \n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \ndefault\n:\n \nVal \n}\n \n}\n);\n\n\nvar\n \nm\n \n=\n \nnew\n \nMyModel\n();\n\n\nm\n.$\nisDefault\n(\nname\n);\n\n\n\n\n\n\n\n\nDocument.prototype.$isDeleted()\n\n\nParameters\n\n\n\n\n[val] \u00abBoolean\u00bb optional, overrides whether mongoose thinks the doc is deleted\n\n\n\n\nReturns:\n\n\n\n\n\u00abBoolean\u00bb whether mongoose thinks this doc is deleted.\n\n\n\n\nGetter/setter, determines whether the document was removed or not.\n\n\nExample:\n\n\nproduct.remove(function (err, product) {\n  product.isDeleted();\n  product.remove();\n\n  product.isDeleted(false);\n  product.isDeleted();\n  product.remove();\n})\n\n\n\n\n\n\n\nDocument.prototype.isDirectModified()\n\n\nParameters\n\n\nReturns:\n\n\nReturns true if \npath\n was directly set and modified, else false.\n\n\nExample\n\n\ndoc.set(\ndocuments.0.title\n, \nchanged\n);\ndoc.isDirectModified(\ndocuments.0.title\n)\ndoc.isDirectModified(\ndocuments\n)\n\n\n\n\n\n\n\nDocument.prototype.isInit()\n\n\nParameters\n\n\nReturns:\n\n\nChecks if \npath\n was initialized.\n\n\n\n\nDocument.prototype.isSelected()\n\n\nParameters\n\n\nReturns:\n\n\nChecks if \npath\n was selected in the source query which initialized this document.\n\n\nExample\n\n\nThing.findOne().select(\nname\n).exec(function (err, doc) {\n   doc.isSelected(\nname\n)\n   doc.isSelected(\nage\n)\n})\n\n\n\n\n\n\n\nDocument.prototype.isDirectSelected()\n\n\nParameters\n\n\nReturns:\n\n\nChecks if \npath\n was explicitly selected. If no projection, always returns true.\n\n\nExample\n\n\nThing.findOne().select(\nnested.name\n).exec(function (err, doc) {\n   doc.isDirectSelected(\nnested.name\n)\n   doc.isDirectSelected(\nnested.otherName\n)\n   doc.isDirectSelected(\nnested\n)\n})\n\n\n\n\n\n\n\nDocument.prototype.validate()\n\n\nParameters\n\n\n\n\ncallback \u00abFunction\u00bb optional callback called after validation completes, passing an error if one occurred\n\n\n\n\nReturns:\n\n\nExecutes registered validation rules for this document.\n\n\nNote:\n\n\nThis method is called \npre\n save and if a validation rule is violated, \nsave\n is aborted and the error is returned to your \ncallback\n.\n\n\nExample:\n\n\ndoc.validate(function (err) {\n  if (err) handleError(err);\n  else\n});\n\n\n\n\n\n\n\nDocument.prototype.validateSync()\n\n\nParameters\n\n\n\n\npathsToValidate \u00abArray,string\u00bb only validate the given paths\n\n\n\n\nReturns:\n\n\n\n\n\u00abMongooseError,undefined\u00bb MongooseError if there are errors during validation, or undefined if there is no error.\n\n\n\n\nExecutes registered validation rules (skipping asynchronous validators) for this document.\n\n\nNote:\n\n\nThis method is useful if you need synchronous validation.\n\n\nExample:\n\n\nvar err = doc.validateSync();\nif ( err ){\n  handleError( err );\n} else {\n\n}\n\n\n\n\n\n\n\nDocument.prototype.invalidate()\n\n\nParameters\n\n\n\n\n[kind] \u00abString\u00bb optional \nkind\n property for the error\n\n\n\n\nReturns:\n\n\n\n\n\u00abValidationError\u00bb the current ValidationError, with all currently invalidated paths\n\n\n\n\nMarks a path as invalid, causing validation to fail.\n\n\nThe \nerrorMsg\n argument will become the message of the \nValidationError\n.\n\n\nThe \nvalue\n argument (if passed) will be available through the \nValidationError.value\n property.\n\n\ndoc.invalidate(\nsize\n, \nmust be less than 20\n, 14);\n\ndoc.validate(function (err) {\n  console.log(err)\n\n  { message: \nValidation failed\n,\n    name: \nValidationError\n,\n    errors:\n     { size:\n        { message: \nmust be less than 20\n,\n          name: \nValidatorError\n,\n          path: \nsize\n,\n          type: \nuser defined\n,\n          value: 14 } } }\n})\n\n\n\n\n\n\n\nDocument.prototype.$markValid()\n\n\nParameters\n\n\n\n\npath \u00abString\u00bb the field to mark as valid\n\n\n\n\nMarks a path as valid, removing existing validation errors.\n\n\n\n\nDocument.prototype.save()\n\n\nParameters\n\n\n\n\n[fn] \u00abFunction\u00bb optional callback\n\n\n\n\nReturns:\n\n\nSaves this document.\n\n\nExample:\n\n\nproduct.sold = Date.now();\nproduct.save(function (err, product, numAffected) {\n  if (err) ..\n})\n\n\n\n\n\nThe callback will receive three parameters\n\n\n\n\nerr\n if an error occurred\n\n\nproduct\n which is the saved \nproduct\n\n\nnumAffected\n will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking \nerr\n is sufficient to make sure your document was properly saved.\n\n\n\n\nAs an extra measure of flow control, save will return a Promise.\n\n\nExample:\n\n\nproduct.save().then(function(product) {\n   ...\n});\n\n\n\n\n\n\n\nDocument.prototype.toObject()\n\n\nParameters\n\n\nReturns:\n\n\nConverts this document into a plain javascript object, ready for storage in MongoDB.\n\n\nBuffers are converted to instances of \nmongodb.Binary\n for proper storage.\n\n\nOptions:\n\n\n\n\ngetters\n apply all getters (path and virtual getters)\n\n\nvirtuals\n apply virtual getters (can override \ngetters\n option)\n\n\nminimize\n remove empty objects (defaults to true)\n\n\ntransform\n a transform function to apply to the resulting document before returning\n\n\ndepopulate\n depopulate any populated paths, replacing them with their original refs (defaults to false)\n\n\nversionKey\n whether to include the version key (defaults to true)\n\n\n\n\nGetters/Virtuals\n\n\nExample of only applying path getters\n\n\ndoc.toObject({ getters: true, virtuals: false })\n\n\n\n\n\nExample of only applying virtual getters\n\n\ndoc.toObject({ virtuals: true })\n\n\n\n\n\nExample of applying both path and virtual getters\n\n\ndoc.toObject({ getters: true })\n\n\n\n\n\nTo apply these options to every document of your schema by default, set your \nschemas\n \ntoObject\n option to the same argument.\n\n\nschema.set(\ntoObject\n, { virtuals: true })\n\n\n\n\n\nTransform\n\n\nWe may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional \ntransform\n function.\n\n\nTransform functions receive three arguments\n\n\nfunction\n \n(\ndoc\n,\n \nret\n,\n \noptions\n)\n \n{}\n\n\n\n\n\n\n\n\ndoc\n The mongoose document which is being converted\n\n\nret\n The plain object representation which has been converted\n\n\noptions\n The options in use (either schema options or the options passed inline)\n\n\n\n\nExample\n\n\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n\n  delete ret._id;\n  return ret;\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();\n\n\n\n\n\nWith transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n\n\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  return { movie: ret.name }\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();\n\n\n\n\n\nNote: if a transform function returns \nundefined\n, the return value will be ignored.\n\n\nTransformations may also be applied inline, overridding any transform set in the options:\n\n\nfunction\n \nxform\n \n(\ndoc\n,\n \nret\n,\n \noptions\n)\n \n{\n\n  \nreturn\n \n{\n \ninline\n: \nret.name\n,\n \ncustom\n: \ntrue\n \n}\n\n\n}\n\n\n\n\ndoc\n.\ntoObject\n({\n \ntransform\n: \nxform\n \n});\n\n\n\n\n\n\nIf you want to skip transformations, use \ntransform: false\n:\n\n\nif\n \n(!\nschema\n.\noptions\n.\ntoObject\n)\n \nschema\n.\noptions\n.\ntoObject\n \n=\n \n{}\n;\n\n\nschema\n.\noptions\n.\ntoObject\n.\nhide\n \n=\n \n_id\n;\n\n\nschema\n.\noptions\n.\ntoObject\n.\ntransform\n \n=\n \nfunction\n \n(\ndoc\n,\n \nret\n,\n \noptions\n)\n \n{\n\n  \nif\n \n(options.hide)\n \n{\n\n    \noptions.hide.split(\n \n).forEach(function\n \n(prop)\n \n{\n\n      \ndelete\n \nret\n[\nprop\n]\n;\n\n    \n}\n);\n\n  \n}\n\n  \nreturn\n \nret\n;\n\n\n}\n\n\n\nvar\n \ndoc\n \n=\n \nnew\n \nDoc\n(\n{\n \n_id\n:\n \nanId\n,\n \nsecret\n:\n \n47\n,\n \nname\n:\n \nWreck-it Ralph\n \n}\n);\n\n\ndoc\n.\ntoObject\n();\n\n\ndoc\n.\ntoObject\n(\n{\n \nhide\n:\n \nsecret _id\n,\n \ntransform\n:\n \nfalse\n \n}\n);\n\n\ndoc\n.\ntoObject\n(\n{\n \nhide\n:\n \nsecret _id\n,\n \ntransform\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\nTransforms are applied \nonly to the document and are not applied to sub-documents\n.\n\n\nTransforms, like all of these options, are also available for \ntoJSON\n.\n\n\nSee \nschema options\n for some more details.\n\n\nDuring save, no custom options are applied to the document before being sent to the database.\n\n\n\n\nDocument.prototype.toJSON()\n\n\nParameters\n\n\nReturns:\n\n\nThe return value of this method is used in calls to JSON.stringify(doc).\n\n\nThis method accepts the same options as \nDocument#toObject\n. To apply the options to every document of your schema by default, set your \nschemas\n \ntoJSON\n option to the same argument.\n\n\nschema.set(\ntoJSON\n, { virtuals: true })\n\n\n\n\n\nSee \nschema options\n for details.\n\n\n\n\nDocument.prototype.inspect()\n\n\n\n\nDocument.prototype.toString()\n\n\n\n\nDocument.prototype.equals()\n\n\nParameters\n\n\n\n\ndoc \u00abDocument\u00bb a document to compare\n\n\n\n\nReturns:\n\n\nReturns true if the Document stores the same data as doc.\n\n\nDocuments are considered equal when they have matching \n_id\ns, unless neither document has an \n_id\n, in which case this function falls back to using \ndeepEqual()\n.\n\n\n\n\nDocument.prototype.populate()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb When passed, population is invoked\n\n\n\n\nReturns:\n\n\nPopulates document references, executing the \ncallback\n when complete. If you want to use promises instead, use this function with \nexecPopulate()\n\n\nExample:\n\n\ndoc\n.populate(\ncompany\n)\n.populate({\n  path: \nnotes\n,\n  match: /airline/,\n  select: \ntext\n,\n  model: \nmodelName\n\n  options: opts\n}, function (err, user) {\n  assert(doc._id === user._id)\n})\n\n\ndoc.populate(path)\ndoc.populate(options);\ndoc.populate(path, callback)\ndoc.populate(options, callback);\ndoc.populate(callback);\ndoc.populate(options).execPopulate()\n\n\n\n\n\nNOTE:\n\n\nPopulation does not occur unless a \ncallback\n is passed \nor\n you explicitly call \nexecPopulate()\n. Passing the same path a second time will overwrite the previous path options. See \nModel.populate()\n for explaination of options.\n\n\n\n\nDocument.prototype.execPopulate()\n\n\nReturns:\n\n\n\n\n\u00abPromise\u00bb promise that resolves to the document when population is done\n\n\n\n\nExplicitly executes population and returns a promise. Useful for ES2015 integration.\n\n\nExample:\n\n\nvar promise = doc.\n  populate(\ncompany\n).\n  populate({\n    path: \nnotes\n,\n    match: /airline/,\n    select: \ntext\n,\n    model: \nmodelName\n\n    options: opts\n  }).\n  execPopulate();\n\n\ndoc.execPopulate().then(resolve, reject);\n\n\n\n\n\n\n\nDocument.prototype.populated()\n\n\nParameters\n\n\nReturns:\n\n\n\n\n\u00abArray,ObjectId,Number,Buffer,String,undefined\u00bb\n\n\n\n\nGets _id(s) used during population of the given \npath\n.\n\n\nExample:\n\n\nModel.findOne().populate(\nauthor\n).exec(function (err, doc) {\n  console.log(doc.author.name)\n  console.log(doc.populated(\nauthor\n))\n})\n\n\n\n\n\nIf the path was not populated, undefined is returned.\n\n\n\n\nDocument.prototype.depopulate()\n\n\nParameters\n\n\nReturns:\n\n\nTakes a populated field and returns it to its unpopulated state.\n\n\nExample:\n\n\nModel.findOne().populate(\nauthor\n).exec(function (err, doc) {\n  console.log(doc.author.name);\n  console.log(doc.depopulate(\nauthor\n));\n  console.log(doc.author);\n})\n\n\n\n\n\nIf the path was not populated, this is a no-op.\n\n\n\n\n\n\nModel()\n\n\nParameters\n\n\n\n\ndoc \u00abObject\u00bb values with which to create the document\n\n\n\n\nModel constructor\n\n\nProvides the interface to MongoDB collections as well as creates document instances.\n\n\n\n\nModel.prototype.db\n\n\nConnection the model uses.\n\n\n\n\nModel.prototype.collection\n\n\nCollection the model uses.\n\n\n\n\nModel.prototype.modelName\n\n\n\n\nModel.prototype.$where\n\n\nAdditional properties to attach to the query when calling \nsave()\n and \nisNew\n is false.\n\n\n\n\nModel.prototype.baseModelName\n\n\nIf this is a discriminator model, \nbaseModelName\n is the name of the base model.\n\n\n\n\nModel.prototype.save()\n\n\nParameters\n\n\n\n\n[fn] \u00abFunction\u00bb optional callback\n\n\n\n\nReturns:\n\n\nSaves this document.\n\n\nExample:\n\n\nproduct.sold = Date.now();\nproduct.save(function (err, product) {\n  if (err) ..\n})\n\n\n\n\n\nThe callback will receive three parameters\n\n\n\n\nerr\n if an error occurred\n\n\nproduct\n which is the saved \nproduct\n\n\n\n\nAs an extra measure of flow control, save will return a Promise.\n\n\nExample:\n\n\nproduct.save().then(function(product) {\n   ...\n});\n\n\n\n\n\n\n\nModel.prototype.increment()\n\n\nSignal that we desire an increment of this documents version.\n\n\nExample:\n\n\nModel.findById(id, function (err, doc) {\n  doc.increment();\n  doc.save(function (err) { .. })\n})\n\n\n\n\n\n\n\nModel.prototype.remove()\n\n\nParameters\n\n\n\n\n[fn] \u00abfunction(err,product)\u00bb optional callback\n\n\n\n\nReturns:\n\n\nRemoves this document from the db.\n\n\nExample:\n\n\nproduct.remove(function (err, product) {\n  if (err) return handleError(err);\n  Product.findById(product._id, function (err, product) {\n    console.log(product)\n  })\n})\n\n\n\n\n\nAs an extra measure of flow control, remove will return a Promise (bound to \nfn\n if passed) so it could be chained, or hooked to recive errors\n\n\nExample:\n\n\nproduct.remove().then(function (product) {\n   ...\n}).catch(function (err) {\n   assert.ok(err)\n})\n\n\n\n\n\n\n\nModel.prototype.model()\n\n\nParameters\n\n\n\n\nname \u00abString\u00bb model name\n\n\n\n\nReturns another Model instance.\n\n\nExample:\n\n\nvar doc = new Tank;\ndoc.model(\nUser\n).findById(id, callback);\n\n\n\n\n\n\n\nModel.discriminator()\n\n\nParameters\n\n\n\n\nschema \u00abSchema\u00bb discriminator model schema\n\n\n\n\nAdds a discriminator type.\n\n\nExample:\n\n\nfunction\n \nBaseSchema() {\n\n  \nSchema\n.\napply\n(\nthis\n,\n \narguments\n);\n\n\n  \nthis\n.\nadd\n({\n\n    \nname\n: \nString\n,\n\n    \ncreatedAt\n: \nDate\n\n  \n});\n\n\n}\n\n\nutil\n.\ninherits\n(\nBaseSchema\n,\n \nSchema\n);\n\n\n\nvar\n \nPersonSchema\n \n=\n \nnew\n \nBaseSchema\n();\n\n\nvar\n \nBossSchema\n \n=\n \nnew\n \nBaseSchema\n({\n \ndepartment\n: \nString\n \n});\n\n\n\nvar\n \nPerson\n \n=\n \nmongoose\n.\nmodel\n(\nPerson\n,\n \nPersonSchema\n);\n\n\nvar\n \nBoss\n \n=\n \nPerson\n.\ndiscriminator\n(\nBoss\n,\n \nBossSchema\n);\n\n\n\n\n\n\n\n\nModel.init()\n\n\nParameters\n\n\nPerforms any async initialization of this model against MongoDB. Currently, this function is only responsible for building \nindexes\n, unless \nautoIndex\n is turned off.\n\n\nThis function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to \nMyModel.on('index')\n\n\nExample:\n\n\nvar eventSchema = new Schema({ thing: { type: \nstring\n, unique: true }})\n\n\nvar Event = mongoose.model(\nEvent\n, eventSchema);\n\nEvent.init().then(function(Event) {\n\n\n  console.log(\nIndexes are done building!\n);\n});\n\n\n\n\n\n\n\nModel.ensureIndexes()\n\n\nParameters\n\n\n\n\n[cb] \u00abFunction\u00bb optional callback\n\n\n\n\nReturns:\n\n\nSends \ncreateIndex\n commands to mongo for each index declared in the schema. The \ncreateIndex\n commands are sent in series.\n\n\nExample:\n\n\nEvent.ensureIndexes(function (err) {\n  if (err) return handleError(err);\n});\n\n\n\n\n\nAfter completion, an \nindex\n event is emitted on this \nModel\n passing an error if one occurred.\n\n\nExample:\n\n\nvar eventSchema = new Schema({ thing: { type: \nstring\n, unique: true }})\nvar Event = mongoose.model(\nEvent\n, eventSchema);\n\nEvent.on(\nindex\n, function (err) {\n  if (err) console.error(err);\n})\n\n\n\n\n\nNOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.\n\n\n\n\nModel.createIndexes()\n\n\nParameters\n\n\n\n\n[cb] \u00abFunction\u00bb optional callback\n\n\n\n\nReturns:\n\n\nSimilar to \nensureIndexes()\n, except for it uses the \ncreateIndex\n function. The \nensureIndex()\n function checks to see if an index with that name already exists, and, if not, does not attempt to create the index. \ncreateIndex()\n bypasses this check.\n\n\n\n\nModel.prototype.schema\n\n\n\n\nModel.prototype.base\n\n\nBase Mongoose instance the model uses.\n\n\n\n\nModel.prototype.discriminators\n\n\nRegistered discriminators for this model.\n\n\n\n\nModel.translateAliases()\n\n\nParameters\n\n\n\n\nraw \u00abObject\u00bb fields/conditions that may contain aliased keys\n\n\n\n\nReturns:\n\n\n\n\n\u00abObject\u00bb the translated 'pure' fields/conditions\n\n\n\n\nTranslate any aliases fields/conditions so the final query or document object is pure\n\n\nExample:\n\n\nCharacter\n  .find(Character.translateAliases({\n    \n\u540d\n: \nEddard Stark\n\n  })\n  .exec(function(err, characters) {})\n\n\n\n\n\nNote:\n\n\nOnly translate arguments of object type anything else is returned raw\n\n\n\n\nModel.remove()\n\n\nParameters\n\n\nReturns:\n\n\nRemoves all documents that match \nconditions\n from the collection. To remove just the first document that matches \nconditions\n, set the \nsingle\n option to true.\n\n\nExample:\n\n\nCharacter\n.\nremove\n(\n{\n \nname\n:\n \nEddard Stark\n \n}\n,\n \nfunction\n \n(\nerr\n)\n \n{}\n);\n\n\n\n\n\n\nNote:\n\n\nThis method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, \nno middleware (hooks) are executed\n.\n\n\n\n\nModel.deleteOne()\n\n\nParameters\n\n\nReturns:\n\n\nDeletes the first document that matches \nconditions\n from the collection. Behaves like \nremove()\n, but deletes at most one document regardless of the \nsingle\n option.\n\n\nExample:\n\n\nCharacter\n.\ndeleteOne\n(\n{\n \nname\n:\n \nEddard Stark\n \n}\n,\n \nfunction\n \n(\nerr\n)\n \n{}\n);\n\n\n\n\n\n\nNote:\n\n\nLike \nModel.remove()\n, this function does \nnot\n trigger \npre('remove')\n or \npost('remove')\n hooks.\n\n\n\n\nModel.deleteMany()\n\n\nParameters\n\n\nReturns:\n\n\nDeletes all of the documents that match \nconditions\n from the collection. Behaves like \nremove()\n, but deletes all documents that match \nconditions\n regardless of the \nsingle\n option.\n\n\nExample:\n\n\nCharacter\n.\ndeleteMany\n(\n{\n \nname\n:\n \n/\nStark\n/\n,\n \nage\n:\n \n{\n \n$\ngte\n:\n \n18\n \n}\n \n}\n,\n \nfunction\n \n(\nerr\n)\n \n{}\n);\n\n\n\n\n\n\nNote:\n\n\nLike \nModel.remove()\n, this function does \nnot\n trigger \npre('remove')\n or \npost('remove')\n hooks.\n\n\n\n\nModel.find()\n\n\nParameters\n\n\nReturns:\n\n\nFinds documents\n\n\nThe \nconditions\n are cast to their respective SchemaTypes before the command is sent.\n\n\nExamples:\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \njohn\n,\n \nage\n:\n \n{\n \n$\ngte\n:\n \n18\n \n}\n}\n);\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \njohn\n,\n \nage\n:\n \n{\n \n$\ngte\n:\n \n18\n \n}\n}\n,\n \nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nname friends\n,\n \nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{\n \n}\n)\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n)\n\n\n\n\nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\nvar\n \nquery\n \n=\n \nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n)\n\n\nquery\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\nvar\n \nquery\n \n=\n \nMyModel\n.\nfind\n(\n{\n \nname\n:\n \n/\njohn\n/\ni\n \n}\n,\n \nnull\n,\n \n{\n \nskip\n:\n \n10\n \n}\n);\n\n\nvar\n \npromise\n \n=\n \nquery\n.\nexec\n();\n\n\npromise\n.\naddBack\n(\nfunction\n \n(\nerr\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\n\n\n\n\nModel.findById()\n\n\nParameters\n\n\nReturns:\n\n\nFinds a single document by its _id field. \nfindById(id)\n is almost* equivalent to \nfindOne({ _id: id })\n. If you want to query by a document's \n_id\n, use \nfindById()\n instead of \nfindOne()\n.\n\n\nThe \nid\n is cast based on the Schema before sending the command.\n\n\nThis function triggers the following middleware.\n\n\n\n\nExcept for how it treats \nundefined\n. If you use \nfindOne()\n, you'll see that \nfindOne(undefined)\n and \nfindOne({ _id: undefined })\n are equivalent to \nfindOne({})\n and return arbitrary documents. However, mongoose translates \nfindById(undefined)\n into \nfindOne({ _id: null })\n.\n\n\n\n\nExample:\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname length\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname length\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \n-length\n)\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname\n,\n \n{\n \nlean\n:\n \ntrue\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \ndoc\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindById\n(\nid\n,\n \nname\n)\n.\nlean\n()\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \ndoc\n)\n \n{}\n);\n\n\n\n\n\n\n\n\nModel.findOne()\n\n\nParameters\n\n\nReturns:\n\n\nFinds one document.\n\n\nThe \nconditions\n are cast to their respective SchemaTypes before the command is sent.\n\n\nNote:\n \nconditions\n is optional, and if \nconditions\n is null or undefined, mongoose will send an empty \nfindOne\n command to MongoDB, which will return an arbitrary document. If you're querying by \n_id\n, use \nfindById()\n instead.\n\n\nExample:\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n)\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n,\n \nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n)\n.\nexec\n(\nfunction\n \n(\nerr\n,\n \nadventure\n)\n \n{}\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n,\n \n{\n \nlean\n:\n \ntrue\n \n}\n,\n \ncallback\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n,\n \nname\n,\n \n{\n \nlean\n:\n \ntrue\n \n}\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\nAdventure\n.\nfindOne\n(\n{\n \ntype\n:\n \niphone\n \n}\n)\n.\nselect\n(\nname\n)\n.\nlean\n()\n.\nexec\n(\ncallback\n);\n\n\n\n\n\n\n\n\nModel.count()\n\n\nParameters\n\n\nReturns:\n\n\nCounts number of matching documents in a database collection.\n\n\nExample:\n\n\nAdventure.count({ type: \njungle\n }, function (err, count) {\n  if (err) ..\n  console.log(\nthere are %d jungle adventures\n, count);\n});\n\n\n\n\n\n\n\nModel.distinct()\n\n\nParameters\n\n\nReturns:\n\n\nCreates a Query for a \ndistinct\n operation.\n\n\nPassing a \ncallback\n immediately executes the query.\n\n\nExample\n\n\nLink.distinct(\nurl\n, \n{\n \nclicks\n:\n \n{\n$gt\n:\n \n100\n}}\n, function (err, result) \n{\n\n  \nif\n \n(\nerr\n)\n \nreturn\n \nhandleError\n(\nerr\n);\n\n\n  \nassert\n(\nArray\n.\nisArray\n(\nresult\n));\n\n  \nconsole\n.\nlog\n(\nunique urls with more than 100 clicks\n,\n \nresult\n);\n\n\n}\n)\n\n\n\nvar query = Link.distinct(\nurl\n);\n\n\nquery.exec(callback);\n\n\n\n\n\n\n\n\nModel.where()\n\n\nParameters\n\n\n\n\n[val] \u00abObject\u00bb optional value\n\n\n\n\nReturns:\n\n\nCreates a Query, applies the passed conditions, and returns the Query.\n\n\nFor example, instead of writing:\n\n\nUser\n.\nfind\n(\n{\nage\n:\n \n{$\ngte\n:\n \n21\n,\n \n$\nlte\n:\n \n65\n}\n}\n,\n \ncallback\n);\n\n\n\n\n\n\nwe can instead write:\n\n\nUser.where(\nage\n).gte(21).lte(65).exec(callback);\n\n\n\n\n\nSince the Query class also supports \nwhere\n you can continue chaining\n\n\nUser\n.where(\nage\n).gte(21).lte(65)\n.where(\nname\n, /^b/i)\n... etc\n\n\n\n\n\n\n\nModel.prototype.$where()\n\n\nParameters\n\n\n\n\nargument \u00abString,Function\u00bb is a javascript string or anonymous function\n\n\n\n\nReturns:\n\n\nCreates a \nQuery\n and specifies a \n$where\n condition.\n\n\nSometimes you need to query for things in mongodb using a JavaScript expression. You can do so via \nfind({ $where: javascript })\n, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n\n\nBlog.$where(\nthis.username.indexOf(\nval\n) !== -1\n).exec(function (err, docs) {});\n\n\n\n\n\n\n\nModel.findOneAndUpdate()\n\n\nParameters\n\n\nReturns:\n\n\nIssues a mongodb findAndModify update command.\n\n\nFinds a matching document, updates it according to the \nupdate\n arg, passing any \noptions\n, and returns the found document (if any) to the callback. The query executes immediately if \ncallback\n is passed else a Query object is returned.\n\n\nOptions:\n\n\n\n\nnew\n: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n\n\nupsert\n: bool - creates the object if it doesn't exist. defaults to false.\n\n\nfields\n: {Object|String} - Field selection. Equivalent to \n.select(fields).findOneAndUpdate()\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nrunValidators\n: if true, runs \nupdate validators\n on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the \ndefaults\n specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on \nMongoDB's \n$setOnInsert\n operator\n.\n\n\nrawResult\n: if true, returns the \nraw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's \nstrict mode option\n for this update\n\n\n\n\nExamples:\n\n\nA.findOneAndUpdate(conditions, update, options, callback)\nA.findOneAndUpdate(conditions, update, options)\nA.findOneAndUpdate(conditions, update, callback)\nA.findOneAndUpdate(conditions, update)\nA.findOneAndUpdate()\n\n\n\n\n\nNote:\n\n\nAll top level update keys which are not \natomic\n operation names are treated as set operations:\n\n\nExample:\n\n\nvar\n \nquery\n \n=\n \n{\n \nname\n:\n \nborne\n \n}\n;\n\n\nModel\n.\nfindOneAndUpdate\n(\nquery\n,\n \n{\n \nname\n:\n \njason bourne\n \n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\nModel\n.\nfindOneAndUpdate\n(\nquery\n,\n \n{\n \n$\nset\n:\n \n{\n \nname\n:\n \njason bourne\n \n}\n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\n\n\nThis helps prevent accidentally overwriting your document with \n{ name: 'jason bourne' }\n.\n\n\nNote:\n\n\nValues are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.\n\n\n\n\ndefaults. Use the \nsetDefaultsOnInsert\n option to override.\n\n\n\n\nfindAndModify\n helpers support limited validation. You can enable these by setting the \nrunValidators\n options, respectively.\n\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n\nModel.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n});\n\n\n\n\n\n\n\nModel.findByIdAndUpdate()\n\n\nParameters\n\n\nReturns:\n\n\nIssues a mongodb findAndModify update command by a document's _id field. \nfindByIdAndUpdate(id, ...)\n is equivalent to \nfindOneAndUpdate({ _id: id }, ...)\n.\n\n\nFinds a matching document, updates it according to the \nupdate\n arg, passing any \noptions\n, and returns the found document (if any) to the callback. The query executes immediately if \ncallback\n is passed else a Query object is returned.\n\n\nThis function triggers the following middleware.\n\n\nOptions:\n\n\n\n\nnew\n: bool - true to return the modified document rather than the original. defaults to false\n\n\nupsert\n: bool - creates the object if it doesn't exist. defaults to false.\n\n\nrunValidators\n: if true, runs \nupdate validators\n on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the \ndefaults\n specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on \nMongoDB's \n$setOnInsert\n operator\n.\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nselect\n: sets the document fields to return\n\n\nrawResult\n: if true, returns the \nraw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's \nstrict mode option\n for this update\n\n\n\n\nExamples:\n\n\nA.findByIdAndUpdate(id, update, options, callback)\nA.findByIdAndUpdate(id, update, options)\nA.findByIdAndUpdate(id, update, callback)\nA.findByIdAndUpdate(id, update)\nA.findByIdAndUpdate()\n\n\n\n\n\nNote:\n\n\nAll top level update keys which are not \natomic\n operation names are treated as set operations:\n\n\nExample:\n\n\nModel.findByIdAndUpdate(id, { name: \njason bourne\n }, options, callback)\n\n\nModel.findByIdAndUpdate(id, { $set: { name: \njason bourne\n }}, options, callback)\n\n\n\n\n\nThis helps prevent accidentally overwriting your document with \n{ name: 'jason bourne' }\n.\n\n\nNote:\n\n\nValues are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.\n\n\n\n\ndefaults. Use the \nsetDefaultsOnInsert\n option to override.\n\n\n\n\nfindAndModify\n helpers support limited validation. You can enable these by setting the \nrunValidators\n options, respectively.\n\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n\nModel.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n});\n\n\n\n\n\n\n\nModel.findOneAndRemove()\n\n\nParameters\n\n\nReturns:\n\n\nIssue a mongodb findAndModify remove command.\n\n\nFinds a matching document, removes it, passing the found document (if any) to the callback.\n\n\nExecutes immediately if \ncallback\n is passed else a Query object is returned.\n\n\nThis function triggers the following middleware.\n\n\nOptions:\n\n\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nselect\n: sets the document fields to return\n\n\nrawResult\n: if true, returns the \nraw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's \nstrict mode option\n for this update\n\n\n\n\nExamples:\n\n\nA.findOneAndRemove(conditions, options, callback)\nA.findOneAndRemove(conditions, options)\nA.findOneAndRemove(conditions, callback)\nA.findOneAndRemove(conditions)\nA.findOneAndRemove()\n\n\n\n\n\nValues are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.\n\n\n\n\ndefaults. Use the \nsetDefaultsOnInsert\n option to override.\n\n\n\n\nfindAndModify\n helpers support limited validation. You can enable these by setting the \nrunValidators\n options, respectively.\n\n\nIf you need full-fledged validation, use the traditional approach of first retrieving the document.\n\n\nModel.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n});\n\n\n\n\n\n\n\nModel.findByIdAndRemove()\n\n\nParameters\n\n\nReturns:\n\n\nIssue a mongodb findAndModify remove command by a document's _id field. \nfindByIdAndRemove(id, ...)\n is equivalent to \nfindOneAndRemove({ _id: id }, ...)\n.\n\n\nFinds a matching document, removes it, passing the found document (if any) to the callback.\n\n\nExecutes immediately if \ncallback\n is passed, else a \nQuery\n object is returned.\n\n\nThis function triggers the following middleware.\n\n\nOptions:\n\n\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nselect\n: sets the document fields to return\n\n\nrawResult\n: if true, returns the \nraw result from the MongoDB driver\n\n\nstrict\n: overwrites the schema's \nstrict mode option\n for this update\n\n\n\n\nExamples:\n\n\nA.findByIdAndRemove(id, options, callback)\nA.findByIdAndRemove(id, options)\nA.findByIdAndRemove(id, callback)\nA.findByIdAndRemove(id)\nA.findByIdAndRemove()\n\n\n\n\n\n\n\nModel.create()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb callback\n\n\n\n\nReturns:\n\n\nShortcut for saving one or more documents to the database. \nMyModel.create(docs)\n does \nnew MyModel(doc).save()\n for every doc in docs.\n\n\nThis function triggers the following middleware.\n\n\nExample:\n\n\nCandy\n.\ncreate\n(\n{\n \ntype\n:\n \njelly bean\n \n}\n,\n \n{\n \ntype\n:\n \nsnickers\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \njellybean\n,\n \nsnickers\n)\n \n{\n\n  \nif\n \n(err)\n\n\n}\n);\n\n\n\n\nvar\n \narray\n \n=\n \n[\n{\n \ntype\n:\n \njelly bean\n \n},\n \n{\n \ntype\n:\n \nsnickers\n \n}\n]\n;\n\n\nCandy\n.\ncreate\n(\narray\n,\n \nfunction\n \n(\nerr\n,\n \ncandies\n)\n \n{\n\n  \nif\n \n(err)\n\n\n  \nvar\n \njellybean\n \n=\n \ncandies\n[\n0\n]\n;\n\n  \nvar\n \nsnickers\n \n=\n \ncandies\n[\n1\n]\n;\n\n\n\n}\n);\n\n\n\n\nvar\n \npromise\n \n=\n \nCandy\n.\ncreate\n(\n{\n \ntype\n:\n \njawbreaker\n \n}\n);\n\n\npromise\n.\nthen\n(\nfunction\n \n(\njawbreaker\n)\n \n{\n\n\n\n}\n)\n\n\n\n\n\n\n\n\nModel.watch()\n\n\nParameters\n\n\nReturns:\n\n\n\n\n\u00abChangeStream\u00bb mongoose-specific change stream wrapper\n\n\n\n\nRequires a replica set running MongoDB \n= 3.6.0.\n Watches the underlying collection for changes using \nMongoDB change streams\n.\n\n\nThis function does \nnot\n trigger any middleware. In particular, it does \nnot\n trigger aggregate middleware.\n\n\nExample:\n\n\nconst\n \ndoc\n \n=\n \nawait\n \nPerson\n.\ncreate\n(\n{\n \nname\n:\n \nNed Stark\n \n}\n);\n\n\nPerson\n.\nwatch\n()\n.\non\n(\nchange\n,\n \nchange\n \n=\n \nconsole\n.\nlog\n(\nchange\n));\n\n\n\n\n\n\n\nawait\n \ndoc\n.\nremove\n();\n\n\n\n\n\n\n\n\nModel.insertMany()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb callback\n\n\n\n\nReturns:\n\n\nShortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than \n.create()\n because it only sends one operation to the server, rather than one for each document.\n\n\nMongoose always validates each document \nbefore\n sending \ninsertMany\n to MongoDB. So if one document has a validation error, no documents will be saved, unless you set \nthe \nordered\n option to false\n.\n\n\nThis function does \nnot\n trigger save middleware.\n\n\nThis function triggers the following middleware.\n\n\nExample:\n\n\nvar\n \narr\n \n=\n \n[\n{\n \nname\n:\n \nStar Wars\n \n},\n \n{\n \nname\n:\n \nThe Empire Strikes Back\n \n}\n]\n;\n\n\nMovies\n.\ninsertMany\n(\narr\n,\n \nfunction\n(\nerror\n,\n \ndocs\n)\n \n{}\n);\n\n\n\n\n\n\n\n\nModel.bulkWrite()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb callback \nfunction(error, bulkWriteOpResult) {}\n\n\n\n\nReturns:\n\n\n\n\n\u00abPromise\u00bb resolves to a \nBulkWriteOpResult\n if the operation succeeds\n\n\n\n\nSends multiple \ninsertOne\n, \nupdateOne\n, \nupdateMany\n, \nreplaceOne\n, \ndeleteOne\n, and/or \ndeleteMany\n operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use \ncreate()\n) because with \nbulkWrite()\n there is only one round trip to MongoDB.\n\n\nMongoose will perform casting on all operations you provide.\n\n\nThis function does \nnot\n trigger any middleware, not \nsave()\n nor \nupdate()\n. If you need to trigger \nsave()\n middleware for every document use \ncreate()\n instead.\n\n\nExample:\n\n\nCharacter.bulkWrite([\n  {\n    insertOne: {\n      document: {\n        name: \nEddard Stark\n,\n        title: \nWarden of the North\n\n      }\n    }\n  },\n  {\n    updateOne: {\n      filter: { name: \nEddard Stark\n },\n\n\n\n      update: { title: \nHand of the King\n }\n    }\n  },\n  {\n    deleteOne: {\n      {\n        filter: { name: \nEddard Stark\n }\n      }\n    }\n  }\n]).then(handleResult);\n\n\n\n\n\n\n\nModel.hydrate()\n\n\nParameters\n\n\nReturns:\n\n\n\n\n\u00abModel\u00bb document instance\n\n\n\n\nShortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.\n\n\nExample:\n\n\nvar\n \nmongooseCandy\n \n=\n \nCandy\n.\nhydrate\n(\n{\n \n_id\n:\n \n54108337212ffb6d459f854c\n,\n \ntype\n:\n \njelly bean\n \n}\n);\n\n\n\n\n\n\n\n\nModel.update()\n\n\nParameters\n\n\nReturns:\n\n\nUpdates one document in the database without returning it.\n\n\nThis function triggers the following middleware.\n\n\nExamples:\n\n\nMyModel\n.\nupdate\n(\n{\n \nage\n:\n \n{\n \n$\ngt\n:\n \n18\n \n}\n \n}\n,\n \n{\n \noldEnough\n:\n \ntrue\n \n}\n,\n \nfn\n);\n\n\nMyModel\n.\nupdate\n(\n{\n \nname\n:\n \nTobi\n \n}\n,\n \n{\n \nferret\n:\n \ntrue\n \n}\n,\n \n{\n \nmulti\n:\n \ntrue\n \n}\n,\n \nfunction\n \n(\nerr\n,\n \nraw\n)\n \n{\n\n  \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n  \nconsole.log(\nThe\n \nraw\n \nresponse\n \nfrom\n \nMongo\n \nwas\n \n,\n \nraw)\n;\n\n\n}\n);\n\n\n\n\n\n\nValid options:\n\n\n\n\nsafe\n (boolean) safe mode (defaults to value set in schema (true))\n\n\nupsert\n (boolean) whether to create the doc if it doesn't match (false)\n\n\nmulti\n (boolean) whether multiple documents should be updated (false)\n\n\nrunValidators\n: if true, runs \nupdate validators\n on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the \ndefaults\n specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on \nMongoDB's \n$setOnInsert\n operator\n.\n\n\nstrict\n (boolean) overrides the \nstrict\n option for this update\n\n\noverwrite\n (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n\n\n\n\nAll \nupdate\n values are cast to their appropriate SchemaTypes before being sent.\n\n\nThe \ncallback\n function receives \n(err, rawResponse)\n.\n\n\n\n\nerr\n is the error if any occurred\n\n\nrawResponse\n is the full response from Mongo\n\n\n\n\nNote:\n\n\nAll top level keys which are not \natomic\n operation names are treated as set operations:\n\n\nExample:\n\n\nvar\n \nquery\n \n=\n \n{\n \nname\n:\n \nborne\n \n}\n;\n\n\nModel\n.\nupdate\n(\nquery\n,\n \n{\n \nname\n:\n \njason bourne\n \n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\nModel\n.\nupdate\n(\nquery\n,\n \n{\n \n$\nset\n:\n \n{\n \nname\n:\n \njason bourne\n \n}\n}\n,\n \noptions\n,\n \ncallback\n)\n\n\n\n\n\n\nThis helps prevent accidentally overwriting all documents in your collection with \n{ name: 'jason bourne' }\n.\n\n\nNote:\n\n\nBe careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error.\n\n\nNote:\n\n\nTo update documents without waiting for a response from MongoDB, do not pass a \ncallback\n, then call \nexec\n on the returned \nQuery\n:\n\n\nComment\n.\nupdate\n(\n{\n \n_id\n:\n \nid\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \ntext\n:\n \nchanged\n \n}\n}\n)\n.\nexec\n();\n\n\n\n\n\n\nNote:\n\n\nAlthough values are casted to their appropriate types when using update, the following are \nnot\n applied:\n\n\n\n\ndefaults\n\n\nsetters\n\n\nvalidators\n\n\nmiddleware\n\n\n\n\nIf you need those features, use the traditional approach of first retrieving the document.\n\n\nModel.findOne({ name: \nborne\n }, function (err, doc) {\n  if (err) ..\n  doc.name = \njason bourne\n;\n  doc.save(callback);\n})\n\n\n\n\n\n\n\nModel.updateMany()\n\n\nParameters\n\n\nReturns:\n\n\nSame as \nupdate()\n, except MongoDB will update \nall\n documents that match \ncriteria\n (as opposed to just the first one) regardless of the value of the \nmulti\n option.\n\n\nNote\n updateMany will \nnot\n fire update middleware. Use \npre('updateMany')\n and \npost('updateMany')\n instead.\n\n\nThis function triggers the following middleware.\n\n\n\n\nModel.updateOne()\n\n\nParameters\n\n\nReturns:\n\n\nSame as \nupdate()\n, except MongoDB will update \nonly\n the first document that matches \ncriteria\n regardless of the value of the \nmulti\n option.\n\n\nThis function triggers the following middleware.\n\n\n\n\nModel.replaceOne()\n\n\nParameters\n\n\nReturns:\n\n\nSame as \nupdate()\n, except MongoDB replace the existing document with the given document (no atomic operators like \n$set\n).\n\n\nThis function triggers the following middleware.\n\n\n\n\nModel.mapReduce()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional callback\n\n\n\n\nReturns:\n\n\nExecutes a mapReduce command.\n\n\no\n is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See \nnode-mongodb-native mapReduce() documentation\n for more detail about options.\n\n\nThis function does not trigger any middleware.\n\n\nExample:\n\n\nvar o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\nUser.mapReduce(o, function (err, results) {\n  console.log(results)\n})\n\n\n\n\n\nOther options:\n\n\n\n\nquery\n {Object} query filter object.\n\n\nsort\n {Object} sort input objects using this key\n\n\nlimit\n {Number} max number of documents\n\n\nkeeptemp\n {Boolean, default:false} keep temporary data\n\n\nfinalize\n {Function} finalize function\n\n\nscope\n {Object} scope variables exposed to map/reduce/finalize during execution\n\n\njsMode\n {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB \n 2.0.X\n\n\nverbose\n {Boolean, default:false} provide statistics on job execution time.\n\n\nreadPreference\n {String}\n\n\nout*\n {Object, default: {inline:1}} sets the output target for the map reduce job.\n\n\n\n\n* out options:\n\n\n\n\n{inline:1}\n the results are returned in an array\n\n\n{replace: 'collectionName'}\n add the results to collectionName: the results replace the collection\n\n\n{reduce: 'collectionName'}\n add the results to collectionName: if dups are detected, uses the reducer / finalize functions\n\n\n{merge: 'collectionName'}\n add the results to collectionName: if dups exist the new docs overwrite the old\n\n\n\n\nIf \noptions.out\n is set to \nreplace\n, \nmerge\n, or \nreduce\n, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the \nlean\n option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).\n\n\nExample:\n\n\nvar o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\no.out = { replace: \ncreatedCollectionNameForResults\n }\no.verbose = true;\n\nUser.mapReduce(o, function (err, model, stats) {\n  console.log(\nmap reduce took %d ms\n, stats.processtime)\n  model.find().where(\nvalue\n).gt(10).exec(function (err, docs) {\n    console.log(docs);\n  });\n})\n\n\n\no.resolveToObject = true;\nvar promise = User.mapReduce(o);\npromise.then(function (res) {\n  var model = res.model;\n  var stats = res.stats;\n  console.log(\nmap reduce took %d ms\n, stats.processtime)\n  return model.find().where(\nvalue\n).gt(10).exec();\n}).then(function (docs) {\n   console.log(docs);\n}).then(null, handleError).end()\n\n\n\n\n\n\n\nModel.aggregate()\n\n\nParameters\n\n\nReturns:\n\n\nPerforms \naggregations\n on the models collection.\n\n\nIf a \ncallback\n is passed, the \naggregate\n is executed and a \nPromise\n is returned. If a callback is not passed, the \naggregate\n itself is returned.\n\n\nThis function does not trigger any middleware.\n\n\nExample:\n\n\nUsers.aggregate(\n  { $group: { _id: null, maxBalance: { $max: \n$balance\n }}},\n  { $project: { _id: 0, maxBalance: 1 }},\n  function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n  });\n\n\nUsers.aggregate()\n  .group({ _id: null, maxBalance: { $max: \n$balance\n } })\n  .select(\n-id maxBalance\n)\n  .exec(function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n});\n\n\n\n\n\nNOTE:\n\n\n\n\nArguments are not cast to the model's schema because \n$project\n operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.\n\n\nThe documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n\n\nRequires MongoDB \n= 2.1\n\n\n\n\n\n\nModel.geoSearch()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional callback\n\n\n\n\nReturns:\n\n\nImplements \n$geoSearch\n functionality for Mongoose\n\n\nThis function does not trigger any middleware\n\n\nExample:\n\n\nvar\n \noptions\n \n=\n \n{\n \nnear\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n;\n\n\nLocations\n.\ngeoSearch\n(\n{\n \ntype\n \n:\n \nhouse\n \n}\n,\n \noptions\n,\n \nfunction\n(\nerr\n,\n \nres\n)\n \n{\n\n  \nconsole.log(res)\n;\n\n\n}\n);\n\n\n\n\n\n\nOptions:\n\n\n\n\nnear\n {Array} x,y point to search for\n\n\nmaxDistance\n {Number} the maximum distance from the point near that a result can be\n\n\nlimit\n {Number} The maximum number of results to return\n\n\nlean\n {Boolean} return the raw object instead of the Mongoose Model\n\n\n\n\n\n\nModel.populate()\n\n\nParameters\n\n\n\n\n[callback(err,doc)] \u00abFunction\u00bb Optional callback, executed upon completion. Receives \nerr\n and the \ndoc(s)\n.\n\n\n\n\nReturns:\n\n\nPopulates document references.\n\n\nAvailable options:\n\n\n\n\npath: space delimited path(s) to populate\n\n\nselect: optional fields to select\n\n\nmatch: optional query conditions to match\n\n\nmodel: optional name of the model to use for population\n\n\noptions: optional query options like sort, limit, etc\n\n\n\n\nExamples:\n\n\nUser.findById(id, function (err, user) {\n  var opts = [\n      { path: \ncompany\n, match: { x: 1 }, select: \nname\n }\n    , { path: \nnotes\n, options: { limit: 10 }, model: \noverride\n }\n  ]\n\n  User.populate(user, opts, function (err, user) {\n    console.log(user);\n  });\n});\n\n\nUser.find(match, function (err, users) {\n  var opts = [{ path: \ncompany\n, match: { x: 1 }, select: \nname\n }]\n\n  var promise = User.populate(users, opts);\n  promise.then(console.log).end();\n})\n\n\n\n\n\n\n\n\n\n\nvar user = { name: \nIndiana Jones\n, weapon: 389 }\nWeapon.populate(user, { path: \nweapon\n, model: \nWeapon\n }, function (err, user) {\n  console.log(user.weapon.name)\n})\n\n\nvar users = [{ name: \nIndiana Jones\n, weapon: 389 }]\nusers.push({ name: \nBatman\n, weapon: 8921 })\nWeapon.populate(users, { path: \nweapon\n }, function (err, users) {\n  users.forEach(function (user) {\n    console.log(\n%s uses a %s\n, users.name, user.weapon.name)\n\n\n  });\n});\n\n\n\n\n\n\n\n\n\nQuery()\n\n\nParameters\n\n\n\n\n[collection] \u00abObject\u00bb Mongoose collection\n\n\n\n\nQuery constructor used for building queries. You do not need to instantiate a \nQuery\n directly. Instead use Model functions like \nModel.find()\n.\n\n\nExample:\n\n\nconst query = MyModel.find();\nquery.setOptions({ lean : true });\nquery.collection(model.collection);\nquery.where(\nage\n).gte(21).exec(callback);\n\n\n\nconst query = new mongoose.Query();\n\n\n\n\n\n\n\nQuery.prototype.use$geoWithin\n\n\nFlag to opt out of using \n$geoWithin\n.\n\n\nmongoose.Query.use$geoWithin = false;\n\n\n\n\n\nMongoDB 2.4 deprecated the use of \n$within\n, replacing it with \n$geoWithin\n. Mongoose uses \n$geoWithin\n by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to \nfalse\n so your \nwithin()\n queries continue to work.\n\n\n\n\nQuery.prototype.toConstructor()\n\n\nReturns:\n\n\n\n\n\u00abQuery\u00bb subclass-of-Query\n\n\n\n\nConverts this query to a customized, reusable query constructor with all arguments and options retained.\n\n\nExample\n\n\nvar\n \nquery\n \n=\n \nMovie\n.\nfind\n(\n{\n \ntags\n:\n \nadventure\n \n}\n)\n.\nread\n(\nprimaryPreferred\n);\n\n\n\n\nvar\n \nAdventure\n \n=\n \nquery\n.\ntoConstructor\n();\n\n\n\n\n\nAdventure\n()\n.\nexec\n(\ncallback\n)\n\n\n\n\nAdventure\n()\n.\nwhere\n(\n{\n \nname\n:\n \n/^\nLife\n/\n \n}\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\n\nAdventure\n.\nprototype\n.\nstartsWith\n \n=\n \nfunction\n \n(\nprefix\n)\n \n{\n\n  \nthis.where({\n \nname\n:\n \nnew\n \nRegExp\n(\n^\n \n+\n \nprefix\n)\n \n}\n)\n\n  \nreturn\n \nthis\n;\n\n\n}\n\n\nObject\n.\ndefineProperty\n(\nAdventure\n.\nprototype\n,\n \nhighlyRated\n,\n \n{\n\n  \nget\n:\n \nfunction\n \n()\n \n{\n\n    \nthis\n.\nwhere\n(\n{\n \nrating\n:\n \n{\n \n$\ngt\n:\n \n4.5\n \n}}\n);\n\n    \nreturn\n \nthis\n;\n\n  \n}\n\n\n}\n)\n\n\nAdventure\n()\n.\nhighlyRated\n.\nstartsWith\n(\nLife\n)\n.\nexec\n(\ncallback\n)\n\n\n\n\n\n\nNew in 3.7.3\n\n\n\n\nQuery.prototype.$where()\n\n\nParameters\n\n\n\n\njs \u00abString,Function\u00bb javascript string or function\n\n\n\n\nReturns:\n\n\nSpecifies a javascript function or expression to pass to MongoDBs query system.\n\n\nExample\n\n\nquery.$where(\nthis.comments.length === 10 || this.name.length === 5\n)\n\n\n\nquery.$where(function () {\n  return this.comments.length === 10 || this.name.length === 5;\n})\n\n\n\n\n\nNOTE:\n\n\nOnly use \n$where\n when you have a condition that cannot be met using other MongoDB operators like \n$lt\n. \nBe sure to read about all of \nits caveats\n before using.\n\n\n\n\nQuery.prototype.where()\n\n\nParameters\n\n\nReturns:\n\n\nSpecifies a \npath\n for use with chaining.\n\n\nExample\n\n\nUser\n.\nfind\n(\n{\nage\n:\n \n{$\ngte\n:\n \n21\n,\n \n$\nlte\n:\n \n65\n}\n}\n,\n \ncallback\n);\n\n\n\n\nUser\n.\nwhere\n(\nage\n)\n.\ngte\n(\n21\n)\n.\nlte\n(\n65\n);\n\n\n\n\nUser\n.\nfind\n()\n.\nwhere\n(\n{\n \nname\n:\n \nvonderful\n \n}\n)\n\n\n\n\nUser\n\n\n.\nwhere\n(\nage\n)\n.\ngte\n(\n21\n)\n.\nlte\n(\n65\n)\n\n\n.\nwhere\n(\nname\n,\n \n/^\nvonderful\n/\ni\n)\n\n\n.\nwhere\n(\nfriends\n)\n.\nslice\n(\n10\n)\n\n\n.\nexec\n(\ncallback\n)\n\n\n\n\n\n\n\n\nQuery.prototype.equals()\n\n\nParameters\n\n\nReturns:\n\n\nSpecifies the complementary comparison value for paths specified with \nwhere()\n\n\nExample\n\n\nUser.where(\nage\n).equals(49);\n\n\n\nUser.where(\nage\n, 49);\n\n\n\n\n\n\n\nQuery.prototype.or()\n\n\nParameters\n\n\n\n\narray \u00abArray\u00bb array of conditions\n\n\n\n\nReturns:\n\n\nSpecifies arguments for an \n$or\n condition.\n\n\nExample\n\n\nquery.or([{ color: \nred\n }, { status: \nemergency\n }])\n\n\n\n\n\n\n\nQuery.prototype.nor()\n\n\nParameters\n\n\n\n\narray \u00abArray\u00bb array of conditions\n\n\n\n\nReturns:\n\n\nSpecifies arguments for a \n$nor\n condition.\n\n\nExample\n\n\nquery.nor([{ color: \ngreen\n }, { status: \nok\n }])\n\n\n\n\n\n\n\nQuery.prototype.and()\n\n\nParameters\n\n\n\n\narray \u00abArray\u00bb array of conditions\n\n\n\n\nReturns:\n\n\nSpecifies arguments for a \n$and\n condition.\n\n\nExample\n\n\nquery.and([{ color: \ngreen\n }, { status: \nok\n }])\n\n\n\n\n\n\n\nQuery.prototype.gt()\n\n\nParameters\n\n\nSpecifies a $gt query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nExample\n\n\nThing.find().where(\nage\n).gt(21)\n\n\nThing.find().gt(\nage\n, 21)\n\n\n\n\n\n\n\nQuery.prototype.gte()\n\n\nParameters\n\n\nSpecifies a $gte query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.lt()\n\n\nParameters\n\n\nSpecifies a $lt query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.lte()\n\n\nParameters\n\n\nSpecifies a $lte query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.ne()\n\n\nParameters\n\n\nSpecifies a $ne query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.in()\n\n\nParameters\n\n\nSpecifies an $in query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.nin()\n\n\nParameters\n\n\nSpecifies an $nin query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.all()\n\n\nParameters\n\n\nSpecifies an $all query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.size()\n\n\nParameters\n\n\nSpecifies a $size query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\nExample\n\n\nMyModel.where(\ntags\n).size(0).exec(function (err, docs) {\n  if (err) return handleError(err);\n\n  assert(Array.isArray(docs));\n  console.log(\ndocuments with 0 tags\n, docs);\n})\n\n\n\n\n\n\n\nQuery.prototype.regex()\n\n\nParameters\n\n\nSpecifies a $regex query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.maxDistance()\n\n\nParameters\n\n\nSpecifies a $maxDistance query condition.\n\n\nWhen called with one argument, the most recent path passed to \nwhere()\n is used.\n\n\n\n\nQuery.prototype.mod()\n\n\nParameters\n\n\n\n\nval \u00abArray\u00bb must be of length 2, first element is \ndivisor\n, 2nd element is \nremainder\n.\n\n\n\n\nReturns:\n\n\nSpecifies a \n$mod\n condition, filters documents for documents whose \npath\n property is a number that is equal to \nremainder\n modulo \ndivisor\n.\n\n\nExample\n\n\nProduct.find().mod(\ninventory\n, [2, 1]);\nProduct.find().where(\ninventory\n).mod([2, 1]);\n\nProduct.find().where(\ninventory\n).mod(2, 1);\n\n\n\n\n\n\n\nQuery.prototype.exists()\n\n\nParameters\n\n\nReturns:\n\n\nSpecifies an \n$exists\n condition\n\n\nExample\n\n\nThing.where(\nname\n).exists()\nThing.where(\nname\n).exists(true)\nThing.find().exists(\nname\n)\n\n\nThing.where(\nname\n).exists(false);\nThing.find().exists(\nname\n, false);\n\n\n\n\n\n\n\nQuery.prototype.elemMatch()\n\n\nParameters\n\n\n\n\ncriteria \u00abObject,Function\u00bb\n\n\n\n\nReturns:\n\n\nSpecifies an \n$elemMatch\n condition\n\n\nExample\n\n\nquery\n.\nelemMatch\n(\ncomment\n,\n \n{\n \nauthor\n:\n \nautobot\n,\n \nvotes\n:\n \n{$\ngte\n:\n \n5\n}\n}\n)\n\n\n\nquery\n.\nwhere\n(\ncomment\n)\n.\nelemMatch\n(\n{\n \nauthor\n:\n \nautobot\n,\n \nvotes\n:\n \n{$\ngte\n:\n \n5\n}\n}\n)\n\n\n\nquery\n.\nelemMatch\n(\ncomment\n,\n \nfunction\n \n(\nelem\n)\n \n{\n\n  \nelem.where(\nauthor\n).equals(\nautobot\n)\n;\n\n  \nelem.where(\nvotes\n).gte(5)\n;\n\n\n}\n)\n\n\n\nquery\n.\nwhere\n(\ncomment\n)\n.\nelemMatch\n(\nfunction\n \n(\nelem\n)\n \n{\n\n  \nelem.where({\n \nauthor\n:\n \nautobot\n \n}\n);\n\n  \nelem\n.\nwhere\n(\nvotes\n)\n.\ngte\n(\n5\n);\n\n\n}\n)\n\n\n\n\n\n\n\n\nQuery.prototype.within()\n\n\nReturns:\n\n\nDefines a \n$within\n or \n$geoWithin\n argument for geo-spatial queries.\n\n\nExample\n\n\nquery\n.\nwhere\n(\npath\n)\n.\nwithin\n()\n.\nbox\n()\n\n\nquery\n.\nwhere\n(\npath\n)\n.\nwithin\n()\n.\ncircle\n()\n\n\nquery\n.\nwhere\n(\npath\n)\n.\nwithin\n()\n.\ngeometry\n()\n\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \ncenter\n:\n \n[\n50\n,\n50\n]\n,\n \nradius\n:\n \n10\n,\n \nunique\n:\n \ntrue\n,\n \nspherical\n:\n \ntrue\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \nbox\n:\n \n[\n[\n40.73\n,\n \n-\n73.9\n]\n,\n \n[\n40.7\n,\n \n-\n73.988\n]\n]\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \npolygon\n:\n \n[\n[\n]\n,\n[]\n,\n[]\n,\n[]\n]\n \n}\n);\n\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n[]\n,\n \n[]\n,\n \n[]\n)\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n[]\n,\n \n[]\n)\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n(\n{\n \ntype\n:\n \nLineString\n,\n \ncoordinates\n:\n \n[\n...\n]\n \n}\n);\n\n\n\n\n\n\nMUST\n be used after \nwhere()\n.\n\n\nNOTE:\n\n\nAs of Mongoose 3.7, \n$geoWithin\n is always used for queries. To change this behavior, see \nQuery.use$geoWithin\n.\n\n\nNOTE:\n\n\nIn Mongoose 3.7, \nwithin\n changed from a getter to a function. If you need the old syntax, use \nthis\n.\n\n\n\n\nQuery.prototype.slice()\n\n\nParameters\n\n\n\n\nval \u00abNumber\u00bb number/range of elements to slice\n\n\n\n\nReturns:\n\n\nSpecifies a $slice projection for an array.\n\n\nExample\n\n\nquery.slice(\ncomments\n, 5)\nquery.slice(\ncomments\n, -5)\nquery.slice(\ncomments\n, [10, 5])\nquery.where(\ncomments\n).slice(5)\nquery.where(\ncomments\n).slice([-10, 5])\n\n\n\n\n\n\n\nQuery.prototype.limit()\n\n\nParameters\n\n\nSpecifies the maximum number of documents the query will return.\n\n\nExample\n\n\nquery.limit(20)\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.skip()\n\n\nParameters\n\n\nSpecifies the number of documents to skip.\n\n\nExample\n\n\nquery.skip(100).limit(20)\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.maxScan()\n\n\nParameters\n\n\nSpecifies the maxScan option.\n\n\nExample\n\n\nquery.maxScan(100)\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.batchSize()\n\n\nParameters\n\n\nSpecifies the batchSize option.\n\n\nExample\n\n\nquery.batchSize(100)\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nParameters\n\n\nSpecifies the \ncomment\n option.\n\n\nExample\n\n\nquery.comment(\nlogin query\n)\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.snapshot()\n\n\nReturns:\n\n\nSpecifies this query as a \nsnapshot\n query.\n\n\nExample\n\n\nquery.snapshot()\nquery.snapshot(true)\nquery.snapshot(false)\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.hint()\n\n\nParameters\n\n\n\n\nval \u00abObject\u00bb a hint object\n\n\n\n\nReturns:\n\n\nSets query hints.\n\n\nExample\n\n\nquery.hint({ indexA: 1, indexB: -1})\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.select()\n\n\nParameters\n\n\nReturns:\n\n\nSpecifies which document fields to include or exclude (also known as the query \"projection\")\n\n\nWhen using string syntax, prefixing a path with \n-\n will flag that path as excluded. When a path does not have the \n-\n prefix, it is included. Lastly, if a path is prefixed with \n+\n, it forces inclusion of the path, which is useful for paths excluded at the \nschema level\n.\n\n\nA projection \nmust\n be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The \n_id\n field is the only exception because MongoDB includes it by default\n.\n\n\nExample\n\n\nquery\n.\nselect\n(\na b\n);\n\n\n\n\nquery\n.\nselect\n(\n-c -d\n);\n\n\n\n\n\nquery\n.\nselect\n(\n{\n \na\n:\n \n1\n,\n \nb\n:\n \n1\n \n}\n);\n\n\nquery\n.\nselect\n(\n{\n \nc\n:\n \n0\n,\n \nd\n:\n \n0\n \n}\n);\n\n\n\n\nquery\n.\nselect\n(\n+path\n)\n\n\n\n\n\n\n\n\nQuery.prototype.slaveOk()\n\n\nParameters\n\n\n\n\nv \u00abBoolean\u00bb defaults to true\n\n\n\n\nReturns:\n\n\nDEPRECATED\n Sets the slaveOk option.\n\n\nDeprecated\n in MongoDB 2.2 in favor of \nread preferences\n.\n\n\nExample:\n\n\nquery.slaveOk()\nquery.slaveOk(true)\nquery.slaveOk(false)\n\n\n\n\n\n\n\nQuery.prototype.read()\n\n\nParameters\n\n\n\n\n[tags] \u00abArray\u00bb optional tags for this query\n\n\n\n\nReturns:\n\n\nDetermines the MongoDB nodes from which to read.\n\n\nPreferences:\n\n\nprimary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\nsecondary            Read from secondary if available, otherwise error.\nprimaryPreferred     Read from primary if available, otherwise a secondary.\nsecondaryPreferred   Read from a secondary if available, otherwise read from the primary.\nnearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n\n\n\n\n\nAliases\n\n\np   primary\npp  primaryPreferred\ns   secondary\nsp  secondaryPreferred\nn   nearest\n\n\n\n\n\nExample:\n\n\nnew Query().read(\nprimary\n)\nnew Query().read(\np\n)\n\nnew Query().read(\nprimaryPreferred\n)\nnew Query().read(\npp\n)\n\nnew Query().read(\nsecondary\n)\nnew Query().read(\ns\n)\n\nnew Query().read(\nsecondaryPreferred\n)\nnew Query().read(\nsp\n)\n\nnew Query().read(\nnearest\n)\nnew Query().read(\nn\n)\n\n\nnew Query().read(\ns\n, [{ dc:\nsf\n, s: 1 },{ dc:\nma\n, s: 2 }])\n\n\n\n\n\nRead more about how to use read preferrences \nhere\n and \nhere\n.\n\n\n\n\nQuery.prototype.merge()\n\n\nParameters\n\n\nReturns:\n\n\nMerges another Query or conditions object into this one.\n\n\nWhen a Query is passed, conditions, field selection and options are merged.\n\n\nNew in 3.7.0\n\n\n\n\nQuery.prototype.setOptions()\n\n\nParameters\n\n\nSets query options. Some options only make sense for certain operations.\n\n\nOptions:\n\n\nThe following options are only for \nfind()\n: - \ntailable\n - \nsort\n - \nlimit\n - \nskip\n - \nmaxscan\n - \nbatchSize\n - \ncomment\n - \nsnapshot\n - \nreadPreference\n - \nhint\n\n\nThe following options are only for \nupdate()\n, \nupdateOne()\n, \nupdateMany()\n, \nreplaceOne()\n, \nfindOneAndUpdate()\n, and \nfindByIdAndUpdate()\n: - \nupsert\n - \nwriteConcern\n\n\nThe following options are only for \nfind()\n, \nfindOne()\n, \nfindById()\n, \nfindOneAndUpdate()\n, \nfindByIdAndUpdate()\n, and \ngeoSearch()\n: - \nlean\n\n\nThe following options are for all operations\n\n\n\n\nQuery.prototype.getQuery()\n\n\nReturns:\n\n\n\n\n\u00abObject\u00bb current query conditions\n\n\n\n\nReturns the current query conditions as a JSON object.\n\n\nExample:\n\n\nvar\n \nquery\n \n=\n \nnew\n \nQuery\n();\n\n\nquery\n.\nfind\n(\n{\n \na\n:\n \n1\n \n}\n)\n.\nwhere\n(\nb\n)\n.\ngt\n(\n2\n);\n\n\nquery\n.\ngetQuery\n();\n\n\n\n\n\n\n\n\nQuery.prototype.getUpdate()\n\n\nReturns:\n\n\n\n\n\u00abObject\u00bb current update operations\n\n\n\n\nReturns the current update operations as a JSON object.\n\n\nExample:\n\n\nvar\n \nquery\n \n=\n \nnew\n \nQuery\n();\n\n\nquery\n.\nupdate\n(\n{}\n,\n \n{\n \n$\nset\n:\n \n{\n \na\n:\n \n5\n \n}\n \n}\n);\n\n\nquery\n.\ngetUpdate\n();\n\n\n\n\n\n\n\n\nQuery.prototype.lean()\n\n\nParameters\n\n\n\n\nbool \u00abBoolean,Object\u00bb defaults to true\n\n\n\n\nReturns:\n\n\nSets the lean option.\n\n\nDocuments returned from queries with the \nlean\n option enabled are plain javascript objects, not \nMongooseDocuments\n. They have no \nsave\n method, getters/setters or other Mongoose magic applied.\n\n\nExample:\n\n\nnew Query().lean()\nnew Query().lean(true)\nnew Query().lean(false)\n\nModel.find().lean().exec(function (err, docs) {\n  docs[0] instanceof mongoose.Document\n});\n\n\n\n\n\nThis is a \ngreat\n option in high-performance read-only scenarios, especially when combined with \nstream\n.\n\n\n\n\nQuery.prototype.error()\n\n\nParameters\n\n\n\n\nerr \u00abError,null\u00bb if set, \nexec()\n will fail fast before sending the query to MongoDB\n\n\n\n\nGets/sets the error flag on this query. If this flag is not null or undefined, the \nexec()\n promise will reject without executing.\n\n\nExample:\n\n\nQuery().error();\nQuery().error(null);\nQuery().error(new Error(\ntest\n));\nSchema.pre(\nfind\n, function() {\n  if (!this.getQuery().userId) {\n    this.error(new Error(\nNot allowed to query without setting userId\n));\n  }\n});\n\n\n\n\n\nNote that query casting runs \nafter\n hooks, so cast errors will override custom errors.\n\n\nExample:\n\n\nvar\n \nTestSchema\n \n=\n \nnew\n \nSchema\n(\n{\n \nnum\n:\n \nNumber\n \n}\n);\n\n\nvar\n \nTestModel\n \n=\n \ndb\n.\nmodel\n(\nTest\n,\n \nTestSchema\n);\n\n\nTestModel\n.\nfind\n(\n{\n \nnum\n:\n \nnot a number\n \n}\n)\n.\nerror\n(\nnew\n \nError\n(\nwoops\n))\n.\nexec\n(\nfunction\n(\nerror\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\n\n\nQuery.prototype.mongooseOptions()\n\n\nParameters\n\n\n\n\noptions \u00abObject\u00bb if specified, overwrites the current options\n\n\n\n\nGetter/setter around the current mongoose-specific options for this query (populate, lean, etc.)\n\n\n\n\nQuery.prototype.find()\n\n\nParameters\n\n\nReturns:\n\n\nFinds documents.\n\n\nWhen no \ncallback\n is passed, the query is not executed. When the query is executed, the result will be an array of documents.\n\n\nExample\n\n\nquery.find({ name: \nLos Pollos Hermanos\n }).find(callback)\n\n\n\n\n\n\n\nQuery.prototype.merge()\n\n\nParameters\n\n\nReturns:\n\n\nMerges another Query or conditions object into this one.\n\n\nWhen a Query is passed, conditions, field selection and options are merged.\n\n\n\n\nQuery.prototype.collation()\n\n\nParameters\n\n\nReturns:\n\n\nAdds a collation to this op (MongoDB 3.4 and up)\n\n\n\n\nQuery.prototype.findOne()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, document)\n\n\n\n\nReturns:\n\n\nDeclares the query a findOne operation. When executed, the first found document is passed to the callback.\n\n\nPassing a \ncallback\n executes the query. The result of the query is a single document.\n\n\n\n\nNote:\n \nconditions\n is optional, and if \nconditions\n is null or undefined, mongoose will send an empty \nfindOne\n command to MongoDB, which will return an arbitrary document. If you're querying by \n_id\n, use \nModel.findById()\n instead.\n\n\n\n\nThis function triggers the following middleware.\n\n\nExample\n\n\nvar\n \nquery\n  \n=\n \nKitten\n.\nwhere\n(\n{\n \ncolor\n:\n \nwhite\n \n}\n);\n\n\nquery\n.\nfindOne\n(\nfunction\n \n(\nerr\n,\n \nkitten\n)\n \n{\n\n  \nif\n \n(err)\n \nreturn\n \nhandleError(err)\n;\n\n  \nif\n \n(kitten)\n \n{\n\n\n  \n}\n\n\n}\n);\n\n\n\n\n\n\n\n\nQuery.prototype.count()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, count)\n\n\n\n\nReturns:\n\n\nSpecifying this query as a \ncount\n query.\n\n\nPassing a \ncallback\n executes the query.\n\n\nThis function triggers the following middleware.\n\n\nExample:\n\n\nvar countQuery = model.where({ \ncolor\n: \nblack\n }).count();\n\nquery.count({ color: \nblack\n }).count(callback)\n\nquery.count({ color: \nblack\n }, callback)\n\nquery.where(\ncolor\n, \nblack\n).count(function (err, count) {\n  if (err) return handleError(err);\n  console.log(\nthere are %d kittens\n, count);\n})\n\n\n\n\n\n\n\nQuery.prototype.distinct()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, arr)\n\n\n\n\nReturns:\n\n\nDeclares or executes a distict() operation.\n\n\nPassing a \ncallback\n executes the query.\n\n\nThis function does not trigger any middleware.\n\n\nExample\n\n\ndistinct(field, conditions, callback)\ndistinct(field, conditions)\ndistinct(field, callback)\ndistinct(field)\ndistinct(callback)\ndistinct()\n\n\n\n\n\n\n\nQuery.prototype.sort()\n\n\nParameters\n\n\nReturns:\n\n\nSets the sort order\n\n\nIf an object is passed, values allowed are \nasc\n, \ndesc\n, \nascending\n, \ndescending\n, \n1\n, and \n-1\n.\n\n\nIf a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with \n-\n which will be treated as descending.\n\n\nExample\n\n\nquery\n.\nsort\n(\n{\n \nfield\n:\n \nasc\n,\n \ntest\n:\n \n-1\n \n}\n);\n\n\n\n\nquery\n.\nsort\n(\nfield -test\n);\n\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.remove()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nDeclare and/or execute this query as a remove() operation.\n\n\nThis function does not trigger any middleware\n\n\nExample\n\n\nModel.remove({ artist: \nAnne Murray\n }, callback)\n\n\n\n\n\nNote\n\n\nThe operation is only executed when a callback is passed. To force execution without a callback, you must first call \nremove()\n and then execute it by using the \nexec()\n method.\n\n\nvar query = Model.find().remove({ name: \nAnne Murray\n })\n\n\nquery.remove({ name: \nAnne Murray\n }, callback)\nquery.remove({ name: \nAnne Murray\n }).remove(callback)\n\n\nquery.exec()\n\n\nquery.remove(conds, fn);\nquery.remove(conds)\nquery.remove(fn)\nquery.remove()\n\n\n\n\n\n\n\nQuery.prototype.deleteOne()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nDeclare and/or execute this query as a \ndeleteOne()\n operation. Works like remove, except it deletes at most one document regardless of the \nsingle\n option.\n\n\nThis function does not trigger any middleware.\n\n\nExample\n\n\nCharacter.deleteOne({ name: \nEddard Stark\n }, callback)\nCharacter.deleteOne({ name: \nEddard Stark\n }).then(next)\n\n\n\n\n\n\n\nQuery.prototype.deleteMany()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nDeclare and/or execute this query as a \ndeleteMany()\n operation. Works like remove, except it deletes \nevery\n document that matches \ncriteria\n in the collection, regardless of the value of \nsingle\n.\n\n\nThis function does not trigger any middleware\n\n\nExample\n\n\nCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)\nCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)\n\n\n\n\n\n\n\nQuery.prototype.findOneAndUpdate()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, doc), \nunless\n \nrawResult\n is used, in which case params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nIssues a mongodb \nfindAndModify\n update command.\n\n\nFinds a matching document, updates it according to the \nupdate\n arg, passing any \noptions\n, and returns the found document (if any) to the callback. The query executes immediately if \ncallback\n is passed.\n\n\nThis function triggers the following middleware.\n\n\nAvailable options\n\n\n\n\nnew\n: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n\n\nupsert\n: bool - creates the object if it doesn't exist. defaults to false.\n\n\nfields\n: {Object|String} - Field selection. Equivalent to \n.select(fields).findOneAndUpdate()\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nrunValidators\n: if true, runs \nupdate validators\n on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the \ndefaults\n specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on \nMongoDB's \n$setOnInsert\n operator\n.\n\n\nrawResult\n: if true, returns the \nraw result from the MongoDB driver\n\n\ncontext\n (string) if set to 'query' and \nrunValidators\n is on, \nthis\n will refer to the query in custom validator functions that update validation runs. Does nothing if \nrunValidators\n is false.\n\n\n\n\nCallback Signature\n\n\nfunction(error, doc) {\n\n\n}\n\n\n\n\n\nExamples\n\n\nquery.findOneAndUpdate(conditions, update, options, callback)\nquery.findOneAndUpdate(conditions, update, options)\nquery.findOneAndUpdate(conditions, update, callback)\nquery.findOneAndUpdate(conditions, update)\nquery.findOneAndUpdate(update, callback)\nquery.findOneAndUpdate(update)\nquery.findOneAndUpdate(callback)\nquery.findOneAndUpdate()\n\n\n\n\n\n\n\nQuery.prototype.findOneAndRemove()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, document)\n\n\n\n\nReturns:\n\n\nIssues a mongodb \nfindAndModify\n remove command.\n\n\nFinds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if \ncallback\n is passed.\n\n\nThis function triggers the following middleware.\n\n\nAvailable options\n\n\n\n\nsort\n: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n\n\nmaxTimeMS\n: puts a time limit on the query - requires mongodb \n= 2.6.0\n\n\nrawResult\n: if true, resolves to the \nraw result from the MongoDB driver\n\n\n\n\nCallback Signature\n\n\nfunction(error, doc) {\n\n\n}\n\n\n\n\n\nExamples\n\n\nA.where().findOneAndRemove(conditions, options, callback)\nA.where().findOneAndRemove(conditions, options)\nA.where().findOneAndRemove(conditions, callback)\nA.where().findOneAndRemove(conditions)\nA.where().findOneAndRemove(callback)\nA.where().findOneAndRemove()\n\n\n\n\n\n\n\nQuery.prototype.update()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional, params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nDeclare and/or execute this query as an update() operation.\n\n\nAll paths passed that are not $atomic operations will become $set ops.\n\n\nThis function triggers the following middleware.\n\n\nExample\n\n\nModel.where({ _id: id }).update({ title: \nwords\n })\n\n\n\nModel.where({ _id: id }).update({ $set: { title: \nwords\n }})\n\n\n\n\n\nValid options:\n\n\n\n\nsafe\n (boolean) safe mode (defaults to value set in schema (true))\n\n\nupsert\n (boolean) whether to create the doc if it doesn't match (false)\n\n\nmulti\n (boolean) whether multiple documents should be updated (false)\n\n\nrunValidators\n: if true, runs \nupdate validators\n on this command. Update validators validate the update operation against the model's schema.\n\n\nsetDefaultsOnInsert\n: if this and \nupsert\n are true, mongoose will apply the \ndefaults\n specified in the model's schema if a new document is created. This option only works on MongoDB \n= 2.4 because it relies on \nMongoDB's \n$setOnInsert\n operator\n.\n\n\nstrict\n (boolean) overrides the \nstrict\n option for this update\n\n\noverwrite\n (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n\n\ncontext\n (string) if set to 'query' and \nrunValidators\n is on, \nthis\n will refer to the query in custom validator functions that update validation runs. Does nothing if \nrunValidators\n is false.\n\n\n\n\nNote\n\n\nPassing an empty object \n{}\n as the doc will result in a no-op unless the \noverwrite\n option is passed. Without the \noverwrite\n option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.\n\n\nNote\n\n\nThe operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the \nexec()\n method.\n\n\nvar\n \nq\n \n=\n \nModel\n.\nwhere\n(\n{\n \n_id\n:\n \nid\n \n}\n);\n\n\nq\n.\nupdate\n(\n{\n \n$\nset\n:\n \n{\n \nname\n:\n \nbob\n \n}\n}\n)\n.\nupdate\n();\n \n//\n \nnot\n \nexecuted\n\n\n\nq\n.\nupdate\n(\n{\n \n$\nset\n:\n \n{\n \nname\n:\n \nbob\n \n}\n}\n)\n.\nexec\n();\n \n//\n \nexecuted\n\n\n\n//\n \nkeys\n \nthat\n \nare\n \nnot\n \n$\natomic\n \nops\n \nbecome\n \n$\nset\n.\n\n\n//\n \nthis\n \nexecutes\n \nthe\n \nsame\n \ncommand\n \nas\n \nthe\n \nprevious\n \nexample\n.\n\n\nq\n.\nupdate\n(\n{\n \nname\n:\n \nbob\n \n}\n)\n.\nexec\n();\n\n\n\n//\n \noverwriting\n \nwith\n \nempty\n \ndocs\n\n\nvar\n \nq\n \n=\n \nModel\n.\nwhere\n(\n{\n \n_id\n:\n \nid\n \n}\n)\n.\nsetOptions\n(\n{\n \noverwrite\n:\n \ntrue\n \n}\n)\n\n\nq\n.\nupdate\n(\n{\n \n}\n,\n \ncallback\n);\n \n//\n \nexecutes\n\n\n\n//\n \nmulti\n \nupdate\n \nwith\n \noverwrite\n \nto\n \nempty\n \ndoc\n\n\nvar\n \nq\n \n=\n \nModel\n.\nwhere\n(\n{\n \n_id\n:\n \nid\n \n}\n);\n\n\nq\n.\nsetOptions\n(\n{\n \nmulti\n:\n \ntrue\n,\n \noverwrite\n:\n \ntrue\n \n}\n)\n\n\nq\n.\nupdate\n(\n{\n \n}\n);\n\n\nq\n.\nupdate\n(\ncallback\n);\n \n//\n \nexecuted\n\n\n\n//\n \nmulti\n \nupdates\n\n\nModel\n.\nwhere\n()\n\n     \n.\nupdate\n(\n{\n \nname\n:\n \n/^\nmatch\n/\n \n}\n,\n \n{\n \n$\nset\n:\n \n{\n \narr\n:\n \n[]\n \n}\n}\n,\n \n{\n \nmulti\n:\n \ntrue\n \n}\n,\n \ncallback\n)\n\n\n\n//\n \nmore\n \nmulti\n \nupdates\n\n\nModel\n.\nwhere\n()\n\n     \n.\nsetOptions\n(\n{\n \nmulti\n:\n \ntrue\n \n}\n)\n\n     \n.\nupdate\n(\n{\n \n$\nset\n:\n \n{\n \narr\n:\n \n[]\n \n}\n}\n,\n \ncallback\n)\n\n\n\n//\n \nsingle\n \nupdate\n \nby\n \ndefault\n\n\nModel\n.\nwhere\n(\n{\n \nemail\n:\n \n[\naddress\n@\nexample.com\n][\n210\n]\n \n}\n)\n\n     \n.\nupdate\n(\n{\n \n$\ninc\n:\n \n{\n \ncounter\n:\n \n1\n \n}\n}\n,\n \ncallback\n)\n\n\n\n\n\n\nAPI summary\n\n\nupdate(criteria, doc, options, cb)\nupdate(criteria, doc, options)\nupdate(criteria, doc, cb)\nupdate(criteria, doc)\nupdate(doc, cb)\nupdate(doc)\nupdate(cb)\nupdate(true)\nupdate()\n\n\n\n\n\n\n\nQuery.prototype.updateMany()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nDeclare and/or execute this query as an updateMany() operation. Same as \nupdate()\n, except MongoDB will update \nall\n documents that match \ncriteria\n (as opposed to just the first one) regardless of the value of the \nmulti\n option.\n\n\nNote\n updateMany will \nnot\n fire update middleware. Use \npre('updateMany')\n and \npost('updateMany')\n instead.\n\n\nThis function triggers the following middleware.\n\n\n\n\nQuery.prototype.updateOne()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nDeclare and/or execute this query as an updateOne() operation. Same as \nupdate()\n, except MongoDB will update \nonly\n the first document that matches \ncriteria\n regardless of the value of the \nmulti\n option.\n\n\nNote\n updateOne will \nnot\n fire update middleware. Use \npre('updateOne')\n and \npost('updateOne')\n instead.\n\n\nThis function triggers the following middleware.\n\n\n\n\nQuery.prototype.replaceOne()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)\n\n\n\n\nReturns:\n\n\nDeclare and/or execute this query as a replaceOne() operation. Same as \nupdate()\n, except MongoDB will replace the existing document and will not accept any atomic operators (\n$set\n, etc.)\n\n\nNote\n replaceOne will \nnot\n fire update middleware. Use \npre('replaceOne')\n and \npost('replaceOne')\n instead.\n\n\nThis function triggers the following middleware.\n\n\n\n\nQuery.prototype.exec()\n\n\nParameters\n\n\n\n\n[callback] \u00abFunction\u00bb optional params depend on the function being called\n\n\n\n\nReturns:\n\n\nExecutes the query\n\n\nExamples:\n\n\nvar promise = query.exec();\nvar promise = query.exec(\nupdate\n);\n\nquery.exec(callback);\nquery.exec(\nfind\n, callback);\n\n\n\n\n\n\n\nQuery.prototype.then()\n\n\nParameters\n\n\nReturns:\n\n\nExecutes the query returning a \nPromise\n which will be resolved with either the doc(s) or rejected with the error.\n\n\n\n\nQuery.prototype.catch()\n\n\nParameters\n\n\nReturns:\n\n\nExecutes the query returning a \nPromise\n which will be resolved with either the doc(s) or rejected with the error. Like \n.then()\n, but only takes a rejection handler.\n\n\n\n\nQuery.prototype.populate()\n\n\nParameters\n\n\n\n\n[options] \u00abObject\u00bb Options for the population query (sort, etc)\n\n\n\n\nReturns:\n\n\nSpecifies paths which should be populated with other documents.\n\n\nExample:\n\n\nKitten.findOne().populate(\nowner\n).exec(function (err, kitten) {\n  console.log(kitten.owner.name)\n})\n\nKitten.find().populate({\n    path: \nowner\n\n  , select: \nname\n\n  , match: { color: \nblack\n }\n  , options: { sort: { name: -1 }}\n}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})\n\n\nKitten.find().populate(\nowner\n, \nname\n, null, {sort: { name: -1 }}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})\n\n\n\n\n\nPaths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n\n\n\n\nQuery.prototype.cast()\n\n\nParameters\n\n\nReturns:\n\n\nCasts this query to the schema of \nmodel\n\n\nNote\n\n\nIf \nobj\n is present, it is cast instead of this query.\n\n\n\n\nQuery.prototype.cursor()\n\n\nParameters\n\n\nReturns:\n\n\nReturns a wrapper around a \nmongodb driver cursor\n. A QueryCursor exposes a \nStreams3\n-compatible interface, as well as a \n.next()\n function.\n\n\nThe \n.cursor()\n function triggers pre find hooks, but \nnot\n post find hooks.\n\n\nExample\n\n\nThing\n.\n\n  \nfind\n(\n{\n \nname\n:\n \n/^\nhello\n/\n \n}\n).\n\n  \ncursor\n().\n\n  \non\n(\ndata\n,\n \nfunction\n(\ndoc\n)\n \n{\n \nconsole.log(doc)\n;\n \n}\n).\n\n  \non\n(\nend\n,\n \nfunction\n()\n \n{\n \nconsole.log(\nDone!\n)\n;\n \n}\n);\n\n\n\n\n\nvar\n \ncursor\n \n=\n \nThing\n.\nfind\n(\n{\n \nname\n:\n \n/^\nhello\n/\n \n}\n)\n.\ncursor\n();\n\n\ncursor\n.\nnext\n(\nfunction\n(\nerror\n,\n \ndoc\n)\n \n{\n\n  \nconsole.log(doc)\n;\n\n\n}\n);\n\n\n\n\n\n\nco\n(\nfunction\n*()\n \n{\n\n  \nconst\n \ncursor\n \n=\n \nThing.find({\n \nname\n:\n \n/^\nhello\n/\n \n}\n)\n.\ncursor\n();\n\n  \nfor\n \n(\nlet\n \ndoc\n \n=\n \nyield\n \ncursor\n.\nnext\n();\n \ndoc\n \n!=\n \nnull\n;\n \ndoc\n \n=\n \nyield\n \ncursor\n.\nnext\n())\n \n{\n\n    \nconsole.log(doc)\n;\n\n  \n}\n\n\n}\n);\n\n\n\n\n\n\nValid options\n\n\n\n\ntransform\n: optional function which accepts a mongoose document. The return value of the function will be emitted on \ndata\n and returned by \n.next()\n.\n\n\n\n\n\n\nQuery.prototype.maxscan()\n\n\nDEPRECATED\n Alias of \nmaxScan\n\n\n\n\nQuery.prototype.tailable()\n\n\nParameters\n\n\n\n\n[opts.tailableRetryInterval] \u00abNumber\u00bb if cursor is exhausted, wait this many milliseconds before retrying\n\n\n\n\nSets the tailable option (for use with capped collections).\n\n\nExample\n\n\nquery.tailable()\nquery.tailable(true)\nquery.tailable(false)\n\n\n\n\n\nNote\n\n\nCannot be used with \ndistinct()\n\n\n\n\nQuery.prototype.intersects()\n\n\nParameters\n\n\nReturns:\n\n\nDeclares an intersects query for \ngeometry()\n.\n\n\nExample\n\n\nquery.where(\npath\n).intersects().geometry({\n    type: \nLineString\n\n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})\n\nquery.where(\npath\n).intersects({\n    type: \nLineString\n\n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})\n\n\n\n\n\nNOTE:\n\n\nMUST\n be used after \nwhere()\n.\n\n\nNOTE:\n\n\nIn Mongoose 3.7, \nintersects\n changed from a getter to a function. If you need the old syntax, use \nthis\n.\n\n\n\n\nQuery.prototype.geometry()\n\n\nParameters\n\n\n\n\nobject \u00abObject\u00bb Must contain a \ntype\n property which is a String and a \ncoordinates\n property which is an Array. See the examples.\n\n\n\n\nReturns:\n\n\nSpecifies a \n$geometry\n condition\n\n\nExample\n\n\nvar polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\nquery.where(\nloc\n).within().geometry({ type: \nPolygon\n, coordinates: polyA })\n\n\nvar polyB = [[ 0, 0 ], [ 1, 1 ]]\nquery.where(\nloc\n).within().geometry({ type: \nLineString\n, coordinates: polyB })\n\n\nvar polyC = [ 0, 0 ]\nquery.where(\nloc\n).within().geometry({ type: \nPoint\n, coordinates: polyC })\n\n\nquery.where(\nloc\n).intersects().geometry({ type: \nPoint\n, coordinates: polyC })\n\n\n\n\n\nThe argument is assigned to the most recent path passed to \nwhere()\n.\n\n\nNOTE:\n\n\ngeometry()\n \nmust\n come after either \nintersects()\n or \nwithin()\n.\n\n\nThe \nobject\n argument must contain \ntype\n and \ncoordinates\n properties. - type {String} - coordinates {Array}\n\n\n\n\nQuery.prototype.near()\n\n\nParameters\n\n\nReturns:\n\n\nSpecifies a \n$near\n or \n$nearSphere\n condition\n\n\nThese operators return documents sorted by distance.\n\n\nExample\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n);\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n,\n \nspherical\n:\n \ntrue\n \n}\n);\n\n\nquery\n.\nnear\n(\nloc\n,\n \n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n);\n\n\n\n\n\n\n\n\nQuery.prototype.nearSphere()\n\n\nDEPRECATED\n Specifies a \n$nearSphere\n condition\n\n\nExample\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnearSphere\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nmaxDistance\n:\n \n5\n \n}\n);\n\n\n\n\n\n\nDeprecated.\n Use \nquery.near()\n instead with the \nspherical\n option set to \ntrue\n.\n\n\nExample\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nnear\n(\n{\n \ncenter\n:\n \n[\n10\n,\n \n10\n]\n,\n \nspherical\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\n\n\nQuery.prototype.polygon()\n\n\nParameters\n\n\n\n\n[coordinatePairs...] \u00abArray,Object\u00bb\n\n\n\n\nReturns:\n\n\nSpecifies a $polygon condition\n\n\nExample\n\n\nquery.where(\nloc\n).within().polygon([10,20], [13, 25], [7,15])\nquery.polygon(\nloc\n, [10,20], [13, 25], [7,15])\n\n\n\n\n\n\n\nQuery.prototype.box()\n\n\nParameters\n\n\n\n\nUpper \u00ab[Array]\u00bb Right Coords\n\n\n\n\nReturns:\n\n\nSpecifies a $box condition\n\n\nExample\n\n\nvar lowerLeft = [40.73083, -73.99756]\nvar upperRight= [40.741404,  -73.988135]\n\nquery.where(\nloc\n).within().box(lowerLeft, upperRight)\nquery.box({ ll : lowerLeft, ur : upperRight })\n\n\n\n\n\n\n\nQuery.prototype.circle()\n\n\nParameters\n\n\nReturns:\n\n\nSpecifies a $center or $centerSphere condition.\n\n\nExample\n\n\nvar area = { center: [50, 50], radius: 10, unique: true }\nquery.where(\nloc\n).within().circle(area)\n\nquery.circle(\nloc\n, area);\n\n\nvar area = { center: [50, 50], radius: 10, unique: true, spherical: true }\nquery.where(\nloc\n).within().circle(area)\n\nquery.circle(\nloc\n, area);\n\n\n\n\n\nNew in 3.7.0\n\n\n\n\nQuery.prototype.center()\n\n\n\n\nQuery.prototype.centerSphere()\n\n\nParameters\n\n\nReturns:\n\n\nDEPRECATED\n Specifies a $centerSphere condition\n\n\nDeprecated.\n Use \ncircle\n instead.\n\n\nExample\n\n\nvar\n \narea\n \n=\n \n{\n \ncenter\n:\n \n[\n50\n,\n \n50\n]\n,\n \nradius\n:\n \n10\n \n}\n;\n\n\nquery\n.\nwhere\n(\nloc\n)\n.\nwithin\n()\n.\ncenterSphere\n(\narea\n);\n\n\n\n\n\n\n\n\nQuery.prototype.selected()\n\n\nReturns:\n\n\nDetermines if field selection has been made.\n\n\n\n\nQuery.prototype.selectedInclusively()\n\n\nReturns:\n\n\nDetermines if inclusive field selection has been made.\n\n\nquery.selectedInclusively()\nquery.select(\nname\n)\nquery.selectedInclusively()\n\n\n\n\n\n\n\nQuery.prototype.selectedExclusively()\n\n\nReturns:\n\n\nDetermines if exclusive field selection has been made.\n\n\nquery.selectedExclusively()\nquery.select(\n-name\n)\nquery.selectedExclusively()\nquery.selectedInclusively()\n\n\n\n\n\n\n\n\n\nAggregate()\n\n\nParameters\n\n\n\n\n[pipeline] \u00abArray\u00bb aggregation pipeline as an array of objects\n\n\n\n\nAggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use \nModel.aggregate()\n instead.\n\n\nExample:\n\n\nconst aggregate = Model.aggregate([\n  { $project: { a: 1, b: 1 } },\n  { $skip: 5 }\n]);\n\nModel.\n  aggregate({ $match: { age: { $gte: 21 }}}).\n  unwind(\ntags\n).\n  exec(callback);\n\n\n\n\n\nNote:\n\n\n\n\nThe documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n\n\n\n\nMongoose does \nnot\n cast pipeline stages. The below will \nnot\n work unless \n_id\n is a string in the database\n\n\nnew Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n  // Do this instead to cast to an ObjectId\n  new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n\n\n\n\n\n\n\n\nAggregate.prototype.model()\n\n\nParameters\n\n\n\n\nmodel \u00abModel\u00bb the model to which the aggregate is to be bound\n\n\n\n\nReturns:\n\n\nBinds this aggregate to a model.\n\n\n\n\nAggregate.prototype.append()\n\n\nParameters\n\n\n\n\nops \u00abObject\u00bb operator(s) to append\n\n\n\n\nReturns:\n\n\nAppends new operators to this aggregate pipeline\n\n\nExamples:\n\n\naggregate\n.\nappend\n(\n{\n \n$\nproject\n:\n \n{\n \nfield\n:\n \n1\n \n}\n}\n,\n \n{\n \n$\nlimit\n:\n \n2\n \n}\n);\n\n\n\n\nvar\n \npipeline\n \n=\n \n[\n{\n \n$match\n:\n \n{\n \ndaw\n:\n \nLogic Audio X\n \n}}\n \n]\n;\n\n\naggregate\n.\nappend\n(\npipeline\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.addFields()\n\n\nParameters\n\n\n\n\narg \u00abObject\u00bb field specification\n\n\n\n\nReturns:\n\n\nAppends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work\n\n\nExamples:\n\n\naggregate\n.\naddFields\n(\n{\n\n    \nnewField\n:\n \n$b.nested\n\n  \n,\n \nplusTen\n:\n \n{\n \n$\nadd\n:\n \n[\n$val\n,\n \n10\n]\n}\n\n  \n,\n \nsub\n:\n \n{\n\n       \nname\n:\n \n$a\n\n    \n}\n\n\n}\n)\n\n\n\n\naggregate\n.\naddFields\n(\n{\n \nsalary_k\n:\n \n{\n \n$\ndivide\n:\n \n[\n \n$salary\n,\n \n1000\n \n]\n \n}\n \n}\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.project()\n\n\nParameters\n\n\n\n\narg \u00abObject,String\u00bb field specification\n\n\n\n\nReturns:\n\n\nAppends a new $project operator to this aggregate pipeline.\n\n\nMongoose query \nselection syntax\n is also supported.\n\n\nExamples:\n\n\naggregate\n.\nproject\n(\na b -_id\n);\n\n\n\n\n\naggregate\n.\nproject\n(\n{\na\n:\n \n1\n,\n \nb\n:\n \n1\n,\n \n_id\n:\n \n0\n}\n);\n\n\n\n\naggregate\n.\nproject\n(\n{\n\n    \nnewField\n:\n \n$b.nested\n\n  \n,\n \nplusTen\n:\n \n{\n \n$\nadd\n:\n \n[\n$val\n,\n \n10\n]\n}\n\n  \n,\n \nsub\n:\n \n{\n\n       \nname\n:\n \n$a\n\n    \n}\n\n\n}\n)\n\n\n\n\naggregate\n.\nproject\n(\n{\n \nsalary_k\n:\n \n{\n \n$\ndivide\n:\n \n[\n \n$salary\n,\n \n1000\n \n]\n \n}\n \n}\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.group()\n\n\nParameters\n\n\n\n\narg \u00abObject\u00bb $group operator contents\n\n\n\n\nReturns:\n\n\nAppends a new custom $group operator to this aggregate pipeline.\n\n\nExamples:\n\n\naggregate\n.\ngroup\n(\n{\n \n_id\n:\n \n$department\n \n}\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.match()\n\n\nParameters\n\n\n\n\narg \u00abObject\u00bb $match operator contents\n\n\n\n\nReturns:\n\n\nAppends a new custom $match operator to this aggregate pipeline.\n\n\nExamples:\n\n\naggregate\n.\nmatch\n(\n{\n \ndepartment\n:\n \n{\n \n$\nin\n:\n \n[\n \nsales\n,\n \nengineering\n \n]\n \n}\n \n}\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.skip()\n\n\nParameters\n\n\n\n\nnum \u00abNumber\u00bb number of records to skip before next stage\n\n\n\n\nReturns:\n\n\nAppends a new $skip operator to this aggregate pipeline.\n\n\nExamples:\n\n\naggregate.skip(10);\n\n\n\n\n\n\n\nAggregate.prototype.limit()\n\n\nParameters\n\n\n\n\nnum \u00abNumber\u00bb maximum number of records to pass to the next stage\n\n\n\n\nReturns:\n\n\nAppends a new $limit operator to this aggregate pipeline.\n\n\nExamples:\n\n\naggregate.limit(10);\n\n\n\n\n\n\n\nAggregate.prototype.near()\n\n\nParameters\n\n\nReturns:\n\n\nAppends a new $geoNear operator to this aggregate pipeline.\n\n\nNOTE:\n\n\nMUST\n be used as the first operator in the pipeline.\n\n\nExamples:\n\n\naggregate.near({\n  near: [40.724, -73.997],\n  distanceField: \ndist.calculated\n,\n  maxDistance: 0.008,\n  query: { type: \npublic\n },\n  includeLocs: \ndist.location\n,\n  uniqueDocs: true,\n  num: 5\n});\n\n\n\n\n\n\n\nAggregate.prototype.unwind()\n\n\nParameters\n\n\n\n\nfields \u00abString\u00bb the field(s) to unwind\n\n\n\n\nReturns:\n\n\nAppends new custom $unwind operator(s) to this aggregate pipeline.\n\n\nNote that the \n$unwind\n operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'.\n\n\nExamples:\n\n\naggregate.unwind(\ntags\n);\naggregate.unwind(\na\n, \nb\n, \nc\n);\n\n\n\n\n\n\n\nAggregate.prototype.lookup()\n\n\nParameters\n\n\n\n\noptions \u00abObject\u00bb to $lookup as described in the above link\n\n\n\n\nReturns:\n\n\nAppends new custom $lookup operator(s) to this aggregate pipeline.\n\n\nExamples:\n\n\naggregate\n.\nlookup\n(\n{\n \nfrom\n:\n \nusers\n,\n \nlocalField\n:\n \nuserId\n,\n \nforeignField\n:\n \n_id\n,\n \nas\n:\n \nusers\n \n}\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.graphLookup()\n\n\nParameters\n\n\n\n\noptions \u00abObject\u00bb to $graphLookup as described in the above link\n\n\n\n\nReturns:\n\n\nAppends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n\n\nNote that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if \n{ allowDiskUse: true }\n is specified.\n\n\nExamples:\n\n\n aggregate.graphLookup({ from: \ncourses\n, startWith: \n$prerequisite\n, connectFromField: \nprerequisite\n, connectToField: \nname\n, as: \nprerequisites\n, maxDepth: 3 })\n\n\n\n\n\n\n\nAggregate.prototype.sample()\n\n\nParameters\n\n\n\n\nsize \u00abNumber\u00bb number of random documents to pick\n\n\n\n\nReturns:\n\n\nAppepnds new custom $sample operator(s) to this aggregate pipeline.\n\n\nExamples:\n\n\naggregate.sample(3);\n\n\n\n\n\n\n\nAggregate.prototype.sort()\n\n\nParameters\n\n\nReturns:\n\n\nAppends a new $sort operator to this aggregate pipeline.\n\n\nIf an object is passed, values allowed are \nasc\n, \ndesc\n, \nascending\n, \ndescending\n, \n1\n, and \n-1\n.\n\n\nIf a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with \n-\n which will be treated as descending.\n\n\nExamples:\n\n\naggregate\n.\nsort\n(\n{\n \nfield\n:\n \nasc\n,\n \ntest\n:\n \n-1\n \n}\n);\n\n\naggregate\n.\nsort\n(\nfield -test\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.read()\n\n\nParameters\n\n\n\n\n[tags] \u00abArray\u00bb optional tags for this query\n\n\n\n\nSets the readPreference option for the aggregation query.\n\n\nExample:\n\n\nModel.aggregate(..).read(\nprimaryPreferred\n).exec(callback)\n\n\n\n\n\n\n\nAggregate.prototype.explain()\n\n\nParameters\n\n\nReturns:\n\n\nExecute the aggregation with explain\n\n\nExample:\n\n\nModel.aggregate(..).explain(callback)\n\n\n\n\n\n\n\nAggregate.prototype.allowDiskUse()\n\n\nParameters\n\n\n\n\n[tags] \u00abArray\u00bb optional tags for this query\n\n\n\n\nSets the allowDiskUse option for the aggregation query (ignored for \n 2.6.0)\n\n\nExample:\n\n\nModel.aggregate(..).allowDiskUse(true).exec(callback)\n\n\n\n\n\n\n\nAggregate.prototype.option()\n\n\nParameters\n\n\n\n\nvalue \u00abObject\u00bb keys to merge into current options\n\n\n\n\nReturns:\n\n\nLets you set arbitrary options, for middleware or plugins.\n\n\nExample:\n\n\nvar\n \nagg\n \n=\n \nModel\n.\naggregate\n(..)\n.\noption\n(\n{\n \nallowDiskUse\n:\n \ntrue\n \n}\n);\n\n\nagg\n.\noptions\n;\n\n\n\n\n\n\n\n\nAggregate.prototype.cursor()\n\n\nParameters\n\n\n\n\n[options.useMongooseAggCursor] \u00abBoolean\u00bb use experimental mongoose-specific aggregation cursor (for \neachAsync()\n and other query cursor semantics)\n\n\n\n\nSets the cursor option option for the aggregation query (ignored for \n 2.6.0). Note the different syntax below: .exec() returns a cursor object, and no callback is necessary.\n\n\nExample:\n\n\nvar\n \ncursor\n \n=\n \nModel\n.\naggregate\n(..)\n.\ncursor\n(\n{\n \nbatchSize\n:\n \n1000\n \n}\n)\n.\nexec\n();\n\n\ncursor\n.\neach\n(\nfunction\n(\nerror\n,\n \ndoc\n)\n \n{\n\n\n\n}\n);\n\n\n\n\n\n\n\n\nAggregate.prototype.addCursorFlag()\n\n\nParameters\n\n\nAdds a \ncursor flag\n\n\nExample:\n\n\nModel.aggregate(..).addCursorFlag(\nnoCursorTimeout\n, true).exec();\n\n\n\n\n\n\n\nAggregate.prototype.collation()\n\n\nParameters\n\n\nAdds a collation\n\n\nExample:\n\n\nModel\n.\naggregate\n(..)\n.\ncollation\n(\n{\n \nlocale\n:\n \nen_US\n,\n \nstrength\n:\n \n1\n \n}\n)\n.\nexec\n();\n\n\n\n\n\n\n\n\nAggregate.prototype.facet()\n\n\nParameters\n\n\nReturns:\n\n\nCombines multiple aggregation pipelines.\n\n\nExample:\n\n\nModel.aggregate(...)\n .facet({\n   books: [{ groupBy: \n$author\n }],\n   price: [{ $bucketAuto: { groupBy: \n$price\n, buckets: 2 } }]\n })\n .exec();\n\n\n\n\n\n\n\nAggregate.prototype.pipeline()\n\n\nReturns:\n\n\nReturns the current pipeline\n\n\nExample:\n\n\nMyModel\n.\naggregate\n()\n.\nmatch\n(\n{\n \ntest\n:\n \n1\n \n}\n)\n.\npipeline\n();\n\n\n\n\n\n\n\n\nAggregate.prototype.exec()\n\n\nParameters\n\n\nReturns:\n\n\nExecutes the aggregate pipeline on the currently bound Model.\n\n\nExample:\n\n\naggregate.exec(callback);\n\n\nvar promise = aggregate.exec();\npromise.then(..);\n\n\n\n\n\n\n\nAggregate.prototype.then()\n\n\nParameters\n\n\n\n\n[reject] \u00abFunction\u00bb errorCallback\n\n\n\n\nReturns:\n\n\nProvides promise for aggregate.\n\n\nExample:\n\n\nModel.aggregate(..).then(successCallback, errorCallback);\n\n\n\n\n\n\n\n\n\nSchemaType()\n\n\nParameters\n\n\nSchemaType constructor. Do \nnot\n instantiate \nSchemaType\n directly. Mongoose converts your schema paths into SchemaTypes automatically.\n\n\nExample:\n\n\nconst\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\nschema\n.\npath\n(\nname\n)\n \ninstanceof\n \nSchemaType\n;\n\n\n\n\n\n\n\n\nSchemaType.prototype.default()\n\n\nParameters\n\n\n\n\nval \u00abFunction,any\u00bb the default value\n\n\n\n\nReturns:\n\n\nSets a default value for this SchemaType.\n\n\nExample:\n\n\nvar schema = new Schema({ n: { type: Number, default: 10 })\nvar M = db.model(\nM\n, schema)\nvar m = new M;\nconsole.log(m.n)\n\n\n\n\n\nDefaults can be either \nfunctions\n which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n\n\nExample:\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \naNumber\n:\n \n{\n \ntype\n:\n \nNumber\n,\n \ndefault\n:\n \n4.815162342\n \n}\n}\n)\n\n\nvar\n \nM\n \n=\n \ndb\n.\nmodel\n(\nM\n,\n \nschema\n)\n\n\nvar\n \nm\n \n=\n \nnew\n \nM\n;\n\n\nconsole\n.\nlog\n(\nm\n.\naNumber\n)\n\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nmixed\n:\n \nSchema\n.\nTypes\n.\nMixed\n \n}\n);\n\n\nschema\n.\npath\n(\nmixed\n)\n.\ndefault\n(\nfunction\n \n()\n \n{\n\n  \nreturn\n \n{\n}\n;\n\n\n}\n);\n\n\n\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n(\n{\n \nmixed\n:\n \nSchema\n.\nTypes\n.\nMixed\n \n}\n);\n\n\nschema\n.\npath\n(\nmixed\n)\n.\ndefault\n(\n{}\n);\n\n\nvar\n \nM\n \n=\n \ndb\n.\nmodel\n(\nM\n,\n \nschema\n);\n\n\nvar\n \nm1\n \n=\n \nnew\n \nM\n;\n\n\nm1\n.\nmixed\n.\nadded\n \n=\n \n1\n;\n\n\nconsole\n.\nlog\n(\nm1\n.\nmixed\n);\n\n\nvar\n \nm2\n \n=\n \nnew\n \nM\n;\n\n\nconsole\n.\nlog\n(\nm2\n.\nmixed\n);\n\n\n\n\n\n\n\n\nSchemaType.prototype.index()\n\n\nParameters\n\n\n\n\noptions \u00abObject,Boolean,String\u00bb\n\n\n\n\nReturns:\n\n\nDeclares the index options for this schematype.\n\n\nExample:\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nindex\n:\n \ntrue\n \n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \n[\nNumber\n]\n,\n \nindex\n:\n \nhashed\n \n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \n[\nNumber\n]\n,\n \nindex\n:\n \n2d\n,\n \nsparse\n:\n \ntrue\n \n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nloc\n:\n \n{\n \ntype\n:\n \n[\nNumber\n]\n,\n \nindex\n:\n \n{\n \ntype\n:\n \n2dsphere\n,\n \nsparse\n:\n \ntrue\n \n}\n}\n)\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \ndate\n:\n \n{\n \ntype\n:\n \nDate\n,\n \nindex\n:\n \n{\n \nunique\n:\n \ntrue\n,\n \nexpires\n:\n \n1d\n \n}\n}\n)\n\n\nSchema\n.\npath\n(\nmy.path\n)\n.\nindex\n(\ntrue\n);\n\n\nSchema\n.\npath\n(\nmy.date\n)\n.\nindex\n(\n{\n \nexpires\n:\n \n60\n \n}\n);\n\n\nSchema\n.\npath\n(\nmy.path\n)\n.\nindex\n(\n{\n \nunique\n:\n \ntrue\n,\n \nsparse\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\nNOTE:\n\n\nIndexes are created in the background by default. Specify \nbackground: false\n to override.\n\n\nDirection doesn't matter for single key indexes\n\n\n\n\nSchemaType.prototype.unique()\n\n\nParameters\n\n\nReturns:\n\n\nDeclares an unique index.\n\n\nExample:\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nunique\n:\n \ntrue\n \n}\n}\n);\n\n\nSchema\n.\npath\n(\nname\n)\n.\nindex\n(\n{\n \nunique\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\nNOTE: violating the constraint returns an \nE11000\n error from MongoDB when saving, not a Mongoose validation error.\n\n\n\n\nSchemaType.prototype.text()\n\n\nParameters\n\n\nReturns:\n\n\nDeclares a full text index.\n\n\nExample:\n\n\nvar s = new Schema({name : {type: String, text : true })\n Schema.path(\nname\n).index({text : true});\n\n\n\n\n\n\n\nSchemaType.prototype.sparse()\n\n\nParameters\n\n\nReturns:\n\n\nDeclares a sparse index.\n\n\nExample:\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nname\n:\n \n{\n \ntype\n:\n \nString\n,\n \nsparse\n:\n \ntrue\n \n}\n)\n\n\nSchema\n.\npath\n(\nname\n)\n.\nindex\n(\n{\n \nsparse\n:\n \ntrue\n \n}\n);\n\n\n\n\n\n\n\n\nSchemaType.prototype.set()\n\n\nParameters\n\n\nReturns:\n\n\nAdds a setter to this schematype.\n\n\nExample:\n\n\nfunction\n \ncapitalize\n \n(\nval\n)\n \n{\n\n  \nif\n \n(\ntypeof\n \nval\n \n!==\n \nstring\n)\n \nval\n \n=\n \n;\n\n  \nreturn\n \nval\n.\ncharAt\n(\n0\n).\ntoUpperCase\n()\n \n+\n \nval\n.\nsubstring\n(\n1\n);\n\n\n}\n\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nset\n: \ncapitalize\n \n}})\n\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nname\n: \nString\n \n})\n\n\ns\n.\npath\n(\nname\n).\nset\n(\ncapitalize\n)\n\n\n\n\n\n\nSetters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.\n\n\nSuppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, \navenue@q.com\n can be registered for 2 accounts via \navenue@q.com\n and \nAvEnUe@Q.CoM\n.\n\n\nYou can set up email lower case normalization easily via a Mongoose setter.\n\n\nfunction\n \ntoLower\n(\nv\n)\n \n{\n\n  \nreturn\n \nv\n.\ntoLowerCase\n();\n\n\n}\n\n\n\nvar\n \nUserSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nemail\n:\n \n{\n \ntype\n: \nString\n,\n \nset\n: \ntoLower\n \n}\n\n\n});\n\n\n\nvar\n \nUser\n \n=\n \ndb\n.\nmodel\n(\nUser\n,\n \nUserSchema\n);\n\n\n\nvar\n \nuser\n \n=\n \nnew\n \nUser\n({\nemail\n:\n \n[AVENUE@Q.COM][271]\n});\n\n\nconsole\n.\nlog\n(\nuser\n.\nemail\n);\n \n// \n[avenue@q.com][271]\n\n\n\n// or\n\n\nvar\n \nuser\n \n=\n \nnew\n \nUser\n();\n\n\nuser\n.\nemail\n \n=\n \n[Avenue@Q.com][271]\n;\n\n\nconsole\n.\nlog\n(\nuser\n.\nemail\n);\n \n// \n[avenue@q.com][271]\n\n\nUser\n.\nupdateOne\n({\n \n_id\n: \n_id\n \n},\n \n{\n \n$set\n:\n \n{\n \nemail\n:\n \n[AVENUE@Q.COM][271]\n \n}\n \n});\n \n// update to \n[avenue@q.com][271]\n\n\n\n\n\n\nAs you can see above, setters allow you to transform the data before it stored in MongoDB.\n\n\nNOTE: we could have also just used the built-in \nlowercase: true\n SchemaType option instead of defining our own function.\n\n\nnew Schema({ email: { type: String, lowercase: true }})\n\n\n\n\n\nSetters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n\n\nfunction\n \ninspector\n \n(\nval\n,\n \nschematype\n)\n \n{\n\n  \nif\n \n(\nschematype\n.\noptions\n.\nrequired\n)\n \n{\n\n    \nreturn\n \nschematype\n.\npath\n \n+\n \n is required\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nval\n;\n\n  \n}\n\n\n}\n\n\n\nvar\n \nVirusSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nrequired\n: \ntrue\n,\n \nset\n: \ninspector\n \n},\n\n  \ntaxonomy\n:\n \n{\n \ntype\n: \nString\n,\n \nset\n: \ninspector\n \n}\n\n\n})\n\n\n\nvar\n \nVirus\n \n=\n \ndb\n.\nmodel\n(\nVirus\n,\n \nVirusSchema\n);\n\n\nvar\n \nv\n \n=\n \nnew\n \nVirus\n({\n \nname\n:\n \nParvoviridae\n,\n \ntaxonomy\n:\n \nParvovirinae\n \n});\n\n\n\nconsole\n.\nlog\n(\nv\n.\nname\n);\n\n\nconsole\n.\nlog\n(\nv\n.\ntaxonomy\n);\n\n\n\n\n\n\n\n\nSchemaType.prototype.get()\n\n\nParameters\n\n\nReturns:\n\n\nAdds a getter to this schematype.\n\n\nExample:\n\n\nfunction\n \ndob\n \n(\nval\n)\n \n{\n\n  \nif\n \n(\n!\nval\n)\n \nreturn\n \nval\n;\n\n  \nreturn\n \n(\nval\n.\ngetMonth\n()\n \n+\n \n1\n)\n \n+\n \n/\n \n+\n \nval\n.\ngetDate\n()\n \n+\n \n/\n \n+\n \nval\n.\ngetFullYear\n();\n\n\n}\n\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nborn\n:\n \n{\n \ntype\n: \nDate\n,\n \nget\n: \ndob\n \n})\n\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n({\n \nborn\n: \nDate\n \n})\n\n\ns\n.\npath\n(\nborn\n).\nget\n(\ndob\n)\n\n\n\n\n\n\nGetters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n\n\nSuppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n\n\nfunction\n \nobfuscate\n \n(\ncc\n)\n \n{\n\n  \nreturn\n \n****-****-****-\n \n+\n \ncc\n.\nslice\n(\ncc\n.\nlength\n-\n4\n,\n \ncc\n.\nlength\n);\n\n\n}\n\n\n\nvar\n \nAccountSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \ncreditCardNumber\n:\n \n{\n \ntype\n: \nString\n,\n \nget\n: \nobfuscate\n \n}\n\n\n});\n\n\n\nvar\n \nAccount\n \n=\n \ndb\n.\nmodel\n(\nAccount\n,\n \nAccountSchema\n);\n\n\n\nAccount\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \nfound\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nfound\n.\ncreditCardNumber\n);\n\n\n});\n\n\n\n\n\n\nGetters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n\n\nfunction\n \ninspector\n \n(\nval\n,\n \nschematype\n)\n \n{\n\n  \nif\n \n(\nschematype\n.\noptions\n.\nrequired\n)\n \n{\n\n    \nreturn\n \nschematype\n.\npath\n \n+\n \n is required\n;\n\n  \n}\n \nelse\n \n{\n\n    \nreturn\n \nschematype\n.\npath\n \n+\n \n is not\n;\n\n  \n}\n\n\n}\n\n\n\nvar\n \nVirusSchema\n \n=\n \nnew\n \nSchema\n({\n\n  \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nrequired\n: \ntrue\n,\n \nget\n: \ninspector\n \n},\n\n  \ntaxonomy\n:\n \n{\n \ntype\n: \nString\n,\n \nget\n: \ninspector\n \n}\n\n\n})\n\n\n\nvar\n \nVirus\n \n=\n \ndb\n.\nmodel\n(\nVirus\n,\n \nVirusSchema\n);\n\n\n\nVirus\n.\nfindById\n(\nid\n,\n \nfunction\n \n(\nerr\n,\n \nvirus\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nvirus\n.\nname\n);\n\n  \nconsole\n.\nlog\n(\nvirus\n.\ntaxonomy\n);\n\n\n})\n\n\n\n\n\n\n\n\nSchemaType.prototype.validate()\n\n\nParameters\n\n\n\n\n[type] \u00abString\u00bb optional validator type\n\n\n\n\nReturns:\n\n\nAdds validator(s) for this document path.\n\n\nValidators always receive the value to validate as their first argument and must return \nBoolean\n. Returning \nfalse\n means validation failed.\n\n\nThe error message argument is optional. If not passed, the \ndefault generic error message template\n will be used.\n\n\nExamples:\n\n\nfunction\n \nvalidator\n \n(\nval\n)\n \n{\n\n  \nreturn\n \nval\n \n==\n \nsomething\n;\n\n\n}\n\n\nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nvalidate\n: \nvalidator\n \n}});\n\n\n\n\n\nvar\n \ncustom\n \n=\n \n[\nvalidator\n,\n \nUh oh, {PATH} does not equal \nsomething\n.\n]\n\n\nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nvalidate\n: \ncustom\n \n}});\n\n\n\n\n\nvar\n \nmany\n \n=\n \n[\n\n    \n{\n \nvalidator\n: \nvalidator\n,\n \nmsg\n:\n \nuh oh\n \n}\n\n  \n,\n \n{\n \nvalidator\n: \nanotherValidator\n,\n \nmsg\n:\n \nfailed\n \n}\n\n\n]\n\n\nnew\n \nSchema\n({\n \nname\n:\n \n{\n \ntype\n: \nString\n,\n \nvalidate\n: \nmany\n \n}});\n\n\n\n\n\nvar\n \nschema\n \n=\n \nnew\n \nSchema\n({\n \nname\n:\n \nstring\n \n});\n\n\nschema\n.\npath\n(\nname\n).\nvalidate\n(\nvalidator\n,\n \nvalidation of `{PATH}` failed with value `{VALUE}`\n);\n\n\n\n\n\n\nError message templates:\n\n\nFrom the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides \n{PATH}\n and \n{VALUE}\n too. To find out more, details are available \nhere\n\n\nAsynchronous validation:\n\n\nPassing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either \ntrue\n or \nfalse\n to communicate either success or failure respectively.\n\n\nschema.path(\nname\n).validate({\n  isAsync: true,\n  validator: function (value, respond) {\n    doStuff(value, function () {\n      ...\n      respond(false);\n    });\n  },\n  message: \nCustom error message!\n\n});\n\n\nschema.path(\nname\n).validate({\n  validator: function (value) {\n    return new Promise(function (resolve, reject) {\n      resolve(false);\n    });\n  }\n});\n\n\n\n\n\nYou might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n\n\nValidation occurs \npre('save')\n or whenever you manually execute \ndocument#validate\n.\n\n\nIf validation fails during \npre('save')\n and no callback was passed to receive the error, an \nerror\n event will be emitted on your Models associated db \nconnection\n, passing the validation error object along.\n\n\nvar conn = mongoose.createConnection(..);\nconn.on(\nerror\n, handleError);\n\nvar Product = conn.model(\nProduct\n, yourSchema);\nvar dvd = new Product(..);\ndvd.save();\n\n\n\n\n\nIf you desire handling these errors at the Model level, attach an \nerror\n listener to your Model and the event will instead be emitted there.\n\n\nProduct.on(\nerror\n, handleError);\n\n\n\n\n\n\n\nSchemaType.prototype.required()\n\n\nParameters\n\n\n\n\n[message] \u00abString\u00bb optional custom error message\n\n\n\n\nReturns:\n\n\nAdds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using \nunshift()\n.\n\n\nExample:\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nborn\n:\n \n{\n \ntype\n:\n \nDate\n,\n \nrequired\n:\n \ntrue\n \n}\n)\n\n\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n \nborn\n:\n \n{\n \ntype\n:\n \nDate\n,\n \nrequired\n:\n \n{PATH} is required!\n \n}\n)\n\n\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nuserId\n:\n \nObjectId\n,\n\n  \nusername\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n    \nrequired\n:\n \nfunction\n()\n \n{\n \nreturn\n \nthis\n.\nuserId\n \n!=\n \nnull\n;\n \n}\n\n  \n}\n\n\n}\n)\n\n\n\n\nvar\n \ns\n \n=\n \nnew\n \nSchema\n(\n{\n\n  \nuserId\n:\n \nObjectId\n,\n\n  \nusername\n:\n \n{\n\n    \ntype\n:\n \nString\n,\n\n    \nrequired\n:\n \n[\n\n      \nfunction\n()\n \n{\n \nreturn\n \nthis.userId\n \n!=\n \nnull\n;\n \n},\n\n      \nusername is required if id is specified\n\n    \n]\n\n  \n}\n\n\n}\n)\n\n\n\n\n\nSchema\n.\npath\n(\nname\n)\n.\nrequired\n(\ntrue\n);\n\n\n\n\n\nSchema\n.\npath\n(\nname\n)\n.\nrequired\n(\ntrue\n,\n \ngrrr :( \n);\n\n\n\n\nvar\n \nisOver18\n \n=\n \nfunction\n()\n \n{\n \nreturn\n \nthis.age\n \n=\n \n18\n;\n \n}\n;\n\n\nSchema\n.\npath\n(\nvoterRegistrationId\n)\n.\nrequired\n(\nisOver18\n);\n\n\n\n\n\n\nThe required validator uses the SchemaType's \ncheckRequired\n function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if \nval != null\n (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default \ncheckRequired\n function:\n\n\n\n\nSchemaType.prototype.select()\n\n\nParameters\n\n\nReturns:\n\n\nSets default \nselect()\n behavior for this path.\n\n\nSet to \ntrue\n if this path should always be included in the results, \nfalse\n if it should be excluded by default. This setting can be overridden at the query level.\n\n\nExample:\n\n\nT\n \n=\n \ndb\n.\nmodel\n(\nT\n,\n \nnew\n \nSchema\n(\n{\n \nx\n:\n \n{\n \ntype\n:\n \nString\n,\n \nselect\n:\n \ntrue\n \n}\n}\n));\n\n\nT\n.\nfind\n(..);\n\n\n\nT\n.\nfind\n()\n.\nselect\n(\n-x\n)\n.\nexec\n(\ncallback\n);\n\n\n\n\n\n\n\n\n\n\nVirtualType()\n\n\nVirtualType constructor\n\n\nThis is what mongoose uses to define virtual attributes via \nSchema.prototype.virtual\n.\n\n\nExample:\n\n\nvar fullname = schema.virtual(\nfullname\n);\nfullname instanceof mongoose.VirtualType\n\n\n\n\n\n\n\nVirtualType.prototype.get()\n\n\nParameters\n\n\nReturns:\n\n\nDefines a getter.\n\n\nExample:\n\n\nvar virtual = schema.virtual(\nfullname\n);\nvirtual.get(function () {\n  return this.name.first + \n \n + this.name.last;\n});\n\n\n\n\n\n\n\nVirtualType.prototype.set()\n\n\nParameters\n\n\nReturns:\n\n\nDefines a setter.\n\n\nExample:\n\n\nvar virtual = schema.virtual(\nfullname\n);\nvirtual.set(function (v) {\n  var parts = v.split(\n \n);\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});\n\n\n\n\n\n\n\nVirtualType.prototype.applyGetters()\n\n\nParameters\n\n\nReturns:\n\n\n\n\n\u00abany\u00bb the value after applying all getters\n\n\n\n\nApplies getters to \nvalue\n using optional \nscope\n.\n\n\n\n\nVirtualType.prototype.applySetters()\n\n\nParameters\n\n\nReturns:\n\n\n\n\n\u00abany\u00bb the value after applying all setters\n\n\n\n\nApplies setters to \nvalue\n using optional \nscope\n.\n\n\n\n\n\n\nMongooseError()\n\n\nParameters\n\n\n\n\nmsg \u00abString\u00bb Error message\n\n\n\n\nMongooseError constructor\n\n\n\n\nMongooseError.messages\n\n\nThe default built-in validator error messages.\n\n\n\n\nMongooseError.DocumentNotFoundError\n\n\nAn instance of this error class will be returned when \nsave()\n fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to \nupdate()\n when trying to update the document.\n\n\n\n\nMongooseError.CastError\n\n\nAn instance of this error class will be returned when mongoose failed to cast a value.\n\n\n\n\nMongooseError.ValidationError\n\n\nAn instance of this error class will be returned when \nvalidation\n failed.\n\n\n\n\nMongooseError.ValidatorError\n\n\nA \nValidationError\n has a hash of \nerrors\n that contain individual \nValidatorError\n instances\n\n\n\n\nMongooseError.VersionError\n\n\nAn instance of this error class will be returned when you call \nsave()\n after the document in the database was changed in a potentially unsafe way. See the \nversionKey\n option\n for more information.\n\n\n\n\nMongooseError.OverwriteModelError\n\n\n\n\nMongooseError.MissingSchemaError\n\n\nThrown when you try to access a model that has not been registered yet\n\n\n\n\nMongooseError.DivergentArrayError\n\n\nAn instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.", 
            "title": "\u63a5\u53e3"
        }, 
        {
            "location": "/api/#mongoose-v501-api-docs", 
            "text": "Source", 
            "title": "Mongoose v5.0.1: API docs"
        }, 
        {
            "location": "/api/#schema", 
            "text": "", 
            "title": "Schema()"
        }, 
        {
            "location": "/api/#parameters", 
            "text": "Schema constructor.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example", 
            "text": "var   child   =   new   Schema ( {   name :   String   } );  var   schema   =   new   Schema ( {   name :   String ,   age :   Number ,   children :   [ child ]   } );  var   Tree   =   mongoose . model ( Tree ,   schema );  new   Schema ( {   name :   String   } ,   {   _id :   false ,   autoIndex :   false   } )", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#options", 
            "text": "", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#note", 
            "text": "When nesting schemas, ( children  in the example above), always declare the child schema first before passing it into its parent.", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#schemaprototypechildschemas", 
            "text": "Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties:  schema  and  model .  This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.", 
            "title": "Schema.prototype.childSchemas"
        }, 
        {
            "location": "/api/#schemaprototypeobj", 
            "text": "The original object passed to the schema constructor", 
            "title": "Schema.prototype.obj"
        }, 
        {
            "location": "/api/#example_1", 
            "text": "var   schema   =   new   Schema ( {   a :   String   } ) . add ( {   b :   String   } );  schema . obj ;", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schemaprototypeclone", 
            "text": "", 
            "title": "Schema.prototype.clone()"
        }, 
        {
            "location": "/api/#returns", 
            "text": "\u00abSchema\u00bb the cloned schema   Returns a deep copy of the schema", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#schemaprototypeadd", 
            "text": "", 
            "title": "Schema.prototype.add()"
        }, 
        {
            "location": "/api/#parameters_1", 
            "text": "Adds key path / schema type pairs to this schema.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_2", 
            "text": "var   ToySchema   =   new   Schema ;  ToySchema . add ( {   name :   string ,   color :   string ,   price :   number   } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schemareserved", 
            "text": "Reserved document keys.  Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.  on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject  NOTE:  Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.  var schema = new Schema(..);\n schema.methods.init = function () {}", 
            "title": "Schema.reserved"
        }, 
        {
            "location": "/api/#schemaprototypepath", 
            "text": "", 
            "title": "Schema.prototype.path()"
        }, 
        {
            "location": "/api/#parameters_2", 
            "text": "Gets/sets schema paths.  Sets a path (if arity 2) Gets a path (if arity 1)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_3", 
            "text": "schema.path( name )\nschema.path( name , Number)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#schemaprototypeeachpath", 
            "text": "", 
            "title": "Schema.prototype.eachPath()"
        }, 
        {
            "location": "/api/#parameters_3", 
            "text": "fn \u00abFunction\u00bb callback function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_1", 
            "text": "Iterates the schemas paths similar to Array#forEach.  The callback is passed the pathname and schemaType as arguments on each iteration.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#schemaprototyperequiredpaths", 
            "text": "", 
            "title": "Schema.prototype.requiredPaths()"
        }, 
        {
            "location": "/api/#parameters_4", 
            "text": "invalidate \u00abBoolean\u00bb refresh the cache", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_2", 
            "text": "Returns an Array of path strings that are required by this schema.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#schemaprototypepathtype", 
            "text": "", 
            "title": "Schema.prototype.pathType()"
        }, 
        {
            "location": "/api/#parameters_5", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_3", 
            "text": "Returns the pathType of  path  for this schema.  Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#schemaprototypequeue", 
            "text": "", 
            "title": "Schema.prototype.queue()"
        }, 
        {
            "location": "/api/#parameters_6", 
            "text": "args \u00abArray\u00bb arguments to pass to the method   Adds a method call to the queue.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#schemaprototypepre", 
            "text": "", 
            "title": "Schema.prototype.pre()"
        }, 
        {
            "location": "/api/#parameters_7", 
            "text": "Defines a pre hook for the document.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_4", 
            "text": "var toySchema = new Schema(..);\n\ntoySchema.pre( save , function (next) {\n  if (!this.created) this.created = new Date;\n  next();\n})\n\ntoySchema.pre( validate , function (next) {\n  if (this.name !==  Woody ) this.name =  Woody ;\n  next();\n})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#schemaprototypepost", 
            "text": "", 
            "title": "Schema.prototype.post()"
        }, 
        {
            "location": "/api/#parameters_8", 
            "text": "Defines a post hook for the document  var schema = new Schema(..);\nschema.post( save , function (doc) {\n  console.log( this fired after a document was saved );\n});\n\nschema.post( find , function(docs) {\n  console.log( this fired after you run a find query );\n});\n\nvar Model = mongoose.model( Model , schema);\n\nvar m = new Model(..);\nm.save(function(err) {\n  console.log( this fires after the `post` hook );\n});\n\nm.find(function(err, docs) {\n  console.log( this fires after the post find hook );\n});", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#schemaprototypeplugin", 
            "text": "", 
            "title": "Schema.prototype.plugin()"
        }, 
        {
            "location": "/api/#parameters_9", 
            "text": "Registers a plugin for this schema.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#schemaprototypemethod", 
            "text": "", 
            "title": "Schema.prototype.method()"
        }, 
        {
            "location": "/api/#parameters_10", 
            "text": "Adds an instance method to documents constructed from Models compiled from this schema.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_5", 
            "text": "var schema = kittySchema = new Schema(..);\n\nschema.method( meow , function () {\n  console.log( meeeeeoooooooooooow );\n})\n\nvar Kitty = mongoose.model( Kitty , schema);\n\nvar fizz = new Kitty;\nfizz.meow();  If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.  schema.method({\n    purr: function () {}\n  , scratch: function () {}\n});\n\n\nfizz.purr();\nfizz.scratch();", 
            "title": "Example"
        }, 
        {
            "location": "/api/#schemaprototypestatic", 
            "text": "", 
            "title": "Schema.prototype.static()"
        }, 
        {
            "location": "/api/#parameters_11", 
            "text": "Adds static \"class\" methods to Models compiled from this schema.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_6", 
            "text": "var   schema   =   new   Schema (..);  schema . static ( findByName ,   function   ( name ,   callback )   { \n   return   this.find({   name :   name   } ,   callback );  } );  var   Drink   =   mongoose . model ( Drink ,   schema );  Drink . findByName ( sanpellegrino ,   function   ( err ,   drinks )   {  } );   If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.", 
            "title": "Example"
        }, 
        {
            "location": "/api/#schemaprototypeindex", 
            "text": "", 
            "title": "Schema.prototype.index()"
        }, 
        {
            "location": "/api/#parameters_12", 
            "text": "[options.expires=null] \u00abString\u00bb Mongoose-specific syntactic sugar, uses  ms  to convert  expires  option into seconds for the  expireAfterSeconds  in the above link.   Defines an index (most likely compound) for this schema.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_7", 
            "text": "schema.index({ first: 1, last: -1 })", 
            "title": "Example"
        }, 
        {
            "location": "/api/#schemaprototypeset", 
            "text": "", 
            "title": "Schema.prototype.set()"
        }, 
        {
            "location": "/api/#parameters_13", 
            "text": "[value] \u00abObject\u00bb if not passed, the current option value is returned   Sets/gets a schema option.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_8", 
            "text": "schema.set( strict );\nschema.set( strict , false);\nschema.set( strict );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#schemaprototypeget", 
            "text": "", 
            "title": "Schema.prototype.get()"
        }, 
        {
            "location": "/api/#parameters_14", 
            "text": "key \u00abString\u00bb option name", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#indextypes", 
            "text": "", 
            "title": "indexTypes"
        }, 
        {
            "location": "/api/#schemaprototypeindexes", 
            "text": "Compiles indexes from fields and schema-level indexes", 
            "title": "Schema.prototype.indexes()"
        }, 
        {
            "location": "/api/#schemaprototypevirtual", 
            "text": "", 
            "title": "Schema.prototype.virtual()"
        }, 
        {
            "location": "/api/#parameters_15", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_4", 
            "text": "Creates a virtual type with the given name.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#schemaprototypevirtualpath", 
            "text": "", 
            "title": "Schema.prototype.virtualpath()"
        }, 
        {
            "location": "/api/#parameters_16", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_5", 
            "text": "Returns the virtual type with the given  name .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#schemaprototyperemove", 
            "text": "", 
            "title": "Schema.prototype.remove()"
        }, 
        {
            "location": "/api/#parameters_17", 
            "text": "Removes the given  path  (or [ paths ]).", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#schemaprototypeloadclass", 
            "text": "", 
            "title": "Schema.prototype.loadClass()"
        }, 
        {
            "location": "/api/#parameters_18", 
            "text": "Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#schematypes", 
            "text": "The various built-in Mongoose Schema Types.", 
            "title": "Schema.Types"
        }, 
        {
            "location": "/api/#example_9", 
            "text": "var mongoose = require( mongoose );\nvar ObjectId = mongoose.Schema.Types.ObjectId;", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#types", 
            "text": "Using this exposed access to the  Mixed  SchemaType, we can use them in our schema.  var Mixed = mongoose.Schema.Types.Mixed;\nnew mongoose.Schema({ _user: Mixed })", 
            "title": "Types:"
        }, 
        {
            "location": "/api/#connection", 
            "text": "", 
            "title": "Connection()"
        }, 
        {
            "location": "/api/#parameters_19", 
            "text": "base \u00abMongoose\u00bb a mongoose instance   Connection constructor  For practical reasons, a Connection equals a Db.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#connectionprototypereadystate", 
            "text": "Connection ready state   0 = disconnected  1 = connected  2 = connecting  3 = disconnecting   Each state change emits its associated event name.", 
            "title": "Connection.prototype.readyState"
        }, 
        {
            "location": "/api/#example_10", 
            "text": "conn.on( connected , callback);\nconn.on( disconnected , callback);", 
            "title": "Example"
        }, 
        {
            "location": "/api/#connectionprototypecollections", 
            "text": "A hash of the collections associated with this connection", 
            "title": "Connection.prototype.collections"
        }, 
        {
            "location": "/api/#connectionprototypedb", 
            "text": "The mongodb.Db instance, set when the connection is opened", 
            "title": "Connection.prototype.db"
        }, 
        {
            "location": "/api/#connectionprototypeconfig", 
            "text": "A hash of the global options that are associated with this connection", 
            "title": "Connection.prototype.config"
        }, 
        {
            "location": "/api/#connectionprototypecreatecollection", 
            "text": "", 
            "title": "Connection.prototype.createCollection()"
        }, 
        {
            "location": "/api/#parameters_20", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_6", 
            "text": "", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#connectionprototypedropcollection", 
            "text": "", 
            "title": "Connection.prototype.dropCollection()"
        }, 
        {
            "location": "/api/#parameters_21", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_7", 
            "text": "Helper for  dropCollection() . Will delete the given collection, including all documents and indexes.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#connectionprototypedropdatabase", 
            "text": "", 
            "title": "Connection.prototype.dropDatabase()"
        }, 
        {
            "location": "/api/#parameters_22", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_8", 
            "text": "Helper for  dropDatabase() . Deletes the given database, including all collections, documents, and indexes.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#connectionprototypeclose", 
            "text": "", 
            "title": "Connection.prototype.close()"
        }, 
        {
            "location": "/api/#parameters_23", 
            "text": "[callback] \u00abFunction\u00bb optional", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_9", 
            "text": "", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#connectionprototypecollection", 
            "text": "", 
            "title": "Connection.prototype.collection()"
        }, 
        {
            "location": "/api/#parameters_24", 
            "text": "[options] \u00abObject\u00bb optional collection options", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_10", 
            "text": "\u00abCollection\u00bb collection instance   Retrieves a collection, creating it if not cached.  Not typically needed by applications. Just talk to your collection through your model.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#connectionprototypemodel", 
            "text": "", 
            "title": "Connection.prototype.model()"
        }, 
        {
            "location": "/api/#parameters_25", 
            "text": "[collection] \u00abString\u00bb name of mongodb collection (optional) if not given it will be induced from model name", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_11", 
            "text": "\u00abModel\u00bb The compiled model   Defines or retrieves a model.  var mongoose = require( mongoose );\nvar db = mongoose.createConnection(..);\ndb.model( Venue , new Schema(..));\nvar Ticket = db.model( Ticket , new Schema(..));\nvar Venue = db.model( Venue );  When no  collection  argument is passed, Mongoose produces a collection name by passing the model  name  to the  utils.toCollectionName  method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_11", 
            "text": "var   schema   =   new   Schema ( {   name :   String   } ,   {   collection :   actor   } );  schema . set ( collection ,   actor );  var   collectionName   =   actor  var   M   =   conn . model ( Actor ,   schema ,   collectionName )", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#connectionprototypemodelnames", 
            "text": "", 
            "title": "Connection.prototype.modelNames()"
        }, 
        {
            "location": "/api/#returns_12", 
            "text": "Returns an array of model names created on this connection.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#documentprototypeschema", 
            "text": "", 
            "title": "Document.prototype.schema"
        }, 
        {
            "location": "/api/#documentprototypeisnew", 
            "text": "Boolean flag specifying if the document is new.", 
            "title": "Document.prototype.isNew"
        }, 
        {
            "location": "/api/#documentprototypeid", 
            "text": "The string version of this documents _id.", 
            "title": "Document.prototype.id"
        }, 
        {
            "location": "/api/#note_1", 
            "text": "This getter exists on all documents by default. The getter can be disabled by setting the  id   option  of its  Schema  to false at construction time.  new   Schema ( {   name :   String   } ,   {   id :   false   } );", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#documentprototypeerrors", 
            "text": "Hash containing current validation errors.", 
            "title": "Document.prototype.errors"
        }, 
        {
            "location": "/api/#documentprototypeinit", 
            "text": "", 
            "title": "Document.prototype.init()"
        }, 
        {
            "location": "/api/#parameters_26", 
            "text": "doc \u00abObject\u00bb document returned by mongo   Initializes the document without setters or marking anything modified.  Called internally after a document is returned from mongodb.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#documentprototypeupdate", 
            "text": "", 
            "title": "Document.prototype.update()"
        }, 
        {
            "location": "/api/#parameters_27", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_13", 
            "text": "Sends an update command with this document  _id  as the query selector.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_12", 
            "text": "weirdCar . update ( { $ inc :   { wheels : 1 } } ,   {   w :   1   } ,   callback );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#valid-options", 
            "text": "", 
            "title": "Valid options:"
        }, 
        {
            "location": "/api/#documentprototypeset", 
            "text": "", 
            "title": "Document.prototype.$set()"
        }, 
        {
            "location": "/api/#parameters_28", 
            "text": "[options] \u00abObject\u00bb optionally specify options that modify the behavior of the set   Alias for  set() , used internally to avoid conflicts", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#documentprototypeset_1", 
            "text": "", 
            "title": "Document.prototype.set()"
        }, 
        {
            "location": "/api/#parameters_29", 
            "text": "[options] \u00abObject\u00bb optionally specify options that modify the behavior of the set   Sets the value of a path, or many paths.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_13", 
            "text": "doc . set ( path ,   value )  doc . set ( { \n     path    :   value \n   ,   path2   :   { \n        path    :   value \n     }  } )  doc . set ( path ,   value ,   Number )  doc . set ( path ,   value ,   String )  doc . set ( path ,   value ,   {   strict :   false   } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypeget", 
            "text": "", 
            "title": "Document.prototype.get()"
        }, 
        {
            "location": "/api/#parameters_30", 
            "text": "[type] \u00abSchema,String,Number,Buffer,*\u00bb optionally specify a type for on-the-fly attributes   Returns the value of a path.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_14", 
            "text": "doc.get( age )\n\n\ndoc.get( age , String)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#documentprototypemarkmodified", 
            "text": "", 
            "title": "Document.prototype.markModified()"
        }, 
        {
            "location": "/api/#parameters_31", 
            "text": "[scope] \u00abDocument\u00bb the scope to run validators with   Marks the path as having pending changes to write to the db.  Very helpful when using  Mixed  types.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_15", 
            "text": "doc.mixed.type =  changed ;\ndoc.markModified( mixed.type );\ndoc.save()", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypeunmarkmodified", 
            "text": "", 
            "title": "Document.prototype.unmarkModified()"
        }, 
        {
            "location": "/api/#parameters_32", 
            "text": "path \u00abString\u00bb the path to unmark modified   Clears the modified state on the specified path.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_16", 
            "text": "doc.foo =  bar ;\ndoc.unmarkModified( foo );\ndoc.save()", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypeignore", 
            "text": "", 
            "title": "Document.prototype.$ignore()"
        }, 
        {
            "location": "/api/#parameters_33", 
            "text": "path \u00abString\u00bb the path to ignore   Don't run validation on this path or persist changes to this path.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_17", 
            "text": "doc.foo = null;\ndoc.$ignore( foo );\ndoc.save()", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypemodifiedpaths", 
            "text": "", 
            "title": "Document.prototype.modifiedPaths()"
        }, 
        {
            "location": "/api/#returns_14", 
            "text": "Returns the list of paths that have been modified.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#documentprototypeismodified", 
            "text": "", 
            "title": "Document.prototype.isModified()"
        }, 
        {
            "location": "/api/#parameters_34", 
            "text": "[path] \u00abString\u00bb optional", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_15", 
            "text": "Returns true if this document was modified, else false.  If  path  is given, checks if a path or any full path containing  path  as part of its path chain has been modified.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_18", 
            "text": "doc.set( documents.0.title ,  changed );\ndoc.isModified()\ndoc.isModified( documents )\ndoc.isModified( documents.0.title )\ndoc.isModified( documents otherProp )\ndoc.isDirectModified( documents )", 
            "title": "Example"
        }, 
        {
            "location": "/api/#documentprototypeisdefault", 
            "text": "", 
            "title": "Document.prototype.$isDefault()"
        }, 
        {
            "location": "/api/#parameters_35", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_16", 
            "text": "Checks if a path is set to its default.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_19", 
            "text": "MyModel   =   mongoose . model ( test ,   {   name :   {   type :   String ,   default :   Val  }   } );  var   m   =   new   MyModel ();  m .$ isDefault ( name );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#documentprototypeisdeleted", 
            "text": "", 
            "title": "Document.prototype.$isDeleted()"
        }, 
        {
            "location": "/api/#parameters_36", 
            "text": "[val] \u00abBoolean\u00bb optional, overrides whether mongoose thinks the doc is deleted", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_17", 
            "text": "\u00abBoolean\u00bb whether mongoose thinks this doc is deleted.   Getter/setter, determines whether the document was removed or not.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_20", 
            "text": "product.remove(function (err, product) {\n  product.isDeleted();\n  product.remove();\n\n  product.isDeleted(false);\n  product.isDeleted();\n  product.remove();\n})", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypeisdirectmodified", 
            "text": "", 
            "title": "Document.prototype.isDirectModified()"
        }, 
        {
            "location": "/api/#parameters_37", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_18", 
            "text": "Returns true if  path  was directly set and modified, else false.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_21", 
            "text": "doc.set( documents.0.title ,  changed );\ndoc.isDirectModified( documents.0.title )\ndoc.isDirectModified( documents )", 
            "title": "Example"
        }, 
        {
            "location": "/api/#documentprototypeisinit", 
            "text": "", 
            "title": "Document.prototype.isInit()"
        }, 
        {
            "location": "/api/#parameters_38", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_19", 
            "text": "Checks if  path  was initialized.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#documentprototypeisselected", 
            "text": "", 
            "title": "Document.prototype.isSelected()"
        }, 
        {
            "location": "/api/#parameters_39", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_20", 
            "text": "Checks if  path  was selected in the source query which initialized this document.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_22", 
            "text": "Thing.findOne().select( name ).exec(function (err, doc) {\n   doc.isSelected( name )\n   doc.isSelected( age )\n})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#documentprototypeisdirectselected", 
            "text": "", 
            "title": "Document.prototype.isDirectSelected()"
        }, 
        {
            "location": "/api/#parameters_40", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_21", 
            "text": "Checks if  path  was explicitly selected. If no projection, always returns true.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_23", 
            "text": "Thing.findOne().select( nested.name ).exec(function (err, doc) {\n   doc.isDirectSelected( nested.name )\n   doc.isDirectSelected( nested.otherName )\n   doc.isDirectSelected( nested )\n})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#documentprototypevalidate", 
            "text": "", 
            "title": "Document.prototype.validate()"
        }, 
        {
            "location": "/api/#parameters_41", 
            "text": "callback \u00abFunction\u00bb optional callback called after validation completes, passing an error if one occurred", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_22", 
            "text": "Executes registered validation rules for this document.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#note_2", 
            "text": "This method is called  pre  save and if a validation rule is violated,  save  is aborted and the error is returned to your  callback .", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#example_24", 
            "text": "doc.validate(function (err) {\n  if (err) handleError(err);\n  else\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypevalidatesync", 
            "text": "", 
            "title": "Document.prototype.validateSync()"
        }, 
        {
            "location": "/api/#parameters_42", 
            "text": "pathsToValidate \u00abArray,string\u00bb only validate the given paths", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_23", 
            "text": "\u00abMongooseError,undefined\u00bb MongooseError if there are errors during validation, or undefined if there is no error.   Executes registered validation rules (skipping asynchronous validators) for this document.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#note_3", 
            "text": "This method is useful if you need synchronous validation.", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#example_25", 
            "text": "var err = doc.validateSync();\nif ( err ){\n  handleError( err );\n} else {\n\n}", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypeinvalidate", 
            "text": "", 
            "title": "Document.prototype.invalidate()"
        }, 
        {
            "location": "/api/#parameters_43", 
            "text": "[kind] \u00abString\u00bb optional  kind  property for the error", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_24", 
            "text": "\u00abValidationError\u00bb the current ValidationError, with all currently invalidated paths   Marks a path as invalid, causing validation to fail.  The  errorMsg  argument will become the message of the  ValidationError .  The  value  argument (if passed) will be available through the  ValidationError.value  property.  doc.invalidate( size ,  must be less than 20 , 14);\n\ndoc.validate(function (err) {\n  console.log(err)\n\n  { message:  Validation failed ,\n    name:  ValidationError ,\n    errors:\n     { size:\n        { message:  must be less than 20 ,\n          name:  ValidatorError ,\n          path:  size ,\n          type:  user defined ,\n          value: 14 } } }\n})", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#documentprototypemarkvalid", 
            "text": "", 
            "title": "Document.prototype.$markValid()"
        }, 
        {
            "location": "/api/#parameters_44", 
            "text": "path \u00abString\u00bb the field to mark as valid   Marks a path as valid, removing existing validation errors.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#documentprototypesave", 
            "text": "", 
            "title": "Document.prototype.save()"
        }, 
        {
            "location": "/api/#parameters_45", 
            "text": "[fn] \u00abFunction\u00bb optional callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_25", 
            "text": "Saves this document.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_26", 
            "text": "product.sold = Date.now();\nproduct.save(function (err, product, numAffected) {\n  if (err) ..\n})  The callback will receive three parameters   err  if an error occurred  product  which is the saved  product  numAffected  will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking  err  is sufficient to make sure your document was properly saved.   As an extra measure of flow control, save will return a Promise.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#example_27", 
            "text": "product.save().then(function(product) {\n   ...\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypetoobject", 
            "text": "", 
            "title": "Document.prototype.toObject()"
        }, 
        {
            "location": "/api/#parameters_46", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_26", 
            "text": "Converts this document into a plain javascript object, ready for storage in MongoDB.  Buffers are converted to instances of  mongodb.Binary  for proper storage.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#options_1", 
            "text": "getters  apply all getters (path and virtual getters)  virtuals  apply virtual getters (can override  getters  option)  minimize  remove empty objects (defaults to true)  transform  a transform function to apply to the resulting document before returning  depopulate  depopulate any populated paths, replacing them with their original refs (defaults to false)  versionKey  whether to include the version key (defaults to true)", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#gettersvirtuals", 
            "text": "Example of only applying path getters  doc.toObject({ getters: true, virtuals: false })  Example of only applying virtual getters  doc.toObject({ virtuals: true })  Example of applying both path and virtual getters  doc.toObject({ getters: true })  To apply these options to every document of your schema by default, set your  schemas   toObject  option to the same argument.  schema.set( toObject , { virtuals: true })", 
            "title": "Getters/Virtuals"
        }, 
        {
            "location": "/api/#transform", 
            "text": "We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional  transform  function.  Transform functions receive three arguments  function   ( doc ,   ret ,   options )   {}    doc  The mongoose document which is being converted  ret  The plain object representation which has been converted  options  The options in use (either schema options or the options passed inline)", 
            "title": "Transform"
        }, 
        {
            "location": "/api/#example_28", 
            "text": "if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n\n  delete ret._id;\n  return ret;\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();  With transformations we can do a lot more than remove properties. We can even return completely new customized objects:  if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  return { movie: ret.name }\n}\n\n\ndoc.toObject();\n\n\ndoc.toObject();  Note: if a transform function returns  undefined , the return value will be ignored.  Transformations may also be applied inline, overridding any transform set in the options:  function   xform   ( doc ,   ret ,   options )   { \n   return   {   inline :  ret.name ,   custom :  true   }  }  doc . toObject ({   transform :  xform   });   If you want to skip transformations, use  transform: false :  if   (! schema . options . toObject )   schema . options . toObject   =   {} ;  schema . options . toObject . hide   =   _id ;  schema . options . toObject . transform   =   function   ( doc ,   ret ,   options )   { \n   if   (options.hide)   { \n     options.hide.split(   ).forEach(function   (prop)   { \n       delete   ret [ prop ] ; \n     } ); \n   } \n   return   ret ;  }  var   doc   =   new   Doc ( {   _id :   anId ,   secret :   47 ,   name :   Wreck-it Ralph   } );  doc . toObject ();  doc . toObject ( {   hide :   secret _id ,   transform :   false   } );  doc . toObject ( {   hide :   secret _id ,   transform :   true   } );   Transforms are applied  only to the document and are not applied to sub-documents .  Transforms, like all of these options, are also available for  toJSON .  See  schema options  for some more details.  During save, no custom options are applied to the document before being sent to the database.", 
            "title": "Example"
        }, 
        {
            "location": "/api/#documentprototypetojson", 
            "text": "", 
            "title": "Document.prototype.toJSON()"
        }, 
        {
            "location": "/api/#parameters_47", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_27", 
            "text": "The return value of this method is used in calls to JSON.stringify(doc).  This method accepts the same options as  Document#toObject . To apply the options to every document of your schema by default, set your  schemas   toJSON  option to the same argument.  schema.set( toJSON , { virtuals: true })  See  schema options  for details.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#documentprototypeinspect", 
            "text": "", 
            "title": "Document.prototype.inspect()"
        }, 
        {
            "location": "/api/#documentprototypetostring", 
            "text": "", 
            "title": "Document.prototype.toString()"
        }, 
        {
            "location": "/api/#documentprototypeequals", 
            "text": "", 
            "title": "Document.prototype.equals()"
        }, 
        {
            "location": "/api/#parameters_48", 
            "text": "doc \u00abDocument\u00bb a document to compare", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_28", 
            "text": "Returns true if the Document stores the same data as doc.  Documents are considered equal when they have matching  _id s, unless neither document has an  _id , in which case this function falls back to using  deepEqual() .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#documentprototypepopulate", 
            "text": "", 
            "title": "Document.prototype.populate()"
        }, 
        {
            "location": "/api/#parameters_49", 
            "text": "[callback] \u00abFunction\u00bb When passed, population is invoked", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_29", 
            "text": "Populates document references, executing the  callback  when complete. If you want to use promises instead, use this function with  execPopulate()", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_29", 
            "text": "doc\n.populate( company )\n.populate({\n  path:  notes ,\n  match: /airline/,\n  select:  text ,\n  model:  modelName \n  options: opts\n}, function (err, user) {\n  assert(doc._id === user._id)\n})\n\n\ndoc.populate(path)\ndoc.populate(options);\ndoc.populate(path, callback)\ndoc.populate(options, callback);\ndoc.populate(callback);\ndoc.populate(options).execPopulate()", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_4", 
            "text": "Population does not occur unless a  callback  is passed  or  you explicitly call  execPopulate() . Passing the same path a second time will overwrite the previous path options. See  Model.populate()  for explaination of options.", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#documentprototypeexecpopulate", 
            "text": "", 
            "title": "Document.prototype.execPopulate()"
        }, 
        {
            "location": "/api/#returns_30", 
            "text": "\u00abPromise\u00bb promise that resolves to the document when population is done   Explicitly executes population and returns a promise. Useful for ES2015 integration.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_30", 
            "text": "var promise = doc.\n  populate( company ).\n  populate({\n    path:  notes ,\n    match: /airline/,\n    select:  text ,\n    model:  modelName \n    options: opts\n  }).\n  execPopulate();\n\n\ndoc.execPopulate().then(resolve, reject);", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypepopulated", 
            "text": "", 
            "title": "Document.prototype.populated()"
        }, 
        {
            "location": "/api/#parameters_50", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_31", 
            "text": "\u00abArray,ObjectId,Number,Buffer,String,undefined\u00bb   Gets _id(s) used during population of the given  path .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_31", 
            "text": "Model.findOne().populate( author ).exec(function (err, doc) {\n  console.log(doc.author.name)\n  console.log(doc.populated( author ))\n})  If the path was not populated, undefined is returned.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#documentprototypedepopulate", 
            "text": "", 
            "title": "Document.prototype.depopulate()"
        }, 
        {
            "location": "/api/#parameters_51", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_32", 
            "text": "Takes a populated field and returns it to its unpopulated state.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_32", 
            "text": "Model.findOne().populate( author ).exec(function (err, doc) {\n  console.log(doc.author.name);\n  console.log(doc.depopulate( author ));\n  console.log(doc.author);\n})  If the path was not populated, this is a no-op.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#model", 
            "text": "", 
            "title": "Model()"
        }, 
        {
            "location": "/api/#parameters_52", 
            "text": "doc \u00abObject\u00bb values with which to create the document   Model constructor  Provides the interface to MongoDB collections as well as creates document instances.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#modelprototypedb", 
            "text": "Connection the model uses.", 
            "title": "Model.prototype.db"
        }, 
        {
            "location": "/api/#modelprototypecollection", 
            "text": "Collection the model uses.", 
            "title": "Model.prototype.collection"
        }, 
        {
            "location": "/api/#modelprototypemodelname", 
            "text": "", 
            "title": "Model.prototype.modelName"
        }, 
        {
            "location": "/api/#modelprototypewhere", 
            "text": "Additional properties to attach to the query when calling  save()  and  isNew  is false.", 
            "title": "Model.prototype.$where"
        }, 
        {
            "location": "/api/#modelprototypebasemodelname", 
            "text": "If this is a discriminator model,  baseModelName  is the name of the base model.", 
            "title": "Model.prototype.baseModelName"
        }, 
        {
            "location": "/api/#modelprototypesave", 
            "text": "", 
            "title": "Model.prototype.save()"
        }, 
        {
            "location": "/api/#parameters_53", 
            "text": "[fn] \u00abFunction\u00bb optional callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_33", 
            "text": "Saves this document.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_33", 
            "text": "product.sold = Date.now();\nproduct.save(function (err, product) {\n  if (err) ..\n})  The callback will receive three parameters   err  if an error occurred  product  which is the saved  product   As an extra measure of flow control, save will return a Promise.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#example_34", 
            "text": "product.save().then(function(product) {\n   ...\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelprototypeincrement", 
            "text": "Signal that we desire an increment of this documents version.", 
            "title": "Model.prototype.increment()"
        }, 
        {
            "location": "/api/#example_35", 
            "text": "Model.findById(id, function (err, doc) {\n  doc.increment();\n  doc.save(function (err) { .. })\n})", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelprototyperemove", 
            "text": "", 
            "title": "Model.prototype.remove()"
        }, 
        {
            "location": "/api/#parameters_54", 
            "text": "[fn] \u00abfunction(err,product)\u00bb optional callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_34", 
            "text": "Removes this document from the db.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_36", 
            "text": "product.remove(function (err, product) {\n  if (err) return handleError(err);\n  Product.findById(product._id, function (err, product) {\n    console.log(product)\n  })\n})  As an extra measure of flow control, remove will return a Promise (bound to  fn  if passed) so it could be chained, or hooked to recive errors", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#example_37", 
            "text": "product.remove().then(function (product) {\n   ...\n}).catch(function (err) {\n   assert.ok(err)\n})", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelprototypemodel", 
            "text": "", 
            "title": "Model.prototype.model()"
        }, 
        {
            "location": "/api/#parameters_55", 
            "text": "name \u00abString\u00bb model name   Returns another Model instance.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_38", 
            "text": "var doc = new Tank;\ndoc.model( User ).findById(id, callback);", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modeldiscriminator", 
            "text": "", 
            "title": "Model.discriminator()"
        }, 
        {
            "location": "/api/#parameters_56", 
            "text": "schema \u00abSchema\u00bb discriminator model schema   Adds a discriminator type.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_39", 
            "text": "function   BaseSchema() { \n   Schema . apply ( this ,   arguments ); \n\n   this . add ({ \n     name :  String , \n     createdAt :  Date \n   });  }  util . inherits ( BaseSchema ,   Schema );  var   PersonSchema   =   new   BaseSchema ();  var   BossSchema   =   new   BaseSchema ({   department :  String   });  var   Person   =   mongoose . model ( Person ,   PersonSchema );  var   Boss   =   Person . discriminator ( Boss ,   BossSchema );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelinit", 
            "text": "", 
            "title": "Model.init()"
        }, 
        {
            "location": "/api/#parameters_57", 
            "text": "Performs any async initialization of this model against MongoDB. Currently, this function is only responsible for building  indexes , unless  autoIndex  is turned off.  This function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to  MyModel.on('index')", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_40", 
            "text": "var eventSchema = new Schema({ thing: { type:  string , unique: true }})\n\n\nvar Event = mongoose.model( Event , eventSchema);\n\nEvent.init().then(function(Event) {\n\n\n  console.log( Indexes are done building! );\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelensureindexes", 
            "text": "", 
            "title": "Model.ensureIndexes()"
        }, 
        {
            "location": "/api/#parameters_58", 
            "text": "[cb] \u00abFunction\u00bb optional callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_35", 
            "text": "Sends  createIndex  commands to mongo for each index declared in the schema. The  createIndex  commands are sent in series.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_41", 
            "text": "Event.ensureIndexes(function (err) {\n  if (err) return handleError(err);\n});  After completion, an  index  event is emitted on this  Model  passing an error if one occurred.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#example_42", 
            "text": "var eventSchema = new Schema({ thing: { type:  string , unique: true }})\nvar Event = mongoose.model( Event , eventSchema);\n\nEvent.on( index , function (err) {\n  if (err) console.error(err);\n})  NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelcreateindexes", 
            "text": "", 
            "title": "Model.createIndexes()"
        }, 
        {
            "location": "/api/#parameters_59", 
            "text": "[cb] \u00abFunction\u00bb optional callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_36", 
            "text": "Similar to  ensureIndexes() , except for it uses the  createIndex  function. The  ensureIndex()  function checks to see if an index with that name already exists, and, if not, does not attempt to create the index.  createIndex()  bypasses this check.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#modelprototypeschema", 
            "text": "", 
            "title": "Model.prototype.schema"
        }, 
        {
            "location": "/api/#modelprototypebase", 
            "text": "Base Mongoose instance the model uses.", 
            "title": "Model.prototype.base"
        }, 
        {
            "location": "/api/#modelprototypediscriminators", 
            "text": "Registered discriminators for this model.", 
            "title": "Model.prototype.discriminators"
        }, 
        {
            "location": "/api/#modeltranslatealiases", 
            "text": "", 
            "title": "Model.translateAliases()"
        }, 
        {
            "location": "/api/#parameters_60", 
            "text": "raw \u00abObject\u00bb fields/conditions that may contain aliased keys", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_37", 
            "text": "\u00abObject\u00bb the translated 'pure' fields/conditions   Translate any aliases fields/conditions so the final query or document object is pure", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_43", 
            "text": "Character\n  .find(Character.translateAliases({\n     \u540d :  Eddard Stark \n  })\n  .exec(function(err, characters) {})", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_5", 
            "text": "Only translate arguments of object type anything else is returned raw", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#modelremove", 
            "text": "", 
            "title": "Model.remove()"
        }, 
        {
            "location": "/api/#parameters_61", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_38", 
            "text": "Removes all documents that match  conditions  from the collection. To remove just the first document that matches  conditions , set the  single  option to true.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_44", 
            "text": "Character . remove ( {   name :   Eddard Stark   } ,   function   ( err )   {} );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_6", 
            "text": "This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved,  no middleware (hooks) are executed .", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#modeldeleteone", 
            "text": "", 
            "title": "Model.deleteOne()"
        }, 
        {
            "location": "/api/#parameters_62", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_39", 
            "text": "Deletes the first document that matches  conditions  from the collection. Behaves like  remove() , but deletes at most one document regardless of the  single  option.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_45", 
            "text": "Character . deleteOne ( {   name :   Eddard Stark   } ,   function   ( err )   {} );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_7", 
            "text": "Like  Model.remove() , this function does  not  trigger  pre('remove')  or  post('remove')  hooks.", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#modeldeletemany", 
            "text": "", 
            "title": "Model.deleteMany()"
        }, 
        {
            "location": "/api/#parameters_63", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_40", 
            "text": "Deletes all of the documents that match  conditions  from the collection. Behaves like  remove() , but deletes all documents that match  conditions  regardless of the  single  option.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_46", 
            "text": "Character . deleteMany ( {   name :   / Stark / ,   age :   {   $ gte :   18   }   } ,   function   ( err )   {} );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_8", 
            "text": "Like  Model.remove() , this function does  not  trigger  pre('remove')  or  post('remove')  hooks.", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#modelfind", 
            "text": "", 
            "title": "Model.find()"
        }, 
        {
            "location": "/api/#parameters_64", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_41", 
            "text": "Finds documents  The  conditions  are cast to their respective SchemaTypes before the command is sent.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples", 
            "text": "MyModel . find ( {   name :   john ,   age :   {   $ gte :   18   } } );  MyModel . find ( {   name :   john ,   age :   {   $ gte :   18   } } ,   function   ( err ,   docs )   {} );  MyModel . find ( {   name :   / john / i   } ,   name friends ,   function   ( err ,   docs )   {   } )  MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } )  MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } ,   function   ( err ,   docs )   {} );  var   query   =   MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } )  query . exec ( function   ( err ,   docs )   {} );  var   query   =   MyModel . find ( {   name :   / john / i   } ,   null ,   {   skip :   10   } );  var   promise   =   query . exec ();  promise . addBack ( function   ( err ,   docs )   {} );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#modelfindbyid", 
            "text": "", 
            "title": "Model.findById()"
        }, 
        {
            "location": "/api/#parameters_65", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_42", 
            "text": "Finds a single document by its _id field.  findById(id)  is almost* equivalent to  findOne({ _id: id }) . If you want to query by a document's  _id , use  findById()  instead of  findOne() .  The  id  is cast based on the Schema before sending the command.  This function triggers the following middleware.   Except for how it treats  undefined . If you use  findOne() , you'll see that  findOne(undefined)  and  findOne({ _id: undefined })  are equivalent to  findOne({})  and return arbitrary documents. However, mongoose translates  findById(undefined)  into  findOne({ _id: null }) .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_47", 
            "text": "Adventure . findById ( id ,   function   ( err ,   adventure )   {} );  Adventure . findById ( id ) . exec ( callback );  Adventure . findById ( id ,   name length ,   function   ( err ,   adventure )   {} );  Adventure . findById ( id ,   name length ) . exec ( callback );  Adventure . findById ( id ,   -length ) . exec ( function   ( err ,   adventure )   {} );  Adventure . findById ( id ,   name ,   {   lean :   true   } ,   function   ( err ,   doc )   {} );  Adventure . findById ( id ,   name ) . lean () . exec ( function   ( err ,   doc )   {} );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelfindone", 
            "text": "", 
            "title": "Model.findOne()"
        }, 
        {
            "location": "/api/#parameters_66", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_43", 
            "text": "Finds one document.  The  conditions  are cast to their respective SchemaTypes before the command is sent.  Note:   conditions  is optional, and if  conditions  is null or undefined, mongoose will send an empty  findOne  command to MongoDB, which will return an arbitrary document. If you're querying by  _id , use  findById()  instead.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_48", 
            "text": "Adventure . findOne ( {   type :   iphone   } ,   function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ) . exec ( function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ,   name ,   function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ,   name ) . exec ( function   ( err ,   adventure )   {} );  Adventure . findOne ( {   type :   iphone   } ,   name ,   {   lean :   true   } ,   callback );  Adventure . findOne ( {   type :   iphone   } ,   name ,   {   lean :   true   } ) . exec ( callback );  Adventure . findOne ( {   type :   iphone   } ) . select ( name ) . lean () . exec ( callback );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelcount", 
            "text": "", 
            "title": "Model.count()"
        }, 
        {
            "location": "/api/#parameters_67", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_44", 
            "text": "Counts number of matching documents in a database collection.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_49", 
            "text": "Adventure.count({ type:  jungle  }, function (err, count) {\n  if (err) ..\n  console.log( there are %d jungle adventures , count);\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modeldistinct", 
            "text": "", 
            "title": "Model.distinct()"
        }, 
        {
            "location": "/api/#parameters_68", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_45", 
            "text": "Creates a Query for a  distinct  operation.  Passing a  callback  immediately executes the query.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_50", 
            "text": "Link.distinct( url ,  {   clicks :   { $gt :   100 }} , function (err, result)  { \n   if   ( err )   return   handleError ( err ); \n\n   assert ( Array . isArray ( result )); \n   console . log ( unique urls with more than 100 clicks ,   result );  } )  var query = Link.distinct( url );  query.exec(callback);", 
            "title": "Example"
        }, 
        {
            "location": "/api/#modelwhere", 
            "text": "", 
            "title": "Model.where()"
        }, 
        {
            "location": "/api/#parameters_69", 
            "text": "[val] \u00abObject\u00bb optional value", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_46", 
            "text": "Creates a Query, applies the passed conditions, and returns the Query.  For example, instead of writing:  User . find ( { age :   {$ gte :   21 ,   $ lte :   65 } } ,   callback );   we can instead write:  User.where( age ).gte(21).lte(65).exec(callback);  Since the Query class also supports  where  you can continue chaining  User\n.where( age ).gte(21).lte(65)\n.where( name , /^b/i)\n... etc", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#modelprototypewhere_1", 
            "text": "", 
            "title": "Model.prototype.$where()"
        }, 
        {
            "location": "/api/#parameters_70", 
            "text": "argument \u00abString,Function\u00bb is a javascript string or anonymous function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_47", 
            "text": "Creates a  Query  and specifies a  $where  condition.  Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via  find({ $where: javascript }) , or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.  Blog.$where( this.username.indexOf( val ) !== -1 ).exec(function (err, docs) {});", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#modelfindoneandupdate", 
            "text": "", 
            "title": "Model.findOneAndUpdate()"
        }, 
        {
            "location": "/api/#parameters_71", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_48", 
            "text": "Issues a mongodb findAndModify update command.  Finds a matching document, updates it according to the  update  arg, passing any  options , and returns the found document (if any) to the callback. The query executes immediately if  callback  is passed else a Query object is returned.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#options_2", 
            "text": "new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)  upsert : bool - creates the object if it doesn't exist. defaults to false.  fields : {Object|String} - Field selection. Equivalent to  .select(fields).findOneAndUpdate()  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  runValidators : if true, runs  update validators  on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the  defaults  specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on  MongoDB's  $setOnInsert  operator .  rawResult : if true, returns the  raw result from the MongoDB driver  strict : overwrites the schema's  strict mode option  for this update", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#examples_1", 
            "text": "A.findOneAndUpdate(conditions, update, options, callback)\nA.findOneAndUpdate(conditions, update, options)\nA.findOneAndUpdate(conditions, update, callback)\nA.findOneAndUpdate(conditions, update)\nA.findOneAndUpdate()", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#note_9", 
            "text": "All top level update keys which are not  atomic  operation names are treated as set operations:", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#example_51", 
            "text": "var   query   =   {   name :   borne   } ;  Model . findOneAndUpdate ( query ,   {   name :   jason bourne   } ,   options ,   callback )  Model . findOneAndUpdate ( query ,   {   $ set :   {   name :   jason bourne   } } ,   options ,   callback )   This helps prevent accidentally overwriting your document with  { name: 'jason bourne' } .", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_10", 
            "text": "Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.   defaults. Use the  setDefaultsOnInsert  option to override.   findAndModify  helpers support limited validation. You can enable these by setting the  runValidators  options, respectively.  If you need full-fledged validation, use the traditional approach of first retrieving the document.  Model.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n});", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#modelfindbyidandupdate", 
            "text": "", 
            "title": "Model.findByIdAndUpdate()"
        }, 
        {
            "location": "/api/#parameters_72", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_49", 
            "text": "Issues a mongodb findAndModify update command by a document's _id field.  findByIdAndUpdate(id, ...)  is equivalent to  findOneAndUpdate({ _id: id }, ...) .  Finds a matching document, updates it according to the  update  arg, passing any  options , and returns the found document (if any) to the callback. The query executes immediately if  callback  is passed else a Query object is returned.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#options_3", 
            "text": "new : bool - true to return the modified document rather than the original. defaults to false  upsert : bool - creates the object if it doesn't exist. defaults to false.  runValidators : if true, runs  update validators  on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the  defaults  specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on  MongoDB's  $setOnInsert  operator .  sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  select : sets the document fields to return  rawResult : if true, returns the  raw result from the MongoDB driver  strict : overwrites the schema's  strict mode option  for this update", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#examples_2", 
            "text": "A.findByIdAndUpdate(id, update, options, callback)\nA.findByIdAndUpdate(id, update, options)\nA.findByIdAndUpdate(id, update, callback)\nA.findByIdAndUpdate(id, update)\nA.findByIdAndUpdate()", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#note_11", 
            "text": "All top level update keys which are not  atomic  operation names are treated as set operations:", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#example_52", 
            "text": "Model.findByIdAndUpdate(id, { name:  jason bourne  }, options, callback)\n\n\nModel.findByIdAndUpdate(id, { $set: { name:  jason bourne  }}, options, callback)  This helps prevent accidentally overwriting your document with  { name: 'jason bourne' } .", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_12", 
            "text": "Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.   defaults. Use the  setDefaultsOnInsert  option to override.   findAndModify  helpers support limited validation. You can enable these by setting the  runValidators  options, respectively.  If you need full-fledged validation, use the traditional approach of first retrieving the document.  Model.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n});", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#modelfindoneandremove", 
            "text": "", 
            "title": "Model.findOneAndRemove()"
        }, 
        {
            "location": "/api/#parameters_73", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_50", 
            "text": "Issue a mongodb findAndModify remove command.  Finds a matching document, removes it, passing the found document (if any) to the callback.  Executes immediately if  callback  is passed else a Query object is returned.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#options_4", 
            "text": "sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  select : sets the document fields to return  rawResult : if true, returns the  raw result from the MongoDB driver  strict : overwrites the schema's  strict mode option  for this update", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#examples_3", 
            "text": "A.findOneAndRemove(conditions, options, callback)\nA.findOneAndRemove(conditions, options)\nA.findOneAndRemove(conditions, callback)\nA.findOneAndRemove(conditions)\nA.findOneAndRemove()  Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.   defaults. Use the  setDefaultsOnInsert  option to override.   findAndModify  helpers support limited validation. You can enable these by setting the  runValidators  options, respectively.  If you need full-fledged validation, use the traditional approach of first retrieving the document.  Model.findById(id, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n});", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#modelfindbyidandremove", 
            "text": "", 
            "title": "Model.findByIdAndRemove()"
        }, 
        {
            "location": "/api/#parameters_74", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_51", 
            "text": "Issue a mongodb findAndModify remove command by a document's _id field.  findByIdAndRemove(id, ...)  is equivalent to  findOneAndRemove({ _id: id }, ...) .  Finds a matching document, removes it, passing the found document (if any) to the callback.  Executes immediately if  callback  is passed, else a  Query  object is returned.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#options_5", 
            "text": "sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  select : sets the document fields to return  rawResult : if true, returns the  raw result from the MongoDB driver  strict : overwrites the schema's  strict mode option  for this update", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#examples_4", 
            "text": "A.findByIdAndRemove(id, options, callback)\nA.findByIdAndRemove(id, options)\nA.findByIdAndRemove(id, callback)\nA.findByIdAndRemove(id)\nA.findByIdAndRemove()", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#modelcreate", 
            "text": "", 
            "title": "Model.create()"
        }, 
        {
            "location": "/api/#parameters_75", 
            "text": "[callback] \u00abFunction\u00bb callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_52", 
            "text": "Shortcut for saving one or more documents to the database.  MyModel.create(docs)  does  new MyModel(doc).save()  for every doc in docs.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_53", 
            "text": "Candy . create ( {   type :   jelly bean   } ,   {   type :   snickers   } ,   function   ( err ,   jellybean ,   snickers )   { \n   if   (err)  } );  var   array   =   [ {   type :   jelly bean   },   {   type :   snickers   } ] ;  Candy . create ( array ,   function   ( err ,   candies )   { \n   if   (err) \n\n   var   jellybean   =   candies [ 0 ] ; \n   var   snickers   =   candies [ 1 ] ;  } );  var   promise   =   Candy . create ( {   type :   jawbreaker   } );  promise . then ( function   ( jawbreaker )   {  } )", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelwatch", 
            "text": "", 
            "title": "Model.watch()"
        }, 
        {
            "location": "/api/#parameters_76", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_53", 
            "text": "\u00abChangeStream\u00bb mongoose-specific change stream wrapper   Requires a replica set running MongoDB  = 3.6.0.  Watches the underlying collection for changes using  MongoDB change streams .  This function does  not  trigger any middleware. In particular, it does  not  trigger aggregate middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_54", 
            "text": "const   doc   =   await   Person . create ( {   name :   Ned Stark   } );  Person . watch () . on ( change ,   change   =   console . log ( change ));  await   doc . remove ();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelinsertmany", 
            "text": "", 
            "title": "Model.insertMany()"
        }, 
        {
            "location": "/api/#parameters_77", 
            "text": "[callback] \u00abFunction\u00bb callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_54", 
            "text": "Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than  .create()  because it only sends one operation to the server, rather than one for each document.  Mongoose always validates each document  before  sending  insertMany  to MongoDB. So if one document has a validation error, no documents will be saved, unless you set  the  ordered  option to false .  This function does  not  trigger save middleware.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_55", 
            "text": "var   arr   =   [ {   name :   Star Wars   },   {   name :   The Empire Strikes Back   } ] ;  Movies . insertMany ( arr ,   function ( error ,   docs )   {} );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelbulkwrite", 
            "text": "", 
            "title": "Model.bulkWrite()"
        }, 
        {
            "location": "/api/#parameters_78", 
            "text": "[callback] \u00abFunction\u00bb callback  function(error, bulkWriteOpResult) {}", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_55", 
            "text": "\u00abPromise\u00bb resolves to a  BulkWriteOpResult  if the operation succeeds   Sends multiple  insertOne ,  updateOne ,  updateMany ,  replaceOne ,  deleteOne , and/or  deleteMany  operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use  create() ) because with  bulkWrite()  there is only one round trip to MongoDB.  Mongoose will perform casting on all operations you provide.  This function does  not  trigger any middleware, not  save()  nor  update() . If you need to trigger  save()  middleware for every document use  create()  instead.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_56", 
            "text": "Character.bulkWrite([\n  {\n    insertOne: {\n      document: {\n        name:  Eddard Stark ,\n        title:  Warden of the North \n      }\n    }\n  },\n  {\n    updateOne: {\n      filter: { name:  Eddard Stark  },\n\n\n\n      update: { title:  Hand of the King  }\n    }\n  },\n  {\n    deleteOne: {\n      {\n        filter: { name:  Eddard Stark  }\n      }\n    }\n  }\n]).then(handleResult);", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelhydrate", 
            "text": "", 
            "title": "Model.hydrate()"
        }, 
        {
            "location": "/api/#parameters_79", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_56", 
            "text": "\u00abModel\u00bb document instance   Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_57", 
            "text": "var   mongooseCandy   =   Candy . hydrate ( {   _id :   54108337212ffb6d459f854c ,   type :   jelly bean   } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelupdate", 
            "text": "", 
            "title": "Model.update()"
        }, 
        {
            "location": "/api/#parameters_80", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_57", 
            "text": "Updates one document in the database without returning it.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_5", 
            "text": "MyModel . update ( {   age :   {   $ gt :   18   }   } ,   {   oldEnough :   true   } ,   fn );  MyModel . update ( {   name :   Tobi   } ,   {   ferret :   true   } ,   {   multi :   true   } ,   function   ( err ,   raw )   { \n   if   (err)   return   handleError(err) ; \n   console.log( The   raw   response   from   Mongo   was   ,   raw) ;  } );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#valid-options_1", 
            "text": "safe  (boolean) safe mode (defaults to value set in schema (true))  upsert  (boolean) whether to create the doc if it doesn't match (false)  multi  (boolean) whether multiple documents should be updated (false)  runValidators : if true, runs  update validators  on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the  defaults  specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on  MongoDB's  $setOnInsert  operator .  strict  (boolean) overrides the  strict  option for this update  overwrite  (boolean) disables update-only mode, allowing you to overwrite the doc (false)   All  update  values are cast to their appropriate SchemaTypes before being sent.  The  callback  function receives  (err, rawResponse) .   err  is the error if any occurred  rawResponse  is the full response from Mongo", 
            "title": "Valid options:"
        }, 
        {
            "location": "/api/#note_13", 
            "text": "All top level keys which are not  atomic  operation names are treated as set operations:", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#example_58", 
            "text": "var   query   =   {   name :   borne   } ;  Model . update ( query ,   {   name :   jason bourne   } ,   options ,   callback )  Model . update ( query ,   {   $ set :   {   name :   jason bourne   } } ,   options ,   callback )   This helps prevent accidentally overwriting all documents in your collection with  { name: 'jason bourne' } .", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_14", 
            "text": "Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error.", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#note_15", 
            "text": "To update documents without waiting for a response from MongoDB, do not pass a  callback , then call  exec  on the returned  Query :  Comment . update ( {   _id :   id   } ,   {   $ set :   {   text :   changed   } } ) . exec ();", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#note_16", 
            "text": "Although values are casted to their appropriate types when using update, the following are  not  applied:   defaults  setters  validators  middleware   If you need those features, use the traditional approach of first retrieving the document.  Model.findOne({ name:  borne  }, function (err, doc) {\n  if (err) ..\n  doc.name =  jason bourne ;\n  doc.save(callback);\n})", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#modelupdatemany", 
            "text": "", 
            "title": "Model.updateMany()"
        }, 
        {
            "location": "/api/#parameters_81", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_58", 
            "text": "Same as  update() , except MongoDB will update  all  documents that match  criteria  (as opposed to just the first one) regardless of the value of the  multi  option.  Note  updateMany will  not  fire update middleware. Use  pre('updateMany')  and  post('updateMany')  instead.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#modelupdateone", 
            "text": "", 
            "title": "Model.updateOne()"
        }, 
        {
            "location": "/api/#parameters_82", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_59", 
            "text": "Same as  update() , except MongoDB will update  only  the first document that matches  criteria  regardless of the value of the  multi  option.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#modelreplaceone", 
            "text": "", 
            "title": "Model.replaceOne()"
        }, 
        {
            "location": "/api/#parameters_83", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_60", 
            "text": "Same as  update() , except MongoDB replace the existing document with the given document (no atomic operators like  $set ).  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#modelmapreduce", 
            "text": "", 
            "title": "Model.mapReduce()"
        }, 
        {
            "location": "/api/#parameters_84", 
            "text": "[callback] \u00abFunction\u00bb optional callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_61", 
            "text": "Executes a mapReduce command.  o  is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See  node-mongodb-native mapReduce() documentation  for more detail about options.  This function does not trigger any middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_59", 
            "text": "var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\nUser.mapReduce(o, function (err, results) {\n  console.log(results)\n})", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#other-options", 
            "text": "query  {Object} query filter object.  sort  {Object} sort input objects using this key  limit  {Number} max number of documents  keeptemp  {Boolean, default:false} keep temporary data  finalize  {Function} finalize function  scope  {Object} scope variables exposed to map/reduce/finalize during execution  jsMode  {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB   2.0.X  verbose  {Boolean, default:false} provide statistics on job execution time.  readPreference  {String}  out*  {Object, default: {inline:1}} sets the output target for the map reduce job.", 
            "title": "Other options:"
        }, 
        {
            "location": "/api/#out-options", 
            "text": "{inline:1}  the results are returned in an array  {replace: 'collectionName'}  add the results to collectionName: the results replace the collection  {reduce: 'collectionName'}  add the results to collectionName: if dups are detected, uses the reducer / finalize functions  {merge: 'collectionName'}  add the results to collectionName: if dups exist the new docs overwrite the old   If  options.out  is set to  replace ,  merge , or  reduce , a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the  lean  option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).", 
            "title": "* out options:"
        }, 
        {
            "location": "/api/#example_60", 
            "text": "var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\no.out = { replace:  createdCollectionNameForResults  }\no.verbose = true;\n\nUser.mapReduce(o, function (err, model, stats) {\n  console.log( map reduce took %d ms , stats.processtime)\n  model.find().where( value ).gt(10).exec(function (err, docs) {\n    console.log(docs);\n  });\n})\n\n\n\no.resolveToObject = true;\nvar promise = User.mapReduce(o);\npromise.then(function (res) {\n  var model = res.model;\n  var stats = res.stats;\n  console.log( map reduce took %d ms , stats.processtime)\n  return model.find().where( value ).gt(10).exec();\n}).then(function (docs) {\n   console.log(docs);\n}).then(null, handleError).end()", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#modelaggregate", 
            "text": "", 
            "title": "Model.aggregate()"
        }, 
        {
            "location": "/api/#parameters_85", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_62", 
            "text": "Performs  aggregations  on the models collection.  If a  callback  is passed, the  aggregate  is executed and a  Promise  is returned. If a callback is not passed, the  aggregate  itself is returned.  This function does not trigger any middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_61", 
            "text": "Users.aggregate(\n  { $group: { _id: null, maxBalance: { $max:  $balance  }}},\n  { $project: { _id: 0, maxBalance: 1 }},\n  function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n  });\n\n\nUsers.aggregate()\n  .group({ _id: null, maxBalance: { $max:  $balance  } })\n  .select( -id maxBalance )\n  .exec(function (err, res) {\n    if (err) return handleError(err);\n    console.log(res);\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_17", 
            "text": "Arguments are not cast to the model's schema because  $project  operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.  The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).  Requires MongoDB  = 2.1", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#modelgeosearch", 
            "text": "", 
            "title": "Model.geoSearch()"
        }, 
        {
            "location": "/api/#parameters_86", 
            "text": "[callback] \u00abFunction\u00bb optional callback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_63", 
            "text": "Implements  $geoSearch  functionality for Mongoose  This function does not trigger any middleware", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_62", 
            "text": "var   options   =   {   near :   [ 10 ,   10 ] ,   maxDistance :   5   } ;  Locations . geoSearch ( {   type   :   house   } ,   options ,   function ( err ,   res )   { \n   console.log(res) ;  } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#options_6", 
            "text": "near  {Array} x,y point to search for  maxDistance  {Number} the maximum distance from the point near that a result can be  limit  {Number} The maximum number of results to return  lean  {Boolean} return the raw object instead of the Mongoose Model", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#modelpopulate", 
            "text": "", 
            "title": "Model.populate()"
        }, 
        {
            "location": "/api/#parameters_87", 
            "text": "[callback(err,doc)] \u00abFunction\u00bb Optional callback, executed upon completion. Receives  err  and the  doc(s) .", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_64", 
            "text": "Populates document references.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#available-options", 
            "text": "path: space delimited path(s) to populate  select: optional fields to select  match: optional query conditions to match  model: optional name of the model to use for population  options: optional query options like sort, limit, etc", 
            "title": "Available options:"
        }, 
        {
            "location": "/api/#examples_6", 
            "text": "User.findById(id, function (err, user) {\n  var opts = [\n      { path:  company , match: { x: 1 }, select:  name  }\n    , { path:  notes , options: { limit: 10 }, model:  override  }\n  ]\n\n  User.populate(user, opts, function (err, user) {\n    console.log(user);\n  });\n});\n\n\nUser.find(match, function (err, users) {\n  var opts = [{ path:  company , match: { x: 1 }, select:  name  }]\n\n  var promise = User.populate(users, opts);\n  promise.then(console.log).end();\n})\n\n\n\n\n\n\n\n\n\n\nvar user = { name:  Indiana Jones , weapon: 389 }\nWeapon.populate(user, { path:  weapon , model:  Weapon  }, function (err, user) {\n  console.log(user.weapon.name)\n})\n\n\nvar users = [{ name:  Indiana Jones , weapon: 389 }]\nusers.push({ name:  Batman , weapon: 8921 })\nWeapon.populate(users, { path:  weapon  }, function (err, users) {\n  users.forEach(function (user) {\n    console.log( %s uses a %s , users.name, user.weapon.name)\n\n\n  });\n});", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#query", 
            "text": "", 
            "title": "Query()"
        }, 
        {
            "location": "/api/#parameters_88", 
            "text": "[collection] \u00abObject\u00bb Mongoose collection   Query constructor used for building queries. You do not need to instantiate a  Query  directly. Instead use Model functions like  Model.find() .", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_63", 
            "text": "const query = MyModel.find();\nquery.setOptions({ lean : true });\nquery.collection(model.collection);\nquery.where( age ).gte(21).exec(callback);\n\n\n\nconst query = new mongoose.Query();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypeusegeowithin", 
            "text": "Flag to opt out of using  $geoWithin .  mongoose.Query.use$geoWithin = false;  MongoDB 2.4 deprecated the use of  $within , replacing it with  $geoWithin . Mongoose uses  $geoWithin  by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to  false  so your  within()  queries continue to work.", 
            "title": "Query.prototype.use$geoWithin"
        }, 
        {
            "location": "/api/#queryprototypetoconstructor", 
            "text": "", 
            "title": "Query.prototype.toConstructor()"
        }, 
        {
            "location": "/api/#returns_65", 
            "text": "\u00abQuery\u00bb subclass-of-Query   Converts this query to a customized, reusable query constructor with all arguments and options retained.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_64", 
            "text": "var   query   =   Movie . find ( {   tags :   adventure   } ) . read ( primaryPreferred );  var   Adventure   =   query . toConstructor ();  Adventure () . exec ( callback )  Adventure () . where ( {   name :   /^ Life /   } ) . exec ( callback );  Adventure . prototype . startsWith   =   function   ( prefix )   { \n   this.where({   name :   new   RegExp ( ^   +   prefix )   } ) \n   return   this ;  }  Object . defineProperty ( Adventure . prototype ,   highlyRated ,   { \n   get :   function   ()   { \n     this . where ( {   rating :   {   $ gt :   4.5   }} ); \n     return   this ; \n   }  } )  Adventure () . highlyRated . startsWith ( Life ) . exec ( callback )   New in 3.7.3", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypewhere", 
            "text": "", 
            "title": "Query.prototype.$where()"
        }, 
        {
            "location": "/api/#parameters_89", 
            "text": "js \u00abString,Function\u00bb javascript string or function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_66", 
            "text": "Specifies a javascript function or expression to pass to MongoDBs query system.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_65", 
            "text": "query.$where( this.comments.length === 10 || this.name.length === 5 )\n\n\n\nquery.$where(function () {\n  return this.comments.length === 10 || this.name.length === 5;\n})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_18", 
            "text": "Only use  $where  when you have a condition that cannot be met using other MongoDB operators like  $lt .  Be sure to read about all of  its caveats  before using.", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#queryprototypewhere_1", 
            "text": "", 
            "title": "Query.prototype.where()"
        }, 
        {
            "location": "/api/#parameters_90", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_67", 
            "text": "Specifies a  path  for use with chaining.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_66", 
            "text": "User . find ( { age :   {$ gte :   21 ,   $ lte :   65 } } ,   callback );  User . where ( age ) . gte ( 21 ) . lte ( 65 );  User . find () . where ( {   name :   vonderful   } )  User  . where ( age ) . gte ( 21 ) . lte ( 65 )  . where ( name ,   /^ vonderful / i )  . where ( friends ) . slice ( 10 )  . exec ( callback )", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypeequals", 
            "text": "", 
            "title": "Query.prototype.equals()"
        }, 
        {
            "location": "/api/#parameters_91", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_68", 
            "text": "Specifies the complementary comparison value for paths specified with  where()", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_67", 
            "text": "User.where( age ).equals(49);\n\n\n\nUser.where( age , 49);", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypeor", 
            "text": "", 
            "title": "Query.prototype.or()"
        }, 
        {
            "location": "/api/#parameters_92", 
            "text": "array \u00abArray\u00bb array of conditions", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_69", 
            "text": "Specifies arguments for an  $or  condition.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_68", 
            "text": "query.or([{ color:  red  }, { status:  emergency  }])", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypenor", 
            "text": "", 
            "title": "Query.prototype.nor()"
        }, 
        {
            "location": "/api/#parameters_93", 
            "text": "array \u00abArray\u00bb array of conditions", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_70", 
            "text": "Specifies arguments for a  $nor  condition.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_69", 
            "text": "query.nor([{ color:  green  }, { status:  ok  }])", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypeand", 
            "text": "", 
            "title": "Query.prototype.and()"
        }, 
        {
            "location": "/api/#parameters_94", 
            "text": "array \u00abArray\u00bb array of conditions", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_71", 
            "text": "Specifies arguments for a  $and  condition.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_70", 
            "text": "query.and([{ color:  green  }, { status:  ok  }])", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypegt", 
            "text": "", 
            "title": "Query.prototype.gt()"
        }, 
        {
            "location": "/api/#parameters_95", 
            "text": "Specifies a $gt query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_71", 
            "text": "Thing.find().where( age ).gt(21)\n\n\nThing.find().gt( age , 21)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypegte", 
            "text": "", 
            "title": "Query.prototype.gte()"
        }, 
        {
            "location": "/api/#parameters_96", 
            "text": "Specifies a $gte query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypelt", 
            "text": "", 
            "title": "Query.prototype.lt()"
        }, 
        {
            "location": "/api/#parameters_97", 
            "text": "Specifies a $lt query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypelte", 
            "text": "", 
            "title": "Query.prototype.lte()"
        }, 
        {
            "location": "/api/#parameters_98", 
            "text": "Specifies a $lte query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypene", 
            "text": "", 
            "title": "Query.prototype.ne()"
        }, 
        {
            "location": "/api/#parameters_99", 
            "text": "Specifies a $ne query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypein", 
            "text": "", 
            "title": "Query.prototype.in()"
        }, 
        {
            "location": "/api/#parameters_100", 
            "text": "Specifies an $in query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypenin", 
            "text": "", 
            "title": "Query.prototype.nin()"
        }, 
        {
            "location": "/api/#parameters_101", 
            "text": "Specifies an $nin query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypeall", 
            "text": "", 
            "title": "Query.prototype.all()"
        }, 
        {
            "location": "/api/#parameters_102", 
            "text": "Specifies an $all query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypesize", 
            "text": "", 
            "title": "Query.prototype.size()"
        }, 
        {
            "location": "/api/#parameters_103", 
            "text": "Specifies a $size query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_72", 
            "text": "MyModel.where( tags ).size(0).exec(function (err, docs) {\n  if (err) return handleError(err);\n\n  assert(Array.isArray(docs));\n  console.log( documents with 0 tags , docs);\n})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototyperegex", 
            "text": "", 
            "title": "Query.prototype.regex()"
        }, 
        {
            "location": "/api/#parameters_104", 
            "text": "Specifies a $regex query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypemaxdistance", 
            "text": "", 
            "title": "Query.prototype.maxDistance()"
        }, 
        {
            "location": "/api/#parameters_105", 
            "text": "Specifies a $maxDistance query condition.  When called with one argument, the most recent path passed to  where()  is used.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypemod", 
            "text": "", 
            "title": "Query.prototype.mod()"
        }, 
        {
            "location": "/api/#parameters_106", 
            "text": "val \u00abArray\u00bb must be of length 2, first element is  divisor , 2nd element is  remainder .", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_72", 
            "text": "Specifies a  $mod  condition, filters documents for documents whose  path  property is a number that is equal to  remainder  modulo  divisor .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_73", 
            "text": "Product.find().mod( inventory , [2, 1]);\nProduct.find().where( inventory ).mod([2, 1]);\n\nProduct.find().where( inventory ).mod(2, 1);", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypeexists", 
            "text": "", 
            "title": "Query.prototype.exists()"
        }, 
        {
            "location": "/api/#parameters_107", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_73", 
            "text": "Specifies an  $exists  condition", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_74", 
            "text": "Thing.where( name ).exists()\nThing.where( name ).exists(true)\nThing.find().exists( name )\n\n\nThing.where( name ).exists(false);\nThing.find().exists( name , false);", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypeelemmatch", 
            "text": "", 
            "title": "Query.prototype.elemMatch()"
        }, 
        {
            "location": "/api/#parameters_108", 
            "text": "criteria \u00abObject,Function\u00bb", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_74", 
            "text": "Specifies an  $elemMatch  condition", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_75", 
            "text": "query . elemMatch ( comment ,   {   author :   autobot ,   votes :   {$ gte :   5 } } )  query . where ( comment ) . elemMatch ( {   author :   autobot ,   votes :   {$ gte :   5 } } )  query . elemMatch ( comment ,   function   ( elem )   { \n   elem.where( author ).equals( autobot ) ; \n   elem.where( votes ).gte(5) ;  } )  query . where ( comment ) . elemMatch ( function   ( elem )   { \n   elem.where({   author :   autobot   } ); \n   elem . where ( votes ) . gte ( 5 );  } )", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypewithin", 
            "text": "", 
            "title": "Query.prototype.within()"
        }, 
        {
            "location": "/api/#returns_75", 
            "text": "Defines a  $within  or  $geoWithin  argument for geo-spatial queries.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_76", 
            "text": "query . where ( path ) . within () . box ()  query . where ( path ) . within () . circle ()  query . where ( path ) . within () . geometry ()  query . where ( loc ) . within ( {   center :   [ 50 , 50 ] ,   radius :   10 ,   unique :   true ,   spherical :   true   } );  query . where ( loc ) . within ( {   box :   [ [ 40.73 ,   - 73.9 ] ,   [ 40.7 ,   - 73.988 ] ]   } );  query . where ( loc ) . within ( {   polygon :   [ [ ] , [] , [] , [] ]   } );  query . where ( loc ) . within ( [] ,   [] ,   [] )  query . where ( loc ) . within ( [] ,   [] )  query . where ( loc ) . within ( {   type :   LineString ,   coordinates :   [ ... ]   } );   MUST  be used after  where() .", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_19", 
            "text": "As of Mongoose 3.7,  $geoWithin  is always used for queries. To change this behavior, see  Query.use$geoWithin .", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#note_20", 
            "text": "In Mongoose 3.7,  within  changed from a getter to a function. If you need the old syntax, use  this .", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#queryprototypeslice", 
            "text": "", 
            "title": "Query.prototype.slice()"
        }, 
        {
            "location": "/api/#parameters_109", 
            "text": "val \u00abNumber\u00bb number/range of elements to slice", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_76", 
            "text": "Specifies a $slice projection for an array.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_77", 
            "text": "query.slice( comments , 5)\nquery.slice( comments , -5)\nquery.slice( comments , [10, 5])\nquery.where( comments ).slice(5)\nquery.where( comments ).slice([-10, 5])", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypelimit", 
            "text": "", 
            "title": "Query.prototype.limit()"
        }, 
        {
            "location": "/api/#parameters_110", 
            "text": "Specifies the maximum number of documents the query will return.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_78", 
            "text": "query.limit(20)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_21", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypeskip", 
            "text": "", 
            "title": "Query.prototype.skip()"
        }, 
        {
            "location": "/api/#parameters_111", 
            "text": "Specifies the number of documents to skip.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_79", 
            "text": "query.skip(100).limit(20)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_22", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypemaxscan", 
            "text": "", 
            "title": "Query.prototype.maxScan()"
        }, 
        {
            "location": "/api/#parameters_112", 
            "text": "Specifies the maxScan option.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_80", 
            "text": "query.maxScan(100)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_23", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypebatchsize", 
            "text": "", 
            "title": "Query.prototype.batchSize()"
        }, 
        {
            "location": "/api/#parameters_113", 
            "text": "Specifies the batchSize option.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_81", 
            "text": "query.batchSize(100)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_24", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#parameters_114", 
            "text": "Specifies the  comment  option.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_82", 
            "text": "query.comment( login query )", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_25", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypesnapshot", 
            "text": "", 
            "title": "Query.prototype.snapshot()"
        }, 
        {
            "location": "/api/#returns_77", 
            "text": "Specifies this query as a  snapshot  query.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_83", 
            "text": "query.snapshot()\nquery.snapshot(true)\nquery.snapshot(false)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_26", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypehint", 
            "text": "", 
            "title": "Query.prototype.hint()"
        }, 
        {
            "location": "/api/#parameters_115", 
            "text": "val \u00abObject\u00bb a hint object", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_78", 
            "text": "Sets query hints.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_84", 
            "text": "query.hint({ indexA: 1, indexB: -1})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_27", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypeselect", 
            "text": "", 
            "title": "Query.prototype.select()"
        }, 
        {
            "location": "/api/#parameters_116", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_79", 
            "text": "Specifies which document fields to include or exclude (also known as the query \"projection\")  When using string syntax, prefixing a path with  -  will flag that path as excluded. When a path does not have the  -  prefix, it is included. Lastly, if a path is prefixed with  + , it forces inclusion of the path, which is useful for paths excluded at the  schema level .  A projection  must  be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The  _id  field is the only exception because MongoDB includes it by default .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_85", 
            "text": "query . select ( a b );  query . select ( -c -d );  query . select ( {   a :   1 ,   b :   1   } );  query . select ( {   c :   0 ,   d :   0   } );  query . select ( +path )", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypeslaveok", 
            "text": "", 
            "title": "Query.prototype.slaveOk()"
        }, 
        {
            "location": "/api/#parameters_117", 
            "text": "v \u00abBoolean\u00bb defaults to true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_80", 
            "text": "DEPRECATED  Sets the slaveOk option.  Deprecated  in MongoDB 2.2 in favor of  read preferences .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_86", 
            "text": "query.slaveOk()\nquery.slaveOk(true)\nquery.slaveOk(false)", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototyperead", 
            "text": "", 
            "title": "Query.prototype.read()"
        }, 
        {
            "location": "/api/#parameters_118", 
            "text": "[tags] \u00abArray\u00bb optional tags for this query", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_81", 
            "text": "Determines the MongoDB nodes from which to read.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#preferences", 
            "text": "primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\nsecondary            Read from secondary if available, otherwise error.\nprimaryPreferred     Read from primary if available, otherwise a secondary.\nsecondaryPreferred   Read from a secondary if available, otherwise read from the primary.\nnearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.  Aliases  p   primary\npp  primaryPreferred\ns   secondary\nsp  secondaryPreferred\nn   nearest", 
            "title": "Preferences:"
        }, 
        {
            "location": "/api/#example_87", 
            "text": "new Query().read( primary )\nnew Query().read( p )\n\nnew Query().read( primaryPreferred )\nnew Query().read( pp )\n\nnew Query().read( secondary )\nnew Query().read( s )\n\nnew Query().read( secondaryPreferred )\nnew Query().read( sp )\n\nnew Query().read( nearest )\nnew Query().read( n )\n\n\nnew Query().read( s , [{ dc: sf , s: 1 },{ dc: ma , s: 2 }])  Read more about how to use read preferrences  here  and  here .", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypemerge", 
            "text": "", 
            "title": "Query.prototype.merge()"
        }, 
        {
            "location": "/api/#parameters_119", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_82", 
            "text": "Merges another Query or conditions object into this one.  When a Query is passed, conditions, field selection and options are merged.  New in 3.7.0", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypesetoptions", 
            "text": "", 
            "title": "Query.prototype.setOptions()"
        }, 
        {
            "location": "/api/#parameters_120", 
            "text": "Sets query options. Some options only make sense for certain operations.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#options_7", 
            "text": "The following options are only for  find() : -  tailable  -  sort  -  limit  -  skip  -  maxscan  -  batchSize  -  comment  -  snapshot  -  readPreference  -  hint  The following options are only for  update() ,  updateOne() ,  updateMany() ,  replaceOne() ,  findOneAndUpdate() , and  findByIdAndUpdate() : -  upsert  -  writeConcern  The following options are only for  find() ,  findOne() ,  findById() ,  findOneAndUpdate() ,  findByIdAndUpdate() , and  geoSearch() : -  lean", 
            "title": "Options:"
        }, 
        {
            "location": "/api/#the-following-options-are-for-all-operations", 
            "text": "", 
            "title": "The following options are for all operations"
        }, 
        {
            "location": "/api/#queryprototypegetquery", 
            "text": "", 
            "title": "Query.prototype.getQuery()"
        }, 
        {
            "location": "/api/#returns_83", 
            "text": "\u00abObject\u00bb current query conditions   Returns the current query conditions as a JSON object.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_88", 
            "text": "var   query   =   new   Query ();  query . find ( {   a :   1   } ) . where ( b ) . gt ( 2 );  query . getQuery ();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypegetupdate", 
            "text": "", 
            "title": "Query.prototype.getUpdate()"
        }, 
        {
            "location": "/api/#returns_84", 
            "text": "\u00abObject\u00bb current update operations   Returns the current update operations as a JSON object.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_89", 
            "text": "var   query   =   new   Query ();  query . update ( {} ,   {   $ set :   {   a :   5   }   } );  query . getUpdate ();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypelean", 
            "text": "", 
            "title": "Query.prototype.lean()"
        }, 
        {
            "location": "/api/#parameters_121", 
            "text": "bool \u00abBoolean,Object\u00bb defaults to true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_85", 
            "text": "Sets the lean option.  Documents returned from queries with the  lean  option enabled are plain javascript objects, not  MongooseDocuments . They have no  save  method, getters/setters or other Mongoose magic applied.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_90", 
            "text": "new Query().lean()\nnew Query().lean(true)\nnew Query().lean(false)\n\nModel.find().lean().exec(function (err, docs) {\n  docs[0] instanceof mongoose.Document\n});  This is a  great  option in high-performance read-only scenarios, especially when combined with  stream .", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypeerror", 
            "text": "", 
            "title": "Query.prototype.error()"
        }, 
        {
            "location": "/api/#parameters_122", 
            "text": "err \u00abError,null\u00bb if set,  exec()  will fail fast before sending the query to MongoDB   Gets/sets the error flag on this query. If this flag is not null or undefined, the  exec()  promise will reject without executing.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_91", 
            "text": "Query().error();\nQuery().error(null);\nQuery().error(new Error( test ));\nSchema.pre( find , function() {\n  if (!this.getQuery().userId) {\n    this.error(new Error( Not allowed to query without setting userId ));\n  }\n});  Note that query casting runs  after  hooks, so cast errors will override custom errors.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#example_92", 
            "text": "var   TestSchema   =   new   Schema ( {   num :   Number   } );  var   TestModel   =   db . model ( Test ,   TestSchema );  TestModel . find ( {   num :   not a number   } ) . error ( new   Error ( woops )) . exec ( function ( error )   {  } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypemongooseoptions", 
            "text": "", 
            "title": "Query.prototype.mongooseOptions()"
        }, 
        {
            "location": "/api/#parameters_123", 
            "text": "options \u00abObject\u00bb if specified, overwrites the current options   Getter/setter around the current mongoose-specific options for this query (populate, lean, etc.)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#queryprototypefind", 
            "text": "", 
            "title": "Query.prototype.find()"
        }, 
        {
            "location": "/api/#parameters_124", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_86", 
            "text": "Finds documents.  When no  callback  is passed, the query is not executed. When the query is executed, the result will be an array of documents.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_93", 
            "text": "query.find({ name:  Los Pollos Hermanos  }).find(callback)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypemerge_1", 
            "text": "", 
            "title": "Query.prototype.merge()"
        }, 
        {
            "location": "/api/#parameters_125", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_87", 
            "text": "Merges another Query or conditions object into this one.  When a Query is passed, conditions, field selection and options are merged.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypecollation", 
            "text": "", 
            "title": "Query.prototype.collation()"
        }, 
        {
            "location": "/api/#parameters_126", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_88", 
            "text": "Adds a collation to this op (MongoDB 3.4 and up)", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypefindone", 
            "text": "", 
            "title": "Query.prototype.findOne()"
        }, 
        {
            "location": "/api/#parameters_127", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, document)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_89", 
            "text": "Declares the query a findOne operation. When executed, the first found document is passed to the callback.  Passing a  callback  executes the query. The result of the query is a single document.   Note:   conditions  is optional, and if  conditions  is null or undefined, mongoose will send an empty  findOne  command to MongoDB, which will return an arbitrary document. If you're querying by  _id , use  Model.findById()  instead.   This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_94", 
            "text": "var   query    =   Kitten . where ( {   color :   white   } );  query . findOne ( function   ( err ,   kitten )   { \n   if   (err)   return   handleError(err) ; \n   if   (kitten)   { \n\n   }  } );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypecount", 
            "text": "", 
            "title": "Query.prototype.count()"
        }, 
        {
            "location": "/api/#parameters_128", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, count)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_90", 
            "text": "Specifying this query as a  count  query.  Passing a  callback  executes the query.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_95", 
            "text": "var countQuery = model.where({  color :  black  }).count();\n\nquery.count({ color:  black  }).count(callback)\n\nquery.count({ color:  black  }, callback)\n\nquery.where( color ,  black ).count(function (err, count) {\n  if (err) return handleError(err);\n  console.log( there are %d kittens , count);\n})", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypedistinct", 
            "text": "", 
            "title": "Query.prototype.distinct()"
        }, 
        {
            "location": "/api/#parameters_129", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, arr)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_91", 
            "text": "Declares or executes a distict() operation.  Passing a  callback  executes the query.  This function does not trigger any middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_96", 
            "text": "distinct(field, conditions, callback)\ndistinct(field, conditions)\ndistinct(field, callback)\ndistinct(field)\ndistinct(callback)\ndistinct()", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypesort", 
            "text": "", 
            "title": "Query.prototype.sort()"
        }, 
        {
            "location": "/api/#parameters_130", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_92", 
            "text": "Sets the sort order  If an object is passed, values allowed are  asc ,  desc ,  ascending ,  descending ,  1 , and  -1 .  If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with  -  which will be treated as descending.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_97", 
            "text": "query . sort ( {   field :   asc ,   test :   -1   } );  query . sort ( field -test );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_28", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototyperemove", 
            "text": "", 
            "title": "Query.prototype.remove()"
        }, 
        {
            "location": "/api/#parameters_131", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_93", 
            "text": "Declare and/or execute this query as a remove() operation.  This function does not trigger any middleware", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_98", 
            "text": "Model.remove({ artist:  Anne Murray  }, callback)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_29", 
            "text": "The operation is only executed when a callback is passed. To force execution without a callback, you must first call  remove()  and then execute it by using the  exec()  method.  var query = Model.find().remove({ name:  Anne Murray  })\n\n\nquery.remove({ name:  Anne Murray  }, callback)\nquery.remove({ name:  Anne Murray  }).remove(callback)\n\n\nquery.exec()\n\n\nquery.remove(conds, fn);\nquery.remove(conds)\nquery.remove(fn)\nquery.remove()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypedeleteone", 
            "text": "", 
            "title": "Query.prototype.deleteOne()"
        }, 
        {
            "location": "/api/#parameters_132", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_94", 
            "text": "Declare and/or execute this query as a  deleteOne()  operation. Works like remove, except it deletes at most one document regardless of the  single  option.  This function does not trigger any middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_99", 
            "text": "Character.deleteOne({ name:  Eddard Stark  }, callback)\nCharacter.deleteOne({ name:  Eddard Stark  }).then(next)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypedeletemany", 
            "text": "", 
            "title": "Query.prototype.deleteMany()"
        }, 
        {
            "location": "/api/#parameters_133", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_95", 
            "text": "Declare and/or execute this query as a  deleteMany()  operation. Works like remove, except it deletes  every  document that matches  criteria  in the collection, regardless of the value of  single .  This function does not trigger any middleware", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_100", 
            "text": "Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)\nCharacter.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypefindoneandupdate", 
            "text": "", 
            "title": "Query.prototype.findOneAndUpdate()"
        }, 
        {
            "location": "/api/#parameters_134", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, doc),  unless   rawResult  is used, in which case params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_96", 
            "text": "Issues a mongodb  findAndModify  update command.  Finds a matching document, updates it according to the  update  arg, passing any  options , and returns the found document (if any) to the callback. The query executes immediately if  callback  is passed.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#available-options_1", 
            "text": "new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)  upsert : bool - creates the object if it doesn't exist. defaults to false.  fields : {Object|String} - Field selection. Equivalent to  .select(fields).findOneAndUpdate()  sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  runValidators : if true, runs  update validators  on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the  defaults  specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on  MongoDB's  $setOnInsert  operator .  rawResult : if true, returns the  raw result from the MongoDB driver  context  (string) if set to 'query' and  runValidators  is on,  this  will refer to the query in custom validator functions that update validation runs. Does nothing if  runValidators  is false.", 
            "title": "Available options"
        }, 
        {
            "location": "/api/#callback-signature", 
            "text": "function(error, doc) {\n\n\n}", 
            "title": "Callback Signature"
        }, 
        {
            "location": "/api/#examples_7", 
            "text": "query.findOneAndUpdate(conditions, update, options, callback)\nquery.findOneAndUpdate(conditions, update, options)\nquery.findOneAndUpdate(conditions, update, callback)\nquery.findOneAndUpdate(conditions, update)\nquery.findOneAndUpdate(update, callback)\nquery.findOneAndUpdate(update)\nquery.findOneAndUpdate(callback)\nquery.findOneAndUpdate()", 
            "title": "Examples"
        }, 
        {
            "location": "/api/#queryprototypefindoneandremove", 
            "text": "", 
            "title": "Query.prototype.findOneAndRemove()"
        }, 
        {
            "location": "/api/#parameters_135", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, document)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_97", 
            "text": "Issues a mongodb  findAndModify  remove command.  Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if  callback  is passed.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#available-options_2", 
            "text": "sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update  maxTimeMS : puts a time limit on the query - requires mongodb  = 2.6.0  rawResult : if true, resolves to the  raw result from the MongoDB driver", 
            "title": "Available options"
        }, 
        {
            "location": "/api/#callback-signature_1", 
            "text": "function(error, doc) {\n\n\n}", 
            "title": "Callback Signature"
        }, 
        {
            "location": "/api/#examples_8", 
            "text": "A.where().findOneAndRemove(conditions, options, callback)\nA.where().findOneAndRemove(conditions, options)\nA.where().findOneAndRemove(conditions, callback)\nA.where().findOneAndRemove(conditions)\nA.where().findOneAndRemove(callback)\nA.where().findOneAndRemove()", 
            "title": "Examples"
        }, 
        {
            "location": "/api/#queryprototypeupdate", 
            "text": "", 
            "title": "Query.prototype.update()"
        }, 
        {
            "location": "/api/#parameters_136", 
            "text": "[callback] \u00abFunction\u00bb optional, params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_98", 
            "text": "Declare and/or execute this query as an update() operation.  All paths passed that are not $atomic operations will become $set ops.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_101", 
            "text": "Model.where({ _id: id }).update({ title:  words  })\n\n\n\nModel.where({ _id: id }).update({ $set: { title:  words  }})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#valid-options_2", 
            "text": "safe  (boolean) safe mode (defaults to value set in schema (true))  upsert  (boolean) whether to create the doc if it doesn't match (false)  multi  (boolean) whether multiple documents should be updated (false)  runValidators : if true, runs  update validators  on this command. Update validators validate the update operation against the model's schema.  setDefaultsOnInsert : if this and  upsert  are true, mongoose will apply the  defaults  specified in the model's schema if a new document is created. This option only works on MongoDB  = 2.4 because it relies on  MongoDB's  $setOnInsert  operator .  strict  (boolean) overrides the  strict  option for this update  overwrite  (boolean) disables update-only mode, allowing you to overwrite the doc (false)  context  (string) if set to 'query' and  runValidators  is on,  this  will refer to the query in custom validator functions that update validation runs. Does nothing if  runValidators  is false.", 
            "title": "Valid options:"
        }, 
        {
            "location": "/api/#note_30", 
            "text": "Passing an empty object  {}  as the doc will result in a no-op unless the  overwrite  option is passed. Without the  overwrite  option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.", 
            "title": "Note"
        }, 
        {
            "location": "/api/#note_31", 
            "text": "The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the  exec()  method.  var   q   =   Model . where ( {   _id :   id   } );  q . update ( {   $ set :   {   name :   bob   } } ) . update ();   //   not   executed  q . update ( {   $ set :   {   name :   bob   } } ) . exec ();   //   executed  //   keys   that   are   not   $ atomic   ops   become   $ set .  //   this   executes   the   same   command   as   the   previous   example .  q . update ( {   name :   bob   } ) . exec ();  //   overwriting   with   empty   docs  var   q   =   Model . where ( {   _id :   id   } ) . setOptions ( {   overwrite :   true   } )  q . update ( {   } ,   callback );   //   executes  //   multi   update   with   overwrite   to   empty   doc  var   q   =   Model . where ( {   _id :   id   } );  q . setOptions ( {   multi :   true ,   overwrite :   true   } )  q . update ( {   } );  q . update ( callback );   //   executed  //   multi   updates  Model . where () \n      . update ( {   name :   /^ match /   } ,   {   $ set :   {   arr :   []   } } ,   {   multi :   true   } ,   callback )  //   more   multi   updates  Model . where () \n      . setOptions ( {   multi :   true   } ) \n      . update ( {   $ set :   {   arr :   []   } } ,   callback )  //   single   update   by   default  Model . where ( {   email :   [ address @ example.com ][ 210 ]   } ) \n      . update ( {   $ inc :   {   counter :   1   } } ,   callback )   API summary  update(criteria, doc, options, cb)\nupdate(criteria, doc, options)\nupdate(criteria, doc, cb)\nupdate(criteria, doc)\nupdate(doc, cb)\nupdate(doc)\nupdate(cb)\nupdate(true)\nupdate()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypeupdatemany", 
            "text": "", 
            "title": "Query.prototype.updateMany()"
        }, 
        {
            "location": "/api/#parameters_137", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_99", 
            "text": "Declare and/or execute this query as an updateMany() operation. Same as  update() , except MongoDB will update  all  documents that match  criteria  (as opposed to just the first one) regardless of the value of the  multi  option.  Note  updateMany will  not  fire update middleware. Use  pre('updateMany')  and  post('updateMany')  instead.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypeupdateone", 
            "text": "", 
            "title": "Query.prototype.updateOne()"
        }, 
        {
            "location": "/api/#parameters_138", 
            "text": "[callback] \u00abFunction\u00bb params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_100", 
            "text": "Declare and/or execute this query as an updateOne() operation. Same as  update() , except MongoDB will update  only  the first document that matches  criteria  regardless of the value of the  multi  option.  Note  updateOne will  not  fire update middleware. Use  pre('updateOne')  and  post('updateOne')  instead.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypereplaceone", 
            "text": "", 
            "title": "Query.prototype.replaceOne()"
        }, 
        {
            "location": "/api/#parameters_139", 
            "text": "[callback] \u00abFunction\u00bb optional params are (error, writeOpResult)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_101", 
            "text": "Declare and/or execute this query as a replaceOne() operation. Same as  update() , except MongoDB will replace the existing document and will not accept any atomic operators ( $set , etc.)  Note  replaceOne will  not  fire update middleware. Use  pre('replaceOne')  and  post('replaceOne')  instead.  This function triggers the following middleware.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypeexec", 
            "text": "", 
            "title": "Query.prototype.exec()"
        }, 
        {
            "location": "/api/#parameters_140", 
            "text": "[callback] \u00abFunction\u00bb optional params depend on the function being called", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_102", 
            "text": "Executes the query", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_9", 
            "text": "var promise = query.exec();\nvar promise = query.exec( update );\n\nquery.exec(callback);\nquery.exec( find , callback);", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#queryprototypethen", 
            "text": "", 
            "title": "Query.prototype.then()"
        }, 
        {
            "location": "/api/#parameters_141", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_103", 
            "text": "Executes the query returning a  Promise  which will be resolved with either the doc(s) or rejected with the error.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypecatch", 
            "text": "", 
            "title": "Query.prototype.catch()"
        }, 
        {
            "location": "/api/#parameters_142", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_104", 
            "text": "Executes the query returning a  Promise  which will be resolved with either the doc(s) or rejected with the error. Like  .then() , but only takes a rejection handler.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypepopulate", 
            "text": "", 
            "title": "Query.prototype.populate()"
        }, 
        {
            "location": "/api/#parameters_143", 
            "text": "[options] \u00abObject\u00bb Options for the population query (sort, etc)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_105", 
            "text": "Specifies paths which should be populated with other documents.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_102", 
            "text": "Kitten.findOne().populate( owner ).exec(function (err, kitten) {\n  console.log(kitten.owner.name)\n})\n\nKitten.find().populate({\n    path:  owner \n  , select:  name \n  , match: { color:  black  }\n  , options: { sort: { name: -1 }}\n}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})\n\n\nKitten.find().populate( owner ,  name , null, {sort: { name: -1 }}).exec(function (err, kittens) {\n  console.log(kittens[0].owner.name)\n})  Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#queryprototypecast", 
            "text": "", 
            "title": "Query.prototype.cast()"
        }, 
        {
            "location": "/api/#parameters_144", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_106", 
            "text": "Casts this query to the schema of  model", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#note_32", 
            "text": "If  obj  is present, it is cast instead of this query.", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypecursor", 
            "text": "", 
            "title": "Query.prototype.cursor()"
        }, 
        {
            "location": "/api/#parameters_145", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_107", 
            "text": "Returns a wrapper around a  mongodb driver cursor . A QueryCursor exposes a  Streams3 -compatible interface, as well as a  .next()  function.  The  .cursor()  function triggers pre find hooks, but  not  post find hooks.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_103", 
            "text": "Thing . \n   find ( {   name :   /^ hello /   } ). \n   cursor (). \n   on ( data ,   function ( doc )   {   console.log(doc) ;   } ). \n   on ( end ,   function ()   {   console.log( Done! ) ;   } );  var   cursor   =   Thing . find ( {   name :   /^ hello /   } ) . cursor ();  cursor . next ( function ( error ,   doc )   { \n   console.log(doc) ;  } );  co ( function *()   { \n   const   cursor   =   Thing.find({   name :   /^ hello /   } ) . cursor (); \n   for   ( let   doc   =   yield   cursor . next ();   doc   !=   null ;   doc   =   yield   cursor . next ())   { \n     console.log(doc) ; \n   }  } );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#valid-options_3", 
            "text": "transform : optional function which accepts a mongoose document. The return value of the function will be emitted on  data  and returned by  .next() .", 
            "title": "Valid options"
        }, 
        {
            "location": "/api/#queryprototypemaxscan_1", 
            "text": "DEPRECATED  Alias of  maxScan", 
            "title": "Query.prototype.maxscan()"
        }, 
        {
            "location": "/api/#queryprototypetailable", 
            "text": "", 
            "title": "Query.prototype.tailable()"
        }, 
        {
            "location": "/api/#parameters_146", 
            "text": "[opts.tailableRetryInterval] \u00abNumber\u00bb if cursor is exhausted, wait this many milliseconds before retrying   Sets the tailable option (for use with capped collections).", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_104", 
            "text": "query.tailable()\nquery.tailable(true)\nquery.tailable(false)", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_33", 
            "text": "Cannot be used with  distinct()", 
            "title": "Note"
        }, 
        {
            "location": "/api/#queryprototypeintersects", 
            "text": "", 
            "title": "Query.prototype.intersects()"
        }, 
        {
            "location": "/api/#parameters_147", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_108", 
            "text": "Declares an intersects query for  geometry() .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_105", 
            "text": "query.where( path ).intersects().geometry({\n    type:  LineString \n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})\n\nquery.where( path ).intersects({\n    type:  LineString \n  , coordinates: [[180.0, 11.0], [180, 9.0]]\n})", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_34", 
            "text": "MUST  be used after  where() .", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#note_35", 
            "text": "In Mongoose 3.7,  intersects  changed from a getter to a function. If you need the old syntax, use  this .", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#queryprototypegeometry", 
            "text": "", 
            "title": "Query.prototype.geometry()"
        }, 
        {
            "location": "/api/#parameters_148", 
            "text": "object \u00abObject\u00bb Must contain a  type  property which is a String and a  coordinates  property which is an Array. See the examples.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_109", 
            "text": "Specifies a  $geometry  condition", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_106", 
            "text": "var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\nquery.where( loc ).within().geometry({ type:  Polygon , coordinates: polyA })\n\n\nvar polyB = [[ 0, 0 ], [ 1, 1 ]]\nquery.where( loc ).within().geometry({ type:  LineString , coordinates: polyB })\n\n\nvar polyC = [ 0, 0 ]\nquery.where( loc ).within().geometry({ type:  Point , coordinates: polyC })\n\n\nquery.where( loc ).intersects().geometry({ type:  Point , coordinates: polyC })  The argument is assigned to the most recent path passed to  where() .", 
            "title": "Example"
        }, 
        {
            "location": "/api/#note_36", 
            "text": "geometry()   must  come after either  intersects()  or  within() .  The  object  argument must contain  type  and  coordinates  properties. - type {String} - coordinates {Array}", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#queryprototypenear", 
            "text": "", 
            "title": "Query.prototype.near()"
        }, 
        {
            "location": "/api/#parameters_149", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_110", 
            "text": "Specifies a  $near  or  $nearSphere  condition  These operators return documents sorted by distance.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_107", 
            "text": "query . where ( loc ) . near ( {   center :   [ 10 ,   10 ]   } );  query . where ( loc ) . near ( {   center :   [ 10 ,   10 ] ,   maxDistance :   5   } );  query . where ( loc ) . near ( {   center :   [ 10 ,   10 ] ,   maxDistance :   5 ,   spherical :   true   } );  query . near ( loc ,   {   center :   [ 10 ,   10 ] ,   maxDistance :   5   } );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypenearsphere", 
            "text": "DEPRECATED  Specifies a  $nearSphere  condition", 
            "title": "Query.prototype.nearSphere()"
        }, 
        {
            "location": "/api/#example_108", 
            "text": "query . where ( loc ) . nearSphere ( {   center :   [ 10 ,   10 ] ,   maxDistance :   5   } );   Deprecated.  Use  query.near()  instead with the  spherical  option set to  true .", 
            "title": "Example"
        }, 
        {
            "location": "/api/#example_109", 
            "text": "query . where ( loc ) . near ( {   center :   [ 10 ,   10 ] ,   spherical :   true   } );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypepolygon", 
            "text": "", 
            "title": "Query.prototype.polygon()"
        }, 
        {
            "location": "/api/#parameters_150", 
            "text": "[coordinatePairs...] \u00abArray,Object\u00bb", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_111", 
            "text": "Specifies a $polygon condition", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_110", 
            "text": "query.where( loc ).within().polygon([10,20], [13, 25], [7,15])\nquery.polygon( loc , [10,20], [13, 25], [7,15])", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypebox", 
            "text": "", 
            "title": "Query.prototype.box()"
        }, 
        {
            "location": "/api/#parameters_151", 
            "text": "Upper \u00ab[Array]\u00bb Right Coords", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_112", 
            "text": "Specifies a $box condition", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_111", 
            "text": "var lowerLeft = [40.73083, -73.99756]\nvar upperRight= [40.741404,  -73.988135]\n\nquery.where( loc ).within().box(lowerLeft, upperRight)\nquery.box({ ll : lowerLeft, ur : upperRight })", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypecircle", 
            "text": "", 
            "title": "Query.prototype.circle()"
        }, 
        {
            "location": "/api/#parameters_152", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_113", 
            "text": "Specifies a $center or $centerSphere condition.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_112", 
            "text": "var area = { center: [50, 50], radius: 10, unique: true }\nquery.where( loc ).within().circle(area)\n\nquery.circle( loc , area);\n\n\nvar area = { center: [50, 50], radius: 10, unique: true, spherical: true }\nquery.where( loc ).within().circle(area)\n\nquery.circle( loc , area);  New in 3.7.0", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypecenter", 
            "text": "", 
            "title": "Query.prototype.center()"
        }, 
        {
            "location": "/api/#queryprototypecentersphere", 
            "text": "", 
            "title": "Query.prototype.centerSphere()"
        }, 
        {
            "location": "/api/#parameters_153", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_114", 
            "text": "DEPRECATED  Specifies a $centerSphere condition  Deprecated.  Use  circle  instead.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_113", 
            "text": "var   area   =   {   center :   [ 50 ,   50 ] ,   radius :   10   } ;  query . where ( loc ) . within () . centerSphere ( area );", 
            "title": "Example"
        }, 
        {
            "location": "/api/#queryprototypeselected", 
            "text": "", 
            "title": "Query.prototype.selected()"
        }, 
        {
            "location": "/api/#returns_115", 
            "text": "Determines if field selection has been made.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypeselectedinclusively", 
            "text": "", 
            "title": "Query.prototype.selectedInclusively()"
        }, 
        {
            "location": "/api/#returns_116", 
            "text": "Determines if inclusive field selection has been made.  query.selectedInclusively()\nquery.select( name )\nquery.selectedInclusively()", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#queryprototypeselectedexclusively", 
            "text": "", 
            "title": "Query.prototype.selectedExclusively()"
        }, 
        {
            "location": "/api/#returns_117", 
            "text": "Determines if exclusive field selection has been made.  query.selectedExclusively()\nquery.select( -name )\nquery.selectedExclusively()\nquery.selectedInclusively()", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#aggregate", 
            "text": "", 
            "title": "Aggregate()"
        }, 
        {
            "location": "/api/#parameters_154", 
            "text": "[pipeline] \u00abArray\u00bb aggregation pipeline as an array of objects   Aggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use  Model.aggregate()  instead.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_114", 
            "text": "const aggregate = Model.aggregate([\n  { $project: { a: 1, b: 1 } },\n  { $skip: 5 }\n]);\n\nModel.\n  aggregate({ $match: { age: { $gte: 21 }}}).\n  unwind( tags ).\n  exec(callback);", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_37", 
            "text": "The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).   Mongoose does  not  cast pipeline stages. The below will  not  work unless  _id  is a string in the database  new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n  // Do this instead to cast to an ObjectId\n  new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);", 
            "title": "Note:"
        }, 
        {
            "location": "/api/#aggregateprototypemodel", 
            "text": "", 
            "title": "Aggregate.prototype.model()"
        }, 
        {
            "location": "/api/#parameters_155", 
            "text": "model \u00abModel\u00bb the model to which the aggregate is to be bound", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_118", 
            "text": "Binds this aggregate to a model.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#aggregateprototypeappend", 
            "text": "", 
            "title": "Aggregate.prototype.append()"
        }, 
        {
            "location": "/api/#parameters_156", 
            "text": "ops \u00abObject\u00bb operator(s) to append", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_119", 
            "text": "Appends new operators to this aggregate pipeline", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_10", 
            "text": "aggregate . append ( {   $ project :   {   field :   1   } } ,   {   $ limit :   2   } );  var   pipeline   =   [ {   $match :   {   daw :   Logic Audio X   }}   ] ;  aggregate . append ( pipeline );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypeaddfields", 
            "text": "", 
            "title": "Aggregate.prototype.addFields()"
        }, 
        {
            "location": "/api/#parameters_157", 
            "text": "arg \u00abObject\u00bb field specification", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_120", 
            "text": "Appends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_11", 
            "text": "aggregate . addFields ( { \n     newField :   $b.nested \n   ,   plusTen :   {   $ add :   [ $val ,   10 ] } \n   ,   sub :   { \n        name :   $a \n     }  } )  aggregate . addFields ( {   salary_k :   {   $ divide :   [   $salary ,   1000   ]   }   } );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypeproject", 
            "text": "", 
            "title": "Aggregate.prototype.project()"
        }, 
        {
            "location": "/api/#parameters_158", 
            "text": "arg \u00abObject,String\u00bb field specification", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_121", 
            "text": "Appends a new $project operator to this aggregate pipeline.  Mongoose query  selection syntax  is also supported.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_12", 
            "text": "aggregate . project ( a b -_id );  aggregate . project ( { a :   1 ,   b :   1 ,   _id :   0 } );  aggregate . project ( { \n     newField :   $b.nested \n   ,   plusTen :   {   $ add :   [ $val ,   10 ] } \n   ,   sub :   { \n        name :   $a \n     }  } )  aggregate . project ( {   salary_k :   {   $ divide :   [   $salary ,   1000   ]   }   } );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypegroup", 
            "text": "", 
            "title": "Aggregate.prototype.group()"
        }, 
        {
            "location": "/api/#parameters_159", 
            "text": "arg \u00abObject\u00bb $group operator contents", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_122", 
            "text": "Appends a new custom $group operator to this aggregate pipeline.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_13", 
            "text": "aggregate . group ( {   _id :   $department   } );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypematch", 
            "text": "", 
            "title": "Aggregate.prototype.match()"
        }, 
        {
            "location": "/api/#parameters_160", 
            "text": "arg \u00abObject\u00bb $match operator contents", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_123", 
            "text": "Appends a new custom $match operator to this aggregate pipeline.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_14", 
            "text": "aggregate . match ( {   department :   {   $ in :   [   sales ,   engineering   ]   }   } );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypeskip", 
            "text": "", 
            "title": "Aggregate.prototype.skip()"
        }, 
        {
            "location": "/api/#parameters_161", 
            "text": "num \u00abNumber\u00bb number of records to skip before next stage", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_124", 
            "text": "Appends a new $skip operator to this aggregate pipeline.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_15", 
            "text": "aggregate.skip(10);", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypelimit", 
            "text": "", 
            "title": "Aggregate.prototype.limit()"
        }, 
        {
            "location": "/api/#parameters_162", 
            "text": "num \u00abNumber\u00bb maximum number of records to pass to the next stage", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_125", 
            "text": "Appends a new $limit operator to this aggregate pipeline.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_16", 
            "text": "aggregate.limit(10);", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypenear", 
            "text": "", 
            "title": "Aggregate.prototype.near()"
        }, 
        {
            "location": "/api/#parameters_163", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_126", 
            "text": "Appends a new $geoNear operator to this aggregate pipeline.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#note_38", 
            "text": "MUST  be used as the first operator in the pipeline.", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#examples_17", 
            "text": "aggregate.near({\n  near: [40.724, -73.997],\n  distanceField:  dist.calculated ,\n  maxDistance: 0.008,\n  query: { type:  public  },\n  includeLocs:  dist.location ,\n  uniqueDocs: true,\n  num: 5\n});", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypeunwind", 
            "text": "", 
            "title": "Aggregate.prototype.unwind()"
        }, 
        {
            "location": "/api/#parameters_164", 
            "text": "fields \u00abString\u00bb the field(s) to unwind", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_127", 
            "text": "Appends new custom $unwind operator(s) to this aggregate pipeline.  Note that the  $unwind  operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_18", 
            "text": "aggregate.unwind( tags );\naggregate.unwind( a ,  b ,  c );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypelookup", 
            "text": "", 
            "title": "Aggregate.prototype.lookup()"
        }, 
        {
            "location": "/api/#parameters_165", 
            "text": "options \u00abObject\u00bb to $lookup as described in the above link", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_128", 
            "text": "Appends new custom $lookup operator(s) to this aggregate pipeline.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_19", 
            "text": "aggregate . lookup ( {   from :   users ,   localField :   userId ,   foreignField :   _id ,   as :   users   } );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypegraphlookup", 
            "text": "", 
            "title": "Aggregate.prototype.graphLookup()"
        }, 
        {
            "location": "/api/#parameters_166", 
            "text": "options \u00abObject\u00bb to $graphLookup as described in the above link", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_129", 
            "text": "Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.  Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if  { allowDiskUse: true }  is specified.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_20", 
            "text": "aggregate.graphLookup({ from:  courses , startWith:  $prerequisite , connectFromField:  prerequisite , connectToField:  name , as:  prerequisites , maxDepth: 3 })", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypesample", 
            "text": "", 
            "title": "Aggregate.prototype.sample()"
        }, 
        {
            "location": "/api/#parameters_167", 
            "text": "size \u00abNumber\u00bb number of random documents to pick", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_130", 
            "text": "Appepnds new custom $sample operator(s) to this aggregate pipeline.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_21", 
            "text": "aggregate.sample(3);", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototypesort", 
            "text": "", 
            "title": "Aggregate.prototype.sort()"
        }, 
        {
            "location": "/api/#parameters_168", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_131", 
            "text": "Appends a new $sort operator to this aggregate pipeline.  If an object is passed, values allowed are  asc ,  desc ,  ascending ,  descending ,  1 , and  -1 .  If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with  -  which will be treated as descending.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_22", 
            "text": "aggregate . sort ( {   field :   asc ,   test :   -1   } );  aggregate . sort ( field -test );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#aggregateprototyperead", 
            "text": "", 
            "title": "Aggregate.prototype.read()"
        }, 
        {
            "location": "/api/#parameters_169", 
            "text": "[tags] \u00abArray\u00bb optional tags for this query   Sets the readPreference option for the aggregation query.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_115", 
            "text": "Model.aggregate(..).read( primaryPreferred ).exec(callback)", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypeexplain", 
            "text": "", 
            "title": "Aggregate.prototype.explain()"
        }, 
        {
            "location": "/api/#parameters_170", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_132", 
            "text": "Execute the aggregation with explain", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_116", 
            "text": "Model.aggregate(..).explain(callback)", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypeallowdiskuse", 
            "text": "", 
            "title": "Aggregate.prototype.allowDiskUse()"
        }, 
        {
            "location": "/api/#parameters_171", 
            "text": "[tags] \u00abArray\u00bb optional tags for this query   Sets the allowDiskUse option for the aggregation query (ignored for   2.6.0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_117", 
            "text": "Model.aggregate(..).allowDiskUse(true).exec(callback)", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypeoption", 
            "text": "", 
            "title": "Aggregate.prototype.option()"
        }, 
        {
            "location": "/api/#parameters_172", 
            "text": "value \u00abObject\u00bb keys to merge into current options", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_133", 
            "text": "Lets you set arbitrary options, for middleware or plugins.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_118", 
            "text": "var   agg   =   Model . aggregate (..) . option ( {   allowDiskUse :   true   } );  agg . options ;", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypecursor", 
            "text": "", 
            "title": "Aggregate.prototype.cursor()"
        }, 
        {
            "location": "/api/#parameters_173", 
            "text": "[options.useMongooseAggCursor] \u00abBoolean\u00bb use experimental mongoose-specific aggregation cursor (for  eachAsync()  and other query cursor semantics)   Sets the cursor option option for the aggregation query (ignored for   2.6.0). Note the different syntax below: .exec() returns a cursor object, and no callback is necessary.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_119", 
            "text": "var   cursor   =   Model . aggregate (..) . cursor ( {   batchSize :   1000   } ) . exec ();  cursor . each ( function ( error ,   doc )   {  } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypeaddcursorflag", 
            "text": "", 
            "title": "Aggregate.prototype.addCursorFlag()"
        }, 
        {
            "location": "/api/#parameters_174", 
            "text": "Adds a  cursor flag", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_120", 
            "text": "Model.aggregate(..).addCursorFlag( noCursorTimeout , true).exec();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypecollation", 
            "text": "", 
            "title": "Aggregate.prototype.collation()"
        }, 
        {
            "location": "/api/#parameters_175", 
            "text": "Adds a collation", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_121", 
            "text": "Model . aggregate (..) . collation ( {   locale :   en_US ,   strength :   1   } ) . exec ();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypefacet", 
            "text": "", 
            "title": "Aggregate.prototype.facet()"
        }, 
        {
            "location": "/api/#parameters_176", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_134", 
            "text": "Combines multiple aggregation pipelines.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_122", 
            "text": "Model.aggregate(...)\n .facet({\n   books: [{ groupBy:  $author  }],\n   price: [{ $bucketAuto: { groupBy:  $price , buckets: 2 } }]\n })\n .exec();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypepipeline", 
            "text": "", 
            "title": "Aggregate.prototype.pipeline()"
        }, 
        {
            "location": "/api/#returns_135", 
            "text": "Returns the current pipeline", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_123", 
            "text": "MyModel . aggregate () . match ( {   test :   1   } ) . pipeline ();", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypeexec", 
            "text": "", 
            "title": "Aggregate.prototype.exec()"
        }, 
        {
            "location": "/api/#parameters_177", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_136", 
            "text": "Executes the aggregate pipeline on the currently bound Model.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_124", 
            "text": "aggregate.exec(callback);\n\n\nvar promise = aggregate.exec();\npromise.then(..);", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#aggregateprototypethen", 
            "text": "", 
            "title": "Aggregate.prototype.then()"
        }, 
        {
            "location": "/api/#parameters_178", 
            "text": "[reject] \u00abFunction\u00bb errorCallback", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_137", 
            "text": "Provides promise for aggregate.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_125", 
            "text": "Model.aggregate(..).then(successCallback, errorCallback);", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematype", 
            "text": "", 
            "title": "SchemaType()"
        }, 
        {
            "location": "/api/#parameters_179", 
            "text": "SchemaType constructor. Do  not  instantiate  SchemaType  directly. Mongoose converts your schema paths into SchemaTypes automatically.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#example_126", 
            "text": "const   schema   =   new   Schema ( {   name :   String   } );  schema . path ( name )   instanceof   SchemaType ;", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypedefault", 
            "text": "", 
            "title": "SchemaType.prototype.default()"
        }, 
        {
            "location": "/api/#parameters_180", 
            "text": "val \u00abFunction,any\u00bb the default value", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_138", 
            "text": "Sets a default value for this SchemaType.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_127", 
            "text": "var schema = new Schema({ n: { type: Number, default: 10 })\nvar M = db.model( M , schema)\nvar m = new M;\nconsole.log(m.n)  Defaults can be either  functions  which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#example_128", 
            "text": "var   schema   =   new   Schema ( {   aNumber :   {   type :   Number ,   default :   4.815162342   } } )  var   M   =   db . model ( M ,   schema )  var   m   =   new   M ;  console . log ( m . aNumber )  var   schema   =   new   Schema ( {   mixed :   Schema . Types . Mixed   } );  schema . path ( mixed ) . default ( function   ()   { \n   return   { } ;  } );  var   schema   =   new   Schema ( {   mixed :   Schema . Types . Mixed   } );  schema . path ( mixed ) . default ( {} );  var   M   =   db . model ( M ,   schema );  var   m1   =   new   M ;  m1 . mixed . added   =   1 ;  console . log ( m1 . mixed );  var   m2   =   new   M ;  console . log ( m2 . mixed );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypeindex", 
            "text": "", 
            "title": "SchemaType.prototype.index()"
        }, 
        {
            "location": "/api/#parameters_181", 
            "text": "options \u00abObject,Boolean,String\u00bb", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_139", 
            "text": "Declares the index options for this schematype.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_129", 
            "text": "var   s   =   new   Schema ( {   name :   {   type :   String ,   index :   true   } )  var   s   =   new   Schema ( {   loc :   {   type :   [ Number ] ,   index :   hashed   } )  var   s   =   new   Schema ( {   loc :   {   type :   [ Number ] ,   index :   2d ,   sparse :   true   } )  var   s   =   new   Schema ( {   loc :   {   type :   [ Number ] ,   index :   {   type :   2dsphere ,   sparse :   true   } } )  var   s   =   new   Schema ( {   date :   {   type :   Date ,   index :   {   unique :   true ,   expires :   1d   } } )  Schema . path ( my.path ) . index ( true );  Schema . path ( my.date ) . index ( {   expires :   60   } );  Schema . path ( my.path ) . index ( {   unique :   true ,   sparse :   true   } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#note_39", 
            "text": "Indexes are created in the background by default. Specify  background: false  to override.  Direction doesn't matter for single key indexes", 
            "title": "NOTE:"
        }, 
        {
            "location": "/api/#schematypeprototypeunique", 
            "text": "", 
            "title": "SchemaType.prototype.unique()"
        }, 
        {
            "location": "/api/#parameters_182", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_140", 
            "text": "Declares an unique index.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_130", 
            "text": "var   s   =   new   Schema ( {   name :   {   type :   String ,   unique :   true   } } );  Schema . path ( name ) . index ( {   unique :   true   } );   NOTE: violating the constraint returns an  E11000  error from MongoDB when saving, not a Mongoose validation error.", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypetext", 
            "text": "", 
            "title": "SchemaType.prototype.text()"
        }, 
        {
            "location": "/api/#parameters_183", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_141", 
            "text": "Declares a full text index.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_131", 
            "text": "var s = new Schema({name : {type: String, text : true })\n Schema.path( name ).index({text : true});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypesparse", 
            "text": "", 
            "title": "SchemaType.prototype.sparse()"
        }, 
        {
            "location": "/api/#parameters_184", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_142", 
            "text": "Declares a sparse index.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_132", 
            "text": "var   s   =   new   Schema ( {   name :   {   type :   String ,   sparse :   true   } )  Schema . path ( name ) . index ( {   sparse :   true   } );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypeset", 
            "text": "", 
            "title": "SchemaType.prototype.set()"
        }, 
        {
            "location": "/api/#parameters_185", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_143", 
            "text": "Adds a setter to this schematype.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_133", 
            "text": "function   capitalize   ( val )   { \n   if   ( typeof   val   !==   string )   val   =   ; \n   return   val . charAt ( 0 ). toUpperCase ()   +   val . substring ( 1 );  }  var   s   =   new   Schema ({   name :   {   type :  String ,   set :  capitalize   }})  var   s   =   new   Schema ({   name :  String   })  s . path ( name ). set ( capitalize )   Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.  Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise,  avenue@q.com  can be registered for 2 accounts via  avenue@q.com  and  AvEnUe@Q.CoM .  You can set up email lower case normalization easily via a Mongoose setter.  function   toLower ( v )   { \n   return   v . toLowerCase ();  }  var   UserSchema   =   new   Schema ({ \n   email :   {   type :  String ,   set :  toLower   }  });  var   User   =   db . model ( User ,   UserSchema );  var   user   =   new   User ({ email :   [AVENUE@Q.COM][271] });  console . log ( user . email );   //  [avenue@q.com][271]  // or  var   user   =   new   User ();  user . email   =   [Avenue@Q.com][271] ;  console . log ( user . email );   //  [avenue@q.com][271]  User . updateOne ({   _id :  _id   },   {   $set :   {   email :   [AVENUE@Q.COM][271]   }   });   // update to  [avenue@q.com][271]   As you can see above, setters allow you to transform the data before it stored in MongoDB.  NOTE: we could have also just used the built-in  lowercase: true  SchemaType option instead of defining our own function.  new Schema({ email: { type: String, lowercase: true }})  Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.  function   inspector   ( val ,   schematype )   { \n   if   ( schematype . options . required )   { \n     return   schematype . path   +    is required ; \n   }   else   { \n     return   val ; \n   }  }  var   VirusSchema   =   new   Schema ({ \n   name :   {   type :  String ,   required :  true ,   set :  inspector   }, \n   taxonomy :   {   type :  String ,   set :  inspector   }  })  var   Virus   =   db . model ( Virus ,   VirusSchema );  var   v   =   new   Virus ({   name :   Parvoviridae ,   taxonomy :   Parvovirinae   });  console . log ( v . name );  console . log ( v . taxonomy );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypeget", 
            "text": "", 
            "title": "SchemaType.prototype.get()"
        }, 
        {
            "location": "/api/#parameters_186", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_144", 
            "text": "Adds a getter to this schematype.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_134", 
            "text": "function   dob   ( val )   { \n   if   ( ! val )   return   val ; \n   return   ( val . getMonth ()   +   1 )   +   /   +   val . getDate ()   +   /   +   val . getFullYear ();  }  var   s   =   new   Schema ({   born :   {   type :  Date ,   get :  dob   })  var   s   =   new   Schema ({   born :  Date   })  s . path ( born ). get ( dob )   Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.  Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:  function   obfuscate   ( cc )   { \n   return   ****-****-****-   +   cc . slice ( cc . length - 4 ,   cc . length );  }  var   AccountSchema   =   new   Schema ({ \n   creditCardNumber :   {   type :  String ,   get :  obfuscate   }  });  var   Account   =   db . model ( Account ,   AccountSchema );  Account . findById ( id ,   function   ( err ,   found )   { \n   console . log ( found . creditCardNumber );  });   Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.  function   inspector   ( val ,   schematype )   { \n   if   ( schematype . options . required )   { \n     return   schematype . path   +    is required ; \n   }   else   { \n     return   schematype . path   +    is not ; \n   }  }  var   VirusSchema   =   new   Schema ({ \n   name :   {   type :  String ,   required :  true ,   get :  inspector   }, \n   taxonomy :   {   type :  String ,   get :  inspector   }  })  var   Virus   =   db . model ( Virus ,   VirusSchema );  Virus . findById ( id ,   function   ( err ,   virus )   { \n   console . log ( virus . name ); \n   console . log ( virus . taxonomy );  })", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypevalidate", 
            "text": "", 
            "title": "SchemaType.prototype.validate()"
        }, 
        {
            "location": "/api/#parameters_187", 
            "text": "[type] \u00abString\u00bb optional validator type", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_145", 
            "text": "Adds validator(s) for this document path.  Validators always receive the value to validate as their first argument and must return  Boolean . Returning  false  means validation failed.  The error message argument is optional. If not passed, the  default generic error message template  will be used.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#examples_23", 
            "text": "function   validator   ( val )   { \n   return   val   ==   something ;  }  new   Schema ({   name :   {   type :  String ,   validate :  validator   }});  var   custom   =   [ validator ,   Uh oh, {PATH} does not equal  something . ]  new   Schema ({   name :   {   type :  String ,   validate :  custom   }});  var   many   =   [ \n     {   validator :  validator ,   msg :   uh oh   } \n   ,   {   validator :  anotherValidator ,   msg :   failed   }  ]  new   Schema ({   name :   {   type :  String ,   validate :  many   }});  var   schema   =   new   Schema ({   name :   string   });  schema . path ( name ). validate ( validator ,   validation of `{PATH}` failed with value `{VALUE}` );", 
            "title": "Examples:"
        }, 
        {
            "location": "/api/#error-message-templates", 
            "text": "From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides  {PATH}  and  {VALUE}  too. To find out more, details are available  here", 
            "title": "Error message templates:"
        }, 
        {
            "location": "/api/#asynchronous-validation", 
            "text": "Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either  true  or  false  to communicate either success or failure respectively.  schema.path( name ).validate({\n  isAsync: true,\n  validator: function (value, respond) {\n    doStuff(value, function () {\n      ...\n      respond(false);\n    });\n  },\n  message:  Custom error message! \n});\n\n\nschema.path( name ).validate({\n  validator: function (value) {\n    return new Promise(function (resolve, reject) {\n      resolve(false);\n    });\n  }\n});  You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.  Validation occurs  pre('save')  or whenever you manually execute  document#validate .  If validation fails during  pre('save')  and no callback was passed to receive the error, an  error  event will be emitted on your Models associated db  connection , passing the validation error object along.  var conn = mongoose.createConnection(..);\nconn.on( error , handleError);\n\nvar Product = conn.model( Product , yourSchema);\nvar dvd = new Product(..);\ndvd.save();  If you desire handling these errors at the Model level, attach an  error  listener to your Model and the event will instead be emitted there.  Product.on( error , handleError);", 
            "title": "Asynchronous validation:"
        }, 
        {
            "location": "/api/#schematypeprototyperequired", 
            "text": "", 
            "title": "SchemaType.prototype.required()"
        }, 
        {
            "location": "/api/#parameters_188", 
            "text": "[message] \u00abString\u00bb optional custom error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_146", 
            "text": "Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using  unshift() .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_135", 
            "text": "var   s   =   new   Schema ( {   born :   {   type :   Date ,   required :   true   } )  var   s   =   new   Schema ( {   born :   {   type :   Date ,   required :   {PATH} is required!   } )  var   s   =   new   Schema ( { \n   userId :   ObjectId , \n   username :   { \n     type :   String , \n     required :   function ()   {   return   this . userId   !=   null ;   } \n   }  } )  var   s   =   new   Schema ( { \n   userId :   ObjectId , \n   username :   { \n     type :   String , \n     required :   [ \n       function ()   {   return   this.userId   !=   null ;   }, \n       username is required if id is specified \n     ] \n   }  } )  Schema . path ( name ) . required ( true );  Schema . path ( name ) . required ( true ,   grrr :(  );  var   isOver18   =   function ()   {   return   this.age   =   18 ;   } ;  Schema . path ( voterRegistrationId ) . required ( isOver18 );   The required validator uses the SchemaType's  checkRequired  function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if  val != null  (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default  checkRequired  function:", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#schematypeprototypeselect", 
            "text": "", 
            "title": "SchemaType.prototype.select()"
        }, 
        {
            "location": "/api/#parameters_189", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_147", 
            "text": "Sets default  select()  behavior for this path.  Set to  true  if this path should always be included in the results,  false  if it should be excluded by default. This setting can be overridden at the query level.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_136", 
            "text": "T   =   db . model ( T ,   new   Schema ( {   x :   {   type :   String ,   select :   true   } } ));  T . find (..);  T . find () . select ( -x ) . exec ( callback );", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#virtualtype", 
            "text": "VirtualType constructor  This is what mongoose uses to define virtual attributes via  Schema.prototype.virtual .", 
            "title": "VirtualType()"
        }, 
        {
            "location": "/api/#example_137", 
            "text": "var fullname = schema.virtual( fullname );\nfullname instanceof mongoose.VirtualType", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#virtualtypeprototypeget", 
            "text": "", 
            "title": "VirtualType.prototype.get()"
        }, 
        {
            "location": "/api/#parameters_190", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_148", 
            "text": "Defines a getter.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_138", 
            "text": "var virtual = schema.virtual( fullname );\nvirtual.get(function () {\n  return this.name.first +     + this.name.last;\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#virtualtypeprototypeset", 
            "text": "", 
            "title": "VirtualType.prototype.set()"
        }, 
        {
            "location": "/api/#parameters_191", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_149", 
            "text": "Defines a setter.", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#example_139", 
            "text": "var virtual = schema.virtual( fullname );\nvirtual.set(function (v) {\n  var parts = v.split(   );\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});", 
            "title": "Example:"
        }, 
        {
            "location": "/api/#virtualtypeprototypeapplygetters", 
            "text": "", 
            "title": "VirtualType.prototype.applyGetters()"
        }, 
        {
            "location": "/api/#parameters_192", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_150", 
            "text": "\u00abany\u00bb the value after applying all getters   Applies getters to  value  using optional  scope .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#virtualtypeprototypeapplysetters", 
            "text": "", 
            "title": "VirtualType.prototype.applySetters()"
        }, 
        {
            "location": "/api/#parameters_193", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#returns_151", 
            "text": "\u00abany\u00bb the value after applying all setters   Applies setters to  value  using optional  scope .", 
            "title": "Returns:"
        }, 
        {
            "location": "/api/#mongooseerror", 
            "text": "", 
            "title": "MongooseError()"
        }, 
        {
            "location": "/api/#parameters_194", 
            "text": "msg \u00abString\u00bb Error message   MongooseError constructor", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#mongooseerrormessages", 
            "text": "The default built-in validator error messages.", 
            "title": "MongooseError.messages"
        }, 
        {
            "location": "/api/#mongooseerrordocumentnotfounderror", 
            "text": "An instance of this error class will be returned when  save()  fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to  update()  when trying to update the document.", 
            "title": "MongooseError.DocumentNotFoundError"
        }, 
        {
            "location": "/api/#mongooseerrorcasterror", 
            "text": "An instance of this error class will be returned when mongoose failed to cast a value.", 
            "title": "MongooseError.CastError"
        }, 
        {
            "location": "/api/#mongooseerrorvalidationerror", 
            "text": "An instance of this error class will be returned when  validation  failed.", 
            "title": "MongooseError.ValidationError"
        }, 
        {
            "location": "/api/#mongooseerrorvalidatorerror", 
            "text": "A  ValidationError  has a hash of  errors  that contain individual  ValidatorError  instances", 
            "title": "MongooseError.ValidatorError"
        }, 
        {
            "location": "/api/#mongooseerrorversionerror", 
            "text": "An instance of this error class will be returned when you call  save()  after the document in the database was changed in a potentially unsafe way. See the  versionKey  option  for more information.", 
            "title": "MongooseError.VersionError"
        }, 
        {
            "location": "/api/#mongooseerroroverwritemodelerror", 
            "text": "", 
            "title": "MongooseError.OverwriteModelError"
        }, 
        {
            "location": "/api/#mongooseerrormissingschemaerror", 
            "text": "Thrown when you try to access a model that has not been registered yet", 
            "title": "MongooseError.MissingSchemaError"
        }, 
        {
            "location": "/api/#mongooseerrordivergentarrayerror", 
            "text": "An instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.", 
            "title": "MongooseError.DivergentArrayError"
        }, 
        {
            "location": "/api/Schema/", 
            "text": "", 
            "title": "\u67b6\u6784"
        }, 
        {
            "location": "/api/Connection/", 
            "text": "", 
            "title": "\u67b6\u6784"
        }, 
        {
            "location": "/api/Document/", 
            "text": "", 
            "title": "\u6587\u4ef6"
        }, 
        {
            "location": "/api/Model/", 
            "text": "", 
            "title": "\u6a21\u578b"
        }, 
        {
            "location": "/api/Query/", 
            "text": "", 
            "title": "\u8be2\u95ee"
        }, 
        {
            "location": "/api/Aggregate/", 
            "text": "", 
            "title": "\u9aa8\u6599"
        }, 
        {
            "location": "/api/SchemaType/", 
            "text": "", 
            "title": "\u67b6\u6784\u7c7b\u578b"
        }, 
        {
            "location": "/api/VirtualType/", 
            "text": "", 
            "title": "\u865a\u62df\u7c7b\u578b"
        }, 
        {
            "location": "/api/Error/", 
            "text": "", 
            "title": "\u9519\u8bef"
        }, 
        {
            "location": "/VersionCompatibility/", 
            "text": "Mongoose v5.0.1: MongoDB Version Compatibility\n\n\nSource\n\n\nMongoDB Server Version Compatibility\n\n\nMongoose relies on the \nMongoDB Node.js Driver\n to talk to MongoDB. You can refer to \nthis table\n for up-to-date information as to which version of the MongoDB driver supports which version of MongoDB.\n\n\nBelow are the \nsemver\n ranges representing which versions of mongoose are compatible with the listed versions of MongoDB server.\n\n\n\n\nMongoDB Server 2.4.x: mongoose \n~3.8\n or \n4.x\n\n\nMongoDB Server 2.6.x: mongoose \n~3.8.8\n or \n4.x\n\n\nMongoDB Server 3.0.x: mongoose \n~3.8.22\n, \n4.x\n or \n5.x\n\n\nMongoDB Server 3.2.x: mongoose \n=4.3.0\n or \n5.x\n\n\nMongoDB Server 3.4.x: mongoose \n=4.7.3\n or \n5.x\n\n\nMongoDB Server 3.6.x: mongoose \n5.x\n, or \n=4.11.0\n with \nuseMongoClient\n and \nusePushEach", 
            "title": "\u7248\u672c\u517c\u5bb9\u6027"
        }, 
        {
            "location": "/VersionCompatibility/#mongoose-v501-mongodb-version-compatibility", 
            "text": "Source", 
            "title": "Mongoose v5.0.1: MongoDB Version Compatibility"
        }, 
        {
            "location": "/VersionCompatibility/#mongodb-server-version-compatibility", 
            "text": "Mongoose relies on the  MongoDB Node.js Driver  to talk to MongoDB. You can refer to  this table  for up-to-date information as to which version of the MongoDB driver supports which version of MongoDB.  Below are the  semver  ranges representing which versions of mongoose are compatible with the listed versions of MongoDB server.   MongoDB Server 2.4.x: mongoose  ~3.8  or  4.x  MongoDB Server 2.6.x: mongoose  ~3.8.8  or  4.x  MongoDB Server 3.0.x: mongoose  ~3.8.22 ,  4.x  or  5.x  MongoDB Server 3.2.x: mongoose  =4.3.0  or  5.x  MongoDB Server 3.4.x: mongoose  =4.7.3  or  5.x  MongoDB Server 3.6.x: mongoose  5.x , or  =4.11.0  with  useMongoClient  and  usePushEach", 
            "title": "MongoDB Server Version Compatibility"
        }, 
        {
            "location": "/FAQ/", 
            "text": "Mongoose v5.0.1: FAQ\n\n\nSource\n\n\nFAQ\n\n\nQ\n. Why don't my changes to arrays get saved when I update an element directly?\n\n\ndoc.array[3] = \nchanged\n;\ndoc.save();\n\n\n\n\n\nA\n. Mongoose doesn't create getters/setters for array indexes; without them mongoose never gets notified of the change and so doesn't know to persist the new value. The work-around is to use \nMongooseArray#set\n available in \nMongoose \n= 3.2.0\n.\n\n\ndoc.array.set(3, \nchanged\n);\ndoc.save();\n\n\ndoc.array[3] = \nchanged\n;\ndoc.markModified(\narray\n);\ndoc.save();\n\n\n\n\n\n\n\nQ\n. I declared a schema property as \nunique\n but I can still save duplicates. What gives?\n\n\nA\n. Mongoose doesn't handle \nunique\n on its own: \n{ name: { type: String, unique: true } }\n is just a shorthand for creating a \nMongoDB unique index on \nname\n. For example, if MongoDB doesn't already have a unique index on \nname\n, the below code will not error despite the fact that \nunique\n is true.\n\n\nvar schema = new mongoose.Schema({\n  name: { type: String, unique: true }\n});\nvar Model = db.model(\nTest\n, schema);\n\nModel.create([{ name: \nVal\n }, { name: \nVal\n }], function(err) {\n  console.log(err);\n});\n\n\n\n\n\nHowever, if you wait for the index to build using the \nModel.on('index')\n event, attempts to save duplicates will correctly error.\n\n\nvar schema = new mongoose.Schema({\n  name: { type: String, unique: true }\n});\nvar Model = db.model(\nTest\n, schema);\n\nModel.on(\nindex\n, function(err) {\n  assert.ifError(err);\n  Model.create([{ name: \nVal\n }, { name: \nVal\n }], function(err) {\n    console.log(err);\n  });\n});\n\n\n\n\nModel.init().then(function() {\n  assert.ifError(err);\n  Model.create([{ name: \nVal\n }, { name: \nVal\n }], function(err) {\n    console.log(err);\n  });\n});\n\n\n\n\n\nMongoDB persists indexes, so you only need to rebuild indexes if you're starting with a fresh database or you ran \ndb.dropDatabase()\n. In a production environment, you should [create your indexes using the MongoDB shell])() rather than relying on mongoose to do it for you. The \nunique\n option for schemas is convenient for development and documentation, but mongoose is \nnot\n an index management solution.\n\n\n\n\nQ\n. When I have a nested property in a schema, mongoose adds empty objects by default. Why?\n\n\nvar schema = new mongoose.Schema({\n  nested: {\n    prop: String\n  }\n});\nvar Model = db.model(\nTest\n, schema);\n\n\n\nconsole.log(new Model());\n\n\n\n\n\nA\n. This is a performance optimization. These empty objects are not saved to the database, nor are they in the result \ntoObject()\n, nor do they show up in \nJSON.stringify()\n output unless you turn off the \nminimize\n option\n.\n\n\nThe reason for this behavior is that Mongoose's change detection and getters/setters are based on \nObject.defineProperty()\n. In order to support change detection on nested properties without incurring the overhead of running \nObject.defineProperty()\n every time a document is created, mongoose defines properties on the \nModel\n prototype when the model is compiled. Because mongoose needs to define getters and setters for \nnested.prop\n, \nnested\n must always be defined as an object on a mongoose document, even if \nnested\n is undefined on the underlying \nPOJO\n.\n\n\n\n\nQ\n. I'm using an arrow function for a \nvirtual\n, getter/setter, or \nmethod\n and the value of \nthis\n is wrong.\n\n\nA\n. Arrow functions \nhandle the \nthis\n keyword much differently than conventional functions\n. Mongoose getters/setters depend on \nthis\n to give you access to the document that you're writing to, but this functionality does not work with arrow functions. Do \nnot\n use arrow functions for mongoose getters/setters unless do not intend to access the document in the getter/setter.\n\n\nvar schema = new mongoose.Schema({\n  propWithGetter: {\n    type: String,\n    get: v =\n {\n\n      console.log(this);\n      return v;\n    }\n  }\n});\n\n\nschema.method.arrowMethod = () =\n this;\nschema.virtual(\nvirtualWithArrow\n).get(() =\n {\n\n  console.log(this);\n});\n\n\n\n\n\n\n\nQ\n. I have an embedded property named \ntype\n like this:\n\n\nconst holdingSchema = new Schema({\n\n\n\n  asset: {\n    type: String,\n    ticker: String\n  }\n});\n\n\n\n\n\nBut mongoose gives me a CastError telling me that it can't cast an object to a string when I try to save a \nHolding\n with an \nasset\n object. Why is this?\n\n\nHolding.create({ asset: { type: \nstock\n, ticker: \nMDB\n } }).catch(error =\n {\n\n  console.error(error);\n});\n\n\n\n\n\nA\n. The \ntype\n property is special in mongoose, so when you say \ntype: String\n, mongoose interprets it as a type declaration. In the above schema, mongoose thinks \nasset\n is a string, not an object. Do this instead:\n\n\nconst holdingSchema = new Schema({\n\n\n\n  asset: {\n    type: { type: String },\n    ticker: String\n  }\n});\n\n\n\n\n\n\n\nQ\n. Why don't in-place modifications to date objects (e.g. \ndate.setMonth(1);\n) get saved?\n\n\ndoc.createdAt.setDate(2011, 5, 1);\ndoc.save();\n\n\n\n\n\nA\n. Mongoose currently doesn't watch for in-place updates to date objects. If you have need for this feature, feel free to discuss on \nthis GitHub issue\n. There are several workarounds:\n\n\ndoc.createdAt.setDate(2011, 5, 1);\ndoc.markModified(\ncreatedAt\n);\ndoc.save();\n\ndoc.createdAt = new Date(2011, 5, 1).setHours(4);\ndoc.save();\n\n\n\n\n\n\n\nQ\n. I'm populating a nested property under an array like the below code:\n\n\n  new Schema({\n    arr: [{\n      child: { ref: \nOtherModel\n, type: Schema.Types.ObjectId }\n    }]\n  });\n\n\n\n\n\n.populate({ path: 'arr.child', options: { sort: 'name' } })\n won't sort by \narr.child.name\n?\n\n\nA\n. See \nthis GitHub issue\n. It's a known issue but one that's exceptionally difficult to fix.\n\n\n\n\nQ\n. All function calls on my models hang, what am I doing wrong?\n\n\nA\n. By default, mongoose will buffer your function calls until it can connect to MongoDB. Read the \nbuffering section of the connection docs\n for more information.\n\n\n\n\nQ\n. How can I enable debugging?\n\n\nA\n. Set the \ndebug\n option to \ntrue\n:\n\n\nmongoose.set(\ndebug\n, true)\n\n\n\n\n\nAll executed collection methods will log output of their arguments to your console.\n\n\n\n\nQ\n. My \nsave()\n callback never executes. What am I doing wrong?\n\n\nA\n. All \ncollection\n actions (insert, remove, queries, etc.) are queued until the \nconnection\n opens. It is likely that an error occurred while attempting to connect. Try adding an error handler to your connection.\n\n\nmongoose.connect(..);\nmongoose.connection.on(\nerror\n, handleError);\n\n\nvar conn = mongoose.createConnection(..);\nconn.on(\nerror\n, handleError);\n\n\n\n\n\nIf you want to opt out of mongoose's buffering mechanism across your entire application, set the global \nbufferCommands\n option to false:\n\n\nmongoose.set(\nbufferCommands\n, false);\n\n\n\n\n\n\n\nQ\n. Should I create/destroy a new connection for each database operation?\n\n\nA\n. No. Open your connection when your application starts up and leave it open until the application shuts down.\n\n\n\n\nQ\n. Why do I get \"OverwriteModelError: Cannot overwrite .. model once compiled\" when I use nodemon / a testing framework?\n\n\nA\n. \nmongoose.model('ModelName', schema)\n requires 'ModelName' to be unique, so you can access the model by using \nmongoose.model('ModelName')\n. If you put \nmongoose.model('ModelName', schema);\n in a \nmocha \nbeforeEach()\n hook\n, this code will attempt to create a new model named 'ModelName' before \nevery\n test, and so you will get an error. Make sure you only create a new model with a given name \nonce\n. If you need to create multiple models with the same name, create a new connection and bind the model to the connection.\n\n\nvar\n \nmongoose\n \n=\n \nrequire\n(\nmongoose\n);\n\n\nvar\n \nconnection\n \n=\n \nmongoose\n.\ncreateConnection\n(..);\n\n\n\n\nvar\n \nkittySchema\n \n=\n \nmongoose\n.\nSchema\n(\n{\n \nname\n:\n \nString\n \n}\n);\n\n\n\n\nvar\n \nKitten\n \n=\n \nconnection\n.\nmodel\n(\nKitten\n,\n \nkittySchema\n);\n\n\n\n\n\n\nSomething to add?\n\n\nIf you'd like to contribute to this page, please \nvisit it\n on github and use the \nEdit\n button to send a pull request.", 
            "title": "\u5e38\u95ee\u95ee\u9898"
        }, 
        {
            "location": "/FAQ/#mongoose-v501-faq", 
            "text": "Source", 
            "title": "Mongoose v5.0.1: FAQ"
        }, 
        {
            "location": "/FAQ/#faq", 
            "text": "Q . Why don't my changes to arrays get saved when I update an element directly?  doc.array[3] =  changed ;\ndoc.save();  A . Mongoose doesn't create getters/setters for array indexes; without them mongoose never gets notified of the change and so doesn't know to persist the new value. The work-around is to use  MongooseArray#set  available in  Mongoose  = 3.2.0 .  doc.array.set(3,  changed );\ndoc.save();\n\n\ndoc.array[3] =  changed ;\ndoc.markModified( array );\ndoc.save();   Q . I declared a schema property as  unique  but I can still save duplicates. What gives?  A . Mongoose doesn't handle  unique  on its own:  { name: { type: String, unique: true } }  is just a shorthand for creating a  MongoDB unique index on  name . For example, if MongoDB doesn't already have a unique index on  name , the below code will not error despite the fact that  unique  is true.  var schema = new mongoose.Schema({\n  name: { type: String, unique: true }\n});\nvar Model = db.model( Test , schema);\n\nModel.create([{ name:  Val  }, { name:  Val  }], function(err) {\n  console.log(err);\n});  However, if you wait for the index to build using the  Model.on('index')  event, attempts to save duplicates will correctly error.  var schema = new mongoose.Schema({\n  name: { type: String, unique: true }\n});\nvar Model = db.model( Test , schema);\n\nModel.on( index , function(err) {\n  assert.ifError(err);\n  Model.create([{ name:  Val  }, { name:  Val  }], function(err) {\n    console.log(err);\n  });\n});\n\n\n\n\nModel.init().then(function() {\n  assert.ifError(err);\n  Model.create([{ name:  Val  }, { name:  Val  }], function(err) {\n    console.log(err);\n  });\n});  MongoDB persists indexes, so you only need to rebuild indexes if you're starting with a fresh database or you ran  db.dropDatabase() . In a production environment, you should [create your indexes using the MongoDB shell])() rather than relying on mongoose to do it for you. The  unique  option for schemas is convenient for development and documentation, but mongoose is  not  an index management solution.   Q . When I have a nested property in a schema, mongoose adds empty objects by default. Why?  var schema = new mongoose.Schema({\n  nested: {\n    prop: String\n  }\n});\nvar Model = db.model( Test , schema);\n\n\n\nconsole.log(new Model());  A . This is a performance optimization. These empty objects are not saved to the database, nor are they in the result  toObject() , nor do they show up in  JSON.stringify()  output unless you turn off the  minimize  option .  The reason for this behavior is that Mongoose's change detection and getters/setters are based on  Object.defineProperty() . In order to support change detection on nested properties without incurring the overhead of running  Object.defineProperty()  every time a document is created, mongoose defines properties on the  Model  prototype when the model is compiled. Because mongoose needs to define getters and setters for  nested.prop ,  nested  must always be defined as an object on a mongoose document, even if  nested  is undefined on the underlying  POJO .   Q . I'm using an arrow function for a  virtual , getter/setter, or  method  and the value of  this  is wrong.  A . Arrow functions  handle the  this  keyword much differently than conventional functions . Mongoose getters/setters depend on  this  to give you access to the document that you're writing to, but this functionality does not work with arrow functions. Do  not  use arrow functions for mongoose getters/setters unless do not intend to access the document in the getter/setter.  var schema = new mongoose.Schema({\n  propWithGetter: {\n    type: String,\n    get: v =  {\n\n      console.log(this);\n      return v;\n    }\n  }\n});\n\n\nschema.method.arrowMethod = () =  this;\nschema.virtual( virtualWithArrow ).get(() =  {\n\n  console.log(this);\n});   Q . I have an embedded property named  type  like this:  const holdingSchema = new Schema({\n\n\n\n  asset: {\n    type: String,\n    ticker: String\n  }\n});  But mongoose gives me a CastError telling me that it can't cast an object to a string when I try to save a  Holding  with an  asset  object. Why is this?  Holding.create({ asset: { type:  stock , ticker:  MDB  } }).catch(error =  {\n\n  console.error(error);\n});  A . The  type  property is special in mongoose, so when you say  type: String , mongoose interprets it as a type declaration. In the above schema, mongoose thinks  asset  is a string, not an object. Do this instead:  const holdingSchema = new Schema({\n\n\n\n  asset: {\n    type: { type: String },\n    ticker: String\n  }\n});   Q . Why don't in-place modifications to date objects (e.g.  date.setMonth(1); ) get saved?  doc.createdAt.setDate(2011, 5, 1);\ndoc.save();  A . Mongoose currently doesn't watch for in-place updates to date objects. If you have need for this feature, feel free to discuss on  this GitHub issue . There are several workarounds:  doc.createdAt.setDate(2011, 5, 1);\ndoc.markModified( createdAt );\ndoc.save();\n\ndoc.createdAt = new Date(2011, 5, 1).setHours(4);\ndoc.save();   Q . I'm populating a nested property under an array like the below code:    new Schema({\n    arr: [{\n      child: { ref:  OtherModel , type: Schema.Types.ObjectId }\n    }]\n  });  .populate({ path: 'arr.child', options: { sort: 'name' } })  won't sort by  arr.child.name ?  A . See  this GitHub issue . It's a known issue but one that's exceptionally difficult to fix.   Q . All function calls on my models hang, what am I doing wrong?  A . By default, mongoose will buffer your function calls until it can connect to MongoDB. Read the  buffering section of the connection docs  for more information.   Q . How can I enable debugging?  A . Set the  debug  option to  true :  mongoose.set( debug , true)  All executed collection methods will log output of their arguments to your console.   Q . My  save()  callback never executes. What am I doing wrong?  A . All  collection  actions (insert, remove, queries, etc.) are queued until the  connection  opens. It is likely that an error occurred while attempting to connect. Try adding an error handler to your connection.  mongoose.connect(..);\nmongoose.connection.on( error , handleError);\n\n\nvar conn = mongoose.createConnection(..);\nconn.on( error , handleError);  If you want to opt out of mongoose's buffering mechanism across your entire application, set the global  bufferCommands  option to false:  mongoose.set( bufferCommands , false);   Q . Should I create/destroy a new connection for each database operation?  A . No. Open your connection when your application starts up and leave it open until the application shuts down.   Q . Why do I get \"OverwriteModelError: Cannot overwrite .. model once compiled\" when I use nodemon / a testing framework?  A .  mongoose.model('ModelName', schema)  requires 'ModelName' to be unique, so you can access the model by using  mongoose.model('ModelName') . If you put  mongoose.model('ModelName', schema);  in a  mocha  beforeEach()  hook , this code will attempt to create a new model named 'ModelName' before  every  test, and so you will get an error. Make sure you only create a new model with a given name  once . If you need to create multiple models with the same name, create a new connection and bind the model to the connection.  var   mongoose   =   require ( mongoose );  var   connection   =   mongoose . createConnection (..);  var   kittySchema   =   mongoose . Schema ( {   name :   String   } );  var   Kitten   =   connection . model ( Kitten ,   kittySchema );   Something to add?  If you'd like to contribute to this page, please  visit it  on github and use the  Edit  button to send a pull request.", 
            "title": "FAQ"
        }
    ]
}