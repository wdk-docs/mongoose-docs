{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mongoose \u00b6 \u4e3anode.js\u4f18\u96c5\u7684mongodb\u5bf9\u8c61\u5efa\u6a21 \u9605\u8bfb\u6587\u6863 \u53d1\u73b0\u63d2\u4ef6 Version 5.0.1 \u9762\u5bf9\u73b0\u5b9e\u5427, \u7f16\u5199MongoDB\u9a8c\u8bc1\uff0c\u94f8\u9020\u548c\u4e1a\u52a1\u903b\u8f91\u6837\u677f\u662f\u4e00\u4e2a\u62d6\u7d2f . \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u5199\u4e86mongoose. JavaScript const mongoose = require ( 'mongoose' ); mongoose . connect ( 'mongodb://localhost/test' ); const Cat = mongoose . model ( 'Cat' , { name : String }); const kitty = new Cat ({ name : 'Zildjian' }); kitty . save (). then (() => console . log ( 'meow' )); Mongoose\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\uff0c\u57fa\u4e8e\u6a21\u5f0f\u7684\u89e3\u51b3\u65b9\u6848\u6765\u5efa\u6a21\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6570\u636e\u3002\u5b83\u5305\u62ec\u5185\u7f6e\u7684\u7c7b\u578b\u8f6c\u6362\uff0c\u9a8c\u8bc1\uff0c\u67e5\u8be2\u6784\u5efa\uff0c\u4e1a\u52a1\u903b\u8f91\u94a9\u5b50\u7b49\u7b49\u3002 \u5165\u95e8 \u00b6 \u5feb\u901f\u5165\u95e8\u6307\u5357 \u652f\u6301 \u00b6 \u5806\u6808\u6ea2\u51fa GitHub\u95ee\u9898 \u683c\u5b50\u804a\u5929 MongoDB\u652f\u6301 \u65b0\u95fb \u00b6 \u63a8\u7279 \u66f4\u65b0\u65e5\u5fd7 \u00b6 \u66f4\u65b0\u65e5\u5fd7 \u8d5e\u52a9\u5546 \u00b6 \u5728OpenCollective\u4e0a\u8d5e\u52a9Mongoose\u4ee5\u83b7\u5f97\u60a8\u516c\u53f8\u7684\u6807\u8bc6\uff01","title":"\u524d\u8a00"},{"location":"#mongoose","text":"\u4e3anode.js\u4f18\u96c5\u7684mongodb\u5bf9\u8c61\u5efa\u6a21 \u9605\u8bfb\u6587\u6863 \u53d1\u73b0\u63d2\u4ef6 Version 5.0.1 \u9762\u5bf9\u73b0\u5b9e\u5427, \u7f16\u5199MongoDB\u9a8c\u8bc1\uff0c\u94f8\u9020\u548c\u4e1a\u52a1\u903b\u8f91\u6837\u677f\u662f\u4e00\u4e2a\u62d6\u7d2f . \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u5199\u4e86mongoose. JavaScript const mongoose = require ( 'mongoose' ); mongoose . connect ( 'mongodb://localhost/test' ); const Cat = mongoose . model ( 'Cat' , { name : String }); const kitty = new Cat ({ name : 'Zildjian' }); kitty . save (). then (() => console . log ( 'meow' )); Mongoose\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\uff0c\u57fa\u4e8e\u6a21\u5f0f\u7684\u89e3\u51b3\u65b9\u6848\u6765\u5efa\u6a21\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u6570\u636e\u3002\u5b83\u5305\u62ec\u5185\u7f6e\u7684\u7c7b\u578b\u8f6c\u6362\uff0c\u9a8c\u8bc1\uff0c\u67e5\u8be2\u6784\u5efa\uff0c\u4e1a\u52a1\u903b\u8f91\u94a9\u5b50\u7b49\u7b49\u3002","title":"mongoose"},{"location":"#_1","text":"\u5feb\u901f\u5165\u95e8\u6307\u5357","title":"\u5165\u95e8"},{"location":"#_2","text":"\u5806\u6808\u6ea2\u51fa GitHub\u95ee\u9898 \u683c\u5b50\u804a\u5929 MongoDB\u652f\u6301","title":"\u652f\u6301"},{"location":"#_3","text":"\u63a8\u7279","title":"\u65b0\u95fb"},{"location":"#_4","text":"\u66f4\u65b0\u65e5\u5fd7","title":"\u66f4\u65b0\u65e5\u5fd7"},{"location":"#_5","text":"\u5728OpenCollective\u4e0a\u8d5e\u52a9Mongoose\u4ee5\u83b7\u5f97\u60a8\u516c\u53f8\u7684\u6807\u8bc6\uff01","title":"\u8d5e\u52a9\u5546"},{"location":"FAQ/","text":"\u5e38\u89c1\u95ee\u9898 \u00b6 \u6e90 \u5f53\u6211\u76f4\u63a5\u66f4\u65b0\u6570\u7ec4\u5143\u7d20\u65f6\u200b\u200b\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u66f4\u6539\uff1f JavaScript doc . array [ 3 ] = 'changed' ; doc . save (); \u7b54\u6848 Mongoose\u4e0d\u4f1a\u4e3a\u6570\u7ec4\u7d22\u5f15\u521b\u5efagetter/setter; \u6ca1\u6709\u4ed6\u4eec\u732b\u9f2c\u4ece\u6765\u6ca1\u6709\u5f97\u5230\u901a\u77e5\u7684\u53d8\u5316\uff0c\u6240\u4ee5\u4e0d\u77e5\u9053\u575a\u6301\u65b0\u7684\u4ef7\u503c\u3002 \u89e3\u51b3\u65b9\u6cd5\u662f\u4f7f\u7528 Mongoose> = 3.2.0 \u4e2d\u7684 MongooseArray\uff03set \u3002 JavaScript doc . array . set ( 3 , 'changed' ); doc . save (); doc . array [ 3 ] = 'changed' ; doc . markModified ( 'array' ); doc . save (); \u6211\u5b9a\u4e49\u6a21\u5f0f\u5c5e\u6027\u4e3a\u201cunique\u201d\uff0c\u4f46\u6211\u4ecd\u7136\u53ef\u4ee5\u4fdd\u5b58\u4e86\u91cd\u590d\u6570\u636e,\u662f\u4ec0\u4e48\u5bfc\u81f4\u7684\uff1f \u7b54\u6848 Mongoose\u672c\u8eab\u5e76\u4e0d\u5904\u7406 unique \uff1a {name\uff1a{type\uff1aString\uff0cunique\uff1atrue}} \u53ea\u662f\u5728 name \u4e0a\u521b\u5efa\u4e00\u4e2a[MongoDB\u552f\u4e00\u7d22\u5f15]\u7684\u7b80\u5199 2 \u4f8b\u5982\uff0c\u5982\u679cMongoDB\u5728 name \u4e0a\u6ca1\u6709\u552f\u4e00\u7684\u7d22\u5f15\uff0c \u5c3d\u7ba1\u201cunique\u201d\u662f\u771f\u5b9e\u7684\uff0c\u4f46\u4e0b\u9762\u7684\u4ee3\u7801\u4e0d\u4f1a\u51fa\u9519\u3002 JavaScript var schema = new mongoose . Schema ({ name : { type : String , unique : true } }); var Model = db . model ( 'Test' , schema ); Model . create ([{ name : 'Val' }, { name : 'Val' }], function ( err ) { console . log ( err ); }); \u7136\u800c\uff0c \u5982\u679c\u60a8\u4f7f\u7528 Model.on\uff08'index'\uff09 \u4e8b\u4ef6\u7b49\u5f85\u7d22\u5f15\u5efa\u7acb\uff0c\u5c1d\u8bd5\u4fdd\u5b58\u91cd\u590d\u5c06\u4f1a\u629b\u9519 JavaScript var schema = new mongoose . Schema ({ name : { type : String , unique : true } }); var Model = db . model ( 'Test' , schema ); Model . on ( 'index' , function ( err ) { assert . ifError ( err ); Model . create ([{ name : 'Val' }, { name : 'Val' }], function ( err ) { console . log ( err ); }); }); Model . init (). then ( function () { assert . ifError ( err ); Model . create ([{ name : 'Val' }, { name : 'Val' }], function ( err ) { console . log ( err ); }); }); MongoDB\u575a\u6301\u7d22\u5f15\uff0c \u6240\u4ee5\u4f60\u53ea\u9700\u8981\u91cd\u65b0\u5efa\u7acb\u7d22\u5f15\uff0c\u5982\u679c\u4f60\u5f00\u59cb\u4e00\u4e2a\u65b0\u7684\u6570\u636e\u5e93\uff0c\u6216\u8005\u4f60\u8fd0\u884c db.dropDatabase\uff08\uff09 \u3002\u5728\u751f\u4ea7\u73af\u5883\u4e2d\uff0c \u4f60\u5e94\u8be5[\u4f7f\u7528MongoDB shell]\uff09\uff08\uff09\u521b\u5efa\u7d22\u5f15\uff0c\u800c\u4e0d\u662f\u4f9d\u9760\u732b\u9f2c\u4e3a\u4f60\u505a\u3002 \u6a21\u5f0f\u7684 unique \u9009\u9879\u65b9\u4fbf\u5f00\u53d1\u548c\u6587\u6863\u5316\uff0c\u4f46\u732b\u9f2c\u4e0d\u662f\u7d22\u5f15\u7ba1\u7406\u89e3\u51b3\u65b9\u6848 \u5f53\u6211\u5728\u6a21\u5f0f\u4e2d\u6709\u4e00\u4e2a\u5d4c\u5957\u5c5e\u6027\u65f6\uff0cmongoose\u9ed8\u8ba4\u6dfb\u52a0\u7a7a\u5bf9\u8c61,\u4e3a\u4ec0\u4e48\uff1f JavaScript var schema = new mongoose . Schema ({ nested : { prop : String } }); var Model = db . model ( 'Test' , schema ); console . log ( new Model ()); \u7b54\u6848 \u8fd9\u662f\u4e00\u4e2a\u6027\u80fd\u4f18\u5316 \u8fd9\u4e9b\u7a7a\u7684\u5bf9\u8c61\u4e0d\u4f1a\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\uff0c \u4e5f\u4e0d\u662f\u5728\u7ed3\u679c toObject\uff08\uff09 \u4e2d\uff0c \u9664\u975e\u5173\u95ed minimize \u9009\u9879 \uff0c\u5426\u5219\u5b83\u4eec\u4e0d\u4f1a\u51fa\u73b0\u5728 JSON.stringify\uff08\uff09 \u8f93\u51fa\u4e2d\u3002 \u8fd9\u79cd\u884c\u4e3a\u7684\u539f\u56e0\u662fMongoose\u7684\u53d8\u5316\u68c0\u6d4b\u548cgetter / setter\u662f\u57fa\u4e8e Object.defineProperty\uff08\uff09 \u3002\u4e3a\u4e86\u652f\u6301\u5bf9\u5d4c\u5957\u5c5e\u6027\u7684\u66f4\u6539\u68c0\u6d4b\uff0c\u800c\u4e0d\u4f1a\u5728\u6bcf\u6b21\u521b\u5efa\u6587\u6863\u65f6\u62db\u81f4\u8fd0\u884cObject.defineProperty\uff08\uff09\u7684\u5f00\u9500\uff0c mongoose\u5728\u6a21\u578b\u7f16\u8bd1\u65f6\u5b9a\u4e49 Model \u539f\u578b\u7684\u5c5e\u6027\u3002,\u7531\u4e8e\u732b\u9f2c\u9700\u8981\u4e3a nested.prop \u5b9a\u4e49getter\u548csetter\uff0c \u5fc5\u987b\u59cb\u7ec8\u5c06\u201c\u5d4c\u5957\u201d\u5b9a\u4e49\u4e3a\u732b\u9f2c\u6587\u6863\u4e0a\u7684\u5bf9\u8c61\uff0c \u5373\u4f7f nested \u5728\u5e95\u5c42\u7684 POJO \u4e0a\u662f\u672a\u5b9a\u4e49\u7684\u3002 \u6211\u5728 virtual \uff0cgetter/setter\u6216 method \u4f7f\u7528\u7bad\u5934\u51fd\u6570\uff0cthis\u7684\u503c\u662f\u4e3a\u4ec0\u4e48\u662f\u9519\u8bef\u7684\uff1f \u7b54\u6848 \u7bad\u5934\u51fd\u6570 \u5904\u7406 this \u5173\u952e\u5b57\u4e0e\u4f20\u7edf\u51fd\u6570\u5927\u4e0d\u76f8\u540c . Mongoose getter/setter\u4f9d\u8d56 this \u6765\u8ba9\u4f60\u8bbf\u95ee\u4f60\u6b63\u5728\u5199\u7684\u6587\u6863\uff0c\u4f46\u662f\u8fd9\u4e2a\u529f\u80fd\u4e0d\u80fd\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u3002 \u9664\u975e\u4e0d\u6253\u7b97\u8bbf\u95eegetter/setter\u4e2d\u7684\u6587\u6863\uff0c\u5426\u5219\u4e0d\u8981\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u6765\u53d6\u5f97 Mongoose getter/setter\u3002 JavaScript var schema = new mongoose . Schema ({ propWithGetter : { type : String , get : v => { console . log ( this ); return v ; } } }); schema . method . arrowMethod = () => this ; schema . virtual ( 'virtualWithArrow' ). get (() => { console . log ( this ); }); \u6211\u6709\u4e00\u4e2a\u540d\u4e3a type \u7684\u5d4c\u5165\u5f0f\u5c5e\u6027\u662f\u8fd9\u6837\u7684\uff1a JavaScript const holdingSchema = new Schema ({ asset : { type : String , ticker : String } }); \u4f46mongoose\u7ed9\u4e86\u6211\u4e00\u4e2aCastError\u63d0\u793a\uff0c\u5f53\u6211\u8bd5\u56fe\u7528\u4e00\u4e2a asset \u5bf9\u8c61\u6765\u4fdd\u5b58 Holding \u65f6\uff0c\u5b83\u4e0d\u80fd\u628a\u4e00\u4e2a\u5bf9\u8c61\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002 JavaScript Holding . create ({ asset : { type : 'stock' , ticker : 'MDB' } }). catch ( error => { console . error ( error ); }); \u7b54\u6848 \u201c\u7c7b\u578b\u201d\u5c5e\u6027\u5728\u732b\u9f2c\u662f\u7279\u522b\u7684\uff0c\u6240\u4ee5\u5f53\u4f60\u8bf4 type\uff1aString \u65f6\uff0c\u732b\u9f2c\u628a\u5b83\u89e3\u91ca\u4e3a\u4e00\u4e2a\u7c7b\u578b\u58f0\u660e. \u5728\u4e0a\u9762\u7684\u6a21\u5f0f\u4e2d\uff0c\u732b\u9f2c\u8ba4\u4e3a\u201casset\u201d\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5bf9\u8c61\u3002,\u505a\u8fd9\u4e2a\uff0c\u800c\u4e0d\u662f\uff1a JavaScript const holdingSchema = new Schema ({ asset : { type : { type : String }, ticker : String } }); \u4e3a\u4ec0\u4e48\u4e0d\u80fd\u5bf9\u65e5\u671f\u5bf9\u8c61\uff08\u4f8b\u5982 date.setMonth\uff081\uff09; \uff09\u8fdb\u884c\u5c31\u5730\u4fee\u6539\uff1f JavaScript doc . createdAt . setDate ( 2011 , 5 , 1 ); doc . save (); \u7b54\u6848 Mongoose\u76ee\u524d\u4e0d\u4f1a\u76d1\u89c6\u65e5\u671f\u5bf9\u8c61\u7684\u5c31\u5730\u66f4\u65b0,\u5982\u679c\u60a8\u9700\u8981\u8fd9\u4e2a\u529f\u80fd\uff0c\u8bf7\u968f\u65f6\u5728 \u6b64GitHub\u95ee\u9898 \u4e0a\u8ba8\u8bba\u3002,\u6709\u51e0\u4e2a\u89e3\u51b3\u65b9\u6cd5\uff1a JavaScript doc . createdAt . setDate ( 2011 , 5 , 1 ); doc . markModified ( 'createdAt' ); doc . save (); doc . createdAt = new Date ( 2011 , 5 , 1 ). setHours ( 4 ); doc . save (); \u6211\u5728\u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u586b\u5145\u6570\u7ec4\u4e0b\u7684\u5d4c\u5957\u5c5e\u6027\uff1a JavaScript new Schema ({ arr : [{ child : { ref : 'OtherModel' , type : Schema . Types . ObjectId } }] }); .populate\uff08{path\uff1a'arr.child'\uff0coptions\uff1a{sort\uff1a'name'}}\uff09 \u4e0d\u4f1a\u88ab arr.child.name \u6392\u5e8f \u7b54\u6848 \u89c1 \u8fd9\u4e2aGitHub\u95ee\u9898 \u3002,\u8fd9\u662f\u4e00\u4e2a\u5df2\u77e5\u7684\u95ee\u9898\uff0c\u4f46\u662f\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u96be\u4ee5\u89e3\u51b3\u7684\u95ee\u9898 \u6211\u7684\u6a21\u578b\u4e0a\u7684\u6240\u6709\u51fd\u6570\u8c03\u7528\u6302\u8d77\uff0c\u6211\u505a\u9519\u4e86\u4ec0\u4e48\uff1f \u7b54\u6848 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmongoose\u4f1a\u7f13\u51b2\u4f60\u7684\u51fd\u6570\u8c03\u7528\uff0c\u76f4\u5230\u5b83\u53ef\u4ee5\u8fde\u63a5\u5230MongoDB\u3002,\u9605\u8bfb \u8fde\u63a5\u6587\u6863\u7684\u7f13\u51b2\u90e8\u5206 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 \u6211\u600e\u6837\u624d\u80fd\u542f\u7528\u8c03\u8bd5\uff1f \u7b54\u6848 \u5c06 debug \u9009\u9879\u8bbe\u7f6e\u4e3a true JavaScript mongoose . set ( 'debug' , true ) \u6240\u6709\u6267\u884c\u7684\u6536\u96c6\u65b9\u6cd5\u90fd\u4f1a\u5c06\u5176\u53c2\u6570\u7684\u8f93\u51fa\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002 \u6211\u7684 save\uff08\uff09 \u56de\u8c03\u4ece\u4e0d\u6267\u884c\u3002 \u6211\u7a76\u7adf\u505a\u9519\u4e86\u4ec0\u4e48\uff1f \u7b54\u6848 \u6240\u6709\u7684\u201c\u96c6\u5408\u201d\u64cd\u4f5c\uff08\u63d2\u5165\uff0c\u5220\u9664\uff0c\u67e5\u8be2\u7b49\uff09\u90fd\u88ab\u6392\u961f\uff0c\u76f4\u5230\u201c\u8fde\u63a5\u201d\u6253\u5f00. \u5c1d\u8bd5\u8fde\u63a5\u65f6\u53ef\u80fd\u53d1\u751f\u9519\u8bef\u3002\u5c1d\u8bd5\u6dfb\u52a0\u4e00\u4e2a\u9519\u8bef\u5904\u7406\u7a0b\u5e8f\u5230\u60a8\u7684\u8fde\u63a5\u3002 JavaScript mongoose . connect (..); mongoose . connection . on ( 'error' , handleError ); var conn = mongoose . createConnection (..); conn . on ( 'error' , handleError ); \u5982\u679c\u60a8\u60f3\u8981\u5728\u6574\u4e2a\u5e94\u7528\u7a0b\u5e8f\u4e2d\u9009\u62e9\u4e0d\u4f7f\u7528\u732b\u9f2c\u7684\u7f13\u51b2\u673a\u5236\uff0c\u8bf7\u5c06\u5168\u5c40 bufferCommands \u9009\u9879\u8bbe\u7f6e\u4e3afalse JavaScript mongoose . set ( 'bufferCommands' , false ); \u6211\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u6570\u636e\u5e93\u64cd\u4f5c\u521b\u5efa/\u9500\u6bc1\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5417\uff1f \u7b54\u6848 \u4e0d\u7528\u3002\u5728\u5e94\u7528\u7a0b\u5e8f\u542f\u52a8\u65f6\u6253\u5f00\u8fde\u63a5\uff0c\u5e76\u4fdd\u6301\u6253\u5f00\u72b6\u6001\uff0c\u76f4\u5230\u5e94\u7528\u7a0b\u5e8f\u5173\u95ed\u3002 \u4e3a\u4ec0\u4e48\u6211\u5f97\u5230\"OverwriteModelError: Cannot overwrite .. model once compiled\" \u5f53\u6211\u4f7f\u7528nodemon(\u4e00\u4e2a\u6d4b\u8bd5\u6846\u67b6)\uff1f \u7b54\u6848 mongoose.model('ModelName',schema)'\u8981\u6c42 ModelName \u662f\u552f\u4e00\u7684\uff0c \u6240\u4ee5\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 mongoose.model('ModelName') \u6765\u8bbf\u95ee\u6a21\u578b\u3002 \u5982\u679c\u4f60\u628amongoose.model('ModelName',schema); \u653e\u5728 mocha beforeEach() hook \u4e2d\uff0c \u6b64\u4ee3\u7801\u5c06\u5c1d\u8bd5\u5728 \u6bcf \u6d4b\u8bd5\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a\u201cModelName\u201d\u7684\u65b0\u6a21\u578b\uff0c \u6240\u4ee5\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u9519\u8bef\u3002 \u786e\u4fdd\u4f60\u53ea\u7528\u4e00\u4e2a\u7ed9\u5b9a\u7684\u540d\u5b57 once \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6a21\u578b\u3002 \u5982\u679c\u60a8\u9700\u8981\u521b\u5efa\u5177\u6709\u76f8\u540c\u540d\u79f0\u7684\u591a\u4e2a\u6a21\u578b\uff0c\u8bf7\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5e76\u5c06\u6a21\u578b\u7ed1\u5b9a\u5230\u8fde\u63a5\u3002 JavaScript var mongoose = require ( 'mongoose' ); var connection = mongoose . createConnection (..); var kittySchema = mongoose . Schema ({ name : String }); var Kitten = connection . model ( 'Kitten' , kittySchema ); \u8981\u6dfb\u52a0\u7684\u4e1c\u897f? \u5982\u679c\u60a8\u60f3\u8d21\u732e\u6b64\u9875\u9762\uff0c\u8bf7\u5728github\u4e0a \u8bbf\u95ee\u5b83 \uff0c\u5e76\u4f7f\u7528 \u7f16\u8f91 \u6309\u94ae\u53d1\u9001\u62c9\u53d6\u8bf7\u6c42\u3002","title":"\u5e38\u95ee\u95ee\u9898"},{"location":"FAQ/#_1","text":"\u6e90 \u5f53\u6211\u76f4\u63a5\u66f4\u65b0\u6570\u7ec4\u5143\u7d20\u65f6\u200b\u200b\uff0c\u4e3a\u4ec0\u4e48\u4e0d\u66f4\u6539\uff1f JavaScript doc . array [ 3 ] = 'changed' ; doc . save (); \u7b54\u6848 Mongoose\u4e0d\u4f1a\u4e3a\u6570\u7ec4\u7d22\u5f15\u521b\u5efagetter/setter; \u6ca1\u6709\u4ed6\u4eec\u732b\u9f2c\u4ece\u6765\u6ca1\u6709\u5f97\u5230\u901a\u77e5\u7684\u53d8\u5316\uff0c\u6240\u4ee5\u4e0d\u77e5\u9053\u575a\u6301\u65b0\u7684\u4ef7\u503c\u3002 \u89e3\u51b3\u65b9\u6cd5\u662f\u4f7f\u7528 Mongoose> = 3.2.0 \u4e2d\u7684 MongooseArray\uff03set \u3002 JavaScript doc . array . set ( 3 , 'changed' ); doc . save (); doc . array [ 3 ] = 'changed' ; doc . markModified ( 'array' ); doc . save (); \u6211\u5b9a\u4e49\u6a21\u5f0f\u5c5e\u6027\u4e3a\u201cunique\u201d\uff0c\u4f46\u6211\u4ecd\u7136\u53ef\u4ee5\u4fdd\u5b58\u4e86\u91cd\u590d\u6570\u636e,\u662f\u4ec0\u4e48\u5bfc\u81f4\u7684\uff1f \u7b54\u6848 Mongoose\u672c\u8eab\u5e76\u4e0d\u5904\u7406 unique \uff1a {name\uff1a{type\uff1aString\uff0cunique\uff1atrue}} \u53ea\u662f\u5728 name \u4e0a\u521b\u5efa\u4e00\u4e2a[MongoDB\u552f\u4e00\u7d22\u5f15]\u7684\u7b80\u5199 2 \u4f8b\u5982\uff0c\u5982\u679cMongoDB\u5728 name \u4e0a\u6ca1\u6709\u552f\u4e00\u7684\u7d22\u5f15\uff0c \u5c3d\u7ba1\u201cunique\u201d\u662f\u771f\u5b9e\u7684\uff0c\u4f46\u4e0b\u9762\u7684\u4ee3\u7801\u4e0d\u4f1a\u51fa\u9519\u3002 JavaScript var schema = new mongoose . Schema ({ name : { type : String , unique : true } }); var Model = db . model ( 'Test' , schema ); Model . create ([{ name : 'Val' }, { name : 'Val' }], function ( err ) { console . log ( err ); }); \u7136\u800c\uff0c \u5982\u679c\u60a8\u4f7f\u7528 Model.on\uff08'index'\uff09 \u4e8b\u4ef6\u7b49\u5f85\u7d22\u5f15\u5efa\u7acb\uff0c\u5c1d\u8bd5\u4fdd\u5b58\u91cd\u590d\u5c06\u4f1a\u629b\u9519 JavaScript var schema = new mongoose . Schema ({ name : { type : String , unique : true } }); var Model = db . model ( 'Test' , schema ); Model . on ( 'index' , function ( err ) { assert . ifError ( err ); Model . create ([{ name : 'Val' }, { name : 'Val' }], function ( err ) { console . log ( err ); }); }); Model . init (). then ( function () { assert . ifError ( err ); Model . create ([{ name : 'Val' }, { name : 'Val' }], function ( err ) { console . log ( err ); }); }); MongoDB\u575a\u6301\u7d22\u5f15\uff0c \u6240\u4ee5\u4f60\u53ea\u9700\u8981\u91cd\u65b0\u5efa\u7acb\u7d22\u5f15\uff0c\u5982\u679c\u4f60\u5f00\u59cb\u4e00\u4e2a\u65b0\u7684\u6570\u636e\u5e93\uff0c\u6216\u8005\u4f60\u8fd0\u884c db.dropDatabase\uff08\uff09 \u3002\u5728\u751f\u4ea7\u73af\u5883\u4e2d\uff0c \u4f60\u5e94\u8be5[\u4f7f\u7528MongoDB shell]\uff09\uff08\uff09\u521b\u5efa\u7d22\u5f15\uff0c\u800c\u4e0d\u662f\u4f9d\u9760\u732b\u9f2c\u4e3a\u4f60\u505a\u3002 \u6a21\u5f0f\u7684 unique \u9009\u9879\u65b9\u4fbf\u5f00\u53d1\u548c\u6587\u6863\u5316\uff0c\u4f46\u732b\u9f2c\u4e0d\u662f\u7d22\u5f15\u7ba1\u7406\u89e3\u51b3\u65b9\u6848 \u5f53\u6211\u5728\u6a21\u5f0f\u4e2d\u6709\u4e00\u4e2a\u5d4c\u5957\u5c5e\u6027\u65f6\uff0cmongoose\u9ed8\u8ba4\u6dfb\u52a0\u7a7a\u5bf9\u8c61,\u4e3a\u4ec0\u4e48\uff1f JavaScript var schema = new mongoose . Schema ({ nested : { prop : String } }); var Model = db . model ( 'Test' , schema ); console . log ( new Model ()); \u7b54\u6848 \u8fd9\u662f\u4e00\u4e2a\u6027\u80fd\u4f18\u5316 \u8fd9\u4e9b\u7a7a\u7684\u5bf9\u8c61\u4e0d\u4f1a\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\uff0c \u4e5f\u4e0d\u662f\u5728\u7ed3\u679c toObject\uff08\uff09 \u4e2d\uff0c \u9664\u975e\u5173\u95ed minimize \u9009\u9879 \uff0c\u5426\u5219\u5b83\u4eec\u4e0d\u4f1a\u51fa\u73b0\u5728 JSON.stringify\uff08\uff09 \u8f93\u51fa\u4e2d\u3002 \u8fd9\u79cd\u884c\u4e3a\u7684\u539f\u56e0\u662fMongoose\u7684\u53d8\u5316\u68c0\u6d4b\u548cgetter / setter\u662f\u57fa\u4e8e Object.defineProperty\uff08\uff09 \u3002\u4e3a\u4e86\u652f\u6301\u5bf9\u5d4c\u5957\u5c5e\u6027\u7684\u66f4\u6539\u68c0\u6d4b\uff0c\u800c\u4e0d\u4f1a\u5728\u6bcf\u6b21\u521b\u5efa\u6587\u6863\u65f6\u62db\u81f4\u8fd0\u884cObject.defineProperty\uff08\uff09\u7684\u5f00\u9500\uff0c mongoose\u5728\u6a21\u578b\u7f16\u8bd1\u65f6\u5b9a\u4e49 Model \u539f\u578b\u7684\u5c5e\u6027\u3002,\u7531\u4e8e\u732b\u9f2c\u9700\u8981\u4e3a nested.prop \u5b9a\u4e49getter\u548csetter\uff0c \u5fc5\u987b\u59cb\u7ec8\u5c06\u201c\u5d4c\u5957\u201d\u5b9a\u4e49\u4e3a\u732b\u9f2c\u6587\u6863\u4e0a\u7684\u5bf9\u8c61\uff0c \u5373\u4f7f nested \u5728\u5e95\u5c42\u7684 POJO \u4e0a\u662f\u672a\u5b9a\u4e49\u7684\u3002 \u6211\u5728 virtual \uff0cgetter/setter\u6216 method \u4f7f\u7528\u7bad\u5934\u51fd\u6570\uff0cthis\u7684\u503c\u662f\u4e3a\u4ec0\u4e48\u662f\u9519\u8bef\u7684\uff1f \u7b54\u6848 \u7bad\u5934\u51fd\u6570 \u5904\u7406 this \u5173\u952e\u5b57\u4e0e\u4f20\u7edf\u51fd\u6570\u5927\u4e0d\u76f8\u540c . Mongoose getter/setter\u4f9d\u8d56 this \u6765\u8ba9\u4f60\u8bbf\u95ee\u4f60\u6b63\u5728\u5199\u7684\u6587\u6863\uff0c\u4f46\u662f\u8fd9\u4e2a\u529f\u80fd\u4e0d\u80fd\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u3002 \u9664\u975e\u4e0d\u6253\u7b97\u8bbf\u95eegetter/setter\u4e2d\u7684\u6587\u6863\uff0c\u5426\u5219\u4e0d\u8981\u4f7f\u7528\u7bad\u5934\u51fd\u6570\u6765\u53d6\u5f97 Mongoose getter/setter\u3002 JavaScript var schema = new mongoose . Schema ({ propWithGetter : { type : String , get : v => { console . log ( this ); return v ; } } }); schema . method . arrowMethod = () => this ; schema . virtual ( 'virtualWithArrow' ). get (() => { console . log ( this ); }); \u6211\u6709\u4e00\u4e2a\u540d\u4e3a type \u7684\u5d4c\u5165\u5f0f\u5c5e\u6027\u662f\u8fd9\u6837\u7684\uff1a JavaScript const holdingSchema = new Schema ({ asset : { type : String , ticker : String } }); \u4f46mongoose\u7ed9\u4e86\u6211\u4e00\u4e2aCastError\u63d0\u793a\uff0c\u5f53\u6211\u8bd5\u56fe\u7528\u4e00\u4e2a asset \u5bf9\u8c61\u6765\u4fdd\u5b58 Holding \u65f6\uff0c\u5b83\u4e0d\u80fd\u628a\u4e00\u4e2a\u5bf9\u8c61\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002 JavaScript Holding . create ({ asset : { type : 'stock' , ticker : 'MDB' } }). catch ( error => { console . error ( error ); }); \u7b54\u6848 \u201c\u7c7b\u578b\u201d\u5c5e\u6027\u5728\u732b\u9f2c\u662f\u7279\u522b\u7684\uff0c\u6240\u4ee5\u5f53\u4f60\u8bf4 type\uff1aString \u65f6\uff0c\u732b\u9f2c\u628a\u5b83\u89e3\u91ca\u4e3a\u4e00\u4e2a\u7c7b\u578b\u58f0\u660e. \u5728\u4e0a\u9762\u7684\u6a21\u5f0f\u4e2d\uff0c\u732b\u9f2c\u8ba4\u4e3a\u201casset\u201d\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5bf9\u8c61\u3002,\u505a\u8fd9\u4e2a\uff0c\u800c\u4e0d\u662f\uff1a JavaScript const holdingSchema = new Schema ({ asset : { type : { type : String }, ticker : String } }); \u4e3a\u4ec0\u4e48\u4e0d\u80fd\u5bf9\u65e5\u671f\u5bf9\u8c61\uff08\u4f8b\u5982 date.setMonth\uff081\uff09; \uff09\u8fdb\u884c\u5c31\u5730\u4fee\u6539\uff1f JavaScript doc . createdAt . setDate ( 2011 , 5 , 1 ); doc . save (); \u7b54\u6848 Mongoose\u76ee\u524d\u4e0d\u4f1a\u76d1\u89c6\u65e5\u671f\u5bf9\u8c61\u7684\u5c31\u5730\u66f4\u65b0,\u5982\u679c\u60a8\u9700\u8981\u8fd9\u4e2a\u529f\u80fd\uff0c\u8bf7\u968f\u65f6\u5728 \u6b64GitHub\u95ee\u9898 \u4e0a\u8ba8\u8bba\u3002,\u6709\u51e0\u4e2a\u89e3\u51b3\u65b9\u6cd5\uff1a JavaScript doc . createdAt . setDate ( 2011 , 5 , 1 ); doc . markModified ( 'createdAt' ); doc . save (); doc . createdAt = new Date ( 2011 , 5 , 1 ). setHours ( 4 ); doc . save (); \u6211\u5728\u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u586b\u5145\u6570\u7ec4\u4e0b\u7684\u5d4c\u5957\u5c5e\u6027\uff1a JavaScript new Schema ({ arr : [{ child : { ref : 'OtherModel' , type : Schema . Types . ObjectId } }] }); .populate\uff08{path\uff1a'arr.child'\uff0coptions\uff1a{sort\uff1a'name'}}\uff09 \u4e0d\u4f1a\u88ab arr.child.name \u6392\u5e8f \u7b54\u6848 \u89c1 \u8fd9\u4e2aGitHub\u95ee\u9898 \u3002,\u8fd9\u662f\u4e00\u4e2a\u5df2\u77e5\u7684\u95ee\u9898\uff0c\u4f46\u662f\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u96be\u4ee5\u89e3\u51b3\u7684\u95ee\u9898 \u6211\u7684\u6a21\u578b\u4e0a\u7684\u6240\u6709\u51fd\u6570\u8c03\u7528\u6302\u8d77\uff0c\u6211\u505a\u9519\u4e86\u4ec0\u4e48\uff1f \u7b54\u6848 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cmongoose\u4f1a\u7f13\u51b2\u4f60\u7684\u51fd\u6570\u8c03\u7528\uff0c\u76f4\u5230\u5b83\u53ef\u4ee5\u8fde\u63a5\u5230MongoDB\u3002,\u9605\u8bfb \u8fde\u63a5\u6587\u6863\u7684\u7f13\u51b2\u90e8\u5206 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 \u6211\u600e\u6837\u624d\u80fd\u542f\u7528\u8c03\u8bd5\uff1f \u7b54\u6848 \u5c06 debug \u9009\u9879\u8bbe\u7f6e\u4e3a true JavaScript mongoose . set ( 'debug' , true ) \u6240\u6709\u6267\u884c\u7684\u6536\u96c6\u65b9\u6cd5\u90fd\u4f1a\u5c06\u5176\u53c2\u6570\u7684\u8f93\u51fa\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002 \u6211\u7684 save\uff08\uff09 \u56de\u8c03\u4ece\u4e0d\u6267\u884c\u3002 \u6211\u7a76\u7adf\u505a\u9519\u4e86\u4ec0\u4e48\uff1f \u7b54\u6848 \u6240\u6709\u7684\u201c\u96c6\u5408\u201d\u64cd\u4f5c\uff08\u63d2\u5165\uff0c\u5220\u9664\uff0c\u67e5\u8be2\u7b49\uff09\u90fd\u88ab\u6392\u961f\uff0c\u76f4\u5230\u201c\u8fde\u63a5\u201d\u6253\u5f00. \u5c1d\u8bd5\u8fde\u63a5\u65f6\u53ef\u80fd\u53d1\u751f\u9519\u8bef\u3002\u5c1d\u8bd5\u6dfb\u52a0\u4e00\u4e2a\u9519\u8bef\u5904\u7406\u7a0b\u5e8f\u5230\u60a8\u7684\u8fde\u63a5\u3002 JavaScript mongoose . connect (..); mongoose . connection . on ( 'error' , handleError ); var conn = mongoose . createConnection (..); conn . on ( 'error' , handleError ); \u5982\u679c\u60a8\u60f3\u8981\u5728\u6574\u4e2a\u5e94\u7528\u7a0b\u5e8f\u4e2d\u9009\u62e9\u4e0d\u4f7f\u7528\u732b\u9f2c\u7684\u7f13\u51b2\u673a\u5236\uff0c\u8bf7\u5c06\u5168\u5c40 bufferCommands \u9009\u9879\u8bbe\u7f6e\u4e3afalse JavaScript mongoose . set ( 'bufferCommands' , false ); \u6211\u5e94\u8be5\u4e3a\u6bcf\u4e2a\u6570\u636e\u5e93\u64cd\u4f5c\u521b\u5efa/\u9500\u6bc1\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5417\uff1f \u7b54\u6848 \u4e0d\u7528\u3002\u5728\u5e94\u7528\u7a0b\u5e8f\u542f\u52a8\u65f6\u6253\u5f00\u8fde\u63a5\uff0c\u5e76\u4fdd\u6301\u6253\u5f00\u72b6\u6001\uff0c\u76f4\u5230\u5e94\u7528\u7a0b\u5e8f\u5173\u95ed\u3002 \u4e3a\u4ec0\u4e48\u6211\u5f97\u5230\"OverwriteModelError: Cannot overwrite .. model once compiled\" \u5f53\u6211\u4f7f\u7528nodemon(\u4e00\u4e2a\u6d4b\u8bd5\u6846\u67b6)\uff1f \u7b54\u6848 mongoose.model('ModelName',schema)'\u8981\u6c42 ModelName \u662f\u552f\u4e00\u7684\uff0c \u6240\u4ee5\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 mongoose.model('ModelName') \u6765\u8bbf\u95ee\u6a21\u578b\u3002 \u5982\u679c\u4f60\u628amongoose.model('ModelName',schema); \u653e\u5728 mocha beforeEach() hook \u4e2d\uff0c \u6b64\u4ee3\u7801\u5c06\u5c1d\u8bd5\u5728 \u6bcf \u6d4b\u8bd5\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a\u201cModelName\u201d\u7684\u65b0\u6a21\u578b\uff0c \u6240\u4ee5\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u9519\u8bef\u3002 \u786e\u4fdd\u4f60\u53ea\u7528\u4e00\u4e2a\u7ed9\u5b9a\u7684\u540d\u5b57 once \u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6a21\u578b\u3002 \u5982\u679c\u60a8\u9700\u8981\u521b\u5efa\u5177\u6709\u76f8\u540c\u540d\u79f0\u7684\u591a\u4e2a\u6a21\u578b\uff0c\u8bf7\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fde\u63a5\u5e76\u5c06\u6a21\u578b\u7ed1\u5b9a\u5230\u8fde\u63a5\u3002 JavaScript var mongoose = require ( 'mongoose' ); var connection = mongoose . createConnection (..); var kittySchema = mongoose . Schema ({ name : String }); var Kitten = connection . model ( 'Kitten' , kittySchema ); \u8981\u6dfb\u52a0\u7684\u4e1c\u897f? \u5982\u679c\u60a8\u60f3\u8d21\u732e\u6b64\u9875\u9762\uff0c\u8bf7\u5728github\u4e0a \u8bbf\u95ee\u5b83 \uff0c\u5e76\u4f7f\u7528 \u7f16\u8f91 \u6309\u94ae\u53d1\u9001\u62c9\u53d6\u8bf7\u6c42\u3002","title":"\u5e38\u89c1\u95ee\u9898"},{"location":"QuickStart/","text":"\u5165\u95e8 \u00b6 \u5165\u95e8\u4f7f\u7528 \u00b6 \u6e90 \u9996\u5148\u5b89\u88c5 MongoDB \u548c Node.js \u3002 \u63a5\u4e0b\u6765\u4f7f\u7528 npm \u5b89\u88c5Mongoose\uff1a Bash $ npm install mongoose \u505a\u4e2a\u5c0f\u732b\u6a21\u578b\uff0c\u5148\u8fde\u63a5\u672c\u5730\u6570\u636e\u5e93 test . JavaScript var mongoose = require ( 'mongoose' ); mongoose . connect ( 'mongodb://localhost/test' ); \u6dfb\u52a0\u9519\u8bef\u901a\u77e5\uff0c\u4ee5\u53ca\u8fde\u63a5\u6210\u529f\u65b9\u6cd5: JavaScript var db = mongoose . connection ; db . on ( 'error' , console . error . bind ( console , 'connection error:' )); db . once ( 'open' , function () { }); \u4e00\u65e6\u6211\u4eec\u7684\u8fde\u63a5\u6253\u5f00\uff0c\u6211\u4eec\u7684\u56de\u8c03\u5c06\u88ab\u8c03\u7528\uff0c\u4e3a\u7b80\u6d01\u8d77\u89c1\uff0c\u6211\u4eec\u5047\u8bbe\u4ee5\u4e0b\u6240\u6709\u4ee3\u7801\u90fd\u4f4d\u4e8e\u6b64\u56de\u8c03\u4e2d\u3002 \u5b9a\u4e49\u5c0f\u732b \u6a21\u5f0f . JavaScript var kittySchema = mongoose . Schema ({ name : String }); \u6211\u4eec\u6709\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027 name , \u7c7b\u578b String . \u4e0b\u4e00\u6b65\u662f\u5c06\u6211\u4eec\u7684\u6a21\u5f0f\u7f16\u8bd1\u6210\u4e00\u4e2a \u6a21\u578b . JavaScript var Kitten = mongoose . model ( 'Kitten' , kittySchema ); \u6a21\u578b\u662f\u6211\u4eec\u6784\u9020\u6587\u6863\u7684\u7c7b\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c \u6bcf\u4e2a\u6587\u6863\u5c06\u6210\u4e3a\u4e00\u4e2a\u5c0f\u732b\uff0c\u5176\u7279\u6027\u548c\u884c\u4e3a\u5728\u6211\u4eec\u7684\u6a21\u5f0f\u4e2d\u58f0\u660e\u3002 \u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u5c0f\u732b\u6587\u6863\uff0c\u4ee3\u8868\u6211\u4eec\u521a\u521a\u5728\u5916\u9762\u7684\u4eba\u884c\u9053\u4e0a\u9047\u5230\u7684\u5c0f\u5bb6\u4f19\uff1a JavaScript var silence = new Kitten ({ name : 'Silence' }); console . log ( silence . name ); \u5c0f\u732b\u53ef\u4ee5\u55b5\u55b5\u53eb\uff0c\u90a3\u4e48\u8ba9\u6211\u4eec\u6765\u770b\u770b\u5982\u4f55\u5728\u6211\u4eec\u7684\u6587\u6863\u4e2d\u6dfb\u52a0\u201cspeak\u201d\u529f\u80fd\uff1a JavaScript kittySchema . methods . speak = function () { var greeting = this . name ? \"Meow name is \" + this . name : \"I don't have a name\" ; console . log ( greeting ); } var Kitten = mongoose . model ( 'Kitten' , kittySchema ); \u6dfb\u52a0\u5230\u6a21\u5f0f\u7684\u201c\u65b9\u6cd5\u201d\u5c5e\u6027\u7684\u51fd\u6570\u88ab\u7f16\u8bd1\u5230\u201c\u6a21\u578b\u201d\u539f\u578b\u4e2d\uff0c\u5e76\u663e\u793a\u5728\u6bcf\u4e2a\u6587\u6863\u5b9e\u4f8b\u4e0a\uff1a JavaScript var fluffy = new Kitten ({ name : 'fluffy' }); fluffy . speak (); \u6211\u4eec\u6709\u8bf4\u8bdd\u7684\u5c0f\u732b\uff01\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4fdd\u5b58\u4efb\u4f55\u4e1c\u897f\u7ed9MongoDB\u3002 \u6bcf\u4e2a\u6587\u6863\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 save \u65b9\u6cd5\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\u3002 \u56de\u8c03\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c06\u662f\u4e00\u4e2a\u9519\u8bef\uff0c\u5982\u679c\u6709\u9519\u8bef\u5c06\u663e\u793a\u51fa\u6765\u3002 JavaScript fluffy . save ( function ( err , fluffy ) { if ( err ) return console . error ( err ); fluffy . speak (); }); \u8bf4\u65f6\u95f4\u8fc7\u53bb\u4e86\uff0c\u6211\u4eec\u60f3\u8981\u663e\u793a\u6211\u4eec\u770b\u5230\u7684\u6240\u6709\u5c0f\u732b\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6211\u4eec\u7684\u5c0f\u732b \u6a21\u578b \u8bbf\u95ee\u6240\u6709\u7684\u5c0f\u732b\u6587\u6863\u3002 JavaScript Kitten . find ( function ( err , kittens ) { if ( err ) return console . error ( err ); console . log ( kittens ); }) \u6211\u4eec\u53ea\u628a\u6211\u4eec\u7684\u6570\u636e\u5e93\u4e2d\u7684\u6240\u6709\u5c0f\u732b\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002 \u5982\u679c\u6211\u4eec\u60f3\u6309\u540d\u5b57\u8fc7\u6ee4\u6211\u4eec\u7684\u5c0f\u732b\uff0cMongoose\u652f\u6301MongoDB\u4e30\u5bcc\u7684 \u67e5\u8be2 \u8bed\u6cd5\u3002 JavaScript Kitten . find ({ name : /^fluff/ }, callback ); \u8fd9\u5c06\u641c\u7d22\u540d\u79f0\u5c5e\u6027\u4ee5\u201cFluff\u201d\u5f00\u5934\u7684\u6240\u6709\u6587\u6863\uff0c\u5e76\u5c06\u7ed3\u679c\u4f5c\u4e3a\u5c0f\u732b\u6570\u7ec4\u8fd4\u56de\u7ed9\u56de\u8c03\u3002 \u795d\u8d3a \u00b6 \u8fd9\u662f\u6211\u4eec\u5feb\u901f\u542f\u52a8\u7684\u7ed3\u675f\u3002,\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u5f0f\uff0c\u6dfb\u52a0\u4e86\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u6587\u6863\u65b9\u6cd5\uff0c\u4f7f\u7528Mongoose\u5728MongoDB\u4e2d\u4fdd\u5b58\u5e76\u67e5\u8be2\u4e86\u5c0f\u732b\u3002,\u8bf7\u8f6c\u5230 guide \u6216 API\u6587\u6863 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002","title":"\u5feb\u901f\u5f00\u59cb"},{"location":"QuickStart/#_1","text":"","title":"\u5165\u95e8"},{"location":"QuickStart/#_2","text":"\u6e90 \u9996\u5148\u5b89\u88c5 MongoDB \u548c Node.js \u3002 \u63a5\u4e0b\u6765\u4f7f\u7528 npm \u5b89\u88c5Mongoose\uff1a Bash $ npm install mongoose \u505a\u4e2a\u5c0f\u732b\u6a21\u578b\uff0c\u5148\u8fde\u63a5\u672c\u5730\u6570\u636e\u5e93 test . JavaScript var mongoose = require ( 'mongoose' ); mongoose . connect ( 'mongodb://localhost/test' ); \u6dfb\u52a0\u9519\u8bef\u901a\u77e5\uff0c\u4ee5\u53ca\u8fde\u63a5\u6210\u529f\u65b9\u6cd5: JavaScript var db = mongoose . connection ; db . on ( 'error' , console . error . bind ( console , 'connection error:' )); db . once ( 'open' , function () { }); \u4e00\u65e6\u6211\u4eec\u7684\u8fde\u63a5\u6253\u5f00\uff0c\u6211\u4eec\u7684\u56de\u8c03\u5c06\u88ab\u8c03\u7528\uff0c\u4e3a\u7b80\u6d01\u8d77\u89c1\uff0c\u6211\u4eec\u5047\u8bbe\u4ee5\u4e0b\u6240\u6709\u4ee3\u7801\u90fd\u4f4d\u4e8e\u6b64\u56de\u8c03\u4e2d\u3002 \u5b9a\u4e49\u5c0f\u732b \u6a21\u5f0f . JavaScript var kittySchema = mongoose . Schema ({ name : String }); \u6211\u4eec\u6709\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027 name , \u7c7b\u578b String . \u4e0b\u4e00\u6b65\u662f\u5c06\u6211\u4eec\u7684\u6a21\u5f0f\u7f16\u8bd1\u6210\u4e00\u4e2a \u6a21\u578b . JavaScript var Kitten = mongoose . model ( 'Kitten' , kittySchema ); \u6a21\u578b\u662f\u6211\u4eec\u6784\u9020\u6587\u6863\u7684\u7c7b\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c \u6bcf\u4e2a\u6587\u6863\u5c06\u6210\u4e3a\u4e00\u4e2a\u5c0f\u732b\uff0c\u5176\u7279\u6027\u548c\u884c\u4e3a\u5728\u6211\u4eec\u7684\u6a21\u5f0f\u4e2d\u58f0\u660e\u3002 \u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u5c0f\u732b\u6587\u6863\uff0c\u4ee3\u8868\u6211\u4eec\u521a\u521a\u5728\u5916\u9762\u7684\u4eba\u884c\u9053\u4e0a\u9047\u5230\u7684\u5c0f\u5bb6\u4f19\uff1a JavaScript var silence = new Kitten ({ name : 'Silence' }); console . log ( silence . name ); \u5c0f\u732b\u53ef\u4ee5\u55b5\u55b5\u53eb\uff0c\u90a3\u4e48\u8ba9\u6211\u4eec\u6765\u770b\u770b\u5982\u4f55\u5728\u6211\u4eec\u7684\u6587\u6863\u4e2d\u6dfb\u52a0\u201cspeak\u201d\u529f\u80fd\uff1a JavaScript kittySchema . methods . speak = function () { var greeting = this . name ? \"Meow name is \" + this . name : \"I don't have a name\" ; console . log ( greeting ); } var Kitten = mongoose . model ( 'Kitten' , kittySchema ); \u6dfb\u52a0\u5230\u6a21\u5f0f\u7684\u201c\u65b9\u6cd5\u201d\u5c5e\u6027\u7684\u51fd\u6570\u88ab\u7f16\u8bd1\u5230\u201c\u6a21\u578b\u201d\u539f\u578b\u4e2d\uff0c\u5e76\u663e\u793a\u5728\u6bcf\u4e2a\u6587\u6863\u5b9e\u4f8b\u4e0a\uff1a JavaScript var fluffy = new Kitten ({ name : 'fluffy' }); fluffy . speak (); \u6211\u4eec\u6709\u8bf4\u8bdd\u7684\u5c0f\u732b\uff01\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u4fdd\u5b58\u4efb\u4f55\u4e1c\u897f\u7ed9MongoDB\u3002 \u6bcf\u4e2a\u6587\u6863\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 save \u65b9\u6cd5\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u4e2d\u3002 \u56de\u8c03\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c06\u662f\u4e00\u4e2a\u9519\u8bef\uff0c\u5982\u679c\u6709\u9519\u8bef\u5c06\u663e\u793a\u51fa\u6765\u3002 JavaScript fluffy . save ( function ( err , fluffy ) { if ( err ) return console . error ( err ); fluffy . speak (); }); \u8bf4\u65f6\u95f4\u8fc7\u53bb\u4e86\uff0c\u6211\u4eec\u60f3\u8981\u663e\u793a\u6211\u4eec\u770b\u5230\u7684\u6240\u6709\u5c0f\u732b\u3002 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6211\u4eec\u7684\u5c0f\u732b \u6a21\u578b \u8bbf\u95ee\u6240\u6709\u7684\u5c0f\u732b\u6587\u6863\u3002 JavaScript Kitten . find ( function ( err , kittens ) { if ( err ) return console . error ( err ); console . log ( kittens ); }) \u6211\u4eec\u53ea\u628a\u6211\u4eec\u7684\u6570\u636e\u5e93\u4e2d\u7684\u6240\u6709\u5c0f\u732b\u8bb0\u5f55\u5230\u63a7\u5236\u53f0\u3002 \u5982\u679c\u6211\u4eec\u60f3\u6309\u540d\u5b57\u8fc7\u6ee4\u6211\u4eec\u7684\u5c0f\u732b\uff0cMongoose\u652f\u6301MongoDB\u4e30\u5bcc\u7684 \u67e5\u8be2 \u8bed\u6cd5\u3002 JavaScript Kitten . find ({ name : /^fluff/ }, callback ); \u8fd9\u5c06\u641c\u7d22\u540d\u79f0\u5c5e\u6027\u4ee5\u201cFluff\u201d\u5f00\u5934\u7684\u6240\u6709\u6587\u6863\uff0c\u5e76\u5c06\u7ed3\u679c\u4f5c\u4e3a\u5c0f\u732b\u6570\u7ec4\u8fd4\u56de\u7ed9\u56de\u8c03\u3002","title":"\u5165\u95e8\u4f7f\u7528"},{"location":"QuickStart/#_3","text":"\u8fd9\u662f\u6211\u4eec\u5feb\u901f\u542f\u52a8\u7684\u7ed3\u675f\u3002,\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u5f0f\uff0c\u6dfb\u52a0\u4e86\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u6587\u6863\u65b9\u6cd5\uff0c\u4f7f\u7528Mongoose\u5728MongoDB\u4e2d\u4fdd\u5b58\u5e76\u67e5\u8be2\u4e86\u5c0f\u732b\u3002,\u8bf7\u8f6c\u5230 guide \u6216 API\u6587\u6863 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002","title":"\u795d\u8d3a"},{"location":"VersionCompatibility/","text":"MongoDB\u670d\u52a1\u5668\u7248\u672c\u517c\u5bb9\u6027 \u00b6 \u6e90 Mongoose\u4f9d\u9760 MongoDB Node.js \u9a71\u52a8\u5668 \u4e0eMongoDB\u8fdb\u884c\u901a\u4fe1\u3002 \u60a8\u53ef\u4ee5\u53c2\u8003 \u6b64\u8868 \u83b7\u53d6\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u9a71\u52a8\u7a0b\u5e8f\u652f\u6301\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u7684\u6700\u65b0\u4fe1\u606f\u3002 \u4e0b\u9762\u662f\u4ee3\u8868\u54ea\u4e2a\u7248\u672c\u7684mongoose\u4e0e\u5217\u51fa\u7684MongoDB\u7248\u672c\u517c\u5bb9\u7684 semver \u8303\u56f4 MongoDB \u670d\u52a1\u5668 2.4.x: mongoose ~3.8 \u6216\u8005 4.x MongoDB \u670d\u52a1\u5668 2.6.x: mongoose ~3.8.8 \u6216\u8005 4.x MongoDB \u670d\u52a1\u5668 3.0.x: mongoose ~3.8.22 , 4.x \u6216\u8005 5.x MongoDB \u670d\u52a1\u5668 3.2.x: mongoose >=4.3.0 \u6216\u8005 5.x MongoDB \u670d\u52a1\u5668 3.4.x: mongoose >=4.7.3 \u6216\u8005 5.x MongoDB \u670d\u52a1\u5668 3.6.x: mongoose 5.x , \u6216\u8005 >=4.11.0 with useMongoClient and usePushEach","title":"\u7248\u672c\u517c\u5bb9\u6027"},{"location":"VersionCompatibility/#mongodb","text":"\u6e90 Mongoose\u4f9d\u9760 MongoDB Node.js \u9a71\u52a8\u5668 \u4e0eMongoDB\u8fdb\u884c\u901a\u4fe1\u3002 \u60a8\u53ef\u4ee5\u53c2\u8003 \u6b64\u8868 \u83b7\u53d6\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u9a71\u52a8\u7a0b\u5e8f\u652f\u6301\u54ea\u4e2a\u7248\u672c\u7684MongoDB\u7684\u6700\u65b0\u4fe1\u606f\u3002 \u4e0b\u9762\u662f\u4ee3\u8868\u54ea\u4e2a\u7248\u672c\u7684mongoose\u4e0e\u5217\u51fa\u7684MongoDB\u7248\u672c\u517c\u5bb9\u7684 semver \u8303\u56f4 MongoDB \u670d\u52a1\u5668 2.4.x: mongoose ~3.8 \u6216\u8005 4.x MongoDB \u670d\u52a1\u5668 2.6.x: mongoose ~3.8.8 \u6216\u8005 4.x MongoDB \u670d\u52a1\u5668 3.0.x: mongoose ~3.8.22 , 4.x \u6216\u8005 5.x MongoDB \u670d\u52a1\u5668 3.2.x: mongoose >=4.3.0 \u6216\u8005 5.x MongoDB \u670d\u52a1\u5668 3.4.x: mongoose >=4.7.3 \u6216\u8005 5.x MongoDB \u670d\u52a1\u5668 3.6.x: mongoose 5.x , \u6216\u8005 >=4.11.0 with useMongoClient and usePushEach","title":"MongoDB\u670d\u52a1\u5668\u7248\u672c\u517c\u5bb9\u6027"},{"location":"migrating_to_5/","text":"\u5347\u7ea7\u52305 \u00b6 \u7248\u672c\u8981\u6c42 \u00b6 Mongoose now requires node.js >= 4.0.0 and MongoDB >= 3.0.0. MongoDB 2.6 and Node.js < 4 where both EOL-ed in 2016. \u67e5\u8be2\u4e2d\u95f4\u4ef6 \u00b6 Query middleware is now compiled when you call mongoose.model() or db.model() . If you add query middleware after calling mongoose.model() , that middleware will not get called. JavaScript const schema = new Schema ({ name : String }); const MyModel = mongoose . model ( 'Test' , schema ); schema . pre ( 'find' , () => { console . log ( 'find!' ); }); MyModel . find (). exec ( function () { // In mongoose 4.x, the above `.find()` will print \"find!\" // In mongoose 5.x, \"find!\" will **not** be printed. // Call `pre('find')` **before** calling `mongoose.model()` to make the middleware apply. }); Promises and Callbacks for mongoose.connect() \u00b6 mongoose.connect() and mongoose.disconnect() now return a promise if no callback specified, or null otherwise. It does not return the mongoose singleton. JavaScript // Worked in mongoose 4. Does **not** work in mongoose 5, `mongoose.connect()` // now returns a promise consistently. This is to avoid the horrible things // we've done to allow mongoose to be a thenable that resolves to itself. mongoose . connect ( 'mongodb://localhost:27017/test' ). model ( 'Test' , new Schema ({})); // Do this instead mongoose . connect ( 'mongodb://localhost:27017/test' ); mongoose . model ( 'Test' , new Schema ({})); Connection Logic and useMongoClient \u00b6 The useMongoClient option was removed in Mongoose 5, it is now always true . As a consequence, Mongoose 5 no longer supports several function signatures for mongoose.connect() that worked in Mongoose 4.x if the useMongoClient option was off. Below are some examples of mongoose.connect() calls that do not work in Mongoose 5.x. mongoose.connect('localhost', 27017); mongoose.connect('localhost', 'mydb', 27017); mongoose.connect('mongodb://host1:27017,mongodb://host2:27017'); In Mongoose 5.x, the first parameter to mongoose.connect() and mongoose.createConnection() , if specified, must be a MongoDB connection string . The connection string and options are then passed down to the MongoDB Node.js driver's MongoClient.connect() function . Mongoose does not modify the connection string, although mongoose.connect() and mongoose.createConnection() support a few additional options in addition to the ones the MongoDB driver supports . Setter Order \u00b6 Setters run in reverse order in 4.x: JavaScript const schema = new Schema ({ name : String }); schema . path ( 'name' ). get (() => console . log ( 'This will print 2nd' )). get (() => console . log ( 'This will print first' )); In 5.x, setters run in the order they're declared. JavaScript const schema = new Schema ({ name : String }); schema . path ( 'name' ). get (() => console . log ( 'This will print first' )). get (() => console . log ( 'This will print 2nd' )); Return Values for remove() and deleteX() \u00b6 deleteOne() , deleteMany() , and remove() now resolve to the result object rather than the full driver WriteOpResult object . JavaScript // In 4.x, this is how you got the number of documents deleted MyModel . deleteMany (). then ( res => console . log ( res . result . n )); // In 5.x this is how you get the number of documents deleted MyModel . deleteMany (). then ( res => res . n ); \u805a\u5408\u6e38\u6807 \u00b6 The useMongooseAggCursor option from 4.x is now always on. This is the new syntax for aggregation cursors in mongoose 5: JavaScript // When you call `.cursor()`, `.exec()` will now return a mongoose aggregation // cursor. const cursor = MyModel . aggregate ([{ $match : { name : 'Val' } }]). cursor (). exec (); // No need to `await` on the cursor or wait for a promise to resolve cursor . eachAsync ( doc => console . log ( doc )); // Can also pass options to `cursor()` const cursorWithOptions = MyModel . aggregate ([{ $match : { name : 'Val' } }]). cursor ({ batchSize : 10 }). exec (); geoNear \u00b6 Model.geoNear() has been removed because the MongoDB driver no longer supports it \u57df\u5957\u63a5\u5b57 \u00b6 \u57df\u5957\u63a5\u5b57\u5fc5\u987b\u662fURI\u7f16\u7801\u7684\u3002 \u4f8b\u5982\uff1a JavaScript // \u5728mongoose 4\u5de5\u4f5c\u3002 \u7531\u4e8e\u66f4\u4e25\u683c\u7684URI\u89e3\u6790\uff0c**\u6ca1\u6709**\u5728mongoose 5\u4e2d\u5de5\u4f5c\u3002 const host = '/tmp/mongodb-27017.sock' ; mongoose . createConnection ( `mongodb://aaron:psw@ ${ host } /fake` ); // \u505a\u8fd9\u4ef6\u4e8b const host = encodeURIComponent ( '/tmp/mongodb-27017.sock' ); mongoose . createConnection ( `mongodb://aaron:psw@ ${ host } /fake` ); toObject() \u9009\u9879 \u00b6 The options parameter to toObject() and toJSON() merge defaults rather than overwriting them. JavaScript // Note the `toObject` option below const schema = new Schema ({ name : String }, { toObject : { virtuals : true } }); schema . virtual ( 'answer' ). get (() => 42 ); const MyModel = db . model ( 'MyModel' , schema ); const doc = new MyModel ({ name : 'test' }); // In mongoose 4.x this prints \"undefined\", because `{ minimize: false }` // overwrites the entire schema-defined options object. // In mongoose 5.x this prints \"42\", because `{ minimize: false }` gets // merged with the schema-defined options. console . log ( doc . toJSON ({ minimize : false }). answer ); \u805a\u5408\u53c2\u6570 \u00b6 aggregate() no longer accepts a spread, you must pass your aggregation pipeline as an array. The below code worked in 4.x: JavaScript MyModel . aggregate ({ $match : { isDeleted : false } }, { $skip : 10 }). exec ( cb ); The above code does not work in 5.x, you must wrap the $match and $skip stages in an array. JavaScript MyModel . aggregate ([{ $match : { isDeleted : false } }, { $skip : 10 }]). exec ( cb ); \u5e03\u5c14\u6295\u5c04 \u00b6 By default, mongoose 4 would coerce any value to a boolean without error. JavaScript // Fine in mongoose 4, would save a doc with `boolField = true` const MyModel = mongoose . model ( 'Test' , new Schema ({ boolField : Boolean })); MyModel . create ({ boolField : 'not a boolean' }); Mongoose 5 only casts the following values to true : true 'true' 1 '1' 'yes' And the following values to false : false 'false' 0 '0' 'no' All other values will cause a CastError \u67e5\u8be2\u6295\u5c04 \u00b6 Casting for update() , updateOne() , updateMany() , replaceOne() , remove() , deleteOne() , and deleteMany() doesn't happen until exec() . This makes it easier for hooks and custom query helpers to modify data, because mongoose won't restructure the data you passed in until after your hooks and query helpers have ran. It also makes it possible to set the overwrite option after passing in an update. JavaScript // In mongoose 4.x, this becomes `{ $set: { name: 'Baz' } }` despite the `overwrite` // In mongoose 5.x, this overwrite is respected and the first document with // `name = 'Bar'` will be replaced with `{ name: 'Baz' }` User . where ({ name : 'Bar' }). update ({ name : 'Baz' }). setOptions ({ overwrite : true }); Post Save Hooks Get Flow Control \u00b6 Post hooks now get flow control, which means async post save hooks and child document post save hooks execute before your save() callback. Text Only const ChildModelSchema = new mongoose.Schema({ text: { type: String } }); ChildModelSchema.post('save', function(doc) { // In mongoose 5.x this will print **before** the `console.log()` // in the `save()` callback. In mongoose 4.x this was reversed. console.log('Child post save'); }); const ParentModelSchema = new mongoose.Schema({ children: [ChildModelSchema] }); const Model = mongoose.model('Parent', ParentModelSchema); const m = new Model({ children: [{ text: 'test' }] }); m.save(function() { // In mongoose 5.xm this prints **after** the \"Child post save\" message. console.log('Save callback'); }); The $pushAll Operator \u00b6 $pushAll is no longer supported and no longer used internally for save() , since it has been deprecated since MongoDB 2.4 . Use $push with $each instead. Always Use Forward Key Order \u00b6 The retainKeyOrder option was removed, mongoose will now always retain the same key position when cloning objects. If you have queries or indexes that rely on reverse key order, you will have to change them. \u9884\u7f16\u8bd1\u7684\u6d4f\u89c8\u5668\u5305 \u00b6 We no longer have a pre-compiled version of mongoose for the browser. If you want to use mongoose schemas in the browser, you need to build your own bundle with browserify/webpack. \u4fdd\u5b58\u9519\u8bef \u00b6 The saveErrorIfNotFound option was removed, mongoose will now always error out from save() if the underlying document was not found Init hook signatures \u00b6 init hooks are now fully synchronous and do not receive next() as a parameter. Document.prototype.init() no longer takes a callback as a parameter. It was always synchronous, just had a callback for legacy reasons. numAffected \u548c save() \u00b6 doc.save() no longer passes numAffected as a 3rd param to its callback. remove() and debouncing \u00b6 doc.remove() no longer debounces getPromiseConstructor() \u00b6 getPromiseConstructor() is gone, just use mongoose.Promise . Passing Parameters from Pre Hooks \u00b6 You cannot pass parameters to the next pre middleware in the chain using next() in mongoose 5.x. In mongoose 4, next('Test') in pre middleware would call the next middleware with 'Test' as a parameter. Mongoose 5.x has removed support for this. \u6570\u7ec4\u7684 required \u9a8c\u8bc1\u5668 \u00b6 In mongoose 5 the required validator only verifies if the value is an array. That is, it will not fail for empty arrays as it would in mongoose 4.","title":"\u5347\u7ea7\u52305"},{"location":"migrating_to_5/#5","text":"","title":"\u5347\u7ea7\u52305"},{"location":"migrating_to_5/#_1","text":"Mongoose now requires node.js >= 4.0.0 and MongoDB >= 3.0.0. MongoDB 2.6 and Node.js < 4 where both EOL-ed in 2016.","title":"\u7248\u672c\u8981\u6c42"},{"location":"migrating_to_5/#_2","text":"Query middleware is now compiled when you call mongoose.model() or db.model() . If you add query middleware after calling mongoose.model() , that middleware will not get called. JavaScript const schema = new Schema ({ name : String }); const MyModel = mongoose . model ( 'Test' , schema ); schema . pre ( 'find' , () => { console . log ( 'find!' ); }); MyModel . find (). exec ( function () { // In mongoose 4.x, the above `.find()` will print \"find!\" // In mongoose 5.x, \"find!\" will **not** be printed. // Call `pre('find')` **before** calling `mongoose.model()` to make the middleware apply. });","title":"\u67e5\u8be2\u4e2d\u95f4\u4ef6"},{"location":"migrating_to_5/#promises-and-callbacks-for-mongooseconnect","text":"mongoose.connect() and mongoose.disconnect() now return a promise if no callback specified, or null otherwise. It does not return the mongoose singleton. JavaScript // Worked in mongoose 4. Does **not** work in mongoose 5, `mongoose.connect()` // now returns a promise consistently. This is to avoid the horrible things // we've done to allow mongoose to be a thenable that resolves to itself. mongoose . connect ( 'mongodb://localhost:27017/test' ). model ( 'Test' , new Schema ({})); // Do this instead mongoose . connect ( 'mongodb://localhost:27017/test' ); mongoose . model ( 'Test' , new Schema ({}));","title":"Promises and Callbacks for mongoose.connect()"},{"location":"migrating_to_5/#connection-logic-and-usemongoclient","text":"The useMongoClient option was removed in Mongoose 5, it is now always true . As a consequence, Mongoose 5 no longer supports several function signatures for mongoose.connect() that worked in Mongoose 4.x if the useMongoClient option was off. Below are some examples of mongoose.connect() calls that do not work in Mongoose 5.x. mongoose.connect('localhost', 27017); mongoose.connect('localhost', 'mydb', 27017); mongoose.connect('mongodb://host1:27017,mongodb://host2:27017'); In Mongoose 5.x, the first parameter to mongoose.connect() and mongoose.createConnection() , if specified, must be a MongoDB connection string . The connection string and options are then passed down to the MongoDB Node.js driver's MongoClient.connect() function . Mongoose does not modify the connection string, although mongoose.connect() and mongoose.createConnection() support a few additional options in addition to the ones the MongoDB driver supports .","title":"Connection Logic and useMongoClient"},{"location":"migrating_to_5/#setter-order","text":"Setters run in reverse order in 4.x: JavaScript const schema = new Schema ({ name : String }); schema . path ( 'name' ). get (() => console . log ( 'This will print 2nd' )). get (() => console . log ( 'This will print first' )); In 5.x, setters run in the order they're declared. JavaScript const schema = new Schema ({ name : String }); schema . path ( 'name' ). get (() => console . log ( 'This will print first' )). get (() => console . log ( 'This will print 2nd' ));","title":"Setter Order"},{"location":"migrating_to_5/#return-values-for-remove-and-deletex","text":"deleteOne() , deleteMany() , and remove() now resolve to the result object rather than the full driver WriteOpResult object . JavaScript // In 4.x, this is how you got the number of documents deleted MyModel . deleteMany (). then ( res => console . log ( res . result . n )); // In 5.x this is how you get the number of documents deleted MyModel . deleteMany (). then ( res => res . n );","title":"Return Values for remove() and deleteX()"},{"location":"migrating_to_5/#_3","text":"The useMongooseAggCursor option from 4.x is now always on. This is the new syntax for aggregation cursors in mongoose 5: JavaScript // When you call `.cursor()`, `.exec()` will now return a mongoose aggregation // cursor. const cursor = MyModel . aggregate ([{ $match : { name : 'Val' } }]). cursor (). exec (); // No need to `await` on the cursor or wait for a promise to resolve cursor . eachAsync ( doc => console . log ( doc )); // Can also pass options to `cursor()` const cursorWithOptions = MyModel . aggregate ([{ $match : { name : 'Val' } }]). cursor ({ batchSize : 10 }). exec ();","title":"\u805a\u5408\u6e38\u6807"},{"location":"migrating_to_5/#geonear","text":"Model.geoNear() has been removed because the MongoDB driver no longer supports it","title":"geoNear"},{"location":"migrating_to_5/#_4","text":"\u57df\u5957\u63a5\u5b57\u5fc5\u987b\u662fURI\u7f16\u7801\u7684\u3002 \u4f8b\u5982\uff1a JavaScript // \u5728mongoose 4\u5de5\u4f5c\u3002 \u7531\u4e8e\u66f4\u4e25\u683c\u7684URI\u89e3\u6790\uff0c**\u6ca1\u6709**\u5728mongoose 5\u4e2d\u5de5\u4f5c\u3002 const host = '/tmp/mongodb-27017.sock' ; mongoose . createConnection ( `mongodb://aaron:psw@ ${ host } /fake` ); // \u505a\u8fd9\u4ef6\u4e8b const host = encodeURIComponent ( '/tmp/mongodb-27017.sock' ); mongoose . createConnection ( `mongodb://aaron:psw@ ${ host } /fake` );","title":"\u57df\u5957\u63a5\u5b57"},{"location":"migrating_to_5/#toobject","text":"The options parameter to toObject() and toJSON() merge defaults rather than overwriting them. JavaScript // Note the `toObject` option below const schema = new Schema ({ name : String }, { toObject : { virtuals : true } }); schema . virtual ( 'answer' ). get (() => 42 ); const MyModel = db . model ( 'MyModel' , schema ); const doc = new MyModel ({ name : 'test' }); // In mongoose 4.x this prints \"undefined\", because `{ minimize: false }` // overwrites the entire schema-defined options object. // In mongoose 5.x this prints \"42\", because `{ minimize: false }` gets // merged with the schema-defined options. console . log ( doc . toJSON ({ minimize : false }). answer );","title":"toObject() \u9009\u9879"},{"location":"migrating_to_5/#_5","text":"aggregate() no longer accepts a spread, you must pass your aggregation pipeline as an array. The below code worked in 4.x: JavaScript MyModel . aggregate ({ $match : { isDeleted : false } }, { $skip : 10 }). exec ( cb ); The above code does not work in 5.x, you must wrap the $match and $skip stages in an array. JavaScript MyModel . aggregate ([{ $match : { isDeleted : false } }, { $skip : 10 }]). exec ( cb );","title":"\u805a\u5408\u53c2\u6570"},{"location":"migrating_to_5/#_6","text":"By default, mongoose 4 would coerce any value to a boolean without error. JavaScript // Fine in mongoose 4, would save a doc with `boolField = true` const MyModel = mongoose . model ( 'Test' , new Schema ({ boolField : Boolean })); MyModel . create ({ boolField : 'not a boolean' }); Mongoose 5 only casts the following values to true : true 'true' 1 '1' 'yes' And the following values to false : false 'false' 0 '0' 'no' All other values will cause a CastError","title":"\u5e03\u5c14\u6295\u5c04"},{"location":"migrating_to_5/#_7","text":"Casting for update() , updateOne() , updateMany() , replaceOne() , remove() , deleteOne() , and deleteMany() doesn't happen until exec() . This makes it easier for hooks and custom query helpers to modify data, because mongoose won't restructure the data you passed in until after your hooks and query helpers have ran. It also makes it possible to set the overwrite option after passing in an update. JavaScript // In mongoose 4.x, this becomes `{ $set: { name: 'Baz' } }` despite the `overwrite` // In mongoose 5.x, this overwrite is respected and the first document with // `name = 'Bar'` will be replaced with `{ name: 'Baz' }` User . where ({ name : 'Bar' }). update ({ name : 'Baz' }). setOptions ({ overwrite : true });","title":"\u67e5\u8be2\u6295\u5c04"},{"location":"migrating_to_5/#post-save-hooks-get-flow-control","text":"Post hooks now get flow control, which means async post save hooks and child document post save hooks execute before your save() callback. Text Only const ChildModelSchema = new mongoose.Schema({ text: { type: String } }); ChildModelSchema.post('save', function(doc) { // In mongoose 5.x this will print **before** the `console.log()` // in the `save()` callback. In mongoose 4.x this was reversed. console.log('Child post save'); }); const ParentModelSchema = new mongoose.Schema({ children: [ChildModelSchema] }); const Model = mongoose.model('Parent', ParentModelSchema); const m = new Model({ children: [{ text: 'test' }] }); m.save(function() { // In mongoose 5.xm this prints **after** the \"Child post save\" message. console.log('Save callback'); });","title":"Post Save Hooks Get Flow Control"},{"location":"migrating_to_5/#the-pushall-operator","text":"$pushAll is no longer supported and no longer used internally for save() , since it has been deprecated since MongoDB 2.4 . Use $push with $each instead.","title":"The $pushAll Operator"},{"location":"migrating_to_5/#always-use-forward-key-order","text":"The retainKeyOrder option was removed, mongoose will now always retain the same key position when cloning objects. If you have queries or indexes that rely on reverse key order, you will have to change them.","title":"Always Use Forward Key Order"},{"location":"migrating_to_5/#_8","text":"We no longer have a pre-compiled version of mongoose for the browser. If you want to use mongoose schemas in the browser, you need to build your own bundle with browserify/webpack.","title":"\u9884\u7f16\u8bd1\u7684\u6d4f\u89c8\u5668\u5305"},{"location":"migrating_to_5/#_9","text":"The saveErrorIfNotFound option was removed, mongoose will now always error out from save() if the underlying document was not found","title":"\u4fdd\u5b58\u9519\u8bef"},{"location":"migrating_to_5/#init-hook-signatures","text":"init hooks are now fully synchronous and do not receive next() as a parameter. Document.prototype.init() no longer takes a callback as a parameter. It was always synchronous, just had a callback for legacy reasons.","title":"Init hook signatures"},{"location":"migrating_to_5/#numaffected-save","text":"doc.save() no longer passes numAffected as a 3rd param to its callback.","title":"numAffected \u548c save()"},{"location":"migrating_to_5/#remove-and-debouncing","text":"doc.remove() no longer debounces","title":"remove() and debouncing"},{"location":"migrating_to_5/#getpromiseconstructor","text":"getPromiseConstructor() is gone, just use mongoose.Promise .","title":"getPromiseConstructor()"},{"location":"migrating_to_5/#passing-parameters-from-pre-hooks","text":"You cannot pass parameters to the next pre middleware in the chain using next() in mongoose 5.x. In mongoose 4, next('Test') in pre middleware would call the next middleware with 'Test' as a parameter. Mongoose 5.x has removed support for this.","title":"Passing Parameters from Pre Hooks"},{"location":"migrating_to_5/#required","text":"In mongoose 5 the required validator only verifies if the value is an array. That is, it will not fail for empty arrays as it would in mongoose 4.","title":"\u6570\u7ec4\u7684required\u9a8c\u8bc1\u5668"},{"location":"MongoDB_NodeJS_Driver/unified-topology/","text":"\u7edf\u4e00\u62d3\u6251\u8bbe\u8ba1 \u00b6 Unified Topology Design \u5728\u7f16\u5199\u8282\u70b9\u9a71\u52a8\u7a0b\u5e8f\u65f6\uff0c\u5b83\u6709 7 \u4e2a\u62d3\u6251\u7c7b\uff0c\u5305\u62ec\u65b0\u5f15\u5165\u7684\u7edf\u4e00\u62d3\u6251\u3002 \u6bcf\u4e2a\u6765\u81ea\u6838\u5fc3\u6a21\u5757\u7684\u9057\u7559\u62d3\u6251\u7c7b\u578b\u90fd\u4ee5\u4e00\u4e2a\u53d7\u652f\u6301\u7684\u62d3\u6251\u7c7b\u4e3a\u76ee\u6807:\u526f\u672c\u96c6\u3001\u5206\u7247\u90e8\u7f72(mongos)\u548c\u72ec\u7acb\u670d\u52a1\u5668\u3002 \u5728\u5b83\u4eec\u4e4b\u4e0a\u662f\u4e00\u4e2a\u6765\u81ea\u201c\u672c\u673a\u201d\u5c42\u7684\u7626\u62d3\u6251\u5305\u88c5\u5668\uff0c\u5b83\u5f15\u5165\u4e86\u201c\u65ad\u5f00\u5904\u7406\u7a0b\u5e8f\u201d\u7684\u6982\u5ff5\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u7528\u4e8e\u5904\u7406\u7b80\u5355\u7684\u91cd\u8bd5\u6027\u7684\u56de\u8c03\u961f\u5217\u3002 \u7edf\u4e00\u62d3\u6251\u7684\u76ee\u6807\u6709\u4e09\u4e2a\u65b9\u9762:\u2014\u2014\u5b8c\u5168\u652f\u6301\u53f8\u673a\u53d1\u73b0\u548c\u76d1\u63a7\u670d\u52a1\u5668,\u670d\u52a1\u5668\u9009\u62e9\u548c\u9a6c\u514b\u65af\u8fc7\u65f6\u89c4\u8303\u2014\u2014\u51cf\u8f7b\u7ef4\u62a4\u8d1f\u62c5\u652f\u6301\u5efa\u6a21\u4e2d\u7684\u62d3\u6251\u5c42\u9a71\u52a8\u7a0b\u5e8f\u7684\u6240\u6709\u652f\u6301\u62d3\u6251\u7c7b\u578b\u7684\u5355\u5f15\u64ce\u2014\u2014\u5220\u9664\u6df7\u6dc6\u529f\u80fd\u53ef\u4ee5\u4e3a\u6211\u4eec\u7684\u7528\u6237\u6f5c\u5728\u7684\u5371\u9669 \u5982\u4f55\u4f7f\u7528\u5b83 \u00b6 \u7edf\u4e00\u62d3\u6251\u73b0\u5728\u5728 useUnifiedTopology \u7279\u6027\u6807\u5fd7\u540e\u9762\u53ef\u7528\u3002 \u4f60\u53ef\u4ee5\u901a\u8fc7\u5c06\u8fd9\u4e2a\u9009\u9879\u4f20\u9012\u7ed9\u4f60\u7684 MongoClient \u6784\u9020\u51fd\u6570\u6765\u9009\u62e9\u4f7f\u7528\u5b83: JavaScript const client = MongoClient ( \"mongodb://localhost:27017\" , { useUnifiedTopology : true , }); Note \u5728\u5373\u5c06\u5230\u6765\u7684\u5c0f\u7248\u672c\u4e2d\uff0cuseUnifiedTopology \u5c06\u9ed8\u8ba4\u4e3atrue\uff0c\u5728\u9a71\u52a8\u7a0b\u5e8f\u7684\u4e0b\u4e00\u4e2a\u4e3b\u8981\u7248\u672c\u4e2d\uff0c\u8fd9\u4e2a\u62d3\u6251\u5c06\u5b8c\u5168\u53d6\u4ee3\u9057\u7559\u62d3\u6251\u3002 \u884c\u4e3a\u4fee\u6539 \u00b6 MongoClient.connect, isConnected \u00b6 \u4ece\u4f7f\u7528\u8fde\u63a5\u65b9\u6cd5\u201cconnecting\u201d\u5230 MongoDB \u90e8\u7f72\u7684\u6982\u5ff5\u7684\u8303\u4f8b\u8f6c\u53d8\u4e2d\uff0c\u7edf\u4e00\u62d3\u6251\u662f\u7b2c\u4e00\u6b65\u3002 \u8003\u8651\u4e00\u4e0b\u8fde\u63a5\u5230\u590d\u5236\u96c6\u610f\u5473\u7740\u4ec0\u4e48:\u5f53\u8fde\u63a5\u5230\u4e3b\u96c6\u65f6\uff0c\u6211\u4eec\u4f1a\u89e6\u53d1\u8fd9\u79cd\u72b6\u6001\u5417? \u4e00\u4e2a\u4e3b\u8981\u7684\u548c\u4e00\u4e2a\u6b21\u8981\u7684? \u5f53\u8fde\u63a5\u5230\u6240\u6709\u5df2\u77e5\u8282\u70b9\u65f6? \u76ee\u524d\u8fd8\u4e0d\u6e05\u695a\u662f\u5426\u53ef\u4ee5\u5728\u4e0d\u5411 connect \u65b9\u6cd5\u5f15\u5165 ReadPreference \u53c2\u6570\u7684\u60c5\u51b5\u4e0b\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\u3002 \u6b64\u65f6\uff0c\u201cconnecting\u201d\u53ea\u662f\u201coperation execution\u201d\u7684\u4e00\u534a\u2014\u2014\u4f60\u4f20\u5165\u4e00\u4e2a ReadPreference\uff0c\u5e76\u7b49\u5f85\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u670d\u52a1\u5668\u8fdb\u884c\u64cd\u4f5c\uff0c\u73b0\u5728\u6211\u4eec\u8fde\u63a5\u4e86! \u4f46\u4f60\u4e0d\u80fd\u628a\u8fd9\u4e9b\u90fd\u4f5c\u4e3a\u4f60\u7b2c\u4e00\u6b21\u624b\u672f\u7684\u4e00\u90e8\u5206\u5417? \u6211\u4eec\u7684\u76ee\u6807\u662f\u8ba9\u4ee3\u7801\u770b\u8d77\u6765\u66f4\u50cf\u4e0b\u9762\u8fd9\u6837: JavaScript const client = new MongoClient ( \"mongodb://llama:drama@localhost:27017/?replicaSet=rs\" ); const coll = client . db ( \"test\" ). collection ( \"foo\" ); await coll . insert ({ test : \"document\" }); const docs = coll . find ({ test : 1 }, { readPreference : \"secondary\" }). toArray (); console . dir ({ docs }); await client . close (); \u9ed8\u8ba4\u7684 ReadPreference \u4e3a\u201cprimary\u201d\u7528\u4e8e\u7b2c\u4e00\u6b21\u5199\u64cd\u4f5c, \u7b49\u5f85\u63d2\u5165\u7684\u4e00\u90e8\u5206\u5305\u62ec\u542f\u52a8\u5230\u96c6\u7fa4\u4e2d\u6240\u6709\u670d\u52a1\u5668\u7684\u8fde\u63a5, \u9009\u62e9\u670d\u52a1\u5668\u5e76\u6267\u884c\u64cd\u4f5c. \u9519\u8bef\u5c06\u51fa\u73b0\u5728\u4efb\u4f55\u7ed9\u5b9a\u64cd\u4f5c\u7684\u8c03\u7528\u7ad9\u70b9\uff0c\u4f7f\u7528\u6237\u53ef\u4ee5\u66f4\u7ec6\u7c92\u5ea6\u5730\u63a7\u5236\u9519\u8bef\u5904\u7406. \u4e3a\u4ec0\u4e48 MongoClient.isConnected \u603b\u662f\u8fd4\u56de true? \u00b6 \u6211\u4eec\u8ba4\u4e3a\u201c\u8fde\u63a5\u201d\u542b\u4e49\u7684\u6a21\u7cca\u6027\u4f1a\u5bfc\u81f4\u66f4\u591a\u7684\u95ee\u9898\uff0c\u800c\u4e0d\u662f\u5b83\u60f3\u8981\u89e3\u51b3\u7684\u95ee\u9898\u3002 \u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u4e3b\u8981\u5173\u5fc3\u7684\u662f\u64cd\u4f5c\u7684\u6210\u529f\u6267\u884c\u3002 isConnected \u65b9\u6cd5\u901a\u5e38\u7528\u4e8e\u5bf9 MongoClient \u8fdb\u884c\u201c\u5065\u5eb7\u68c0\u67e5\u201d\uff0c\u4ee5\u786e\u5b9a\u64cd\u4f5c\u662f\u5426\u53ef\u4ee5\u6210\u529f\u6267\u884c\u3002 \u7edf\u4e00\u62d3\u6251\u901a\u8fc7\u5f15\u5165\u201c\u670d\u52a1\u5668\u9009\u62e9\u5faa\u73af\u201d(\u4e0b\u9762\u5c06\u8be6\u7ec6\u8ba8\u8bba)\u5c06\u8fd9\u4e2a\u95ee\u9898\u76f4\u63a5\u63a8\u5230\u64cd\u4f5c\u6267\u884c\u4e2d\u3002 \u56e0\u6b64\uff0cMongoClient \u603b\u662f\u201c\u8fde\u63a5\u201d\u7684\uff0c\u56e0\u4e3a\u5b83\u603b\u662f\u63a5\u53d7\u64cd\u4f5c\u5e76\u5c1d\u8bd5\u6267\u884c\u5b83\u4eec\u3002 Note \u5728\u9a71\u52a8\u7a0b\u5e8f\u7684\u4e0b\u4e00\u4e2a\u4e3b\u8981\u7248\u672c\u4e2d\uff0cisConnected\u5c06\u88ab\u5b8c\u5168\u5220\u9664\u3002 \u670d\u52a1\u5668\u9009\u62e9 \u00b6 \u64cd\u4f5c\u6267\u884c\u7684\u4f2a\u4ee3\u7801\u5982\u4e0b\u6240\u793a: JavaScript function executeOperation ( topology , operation , callback ) { const readPreference = resolveReadPreference ( operation ); topology . selectServer ( readPreference , ( err , server ) => { if ( err ) { // This error is most likely a \"Server selection timed out after Xms\" return callback ( err ); } // checks a connection out of the server to execute the operation, then checks it back in server . withConnection (( conn ) => operation . execute ( conn , callback )); }); } \u4e0a\u9762\u7684 serverSelection \u65b9\u6cd5\u5c06\u4e00\u76f4\u5faa\u73af\u5230 serverSelectionTimeoutMS(\u9ed8\u8ba4\u4e3a 30s)\uff0c\u7b49\u5f85\u9a71\u52a8\u7a0b\u5e8f\u6210\u529f\u8fde\u63a5\u5230\u4e00\u4e2a\u53ef\u884c\u7684\u670d\u52a1\u5668\uff0c\u4ee5\u6267\u884c\u8bf7\u6c42\u7684\u64cd\u4f5c\u3002 \u5982\u679c\u670d\u52a1\u5668\u9009\u62e9\u6ca1\u6709\u4ea7\u751f\u53ef\u884c\u7684\u670d\u52a1\u5668\uff0c\u5219\u5c06\u63a7\u5236\u6743\u4f20\u9012\u7ed9\u7528\u6237\uff0c\u4ee5\u786e\u5b9a\u4e0b\u4e00\u4e2a\u6700\u4f73\u64cd\u4f5c\u65b9\u6848\u662f\u4ec0\u4e48\u3002 \u8fd9\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u5ba2\u6237\u673a\u901a\u5e38\u4e0e\u96c6\u7fa4\u65ad\u5f00\u8fde\u63a5\uff0c\u4f46\u5b83\u76ee\u524d\u6ca1\u6709\u8fde\u63a5\u5230\u4efb\u4f55\u6ee1\u8db3\u6307\u5b9a ReadPreference \u7684\u670d\u52a1\u5668\u3002 disconnectHandler \u00b6 \u6765\u81ea\u201c\u672c\u673a\u201d\u5c42(\u5728 lib/\u62d3\u6251\u4e2d)\u7684\u4e09\u79cd\u62d3\u6251\u7c7b\u578b\u4e3b\u8981\u4e3a\u56de\u8c03\u5b58\u50a8\u63d0\u4f9b\u652f\u6301\uff0c\u79f0\u4e3a\u201c\u65ad\u5f00\u5904\u7406\u7a0b\u5e8f\u201d\u3002 \u9057\u7559\u62d3\u6251\u4e0d\u662f\u4f7f\u7528\u670d\u52a1\u5668\u9009\u62e9\u5faa\u73af\uff0c\u800c\u662f\u5728\u6ca1\u6709\u5408\u9002\u7684\u670d\u52a1\u5668\u53ef\u7528\u7684\u60c5\u51b5\u4e0b\u5728\u8fd9\u4e2a\u5b58\u50a8\u4e0a\u653e\u7f6e\u56de\u8c03\uff0c\u4ee5\u4fbf\u5728\u7a0d\u540e\u8fd0\u884c\u64cd\u4f5c\u3002 \u8fd9\u4e2a\u56de\u8c03\u5b58\u50a8\u8fd8\u63d0\u4f9b\u4e86\u4e00\u79cd\u6734\u7d20\u7684\u53ef\u91cd\u8bd5\u6027\u5f62\u5f0f\uff0c\u4f46\u662f\u5728\u5b9e\u8df5\u4e2d\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u610f\u60f3\u4e0d\u5230\u7684\uff0c\u751a\u81f3\u610f\u60f3\u4e0d\u5230\u7684\u7ed3\u679c: \u56de\u8c03\u5b58\u50a8\u53ea\u4e0e\u5355\u4e2a\u670d\u52a1\u5668\u76f8\u5173\u8054\uff0c\u56e0\u6b64\u53ea\u6709\u5728\u6700\u521d\u9009\u62e9\u7684\u670d\u52a1\u5668\u4e0a\u624d\u5c1d\u8bd5\u91cd\u65b0\u6267\u884c\u64cd\u4f5c\u3002 \u5982\u679c\u8be5\u670d\u52a1\u5668\u518d\u4e5f\u4e0d\u80fd\u6062\u590d(\u4f8b\u5982\uff0c\u5b83\u5df2\u7ecf\u9000\u51fa\u6216\u9000\u5f79)\uff0c\u90a3\u4e48\u8be5\u64cd\u4f5c\u5c06\u5904\u4e8e\u4e0d\u786e\u5b9a\u72b6\u6001\u3002 \u6ca1\u6709\u4e0e\u670d\u52a1\u5668\u534f\u4f5c\u6765\u786e\u4fdd\u6392\u961f\u5199\u64cd\u4f5c\u53ea\u53d1\u751f\u4e00\u6b21\u3002 \u5047\u8bbe\u8fd0\u884c\u4e00\u4e2a updateOne \u64cd\u4f5c\u88ab\u7f51\u7edc\u9519\u8bef\u4e2d\u65ad\u3002 \u8be5\u64cd\u4f5c\u5df2\u6210\u529f\u53d1\u9001\u5230\u670d\u52a1\u5668\uff0c\u4f46\u670d\u52a1\u5668\u54cd\u5e94\u5728\u4e2d\u65ad\u671f\u95f4\u4e22\u5931\uff0c\u8fd9\u610f\u5473\u7740\u8be5\u64cd\u4f5c\u88ab\u653e\u7f6e\u5728\u56de\u8c03\u5b58\u50a8\u533a\u4e2d\uff0c\u7b49\u5f85\u91cd\u8bd5\u3002 \u4e0e\u6b64\u540c\u65f6\uff0c\u53e6\u4e00\u4e2a\u5fae\u670d\u52a1\u5141\u8bb8\u7528\u6237\u66f4\u65b0\u5199\u5165\u7684\u6570\u636e\u3002 \u4e00\u65e6\u539f\u59cb\u5ba2\u6237\u7aef\u91cd\u65b0\u8fde\u63a5\u5230\u670d\u52a1\u5668\uff0c\u5b83\u5c06\u81ea\u52a8\u91cd\u65b0\u6267\u884c\u64cd\u4f5c\u5e76\u4f7f\u7528\u8f83\u65e7\u7684\u503c\u66f4\u65b0\u8f83\u65b0\u7684\u6570\u636e\u3002 \u7edf\u4e00\u62d3\u6251\u5b8c\u5168\u6d88\u9664\u4e86\u65ad\u5f00\u8fde\u63a5\u7684\u5904\u7406\u7a0b\u5e8f\uff0c\u652f\u6301\u66f4\u5065\u58ee\u548c\u4e00\u81f4\u7684\u201c\u53ef\u91cd\u8bd5\u8bfb\u53d6\u201d\u548c\u201c\u53ef\u91cd\u8bd5\u5199\u5165\u201d\u7279\u6027\u3002 \u64cd\u4f5c\u73b0\u5728\u5c06\u5c1d\u8bd5\u5728\u670d\u52a1\u5668\u9009\u62e9\u5faa\u73af\u4e2d\u6267\u884c\uff0c\u76f4\u5230 serverSelectionTimeoutMS(\u9ed8\u8ba4:30s)\uff0c\u5e76\u5c06\u5728\u53d1\u751f\u53ef\u91cd\u8bd5\u9519\u8bef\u65f6\u91cd\u8bd5\u4e00\u6b21\u64cd\u4f5c\u3002 \u8fd9\u4e2a\u5faa\u73af\u4e4b\u5916\u7684\u6240\u6709\u9519\u8bef\u90fd\u8fd4\u56de\u7ed9\u7528\u6237\uff0c\u56e0\u4e3a\u4ed6\u4eec\u77e5\u9053\u5728\u8fd9\u4e9b\u573a\u666f\u4e2d\u6700\u597d\u505a\u4ec0\u4e48\u3002","title":"unified-topology"},{"location":"MongoDB_NodeJS_Driver/unified-topology/#_1","text":"Unified Topology Design \u5728\u7f16\u5199\u8282\u70b9\u9a71\u52a8\u7a0b\u5e8f\u65f6\uff0c\u5b83\u6709 7 \u4e2a\u62d3\u6251\u7c7b\uff0c\u5305\u62ec\u65b0\u5f15\u5165\u7684\u7edf\u4e00\u62d3\u6251\u3002 \u6bcf\u4e2a\u6765\u81ea\u6838\u5fc3\u6a21\u5757\u7684\u9057\u7559\u62d3\u6251\u7c7b\u578b\u90fd\u4ee5\u4e00\u4e2a\u53d7\u652f\u6301\u7684\u62d3\u6251\u7c7b\u4e3a\u76ee\u6807:\u526f\u672c\u96c6\u3001\u5206\u7247\u90e8\u7f72(mongos)\u548c\u72ec\u7acb\u670d\u52a1\u5668\u3002 \u5728\u5b83\u4eec\u4e4b\u4e0a\u662f\u4e00\u4e2a\u6765\u81ea\u201c\u672c\u673a\u201d\u5c42\u7684\u7626\u62d3\u6251\u5305\u88c5\u5668\uff0c\u5b83\u5f15\u5165\u4e86\u201c\u65ad\u5f00\u5904\u7406\u7a0b\u5e8f\u201d\u7684\u6982\u5ff5\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u7528\u4e8e\u5904\u7406\u7b80\u5355\u7684\u91cd\u8bd5\u6027\u7684\u56de\u8c03\u961f\u5217\u3002 \u7edf\u4e00\u62d3\u6251\u7684\u76ee\u6807\u6709\u4e09\u4e2a\u65b9\u9762:\u2014\u2014\u5b8c\u5168\u652f\u6301\u53f8\u673a\u53d1\u73b0\u548c\u76d1\u63a7\u670d\u52a1\u5668,\u670d\u52a1\u5668\u9009\u62e9\u548c\u9a6c\u514b\u65af\u8fc7\u65f6\u89c4\u8303\u2014\u2014\u51cf\u8f7b\u7ef4\u62a4\u8d1f\u62c5\u652f\u6301\u5efa\u6a21\u4e2d\u7684\u62d3\u6251\u5c42\u9a71\u52a8\u7a0b\u5e8f\u7684\u6240\u6709\u652f\u6301\u62d3\u6251\u7c7b\u578b\u7684\u5355\u5f15\u64ce\u2014\u2014\u5220\u9664\u6df7\u6dc6\u529f\u80fd\u53ef\u4ee5\u4e3a\u6211\u4eec\u7684\u7528\u6237\u6f5c\u5728\u7684\u5371\u9669","title":"\u7edf\u4e00\u62d3\u6251\u8bbe\u8ba1"},{"location":"MongoDB_NodeJS_Driver/unified-topology/#_2","text":"\u7edf\u4e00\u62d3\u6251\u73b0\u5728\u5728 useUnifiedTopology \u7279\u6027\u6807\u5fd7\u540e\u9762\u53ef\u7528\u3002 \u4f60\u53ef\u4ee5\u901a\u8fc7\u5c06\u8fd9\u4e2a\u9009\u9879\u4f20\u9012\u7ed9\u4f60\u7684 MongoClient \u6784\u9020\u51fd\u6570\u6765\u9009\u62e9\u4f7f\u7528\u5b83: JavaScript const client = MongoClient ( \"mongodb://localhost:27017\" , { useUnifiedTopology : true , }); Note \u5728\u5373\u5c06\u5230\u6765\u7684\u5c0f\u7248\u672c\u4e2d\uff0cuseUnifiedTopology \u5c06\u9ed8\u8ba4\u4e3atrue\uff0c\u5728\u9a71\u52a8\u7a0b\u5e8f\u7684\u4e0b\u4e00\u4e2a\u4e3b\u8981\u7248\u672c\u4e2d\uff0c\u8fd9\u4e2a\u62d3\u6251\u5c06\u5b8c\u5168\u53d6\u4ee3\u9057\u7559\u62d3\u6251\u3002","title":"\u5982\u4f55\u4f7f\u7528\u5b83"},{"location":"MongoDB_NodeJS_Driver/unified-topology/#_3","text":"","title":"\u884c\u4e3a\u4fee\u6539"},{"location":"MongoDB_NodeJS_Driver/unified-topology/#mongoclientconnect-isconnected","text":"\u4ece\u4f7f\u7528\u8fde\u63a5\u65b9\u6cd5\u201cconnecting\u201d\u5230 MongoDB \u90e8\u7f72\u7684\u6982\u5ff5\u7684\u8303\u4f8b\u8f6c\u53d8\u4e2d\uff0c\u7edf\u4e00\u62d3\u6251\u662f\u7b2c\u4e00\u6b65\u3002 \u8003\u8651\u4e00\u4e0b\u8fde\u63a5\u5230\u590d\u5236\u96c6\u610f\u5473\u7740\u4ec0\u4e48:\u5f53\u8fde\u63a5\u5230\u4e3b\u96c6\u65f6\uff0c\u6211\u4eec\u4f1a\u89e6\u53d1\u8fd9\u79cd\u72b6\u6001\u5417? \u4e00\u4e2a\u4e3b\u8981\u7684\u548c\u4e00\u4e2a\u6b21\u8981\u7684? \u5f53\u8fde\u63a5\u5230\u6240\u6709\u5df2\u77e5\u8282\u70b9\u65f6? \u76ee\u524d\u8fd8\u4e0d\u6e05\u695a\u662f\u5426\u53ef\u4ee5\u5728\u4e0d\u5411 connect \u65b9\u6cd5\u5f15\u5165 ReadPreference \u53c2\u6570\u7684\u60c5\u51b5\u4e0b\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\u3002 \u6b64\u65f6\uff0c\u201cconnecting\u201d\u53ea\u662f\u201coperation execution\u201d\u7684\u4e00\u534a\u2014\u2014\u4f60\u4f20\u5165\u4e00\u4e2a ReadPreference\uff0c\u5e76\u7b49\u5f85\u4e00\u4e2a\u53ef\u9009\u62e9\u7684\u670d\u52a1\u5668\u8fdb\u884c\u64cd\u4f5c\uff0c\u73b0\u5728\u6211\u4eec\u8fde\u63a5\u4e86! \u4f46\u4f60\u4e0d\u80fd\u628a\u8fd9\u4e9b\u90fd\u4f5c\u4e3a\u4f60\u7b2c\u4e00\u6b21\u624b\u672f\u7684\u4e00\u90e8\u5206\u5417? \u6211\u4eec\u7684\u76ee\u6807\u662f\u8ba9\u4ee3\u7801\u770b\u8d77\u6765\u66f4\u50cf\u4e0b\u9762\u8fd9\u6837: JavaScript const client = new MongoClient ( \"mongodb://llama:drama@localhost:27017/?replicaSet=rs\" ); const coll = client . db ( \"test\" ). collection ( \"foo\" ); await coll . insert ({ test : \"document\" }); const docs = coll . find ({ test : 1 }, { readPreference : \"secondary\" }). toArray (); console . dir ({ docs }); await client . close (); \u9ed8\u8ba4\u7684 ReadPreference \u4e3a\u201cprimary\u201d\u7528\u4e8e\u7b2c\u4e00\u6b21\u5199\u64cd\u4f5c, \u7b49\u5f85\u63d2\u5165\u7684\u4e00\u90e8\u5206\u5305\u62ec\u542f\u52a8\u5230\u96c6\u7fa4\u4e2d\u6240\u6709\u670d\u52a1\u5668\u7684\u8fde\u63a5, \u9009\u62e9\u670d\u52a1\u5668\u5e76\u6267\u884c\u64cd\u4f5c. \u9519\u8bef\u5c06\u51fa\u73b0\u5728\u4efb\u4f55\u7ed9\u5b9a\u64cd\u4f5c\u7684\u8c03\u7528\u7ad9\u70b9\uff0c\u4f7f\u7528\u6237\u53ef\u4ee5\u66f4\u7ec6\u7c92\u5ea6\u5730\u63a7\u5236\u9519\u8bef\u5904\u7406.","title":"MongoClient.connect, isConnected"},{"location":"MongoDB_NodeJS_Driver/unified-topology/#mongoclientisconnected-true","text":"\u6211\u4eec\u8ba4\u4e3a\u201c\u8fde\u63a5\u201d\u542b\u4e49\u7684\u6a21\u7cca\u6027\u4f1a\u5bfc\u81f4\u66f4\u591a\u7684\u95ee\u9898\uff0c\u800c\u4e0d\u662f\u5b83\u60f3\u8981\u89e3\u51b3\u7684\u95ee\u9898\u3002 \u5e94\u7528\u7a0b\u5e8f\u5f00\u53d1\u4eba\u5458\u4e3b\u8981\u5173\u5fc3\u7684\u662f\u64cd\u4f5c\u7684\u6210\u529f\u6267\u884c\u3002 isConnected \u65b9\u6cd5\u901a\u5e38\u7528\u4e8e\u5bf9 MongoClient \u8fdb\u884c\u201c\u5065\u5eb7\u68c0\u67e5\u201d\uff0c\u4ee5\u786e\u5b9a\u64cd\u4f5c\u662f\u5426\u53ef\u4ee5\u6210\u529f\u6267\u884c\u3002 \u7edf\u4e00\u62d3\u6251\u901a\u8fc7\u5f15\u5165\u201c\u670d\u52a1\u5668\u9009\u62e9\u5faa\u73af\u201d(\u4e0b\u9762\u5c06\u8be6\u7ec6\u8ba8\u8bba)\u5c06\u8fd9\u4e2a\u95ee\u9898\u76f4\u63a5\u63a8\u5230\u64cd\u4f5c\u6267\u884c\u4e2d\u3002 \u56e0\u6b64\uff0cMongoClient \u603b\u662f\u201c\u8fde\u63a5\u201d\u7684\uff0c\u56e0\u4e3a\u5b83\u603b\u662f\u63a5\u53d7\u64cd\u4f5c\u5e76\u5c1d\u8bd5\u6267\u884c\u5b83\u4eec\u3002 Note \u5728\u9a71\u52a8\u7a0b\u5e8f\u7684\u4e0b\u4e00\u4e2a\u4e3b\u8981\u7248\u672c\u4e2d\uff0cisConnected\u5c06\u88ab\u5b8c\u5168\u5220\u9664\u3002","title":"\u4e3a\u4ec0\u4e48 MongoClient.isConnected \u603b\u662f\u8fd4\u56de true?"},{"location":"MongoDB_NodeJS_Driver/unified-topology/#_4","text":"\u64cd\u4f5c\u6267\u884c\u7684\u4f2a\u4ee3\u7801\u5982\u4e0b\u6240\u793a: JavaScript function executeOperation ( topology , operation , callback ) { const readPreference = resolveReadPreference ( operation ); topology . selectServer ( readPreference , ( err , server ) => { if ( err ) { // This error is most likely a \"Server selection timed out after Xms\" return callback ( err ); } // checks a connection out of the server to execute the operation, then checks it back in server . withConnection (( conn ) => operation . execute ( conn , callback )); }); } \u4e0a\u9762\u7684 serverSelection \u65b9\u6cd5\u5c06\u4e00\u76f4\u5faa\u73af\u5230 serverSelectionTimeoutMS(\u9ed8\u8ba4\u4e3a 30s)\uff0c\u7b49\u5f85\u9a71\u52a8\u7a0b\u5e8f\u6210\u529f\u8fde\u63a5\u5230\u4e00\u4e2a\u53ef\u884c\u7684\u670d\u52a1\u5668\uff0c\u4ee5\u6267\u884c\u8bf7\u6c42\u7684\u64cd\u4f5c\u3002 \u5982\u679c\u670d\u52a1\u5668\u9009\u62e9\u6ca1\u6709\u4ea7\u751f\u53ef\u884c\u7684\u670d\u52a1\u5668\uff0c\u5219\u5c06\u63a7\u5236\u6743\u4f20\u9012\u7ed9\u7528\u6237\uff0c\u4ee5\u786e\u5b9a\u4e0b\u4e00\u4e2a\u6700\u4f73\u64cd\u4f5c\u65b9\u6848\u662f\u4ec0\u4e48\u3002 \u8fd9\u5e76\u4e0d\u4e00\u5b9a\u610f\u5473\u7740\u5ba2\u6237\u673a\u901a\u5e38\u4e0e\u96c6\u7fa4\u65ad\u5f00\u8fde\u63a5\uff0c\u4f46\u5b83\u76ee\u524d\u6ca1\u6709\u8fde\u63a5\u5230\u4efb\u4f55\u6ee1\u8db3\u6307\u5b9a ReadPreference \u7684\u670d\u52a1\u5668\u3002","title":"\u670d\u52a1\u5668\u9009\u62e9"},{"location":"MongoDB_NodeJS_Driver/unified-topology/#disconnecthandler","text":"\u6765\u81ea\u201c\u672c\u673a\u201d\u5c42(\u5728 lib/\u62d3\u6251\u4e2d)\u7684\u4e09\u79cd\u62d3\u6251\u7c7b\u578b\u4e3b\u8981\u4e3a\u56de\u8c03\u5b58\u50a8\u63d0\u4f9b\u652f\u6301\uff0c\u79f0\u4e3a\u201c\u65ad\u5f00\u5904\u7406\u7a0b\u5e8f\u201d\u3002 \u9057\u7559\u62d3\u6251\u4e0d\u662f\u4f7f\u7528\u670d\u52a1\u5668\u9009\u62e9\u5faa\u73af\uff0c\u800c\u662f\u5728\u6ca1\u6709\u5408\u9002\u7684\u670d\u52a1\u5668\u53ef\u7528\u7684\u60c5\u51b5\u4e0b\u5728\u8fd9\u4e2a\u5b58\u50a8\u4e0a\u653e\u7f6e\u56de\u8c03\uff0c\u4ee5\u4fbf\u5728\u7a0d\u540e\u8fd0\u884c\u64cd\u4f5c\u3002 \u8fd9\u4e2a\u56de\u8c03\u5b58\u50a8\u8fd8\u63d0\u4f9b\u4e86\u4e00\u79cd\u6734\u7d20\u7684\u53ef\u91cd\u8bd5\u6027\u5f62\u5f0f\uff0c\u4f46\u662f\u5728\u5b9e\u8df5\u4e2d\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u610f\u60f3\u4e0d\u5230\u7684\uff0c\u751a\u81f3\u610f\u60f3\u4e0d\u5230\u7684\u7ed3\u679c: \u56de\u8c03\u5b58\u50a8\u53ea\u4e0e\u5355\u4e2a\u670d\u52a1\u5668\u76f8\u5173\u8054\uff0c\u56e0\u6b64\u53ea\u6709\u5728\u6700\u521d\u9009\u62e9\u7684\u670d\u52a1\u5668\u4e0a\u624d\u5c1d\u8bd5\u91cd\u65b0\u6267\u884c\u64cd\u4f5c\u3002 \u5982\u679c\u8be5\u670d\u52a1\u5668\u518d\u4e5f\u4e0d\u80fd\u6062\u590d(\u4f8b\u5982\uff0c\u5b83\u5df2\u7ecf\u9000\u51fa\u6216\u9000\u5f79)\uff0c\u90a3\u4e48\u8be5\u64cd\u4f5c\u5c06\u5904\u4e8e\u4e0d\u786e\u5b9a\u72b6\u6001\u3002 \u6ca1\u6709\u4e0e\u670d\u52a1\u5668\u534f\u4f5c\u6765\u786e\u4fdd\u6392\u961f\u5199\u64cd\u4f5c\u53ea\u53d1\u751f\u4e00\u6b21\u3002 \u5047\u8bbe\u8fd0\u884c\u4e00\u4e2a updateOne \u64cd\u4f5c\u88ab\u7f51\u7edc\u9519\u8bef\u4e2d\u65ad\u3002 \u8be5\u64cd\u4f5c\u5df2\u6210\u529f\u53d1\u9001\u5230\u670d\u52a1\u5668\uff0c\u4f46\u670d\u52a1\u5668\u54cd\u5e94\u5728\u4e2d\u65ad\u671f\u95f4\u4e22\u5931\uff0c\u8fd9\u610f\u5473\u7740\u8be5\u64cd\u4f5c\u88ab\u653e\u7f6e\u5728\u56de\u8c03\u5b58\u50a8\u533a\u4e2d\uff0c\u7b49\u5f85\u91cd\u8bd5\u3002 \u4e0e\u6b64\u540c\u65f6\uff0c\u53e6\u4e00\u4e2a\u5fae\u670d\u52a1\u5141\u8bb8\u7528\u6237\u66f4\u65b0\u5199\u5165\u7684\u6570\u636e\u3002 \u4e00\u65e6\u539f\u59cb\u5ba2\u6237\u7aef\u91cd\u65b0\u8fde\u63a5\u5230\u670d\u52a1\u5668\uff0c\u5b83\u5c06\u81ea\u52a8\u91cd\u65b0\u6267\u884c\u64cd\u4f5c\u5e76\u4f7f\u7528\u8f83\u65e7\u7684\u503c\u66f4\u65b0\u8f83\u65b0\u7684\u6570\u636e\u3002 \u7edf\u4e00\u62d3\u6251\u5b8c\u5168\u6d88\u9664\u4e86\u65ad\u5f00\u8fde\u63a5\u7684\u5904\u7406\u7a0b\u5e8f\uff0c\u652f\u6301\u66f4\u5065\u58ee\u548c\u4e00\u81f4\u7684\u201c\u53ef\u91cd\u8bd5\u8bfb\u53d6\u201d\u548c\u201c\u53ef\u91cd\u8bd5\u5199\u5165\u201d\u7279\u6027\u3002 \u64cd\u4f5c\u73b0\u5728\u5c06\u5c1d\u8bd5\u5728\u670d\u52a1\u5668\u9009\u62e9\u5faa\u73af\u4e2d\u6267\u884c\uff0c\u76f4\u5230 serverSelectionTimeoutMS(\u9ed8\u8ba4:30s)\uff0c\u5e76\u5c06\u5728\u53d1\u751f\u53ef\u91cd\u8bd5\u9519\u8bef\u65f6\u91cd\u8bd5\u4e00\u6b21\u64cd\u4f5c\u3002 \u8fd9\u4e2a\u5faa\u73af\u4e4b\u5916\u7684\u6240\u6709\u9519\u8bef\u90fd\u8fd4\u56de\u7ed9\u7528\u6237\uff0c\u56e0\u4e3a\u4ed6\u4eec\u77e5\u9053\u5728\u8fd9\u4e9b\u573a\u666f\u4e2d\u6700\u597d\u505a\u4ec0\u4e48\u3002","title":"disconnectHandler"},{"location":"api/Aggregate/","text":"\u805a\u5408 \u00b6 Aggregate() \u00b6 \u53c2\u6570 [pipeline] \u00abArray\u00bb aggregation pipeline as an array of objects Aggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use [Model.aggregate() instead. \u793a\u4f8b const aggregate = Model . aggregate ([ { $ project : { a : 1 , b : 1 } }, { $ skip : 5 } ]); Model . aggregate ({ $ match : { age : { $ gte : 21 }}}) . unwind ( 'tags' ) . exec ( callback ); \u6ce8\u91ca The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned). Mongoose does not cast pipeline stages. The below will not work unless _id is a string in the database new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]); // Do this instead to cast to an ObjectId new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]); Aggregate.prototype.model() \u00b6 \u53c2\u6570 model \u00abModel\u00bb the model to which the aggregate is to be bound \u8fd4\u56de Binds this aggregate to a model. Aggregate.prototype.append() \u00b6 \u53c2\u6570 ops \u00abObject\u00bb operator(s) to append \u8fd4\u56de Appends new operators to this aggregate pipeline \u793a\u4f8b aggregate . append ({ $ project : { field : 1 }}, { $ limit : 2 }); var pipeline = [{ $ match : { daw : 'Logic Audio X' }} ]; aggregate . append ( pipeline ); Aggregate.prototype.addFields() \u00b6 \u53c2\u6570 arg \u00abObject\u00bb field specification \u8fd4\u56de Appends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work \u793a\u4f8b aggregate . addFields ({ newField: ' $b . nested ' , plusTen: { $add : [' $val ', 10 ]} , sub: { name: ' $a ' } }) aggregate . addFields ({ salary_k: { $divide : [ \"$salary\" , 1000 ] } }); Aggregate.prototype.project() \u00b6 \u53c2\u6570 arg \u00abObject,String\u00bb field specification \u8fd4\u56de Appends a new $project operator to this aggregate pipeline. Mongoose query [selection syntax is also supported. \u793a\u4f8b aggregate . project ( \"a b -_id\" ); aggregate . project ({ a: 1 , b: 1 , _id: 0 }); aggregate . project ({ newField: ' $b . nested ' , plusTen: { $add : [' $val ', 10 ]} , sub: { name: ' $a ' } }) aggregate . project ({ salary_k: { $divide : [ \"$salary\" , 1000 ] } }); Aggregate.prototype.group() \u00b6 \u53c2\u6570 arg \u00abObject\u00bb $group operator contents \u8fd4\u56de Appends a new custom $group operator to this aggregate pipeline. \u793a\u4f8b aggregate . group ({ _id: \"$department\" }); Aggregate.prototype.match() \u00b6 \u53c2\u6570 arg \u00abObject\u00bb $match operator contents \u8fd4\u56de Appends a new custom $match operator to this aggregate pipeline. \u793a\u4f8b aggregate . match ({ department: { $in : [ \"sales\" , \"engineering\" ] } }); Aggregate.prototype.skip() \u00b6 \u53c2\u6570 num \u00abNumber\u00bb number of records to skip before next stage \u8fd4\u56de Appends a new $skip operator to this aggregate pipeline. \u793a\u4f8b aggregate . skip ( 10 ); Aggregate.prototype.limit() \u00b6 \u53c2\u6570 num \u00abNumber\u00bb maximum number of records to pass to the next stage \u8fd4\u56de Appends a new $limit operator to this aggregate pipeline. \u793a\u4f8b aggregate . limit ( 10 ); Aggregate.prototype.near() \u00b6 \u53c2\u6570 \u8fd4\u56de Appends a new $geoNear operator to this aggregate pipeline. \u6ce8\u91ca MUST be used as the first operator in the pipeline. \u793a\u4f8b aggregate . near ({ near: [ 40.724 , - 73.997 ], distanceField: \"dist.calculated\" , maxDistance: 0.008 , query: { type : \"public\" }, includeLocs: \"dist.location\" , uniqueDocs: true , num: 5 }); Aggregate.prototype.unwind() \u00b6 \u53c2\u6570 fields \u00abString\u00bb the field(s) to unwind \u8fd4\u56de Appends new custom $unwind operator(s) to this aggregate pipeline. Note that the $unwind operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'. \u793a\u4f8b aggregate . unwind ( \"tags\" ); aggregate . unwind ( \"a\" , \"b\" , \"c\" ); Aggregate.prototype.lookup() \u00b6 \u53c2\u6570 options \u00abObject\u00bb to $lookup as described in the above link \u8fd4\u56de Appends new custom $lookup operator(s) to this aggregate pipeline. \u793a\u4f8b aggregate . lookup ({ from: ' users ', localField: ' userId ', foreignField: ' _id ', as: ' users ' }); Aggregate.prototype.graphLookup() \u00b6 \u53c2\u6570 options \u00abObject\u00bb to $graphLookup as described in the above link \u8fd4\u56de Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection. Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if { allowDiskUse: true } is specified. \u793a\u4f8b aggregate . graphLookup ({ from: ' courses ', startWith: ' $prerequisite ', connectFromField: ' prerequisite ', connectToField: ' name ', as: ' prerequisites ', maxDepth: 3 }) Aggregate.prototype.sample() \u00b6 \u53c2\u6570 size \u00abNumber\u00bb number of random documents to pick \u8fd4\u56de Appepnds new custom $sample operator(s) to this aggregate pipeline. \u793a\u4f8b aggregate . sample ( 3 ); Aggregate.prototype.sort() \u00b6 \u53c2\u6570 \u8fd4\u56de Appends a new $sort operator to this aggregate pipeline. If an object is passed, values allowed are asc , desc , ascending , descending , 1 , and -1 . If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with - which will be treated as descending. \u793a\u4f8b aggregate . sort ({ field: ' asc ', test: - 1 }); aggregate . sort (' field - test '); Aggregate.prototype.read() \u00b6 \u53c2\u6570 [tags] \u00abArray\u00bb optional tags for this query Sets the readPreference option for the aggregation query. \u793a\u4f8b Model . aggregate (..). read (' primaryPreferred '). exec ( callback ) Aggregate.prototype.explain() \u00b6 \u53c2\u6570 \u8fd4\u56de Execute the aggregation with explain \u793a\u4f8b Model . aggregate (..). explain ( callback ) Aggregate.prototype.allowDiskUse() \u00b6 \u53c2\u6570 [tags] \u00abArray\u00bb optional tags for this query Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0) \u793a\u4f8b Model . aggregate (..). allowDiskUse ( true ). exec ( callback ) Aggregate.prototype.option() \u00b6 \u53c2\u6570 value \u00abObject\u00bb keys to merge into current options \u8fd4\u56de Lets you set arbitrary options, for middleware or plugins. \u793a\u4f8b var agg = Model . aggregate ( .. ) . option ({ allowDiskUse : true }); agg . options ; Aggregate.prototype.cursor() \u00b6 \u53c2\u6570 [options.useMongooseAggCursor] \u00abBoolean\u00bb use experimental mongoose-specific aggregation cursor (for eachAsync() and other query cursor semantics) Sets the cursor option option for the aggregation query (ignored for < 2.6.0). Note the different syntax below: .exec() returns a cursor object, and no callback is necessary. \u793a\u4f8b var cursor = Model . aggregate ( .. ) . cursor ({ batchSize : 1000 }) . exec (); cursor . each ( function ( error , doc ) { }); Aggregate.prototype.addCursorFlag() \u00b6 \u53c2\u6570 Adds a [cursor flag \u793a\u4f8b Model . aggregate (..). addCursorFlag (' noCursorTimeout ', true ). exec (); Aggregate.prototype.collation() \u00b6 \u53c2\u6570 Adds a collation \u793a\u4f8b Model . aggregate (..). collation ({ locale: ' en_US ', strength : 1 }). exec (); Aggregate.prototype.facet() \u00b6 \u53c2\u6570 \u8fd4\u56de Combines multiple aggregation pipelines. \u793a\u4f8b Model . aggregate (...) . facet ({ books: [{ groupBy: ' $author ' }], price: [{ $bucketAuto : { groupBy: ' $price ', buckets: 2 } }] }) . exec (); Aggregate.prototype.pipeline() \u00b6 \u8fd4\u56de Returns the current pipeline \u793a\u4f8b MyModel . aggregate (). match ({ test: 1 }). pipeline (); Aggregate.prototype.exec() \u00b6 \u53c2\u6570 \u8fd4\u56de Executes the aggregate pipeline on the currently bound Model. \u793a\u4f8b aggregate . exec ( callback ); var promise = aggregate . exec (); promise . then ( .. ); Aggregate.prototype.then() \u00b6 \u53c2\u6570 [reject] \u00abFunction\u00bb errorCallback \u8fd4\u56de Provides promise for aggregate. \u793a\u4f8b Model . aggregate (..). then ( successCallback , errorCallback );","title":"\u805a\u5408"},{"location":"api/Aggregate/#_1","text":"","title":"\u805a\u5408"},{"location":"api/Aggregate/#aggregate","text":"\u53c2\u6570 [pipeline] \u00abArray\u00bb aggregation pipeline as an array of objects Aggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use [Model.aggregate() instead. \u793a\u4f8b const aggregate = Model . aggregate ([ { $ project : { a : 1 , b : 1 } }, { $ skip : 5 } ]); Model . aggregate ({ $ match : { age : { $ gte : 21 }}}) . unwind ( 'tags' ) . exec ( callback ); \u6ce8\u91ca The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned). Mongoose does not cast pipeline stages. The below will not work unless _id is a string in the database new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]); // Do this instead to cast to an ObjectId new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);","title":"Aggregate()"},{"location":"api/Aggregate/#aggregateprototypemodel","text":"\u53c2\u6570 model \u00abModel\u00bb the model to which the aggregate is to be bound \u8fd4\u56de Binds this aggregate to a model.","title":"Aggregate.prototype.model()"},{"location":"api/Aggregate/#aggregateprototypeappend","text":"\u53c2\u6570 ops \u00abObject\u00bb operator(s) to append \u8fd4\u56de Appends new operators to this aggregate pipeline \u793a\u4f8b aggregate . append ({ $ project : { field : 1 }}, { $ limit : 2 }); var pipeline = [{ $ match : { daw : 'Logic Audio X' }} ]; aggregate . append ( pipeline );","title":"Aggregate.prototype.append()"},{"location":"api/Aggregate/#aggregateprototypeaddfields","text":"\u53c2\u6570 arg \u00abObject\u00bb field specification \u8fd4\u56de Appends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work \u793a\u4f8b aggregate . addFields ({ newField: ' $b . nested ' , plusTen: { $add : [' $val ', 10 ]} , sub: { name: ' $a ' } }) aggregate . addFields ({ salary_k: { $divide : [ \"$salary\" , 1000 ] } });","title":"Aggregate.prototype.addFields()"},{"location":"api/Aggregate/#aggregateprototypeproject","text":"\u53c2\u6570 arg \u00abObject,String\u00bb field specification \u8fd4\u56de Appends a new $project operator to this aggregate pipeline. Mongoose query [selection syntax is also supported. \u793a\u4f8b aggregate . project ( \"a b -_id\" ); aggregate . project ({ a: 1 , b: 1 , _id: 0 }); aggregate . project ({ newField: ' $b . nested ' , plusTen: { $add : [' $val ', 10 ]} , sub: { name: ' $a ' } }) aggregate . project ({ salary_k: { $divide : [ \"$salary\" , 1000 ] } });","title":"Aggregate.prototype.project()"},{"location":"api/Aggregate/#aggregateprototypegroup","text":"\u53c2\u6570 arg \u00abObject\u00bb $group operator contents \u8fd4\u56de Appends a new custom $group operator to this aggregate pipeline. \u793a\u4f8b aggregate . group ({ _id: \"$department\" });","title":"Aggregate.prototype.group()"},{"location":"api/Aggregate/#aggregateprototypematch","text":"\u53c2\u6570 arg \u00abObject\u00bb $match operator contents \u8fd4\u56de Appends a new custom $match operator to this aggregate pipeline. \u793a\u4f8b aggregate . match ({ department: { $in : [ \"sales\" , \"engineering\" ] } });","title":"Aggregate.prototype.match()"},{"location":"api/Aggregate/#aggregateprototypeskip","text":"\u53c2\u6570 num \u00abNumber\u00bb number of records to skip before next stage \u8fd4\u56de Appends a new $skip operator to this aggregate pipeline. \u793a\u4f8b aggregate . skip ( 10 );","title":"Aggregate.prototype.skip()"},{"location":"api/Aggregate/#aggregateprototypelimit","text":"\u53c2\u6570 num \u00abNumber\u00bb maximum number of records to pass to the next stage \u8fd4\u56de Appends a new $limit operator to this aggregate pipeline. \u793a\u4f8b aggregate . limit ( 10 );","title":"Aggregate.prototype.limit()"},{"location":"api/Aggregate/#aggregateprototypenear","text":"\u53c2\u6570 \u8fd4\u56de Appends a new $geoNear operator to this aggregate pipeline. \u6ce8\u91ca MUST be used as the first operator in the pipeline. \u793a\u4f8b aggregate . near ({ near: [ 40.724 , - 73.997 ], distanceField: \"dist.calculated\" , maxDistance: 0.008 , query: { type : \"public\" }, includeLocs: \"dist.location\" , uniqueDocs: true , num: 5 });","title":"Aggregate.prototype.near()"},{"location":"api/Aggregate/#aggregateprototypeunwind","text":"\u53c2\u6570 fields \u00abString\u00bb the field(s) to unwind \u8fd4\u56de Appends new custom $unwind operator(s) to this aggregate pipeline. Note that the $unwind operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'. \u793a\u4f8b aggregate . unwind ( \"tags\" ); aggregate . unwind ( \"a\" , \"b\" , \"c\" );","title":"Aggregate.prototype.unwind()"},{"location":"api/Aggregate/#aggregateprototypelookup","text":"\u53c2\u6570 options \u00abObject\u00bb to $lookup as described in the above link \u8fd4\u56de Appends new custom $lookup operator(s) to this aggregate pipeline. \u793a\u4f8b aggregate . lookup ({ from: ' users ', localField: ' userId ', foreignField: ' _id ', as: ' users ' });","title":"Aggregate.prototype.lookup()"},{"location":"api/Aggregate/#aggregateprototypegraphlookup","text":"\u53c2\u6570 options \u00abObject\u00bb to $graphLookup as described in the above link \u8fd4\u56de Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection. Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if { allowDiskUse: true } is specified. \u793a\u4f8b aggregate . graphLookup ({ from: ' courses ', startWith: ' $prerequisite ', connectFromField: ' prerequisite ', connectToField: ' name ', as: ' prerequisites ', maxDepth: 3 })","title":"Aggregate.prototype.graphLookup()"},{"location":"api/Aggregate/#aggregateprototypesample","text":"\u53c2\u6570 size \u00abNumber\u00bb number of random documents to pick \u8fd4\u56de Appepnds new custom $sample operator(s) to this aggregate pipeline. \u793a\u4f8b aggregate . sample ( 3 );","title":"Aggregate.prototype.sample()"},{"location":"api/Aggregate/#aggregateprototypesort","text":"\u53c2\u6570 \u8fd4\u56de Appends a new $sort operator to this aggregate pipeline. If an object is passed, values allowed are asc , desc , ascending , descending , 1 , and -1 . If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with - which will be treated as descending. \u793a\u4f8b aggregate . sort ({ field: ' asc ', test: - 1 }); aggregate . sort (' field - test ');","title":"Aggregate.prototype.sort()"},{"location":"api/Aggregate/#aggregateprototyperead","text":"\u53c2\u6570 [tags] \u00abArray\u00bb optional tags for this query Sets the readPreference option for the aggregation query. \u793a\u4f8b Model . aggregate (..). read (' primaryPreferred '). exec ( callback )","title":"Aggregate.prototype.read()"},{"location":"api/Aggregate/#aggregateprototypeexplain","text":"\u53c2\u6570 \u8fd4\u56de Execute the aggregation with explain \u793a\u4f8b Model . aggregate (..). explain ( callback )","title":"Aggregate.prototype.explain()"},{"location":"api/Aggregate/#aggregateprototypeallowdiskuse","text":"\u53c2\u6570 [tags] \u00abArray\u00bb optional tags for this query Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0) \u793a\u4f8b Model . aggregate (..). allowDiskUse ( true ). exec ( callback )","title":"Aggregate.prototype.allowDiskUse()"},{"location":"api/Aggregate/#aggregateprototypeoption","text":"\u53c2\u6570 value \u00abObject\u00bb keys to merge into current options \u8fd4\u56de Lets you set arbitrary options, for middleware or plugins. \u793a\u4f8b var agg = Model . aggregate ( .. ) . option ({ allowDiskUse : true }); agg . options ;","title":"Aggregate.prototype.option()"},{"location":"api/Aggregate/#aggregateprototypecursor","text":"\u53c2\u6570 [options.useMongooseAggCursor] \u00abBoolean\u00bb use experimental mongoose-specific aggregation cursor (for eachAsync() and other query cursor semantics) Sets the cursor option option for the aggregation query (ignored for < 2.6.0). Note the different syntax below: .exec() returns a cursor object, and no callback is necessary. \u793a\u4f8b var cursor = Model . aggregate ( .. ) . cursor ({ batchSize : 1000 }) . exec (); cursor . each ( function ( error , doc ) { });","title":"Aggregate.prototype.cursor()"},{"location":"api/Aggregate/#aggregateprototypeaddcursorflag","text":"\u53c2\u6570 Adds a [cursor flag \u793a\u4f8b Model . aggregate (..). addCursorFlag (' noCursorTimeout ', true ). exec ();","title":"Aggregate.prototype.addCursorFlag()"},{"location":"api/Aggregate/#aggregateprototypecollation","text":"\u53c2\u6570 Adds a collation \u793a\u4f8b Model . aggregate (..). collation ({ locale: ' en_US ', strength : 1 }). exec ();","title":"Aggregate.prototype.collation()"},{"location":"api/Aggregate/#aggregateprototypefacet","text":"\u53c2\u6570 \u8fd4\u56de Combines multiple aggregation pipelines. \u793a\u4f8b Model . aggregate (...) . facet ({ books: [{ groupBy: ' $author ' }], price: [{ $bucketAuto : { groupBy: ' $price ', buckets: 2 } }] }) . exec ();","title":"Aggregate.prototype.facet()"},{"location":"api/Aggregate/#aggregateprototypepipeline","text":"\u8fd4\u56de Returns the current pipeline \u793a\u4f8b MyModel . aggregate (). match ({ test: 1 }). pipeline ();","title":"Aggregate.prototype.pipeline()"},{"location":"api/Aggregate/#aggregateprototypeexec","text":"\u53c2\u6570 \u8fd4\u56de Executes the aggregate pipeline on the currently bound Model. \u793a\u4f8b aggregate . exec ( callback ); var promise = aggregate . exec (); promise . then ( .. );","title":"Aggregate.prototype.exec()"},{"location":"api/Aggregate/#aggregateprototypethen","text":"\u53c2\u6570 [reject] \u00abFunction\u00bb errorCallback \u8fd4\u56de Provides promise for aggregate. \u793a\u4f8b Model . aggregate (..). then ( successCallback , errorCallback );","title":"Aggregate.prototype.then()"},{"location":"api/Error/","text":"\u9519\u8bef \u00b6 MongooseError() \u00b6 \u53c2\u6570 msg \u00abString\u00bb Error message MongooseError constructor MongooseError.messages \u00b6 The default built-in validator error messages. MongooseError.DocumentNotFoundError \u00b6 An instance of this error class will be returned when save() fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to update() when trying to update the document. MongooseError.CastError \u00b6 An instance of this error class will be returned when mongoose failed to cast a value. MongooseError.ValidationError \u00b6 An instance of this error class will be returned when [validation failed. MongooseError.ValidatorError \u00b6 A ValidationError has a hash of errors that contain individual ValidatorError instances MongooseError.VersionError \u00b6 An instance of this error class will be returned when you call save() after the document in the database was changed in a potentially unsafe way. See the [ versionKey option for more information. MongooseError.OverwriteModelError \u00b6 MongooseError.MissingSchemaError \u00b6 Thrown when you try to access a model that has not been registered yet MongooseError.DivergentArrayError \u00b6 An instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.","title":"\u9519\u8bef"},{"location":"api/Error/#_1","text":"","title":"\u9519\u8bef"},{"location":"api/Error/#mongooseerror","text":"\u53c2\u6570 msg \u00abString\u00bb Error message MongooseError constructor","title":"MongooseError()"},{"location":"api/Error/#mongooseerrormessages","text":"The default built-in validator error messages.","title":"MongooseError.messages"},{"location":"api/Error/#mongooseerrordocumentnotfounderror","text":"An instance of this error class will be returned when save() fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to update() when trying to update the document.","title":"MongooseError.DocumentNotFoundError"},{"location":"api/Error/#mongooseerrorcasterror","text":"An instance of this error class will be returned when mongoose failed to cast a value.","title":"MongooseError.CastError"},{"location":"api/Error/#mongooseerrorvalidationerror","text":"An instance of this error class will be returned when [validation failed.","title":"MongooseError.ValidationError"},{"location":"api/Error/#mongooseerrorvalidatorerror","text":"A ValidationError has a hash of errors that contain individual ValidatorError instances","title":"MongooseError.ValidatorError"},{"location":"api/Error/#mongooseerrorversionerror","text":"An instance of this error class will be returned when you call save() after the document in the database was changed in a potentially unsafe way. See the [ versionKey option for more information.","title":"MongooseError.VersionError"},{"location":"api/Error/#mongooseerroroverwritemodelerror","text":"","title":"MongooseError.OverwriteModelError"},{"location":"api/Error/#mongooseerrormissingschemaerror","text":"Thrown when you try to access a model that has not been registered yet","title":"MongooseError.MissingSchemaError"},{"location":"api/Error/#mongooseerrordivergentarrayerror","text":"An instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.","title":"MongooseError.DivergentArrayError"},{"location":"api/VirtualType/","text":"\u865a\u62df\u7c7b\u578b \u00b6 VirtualType() \u00b6 VirtualType constructor This is what mongoose uses to define virtual attributes via Schema.prototype.virtual . \u793a\u4f8b var fullname = schema . virtual ( 'fullname' ); fullname instanceof mongoose . VirtualType VirtualType.prototype.get() \u00b6 \u53c2\u6570 \u8fd4\u56de Defines a getter. \u793a\u4f8b var virtual = schema . virtual ( 'fullname' ); virtual . get ( function () { return this . name . first + ' ' + this . name . last ; }); VirtualType.prototype.set() \u00b6 \u53c2\u6570 \u8fd4\u56de Defines a setter. \u793a\u4f8b var virtual = schema . virtual ( 'fullname' ); virtual . set ( function ( v ) { var parts = v . split ( ' ' ); this . name . first = parts [ 0 ]; this . name . last = parts [ 1 ]; }); VirtualType.prototype.applyGetters() \u00b6 \u53c2\u6570 \u8fd4\u56de \u00abany\u00bb the value after applying all getters Applies getters to value using optional scope . VirtualType.prototype.applySetters() \u00b6 \u53c2\u6570 \u8fd4\u56de \u00abany\u00bb the value after applying all setters Applies setters to value using optional scope .","title":"\u865a\u62df\u7c7b\u578b"},{"location":"api/VirtualType/#_1","text":"","title":"\u865a\u62df\u7c7b\u578b"},{"location":"api/VirtualType/#virtualtype","text":"VirtualType constructor This is what mongoose uses to define virtual attributes via Schema.prototype.virtual . \u793a\u4f8b var fullname = schema . virtual ( 'fullname' ); fullname instanceof mongoose . VirtualType","title":"VirtualType()"},{"location":"api/VirtualType/#virtualtypeprototypeget","text":"\u53c2\u6570 \u8fd4\u56de Defines a getter. \u793a\u4f8b var virtual = schema . virtual ( 'fullname' ); virtual . get ( function () { return this . name . first + ' ' + this . name . last ; });","title":"VirtualType.prototype.get()"},{"location":"api/VirtualType/#virtualtypeprototypeset","text":"\u53c2\u6570 \u8fd4\u56de Defines a setter. \u793a\u4f8b var virtual = schema . virtual ( 'fullname' ); virtual . set ( function ( v ) { var parts = v . split ( ' ' ); this . name . first = parts [ 0 ]; this . name . last = parts [ 1 ]; });","title":"VirtualType.prototype.set()"},{"location":"api/VirtualType/#virtualtypeprototypeapplygetters","text":"\u53c2\u6570 \u8fd4\u56de \u00abany\u00bb the value after applying all getters Applies getters to value using optional scope .","title":"VirtualType.prototype.applyGetters()"},{"location":"api/VirtualType/#virtualtypeprototypeapplysetters","text":"\u53c2\u6570 \u8fd4\u56de \u00abany\u00bb the value after applying all setters Applies setters to value using optional scope .","title":"VirtualType.prototype.applySetters()"},{"location":"connection/api/","text":"\u8fde\u63a5 \u00b6 Connection() \u00b6 \u53c2\u6570 \u57fa\u4e8e \u00abMongoose\u00bb \u4e00\u4e2a\u732b\u9f2c\u7684\u4f8b\u5b50 \u8fde\u63a5\u6784\u9020 \u51fa\u4e8e\u5b9e\u9645\u7684\u539f\u56e0\uff0c\u8fde\u63a5\u7b49\u4e8eDb\u3002 Connection.prototype.readyState \u00b6 \u8fde\u63a5\u51c6\u5907\u72b6\u6001 0 = disconnected 1 = connected 2 = connecting 3 = disconnecting \u6bcf\u4e2a\u72b6\u6001\u66f4\u6539\u90fd\u4f1a\u53d1\u51fa\u5176\u5173\u8054\u7684\u4e8b\u4ef6\u540d\u79f0 \u793a\u4f8b conn.on('connected', callback); conn.on('disconnected', callback); Connection.prototype.collections \u00b6 \u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u96c6\u5408\u7684\u6563\u5217 Connection.prototype.db \u00b6 \u5f53\u8fde\u63a5\u6253\u5f00\u65f6\u8bbe\u7f6e\u7684mongodb.Db\u5b9e\u4f8b Connection.prototype.config \u00b6 \u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u5168\u5c40\u9009\u9879\u7684\u6563\u5217 Connection.prototype.createCollection() \u00b6 \u53c2\u6570 \u8fd4\u56de Connection.prototype.dropCollection() \u00b6 \u53c2\u6570 \u8fd4\u56de dropCollection() \u52a9\u624b. \u5c06\u5220\u9664\u7ed9\u5b9a\u7684\u96c6\u5408\uff0c\u5305\u62ec\u6240\u6709\u6587\u6863\u548c\u7d22\u5f15. Connection.prototype.dropDatabase() \u00b6 \u53c2\u6570 \u8fd4\u56de dropDatabase() \u52a9\u624b. \u5220\u9664\u7ed9\u5b9a\u7684\u6570\u636e\u5e93\uff0c\u5305\u62ec\u6240\u6709\u96c6\u5408\uff0c\u6587\u6863\u548c\u7d22\u5f15. Connection.prototype.close() \u00b6 \u53c2\u6570 \u56de\u8c03\u00ab\u529f\u80fd\u00bb\u9009\u9879 \u8fd4\u56de Connection.prototype.collection() \u00b6 \u53c2\u6570 \u9009\u9879\u00ab\u5bf9\u8c61\u00bb\u53ef\u9009\u6536\u96c6\u9009\u9879 \u8fd4\u56de \u00abCollection\u00bb \u6536\u96c6\u5b9e\u4f8b \u68c0\u7d22\u4e00\u4e2a\u96c6\u5408\uff0c\u5982\u679c\u6ca1\u6709\u7f13\u5b58\u5219\u521b\u5efa\u5b83 \u901a\u5e38\u4e0d\u9700\u8981\u5e94\u7528\u7a0b\u5e8f\u3002 Just talk to your collection through your model. Connection.prototype.model() \u00b6 \u53c2\u6570 collection \u00abString\u00bb name of mongodb collection (optional) if not given it will be induced from model name \u8fd4\u56de \u00abModel\u00bb \u7f16\u8bd1\u6a21\u5f0f \u5b9a\u4e49\u6216\u68c0\u7d22\u6a21\u578b var mongoose = require ( 'mongoose' ); var db = mongoose . createConnection ( .. ); db . model ( 'Venue' , new Schema ( .. )); var Ticket = db . model ( 'Ticket' , new Schema ( .. )); var Venue = db . model ( 'Venue' ); When no collection argument is passed, Mongoose produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option. \u793a\u4f8b var schema = new Schema ({ name : String }, { collection : 'actor' }); schema . set ( 'collection' , 'actor' ); var collectionName = 'actor' var M = conn . model ( 'Actor' , schema , collectionName ) Connection.prototype.modelNames() \u00b6 \u8fd4\u56de \u8fd4\u56de\u5728\u6b64\u8fde\u63a5\u4e0a\u521b\u5efa\u7684\u6a21\u578b\u540d\u79f0\u6570\u7ec4\u3002","title":"\u8fde\u63a5API"},{"location":"connection/api/#_1","text":"","title":"\u8fde\u63a5"},{"location":"connection/api/#connection","text":"\u53c2\u6570 \u57fa\u4e8e \u00abMongoose\u00bb \u4e00\u4e2a\u732b\u9f2c\u7684\u4f8b\u5b50 \u8fde\u63a5\u6784\u9020 \u51fa\u4e8e\u5b9e\u9645\u7684\u539f\u56e0\uff0c\u8fde\u63a5\u7b49\u4e8eDb\u3002","title":"Connection()"},{"location":"connection/api/#connectionprototypereadystate","text":"\u8fde\u63a5\u51c6\u5907\u72b6\u6001 0 = disconnected 1 = connected 2 = connecting 3 = disconnecting \u6bcf\u4e2a\u72b6\u6001\u66f4\u6539\u90fd\u4f1a\u53d1\u51fa\u5176\u5173\u8054\u7684\u4e8b\u4ef6\u540d\u79f0 \u793a\u4f8b conn.on('connected', callback); conn.on('disconnected', callback);","title":"Connection.prototype.readyState"},{"location":"connection/api/#connectionprototypecollections","text":"\u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u96c6\u5408\u7684\u6563\u5217","title":"Connection.prototype.collections"},{"location":"connection/api/#connectionprototypedb","text":"\u5f53\u8fde\u63a5\u6253\u5f00\u65f6\u8bbe\u7f6e\u7684mongodb.Db\u5b9e\u4f8b","title":"Connection.prototype.db"},{"location":"connection/api/#connectionprototypeconfig","text":"\u4e0e\u6b64\u8fde\u63a5\u5173\u8054\u7684\u5168\u5c40\u9009\u9879\u7684\u6563\u5217","title":"Connection.prototype.config"},{"location":"connection/api/#connectionprototypecreatecollection","text":"\u53c2\u6570 \u8fd4\u56de","title":"Connection.prototype.createCollection()"},{"location":"connection/api/#connectionprototypedropcollection","text":"\u53c2\u6570 \u8fd4\u56de dropCollection() \u52a9\u624b. \u5c06\u5220\u9664\u7ed9\u5b9a\u7684\u96c6\u5408\uff0c\u5305\u62ec\u6240\u6709\u6587\u6863\u548c\u7d22\u5f15.","title":"Connection.prototype.dropCollection()"},{"location":"connection/api/#connectionprototypedropdatabase","text":"\u53c2\u6570 \u8fd4\u56de dropDatabase() \u52a9\u624b. \u5220\u9664\u7ed9\u5b9a\u7684\u6570\u636e\u5e93\uff0c\u5305\u62ec\u6240\u6709\u96c6\u5408\uff0c\u6587\u6863\u548c\u7d22\u5f15.","title":"Connection.prototype.dropDatabase()"},{"location":"connection/api/#connectionprototypeclose","text":"\u53c2\u6570 \u56de\u8c03\u00ab\u529f\u80fd\u00bb\u9009\u9879 \u8fd4\u56de","title":"Connection.prototype.close()"},{"location":"connection/api/#connectionprototypecollection","text":"\u53c2\u6570 \u9009\u9879\u00ab\u5bf9\u8c61\u00bb\u53ef\u9009\u6536\u96c6\u9009\u9879 \u8fd4\u56de \u00abCollection\u00bb \u6536\u96c6\u5b9e\u4f8b \u68c0\u7d22\u4e00\u4e2a\u96c6\u5408\uff0c\u5982\u679c\u6ca1\u6709\u7f13\u5b58\u5219\u521b\u5efa\u5b83 \u901a\u5e38\u4e0d\u9700\u8981\u5e94\u7528\u7a0b\u5e8f\u3002 Just talk to your collection through your model.","title":"Connection.prototype.collection()"},{"location":"connection/api/#connectionprototypemodel","text":"\u53c2\u6570 collection \u00abString\u00bb name of mongodb collection (optional) if not given it will be induced from model name \u8fd4\u56de \u00abModel\u00bb \u7f16\u8bd1\u6a21\u5f0f \u5b9a\u4e49\u6216\u68c0\u7d22\u6a21\u578b var mongoose = require ( 'mongoose' ); var db = mongoose . createConnection ( .. ); db . model ( 'Venue' , new Schema ( .. )); var Ticket = db . model ( 'Ticket' , new Schema ( .. )); var Venue = db . model ( 'Venue' ); When no collection argument is passed, Mongoose produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option. \u793a\u4f8b var schema = new Schema ({ name : String }, { collection : 'actor' }); schema . set ( 'collection' , 'actor' ); var collectionName = 'actor' var M = conn . model ( 'Actor' , schema , collectionName )","title":"Connection.prototype.model()"},{"location":"connection/api/#connectionprototypemodelnames","text":"\u8fd4\u56de \u8fd4\u56de\u5728\u6b64\u8fde\u63a5\u4e0a\u521b\u5efa\u7684\u6a21\u578b\u540d\u79f0\u6570\u7ec4\u3002","title":"Connection.prototype.modelNames()"},{"location":"connection/guide/","text":"\u8fde\u63a5\u5230MongoDB \u00b6 Source You can connect to MongoDB with the mongoose.connect() method. mongoose . connect ( 'mongodb://localhost/myapp' ); This is the minimum needed to connect the myapp database running locally on the default port (27017). If the local connection fails then try using 127.0.0.1 instead of localhost. Sometimes issues may arise when the local hostname has been changed. You can also specify several more parameters in the uri : mongoose . connect ( 'mongodb://username:password@host:port/database?options...' ); See the mongodb connection string spec for more detail. \u64cd\u4f5c\u7f13\u51b2 \u00b6 Mongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB. mongoose . connect ( 'mongodb://localhost/myapp' ); var MyModel = mongoose . model ( 'Test' , new Schema ({ name : String })); MyModel . findOne ( function ( error , result ) { }); That's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will not throw any errors by default if you use a model without connecting. var MyModel = mongoose . model ( 'Test' , new Schema ({ name : String })); MyModel . findOne ( function ( error , result ) { }); setTimeout ( function () { mongoose . connect ( 'mongodb://localhost/myapp' ); }, 60000 ); To disable buffering, turn off the bufferCommands option on your schema . If you have bufferCommands on and your connection is hanging, try turning bufferCommands off to see if you haven't opened a connection properly. You can also disable bufferCommands globally: mongoose.set('bufferCommands', false); \u9009\u9879 \u00b6 The connect method also accepts an options object which will be passed on to the underlying MongoDB driver. mongoose . connect ( uri , options ) ; A full list of options can be found on the MongoDB Node.js driver docs for connect() . Mongoose passes options to the driver without modification, modulo three exceptions that are explained below. bufferCommands - This is a mongoose-specific option (not passed to the MongoDB driver) that disables mongoose's buffering mechanism user / pass - The username and password for authentication. These options are mongoose-specific, they are equivalent to the MongoDB driver's auth.user and auth.password options. autoIndex - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set autoIndex to false, mongoose will not automatically build indexes for any model associated with this connection. Below are some of the options that are important for tuning mongoose. autoReconnect - The underlying MongoDB driver will automatically try to reconnect when it loses connection to MongoDB. Unless you are an extremely advanced user that wants to manage their own connection pool, do not set this option to false . reconnectTries - If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every reconnectInterval milliseconds for reconnectTries times, and give up afterward. When the driver gives up, the mongoose connection emits a reconnectFailed event. This option does nothing for replica set connections. reconnectInterval - See reconnectTries promiseLibrary - sets the underlying driver's promise library poolSize - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, poolSize is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. bufferMaxEntries - The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set bufferCommands to false on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection. Example: const options = { useMongoClient : true , autoIndex : false , reconnectTries : Number . MAX_VALUE , reconnectInterval : 500 , poolSize : 10 , bufferMaxEntries : 0 }; mongoose . connect ( uri , options ); \u56de\u8c03\u51fd\u6570 \u00b6 The connect() function also accepts a callback parameter and returns a promise . mongoose . connect ( uri , options , function ( error ) { } ) ; mongoose . connect ( uri , options ) . then ( () => { }, err => { } ) ; \u8fde\u63a5\u5b57\u7b26\u4e32\u9009\u9879 \u00b6 You can also specify driver options in your connection string as parameters in the query string portion of the URI. This only applies to options passed to the MongoDB driver. You can't set Mongoose-specific options like bufferCommands in the query string. mongoose . connect ( 'mongodb://localhost:27017/test?connectTimeoutMS=1000&bufferCommands=false' ); mongoose . connect ( 'mongodb://localhost:27017/test' , { connectTimeoutMS : 1000 } ); The disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for socketTimeoutMS , connectTimeoutMS , etc. Best practice is to put options that likely differ between development and production, like replicaSet or ssl , in the connection string, and options that should remain constant, like connectTimeoutMS or poolSize , in the options object. The MongoDB docs have a full list of supported connection string options \u6709\u5173keepAlive\u7684\u8bf4\u660e \u00b6 For long running applications, it is often prudent to enable keepAlive with a number of milliseconds. Without it, after some period of time you may start to see \"connection closed\" errors for what seems like no reason. If so, after reading this , you may decide to enable keepAlive : mongoose . connect ( uri , { keepAlive : 120 } ); \u526f\u672c\u96c6\u8fde\u63a5 \u00b6 To connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host. mongoose . connect ( 'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]' [ , options ] ); To connect to a single node replica set, specify the replicaSet option. mongoose . connect ( 'mongodb://host1:port1/?replicaSet=rsName' ); \u591amongos\u652f\u6301 \u00b6 High availability over multiple mongos instances is also supported. Pass a connection string for your mongos instances and set the mongos option to true : mongoose . connect ( 'mongodb://mongosA:27501,mongosB:27501' , { mongos : true } , cb ); \u591a\u4e2a\u8fde\u63a5 \u00b6 So far we've seen how to connect to MongoDB using Mongoose's default connection. At times we may need multiple connections open to Mongo, each with different read/write settings, or maybe just to different databases for example. In these cases we can utilize mongoose.createConnection() which accepts all the arguments already discussed and returns a fresh connection for you. const conn = mongoose . createConnection ( 'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]' , options ); This connection object is then used to create and retrieve models . Models are always scoped to a single connection. Mongoose creates a default connection when you call mongoose.connect() . You can access the default connection using mongoose.connection . \u8fde\u63a5\u6c60 \u00b6 Each connection , whether created with mongoose.connect or mongoose.createConnection are all backed by an internal configurable connection pool defaulting to a maximum size of 5. Adjust the pool size using your connection options: mongoose . createConnection ( uri , { poolSize : 4 }); const uri = 'mongodb://localhost/test?poolSize=4' ; mongoose . createConnection ( uri ); v5.x\u4e2d\u7684\u9009\u9879\u66f4\u6539 \u00b6 You may see the following deprecation warning if upgrading from 4.x to 5.x and you didn't use the useMongoClient option in 4.x: the server/replset/mongos options are deprecated, all their options are supported at the top level of the options object In older version of the MongoDB driver you had to specify distinct options for server connections, replica set connections, and mongos connections: mongoose . connect ( myUri , { server : { socketOptions : { socketTimeoutMS : 0 , keepAlive : true } , reconnectTries : 30 } , replset : { socketOptions : { socketTimeoutMS : 0 , keepAlive : true } , reconnectTries : 30 } , mongos : { socketOptions : { socketTimeoutMS : 0 , keepAlive : true } , reconnectTries : 30 } } ); In mongoose v5.x you can instead declare these options at the top level, without all that extra nesting. Here's the list of all supported options . mongoose . connect ( myUri , { socketTimeoutMS : 0 , keepAlive : true , reconnectTries : 30 } ); \u63a5\u4e0b\u6765 \u00b6 \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6db5\u76d6\u4e86\u8fde\u63a5, \u8ba9\u6211\u4eec\u6765\u770b\u770b \u6a21\u578b .","title":"\u8fde\u63a5\u624b\u518c"},{"location":"connection/guide/#mongodb","text":"Source You can connect to MongoDB with the mongoose.connect() method. mongoose . connect ( 'mongodb://localhost/myapp' ); This is the minimum needed to connect the myapp database running locally on the default port (27017). If the local connection fails then try using 127.0.0.1 instead of localhost. Sometimes issues may arise when the local hostname has been changed. You can also specify several more parameters in the uri : mongoose . connect ( 'mongodb://username:password@host:port/database?options...' ); See the mongodb connection string spec for more detail.","title":"\u8fde\u63a5\u5230MongoDB"},{"location":"connection/guide/#_1","text":"Mongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB. mongoose . connect ( 'mongodb://localhost/myapp' ); var MyModel = mongoose . model ( 'Test' , new Schema ({ name : String })); MyModel . findOne ( function ( error , result ) { }); That's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will not throw any errors by default if you use a model without connecting. var MyModel = mongoose . model ( 'Test' , new Schema ({ name : String })); MyModel . findOne ( function ( error , result ) { }); setTimeout ( function () { mongoose . connect ( 'mongodb://localhost/myapp' ); }, 60000 ); To disable buffering, turn off the bufferCommands option on your schema . If you have bufferCommands on and your connection is hanging, try turning bufferCommands off to see if you haven't opened a connection properly. You can also disable bufferCommands globally: mongoose.set('bufferCommands', false);","title":"\u64cd\u4f5c\u7f13\u51b2"},{"location":"connection/guide/#_2","text":"The connect method also accepts an options object which will be passed on to the underlying MongoDB driver. mongoose . connect ( uri , options ) ; A full list of options can be found on the MongoDB Node.js driver docs for connect() . Mongoose passes options to the driver without modification, modulo three exceptions that are explained below. bufferCommands - This is a mongoose-specific option (not passed to the MongoDB driver) that disables mongoose's buffering mechanism user / pass - The username and password for authentication. These options are mongoose-specific, they are equivalent to the MongoDB driver's auth.user and auth.password options. autoIndex - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set autoIndex to false, mongoose will not automatically build indexes for any model associated with this connection. Below are some of the options that are important for tuning mongoose. autoReconnect - The underlying MongoDB driver will automatically try to reconnect when it loses connection to MongoDB. Unless you are an extremely advanced user that wants to manage their own connection pool, do not set this option to false . reconnectTries - If you're connected to a single server or mongos proxy (as opposed to a replica set), the MongoDB driver will try to reconnect every reconnectInterval milliseconds for reconnectTries times, and give up afterward. When the driver gives up, the mongoose connection emits a reconnectFailed event. This option does nothing for replica set connections. reconnectInterval - See reconnectTries promiseLibrary - sets the underlying driver's promise library poolSize - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, poolSize is 5. Keep in mind that, as of MongoDB 3.4, MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. bufferMaxEntries - The MongoDB driver also has its own buffering mechanism that kicks in when the driver is disconnected. Set this option to 0 and set bufferCommands to false on your schemas if you want your database operations to fail immediately when the driver is not connected, as opposed to waiting for reconnection. Example: const options = { useMongoClient : true , autoIndex : false , reconnectTries : Number . MAX_VALUE , reconnectInterval : 500 , poolSize : 10 , bufferMaxEntries : 0 }; mongoose . connect ( uri , options );","title":"\u9009\u9879"},{"location":"connection/guide/#_3","text":"The connect() function also accepts a callback parameter and returns a promise . mongoose . connect ( uri , options , function ( error ) { } ) ; mongoose . connect ( uri , options ) . then ( () => { }, err => { } ) ;","title":"\u56de\u8c03\u51fd\u6570"},{"location":"connection/guide/#_4","text":"You can also specify driver options in your connection string as parameters in the query string portion of the URI. This only applies to options passed to the MongoDB driver. You can't set Mongoose-specific options like bufferCommands in the query string. mongoose . connect ( 'mongodb://localhost:27017/test?connectTimeoutMS=1000&bufferCommands=false' ); mongoose . connect ( 'mongodb://localhost:27017/test' , { connectTimeoutMS : 1000 } ); The disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for socketTimeoutMS , connectTimeoutMS , etc. Best practice is to put options that likely differ between development and production, like replicaSet or ssl , in the connection string, and options that should remain constant, like connectTimeoutMS or poolSize , in the options object. The MongoDB docs have a full list of supported connection string options","title":"\u8fde\u63a5\u5b57\u7b26\u4e32\u9009\u9879"},{"location":"connection/guide/#keepalive","text":"For long running applications, it is often prudent to enable keepAlive with a number of milliseconds. Without it, after some period of time you may start to see \"connection closed\" errors for what seems like no reason. If so, after reading this , you may decide to enable keepAlive : mongoose . connect ( uri , { keepAlive : 120 } );","title":"\u6709\u5173keepAlive\u7684\u8bf4\u660e"},{"location":"connection/guide/#_5","text":"To connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host. mongoose . connect ( 'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]' [ , options ] ); To connect to a single node replica set, specify the replicaSet option. mongoose . connect ( 'mongodb://host1:port1/?replicaSet=rsName' );","title":"\u526f\u672c\u96c6\u8fde\u63a5"},{"location":"connection/guide/#mongos","text":"High availability over multiple mongos instances is also supported. Pass a connection string for your mongos instances and set the mongos option to true : mongoose . connect ( 'mongodb://mongosA:27501,mongosB:27501' , { mongos : true } , cb );","title":"\u591amongos\u652f\u6301"},{"location":"connection/guide/#_6","text":"So far we've seen how to connect to MongoDB using Mongoose's default connection. At times we may need multiple connections open to Mongo, each with different read/write settings, or maybe just to different databases for example. In these cases we can utilize mongoose.createConnection() which accepts all the arguments already discussed and returns a fresh connection for you. const conn = mongoose . createConnection ( 'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]' , options ); This connection object is then used to create and retrieve models . Models are always scoped to a single connection. Mongoose creates a default connection when you call mongoose.connect() . You can access the default connection using mongoose.connection .","title":"\u591a\u4e2a\u8fde\u63a5"},{"location":"connection/guide/#_7","text":"Each connection , whether created with mongoose.connect or mongoose.createConnection are all backed by an internal configurable connection pool defaulting to a maximum size of 5. Adjust the pool size using your connection options: mongoose . createConnection ( uri , { poolSize : 4 }); const uri = 'mongodb://localhost/test?poolSize=4' ; mongoose . createConnection ( uri );","title":"\u8fde\u63a5\u6c60"},{"location":"connection/guide/#v5x","text":"You may see the following deprecation warning if upgrading from 4.x to 5.x and you didn't use the useMongoClient option in 4.x: the server/replset/mongos options are deprecated, all their options are supported at the top level of the options object In older version of the MongoDB driver you had to specify distinct options for server connections, replica set connections, and mongos connections: mongoose . connect ( myUri , { server : { socketOptions : { socketTimeoutMS : 0 , keepAlive : true } , reconnectTries : 30 } , replset : { socketOptions : { socketTimeoutMS : 0 , keepAlive : true } , reconnectTries : 30 } , mongos : { socketOptions : { socketTimeoutMS : 0 , keepAlive : true } , reconnectTries : 30 } } ); In mongoose v5.x you can instead declare these options at the top level, without all that extra nesting. Here's the list of all supported options . mongoose . connect ( myUri , { socketTimeoutMS : 0 , keepAlive : true , reconnectTries : 30 } );","title":"v5.x\u4e2d\u7684\u9009\u9879\u66f4\u6539"},{"location":"connection/guide/#_8","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u6db5\u76d6\u4e86\u8fde\u63a5, \u8ba9\u6211\u4eec\u6765\u770b\u770b \u6a21\u578b .","title":"\u63a5\u4e0b\u6765"},{"location":"document/api/","text":"\u6587\u6863 \u00b6 Document.prototype.schema \u00b6 Document.prototype.isNew \u00b6 \u5e03\u5c14\u6807\u5fd7\u6307\u5b9a\u6587\u6863 Document.prototype.id \u00b6 \u8fd9\u4e2a\u6587\u4ef6\u7684\u5b57\u7b26\u4e32\u7248\u672c_id \u6ce8\u91ca \u8fd9\u4e2agetter\u9ed8\u8ba4\u5b58\u5728\u4e8e\u6240\u6709\u7684\u6587\u4ef6\u4e0a\u3002 The getter can be disabled by setting the id option of its Schema to false at construction time. new Schema ( { name : String } , { id : false } ); Document.prototype.errors \u00b6 Hash containing current validation errors. Document.prototype.init() \u00b6 \u53c2\u6570 doc \u00abObject\u00bb document returned by mongo Initializes the document without setters or marking anything modified. Called internally after a document is returned from mongodb. Document.prototype.update() \u00b6 \u53c2\u6570 \u8fd4\u56de Sends an update command with this document _id as the query selector. \u793a\u4f8b weirdCar . update ( { $ inc : { wheels : 1 } } , { w : 1 } , callback ); \u6709\u6548\u7684\u9009\u9879 Document.prototype.$set() \u00b6 \u53c2\u6570 options] \u00abObject\u00bb optionally specify options that modify the behavior of the set Alias for set() , used internally to avoid conflicts Document.prototype.set() \u00b6 \u53c2\u6570 options] \u00abObject\u00bb optionally specify options that modify the behavior of the set Sets the value of a path, or many paths. \u793a\u4f8b doc . set ( path , value ) doc . set ( { path : value , path2 : { path : value } } ) doc . set ( path , value , Number ) doc . set ( path , value , String ) doc . set ( path , value , { strict : false } ); Document.prototype.get() \u00b6 \u53c2\u6570 type] \u00abSchema,String,Number,Buffer,*\u00bb optionally specify a type for on-the-fly attributes Returns the value of a path. \u793a\u4f8b doc.get('age') doc.get('age', String) Document.prototype.markModified() \u00b6 \u53c2\u6570 scope] \u00abDocument\u00bb the scope to run validators with Marks the path as having pending changes to write to the db. Very helpful when using Mixed types. \u793a\u4f8b doc.mixed.type = 'changed'; doc.markModified('mixed.type'); doc.save() Document.prototype.unmarkModified() \u00b6 \u53c2\u6570 path \u00abString\u00bb the path to unmark modified Clears the modified state on the specified path. \u793a\u4f8b doc.foo = 'bar'; doc.unmarkModified('foo'); doc.save() Document.prototype.$ignore() \u00b6 \u53c2\u6570 path \u00abString\u00bb the path to ignore Don't run validation on this path or persist changes to this path. \u793a\u4f8b doc.foo = null; doc.$ignore('foo'); doc.save() Document.prototype.modifiedPaths() \u00b6 \u8fd4\u56de Returns the list of paths that have been modified. Document.prototype.isModified() \u00b6 \u53c2\u6570 path] \u00abString\u00bb optional \u8fd4\u56de Returns true if this document was modified, else false. If path is given, checks if a path or any full path containing path as part of its path chain has been modified. \u793a\u4f8b doc.set('documents.0.title', 'changed'); doc.isModified() doc.isModified('documents') doc.isModified('documents.0.title') doc.isModified('documents otherProp') doc.isDirectModified('documents') Document.prototype.$isDefault() \u00b6 \u53c2\u6570 \u8fd4\u56de Checks if a path is set to its default. \u793a\u4f8b MyModel = mongoose . model ( 'test' , { name : { type : String , default : 'Val ' } }); var m = new MyModel (); m .$ isDefault ( 'name' ); Document.prototype.$isDeleted() \u00b6 \u53c2\u6570 val] \u00abBoolean\u00bb optional, overrides whether mongoose thinks the doc is deleted \u8fd4\u56de \u00abBoolean\u00bb whether mongoose thinks this doc is deleted. Getter/setter, determines whether the document was removed or not. \u793a\u4f8b product.remove(function (err, product) { product.isDeleted(); product.remove(); product.isDeleted(false); product.isDeleted(); product.remove(); }) Document.prototype.isDirectModified() \u00b6 \u53c2\u6570 \u8fd4\u56de Returns true if path was directly set and modified, else false. \u793a\u4f8b doc.set('documents.0.title', 'changed'); doc.isDirectModified('documents.0.title') doc.isDirectModified('documents') Document.prototype.isInit() \u00b6 \u53c2\u6570 \u8fd4\u56de Checks if path was initialized. Document.prototype.isSelected() \u00b6 \u53c2\u6570 \u8fd4\u56de Checks if path was selected in the source query which initialized this document. \u793a\u4f8b Thing . findOne () . select ( ' name ' ) . exec ( function ( err , doc ) { doc . isSelected ( ' name ' ) doc . isSelected ( ' age ' ) } ) Document.prototype.isDirectSelected() \u00b6 \u53c2\u6570 \u8fd4\u56de Checks if path was explicitly selected. If no projection, always returns true. \u793a\u4f8b Thing . findOne () . select ( ' nested.name ' ) . exec ( function ( err , doc ) { doc . isDirectSelected ( ' nested.name ' ) doc . isDirectSelected ( ' nested.otherName ' ) doc . isDirectSelected ( ' nested ' ) } ) Document.prototype.validate() \u00b6 \u53c2\u6570 callback \u00abFunction\u00bb optional callback called after validation completes, passing an error if one occurred \u8fd4\u56de Executes registered validation rules for this document. \u6ce8\u91ca This method is called pre save and if a validation rule is violated, save is aborted and the error is returned to your callback . \u793a\u4f8b doc . validate ( function ( err ) { if ( err ) handleError ( err ) ; else } ) ; Document.prototype.validateSync() \u00b6 \u53c2\u6570 pathsToValidate \u00abArray,string\u00bb only validate the given paths \u8fd4\u56de \u00abMongooseError,undefined\u00bb MongooseError if there are errors during validation, or undefined if there is no error. Executes registered validation rules (skipping asynchronous validators) for this document. \u6ce8\u91ca This method is useful if you need synchronous validation. \u793a\u4f8b var err = doc . validateSync (); if ( err ){ handleError ( err ); } else { } Document.prototype.invalidate() \u00b6 \u53c2\u6570 kind] \u00abString\u00bb optional kind property for the error \u8fd4\u56de \u00abValidationError\u00bb the current ValidationError, with all currently invalidated paths Marks a path as invalid, causing validation to fail. The errorMsg argument will become the message of the ValidationError . The value argument (if passed) will be available through the ValidationError.value property. doc.invalidate('size', 'must be less than 20', 14); doc.validate(function (err) { console.log(err) { message: 'Validation failed', name: 'ValidationError', errors: { size: { message: 'must be less than 20', name: 'ValidatorError', path: 'size', type: 'user defined', value: 14 } } } }) Document.prototype.$markValid() \u00b6 \u53c2\u6570 path \u00abString\u00bb the field to mark as valid Marks a path as valid, removing existing validation errors. Document.prototype.save() \u00b6 \u53c2\u6570 fn] \u00abFunction\u00bb optional callback \u8fd4\u56de Saves this document. \u793a\u4f8b product . sold = Date . now () ; product . save ( function ( err , product , numAffected ) { if ( err ) .. } ) The callback will receive three parameters err if an error occurred product which is the saved product numAffected will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking err is sufficient to make sure your document was properly saved. As an extra measure of flow control, save will return a Promise. \u793a\u4f8b product . save () . then ( function ( product ) { ... } ) ; Document.prototype.toObject() \u00b6 \u53c2\u6570 \u8fd4\u56de Converts this document into a plain javascript object, ready for storage in MongoDB. Buffers are converted to instances of mongodb.Binary for proper storage. \u9009\u9879: getters apply all getters (path and virtual getters) virtuals apply virtual getters (can override getters option) minimize remove empty objects (defaults to true) transform a transform function to apply to the resulting document before returning depopulate depopulate any populated paths, replacing them with their original refs (defaults to false) versionKey whether to include the version key (defaults to true) Getters/Virtuals Example of only applying path getters doc.toObject({ getters: true, virtuals: false }) Example of only applying virtual getters doc.toObject({ virtuals: true }) Example of applying both path and virtual getters doc.toObject({ getters: true }) To apply these options to every document of your schema by default, set your schemas toObject option to the same argument. schema.set('toObject', { virtuals: true }) \u8f6c\u53d8 We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional transform function. Transform functions receive three arguments function (doc, ret, options) {} doc The mongoose document which is being converted ret The plain object representation which has been converted options The options in use (either schema options or the options passed inline) \u793a\u4f8b if ( ! schema . options . toObject ) schema . options . toObject = {} ; schema . options . toObject . transform = function ( doc , ret , options ) { delete ret . _id ; return ret ; } doc . toObject () ; doc . toObject () ; With transformations we can do a lot more than remove properties. We can even return completely new customized objects: if (! schema . options . toObject ) schema . options . toObject = {} ; schema . options . toObject . transform = function ( doc , ret , options ) { return { movie : ret . name } } doc . toObject (); doc . toObject (); Note: if a transform function returns undefined , the return value will be ignored. Transformations may also be applied inline, overridding any transform set in the options: function xform ( doc , ret , options ) { return { inline : ret . name , custom : true } } doc . toObject ( { transform : xform } ); If you want to skip transformations, use transform: false : if ( ! schema . options . toObject ) schema . options . toObject = {}; schema . options . toObject . hide = '_id' ; schema . options . toObject . transform = function ( doc , ret , options ) { if ( options . hide ) { options . hide . split ( ' ' ) . forEach ( function ( prop ) { delete retprop ]; }); } return ret ; } var doc = new Doc ({ _id : 'anId' , secret : 47 , name : 'Wreck-it Ralph' }); doc . toObject (); doc . toObject ({ hide : 'secret _id' , transform : false }); doc . toObject ({ hide : 'secret _id' , transform : true }); Transforms are applied only to the document and are not applied to sub-documents . Transforms, like all of these options, are also available for toJSON . See schema options for some more details. During save, no custom options are applied to the document before being sent to the database. Document.prototype.toJSON() \u00b6 \u53c2\u6570 \u8fd4\u56de The return value of this method is used in calls to JSON.stringify(doc). This method accepts the same options as Document#toObject. To apply the options to every document of your schema by default, set your schemas toJSON option to the same argument. schema.set('toJSON', { virtuals: true }) See schema options for details. Document.prototype.inspect() \u00b6 Document.prototype.toString() \u00b6 Document.prototype.equals() \u00b6 \u53c2\u6570 doc \u00abDocument\u00bb a document to compare \u8fd4\u56de Returns true if the Document stores the same data as doc. Documents are considered equal when they have matching _id s, unless neither document has an _id , in which case this function falls back to using deepEqual() . Document.prototype.populate() \u00b6 \u53c2\u6570 callback] \u00abFunction\u00bb When passed, population is invoked \u8fd4\u56de Populates document references, executing the callback when complete. If you want to use promises instead, use this function with execPopulate() \u793a\u4f8b doc .populate ( ' company ' ) .populate ( { path: ' notes ' , match: / airline / , select: ' text ' , model: ' modelName ' options: opts }, function ( err , user ) { assert ( doc._id === user._id ) }) doc.populate ( path ) doc.populate ( options ) ; doc.populate ( path , callback ) doc.populate ( options , callback ) ; doc.populate ( callback ) ; doc.populate ( options ). execPopulate () \u6ce8\u91ca Population does not occur unless a callback is passed or you explicitly call execPopulate() . Passing the same path a second time will overwrite the previous path options. See Model.populate() for explaination of options. Document.prototype.execPopulate() \u00b6 \u8fd4\u56de \u00abPromise\u00bb promise that resolves to the document when population is done Explicitly executes population and returns a promise. Useful for ES2015 integration. \u793a\u4f8b var promise = doc . populate ( 'company' ) . populate ({ path : 'notes' , match : / airline / , select : 'text' , model : 'modelName' options : opts }) . execPopulate (); doc . execPopulate () . then ( resolve , reject ); Document.prototype.populated() \u00b6 \u53c2\u6570 \u8fd4\u56de \u00abArray,ObjectId,Number,Buffer,String,undefined\u00bb Gets _id(s) used during population of the given path . \u793a\u4f8b Model . findOne () . populate ( ' author ' ) . exec ( function ( err , doc ) { console . log ( doc . author . name ) console . log ( doc . populated ( ' author ' )) } ) If the path was not populated, undefined is returned. Document.prototype.depopulate() \u00b6 \u53c2\u6570 \u8fd4\u56de Takes a populated field and returns it to its unpopulated state. \u793a\u4f8b Model . findOne () . populate ( ' author ' ) . exec ( function ( err , doc ) { console . log ( doc . author . name ) ; console . log ( doc . depopulate ( ' author ' )) ; console . log ( doc . author ) ; } ) If the path was not populated, this is a no-op.","title":"\u6587\u6863API"},{"location":"document/api/#_1","text":"","title":"\u6587\u6863"},{"location":"document/api/#documentprototypeschema","text":"","title":"Document.prototype.schema"},{"location":"document/api/#documentprototypeisnew","text":"\u5e03\u5c14\u6807\u5fd7\u6307\u5b9a\u6587\u6863","title":"Document.prototype.isNew"},{"location":"document/api/#documentprototypeid","text":"\u8fd9\u4e2a\u6587\u4ef6\u7684\u5b57\u7b26\u4e32\u7248\u672c_id \u6ce8\u91ca \u8fd9\u4e2agetter\u9ed8\u8ba4\u5b58\u5728\u4e8e\u6240\u6709\u7684\u6587\u4ef6\u4e0a\u3002 The getter can be disabled by setting the id option of its Schema to false at construction time. new Schema ( { name : String } , { id : false } );","title":"Document.prototype.id"},{"location":"document/api/#documentprototypeerrors","text":"Hash containing current validation errors.","title":"Document.prototype.errors"},{"location":"document/api/#documentprototypeinit","text":"\u53c2\u6570 doc \u00abObject\u00bb document returned by mongo Initializes the document without setters or marking anything modified. Called internally after a document is returned from mongodb.","title":"Document.prototype.init()"},{"location":"document/api/#documentprototypeupdate","text":"\u53c2\u6570 \u8fd4\u56de Sends an update command with this document _id as the query selector. \u793a\u4f8b weirdCar . update ( { $ inc : { wheels : 1 } } , { w : 1 } , callback ); \u6709\u6548\u7684\u9009\u9879","title":"Document.prototype.update()"},{"location":"document/api/#documentprototypeset","text":"\u53c2\u6570 options] \u00abObject\u00bb optionally specify options that modify the behavior of the set Alias for set() , used internally to avoid conflicts","title":"Document.prototype.$set()"},{"location":"document/api/#documentprototypeset_1","text":"\u53c2\u6570 options] \u00abObject\u00bb optionally specify options that modify the behavior of the set Sets the value of a path, or many paths. \u793a\u4f8b doc . set ( path , value ) doc . set ( { path : value , path2 : { path : value } } ) doc . set ( path , value , Number ) doc . set ( path , value , String ) doc . set ( path , value , { strict : false } );","title":"Document.prototype.set()"},{"location":"document/api/#documentprototypeget","text":"\u53c2\u6570 type] \u00abSchema,String,Number,Buffer,*\u00bb optionally specify a type for on-the-fly attributes Returns the value of a path. \u793a\u4f8b doc.get('age') doc.get('age', String)","title":"Document.prototype.get()"},{"location":"document/api/#documentprototypemarkmodified","text":"\u53c2\u6570 scope] \u00abDocument\u00bb the scope to run validators with Marks the path as having pending changes to write to the db. Very helpful when using Mixed types. \u793a\u4f8b doc.mixed.type = 'changed'; doc.markModified('mixed.type'); doc.save()","title":"Document.prototype.markModified()"},{"location":"document/api/#documentprototypeunmarkmodified","text":"\u53c2\u6570 path \u00abString\u00bb the path to unmark modified Clears the modified state on the specified path. \u793a\u4f8b doc.foo = 'bar'; doc.unmarkModified('foo'); doc.save()","title":"Document.prototype.unmarkModified()"},{"location":"document/api/#documentprototypeignore","text":"\u53c2\u6570 path \u00abString\u00bb the path to ignore Don't run validation on this path or persist changes to this path. \u793a\u4f8b doc.foo = null; doc.$ignore('foo'); doc.save()","title":"Document.prototype.$ignore()"},{"location":"document/api/#documentprototypemodifiedpaths","text":"\u8fd4\u56de Returns the list of paths that have been modified.","title":"Document.prototype.modifiedPaths()"},{"location":"document/api/#documentprototypeismodified","text":"\u53c2\u6570 path] \u00abString\u00bb optional \u8fd4\u56de Returns true if this document was modified, else false. If path is given, checks if a path or any full path containing path as part of its path chain has been modified. \u793a\u4f8b doc.set('documents.0.title', 'changed'); doc.isModified() doc.isModified('documents') doc.isModified('documents.0.title') doc.isModified('documents otherProp') doc.isDirectModified('documents')","title":"Document.prototype.isModified()"},{"location":"document/api/#documentprototypeisdefault","text":"\u53c2\u6570 \u8fd4\u56de Checks if a path is set to its default. \u793a\u4f8b MyModel = mongoose . model ( 'test' , { name : { type : String , default : 'Val ' } }); var m = new MyModel (); m .$ isDefault ( 'name' );","title":"Document.prototype.$isDefault()"},{"location":"document/api/#documentprototypeisdeleted","text":"\u53c2\u6570 val] \u00abBoolean\u00bb optional, overrides whether mongoose thinks the doc is deleted \u8fd4\u56de \u00abBoolean\u00bb whether mongoose thinks this doc is deleted. Getter/setter, determines whether the document was removed or not. \u793a\u4f8b product.remove(function (err, product) { product.isDeleted(); product.remove(); product.isDeleted(false); product.isDeleted(); product.remove(); })","title":"Document.prototype.$isDeleted()"},{"location":"document/api/#documentprototypeisdirectmodified","text":"\u53c2\u6570 \u8fd4\u56de Returns true if path was directly set and modified, else false. \u793a\u4f8b doc.set('documents.0.title', 'changed'); doc.isDirectModified('documents.0.title') doc.isDirectModified('documents')","title":"Document.prototype.isDirectModified()"},{"location":"document/api/#documentprototypeisinit","text":"\u53c2\u6570 \u8fd4\u56de Checks if path was initialized.","title":"Document.prototype.isInit()"},{"location":"document/api/#documentprototypeisselected","text":"\u53c2\u6570 \u8fd4\u56de Checks if path was selected in the source query which initialized this document. \u793a\u4f8b Thing . findOne () . select ( ' name ' ) . exec ( function ( err , doc ) { doc . isSelected ( ' name ' ) doc . isSelected ( ' age ' ) } )","title":"Document.prototype.isSelected()"},{"location":"document/api/#documentprototypeisdirectselected","text":"\u53c2\u6570 \u8fd4\u56de Checks if path was explicitly selected. If no projection, always returns true. \u793a\u4f8b Thing . findOne () . select ( ' nested.name ' ) . exec ( function ( err , doc ) { doc . isDirectSelected ( ' nested.name ' ) doc . isDirectSelected ( ' nested.otherName ' ) doc . isDirectSelected ( ' nested ' ) } )","title":"Document.prototype.isDirectSelected()"},{"location":"document/api/#documentprototypevalidate","text":"\u53c2\u6570 callback \u00abFunction\u00bb optional callback called after validation completes, passing an error if one occurred \u8fd4\u56de Executes registered validation rules for this document. \u6ce8\u91ca This method is called pre save and if a validation rule is violated, save is aborted and the error is returned to your callback . \u793a\u4f8b doc . validate ( function ( err ) { if ( err ) handleError ( err ) ; else } ) ;","title":"Document.prototype.validate()"},{"location":"document/api/#documentprototypevalidatesync","text":"\u53c2\u6570 pathsToValidate \u00abArray,string\u00bb only validate the given paths \u8fd4\u56de \u00abMongooseError,undefined\u00bb MongooseError if there are errors during validation, or undefined if there is no error. Executes registered validation rules (skipping asynchronous validators) for this document. \u6ce8\u91ca This method is useful if you need synchronous validation. \u793a\u4f8b var err = doc . validateSync (); if ( err ){ handleError ( err ); } else { }","title":"Document.prototype.validateSync()"},{"location":"document/api/#documentprototypeinvalidate","text":"\u53c2\u6570 kind] \u00abString\u00bb optional kind property for the error \u8fd4\u56de \u00abValidationError\u00bb the current ValidationError, with all currently invalidated paths Marks a path as invalid, causing validation to fail. The errorMsg argument will become the message of the ValidationError . The value argument (if passed) will be available through the ValidationError.value property. doc.invalidate('size', 'must be less than 20', 14); doc.validate(function (err) { console.log(err) { message: 'Validation failed', name: 'ValidationError', errors: { size: { message: 'must be less than 20', name: 'ValidatorError', path: 'size', type: 'user defined', value: 14 } } } })","title":"Document.prototype.invalidate()"},{"location":"document/api/#documentprototypemarkvalid","text":"\u53c2\u6570 path \u00abString\u00bb the field to mark as valid Marks a path as valid, removing existing validation errors.","title":"Document.prototype.$markValid()"},{"location":"document/api/#documentprototypesave","text":"\u53c2\u6570 fn] \u00abFunction\u00bb optional callback \u8fd4\u56de Saves this document. \u793a\u4f8b product . sold = Date . now () ; product . save ( function ( err , product , numAffected ) { if ( err ) .. } ) The callback will receive three parameters err if an error occurred product which is the saved product numAffected will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking err is sufficient to make sure your document was properly saved. As an extra measure of flow control, save will return a Promise. \u793a\u4f8b product . save () . then ( function ( product ) { ... } ) ;","title":"Document.prototype.save()"},{"location":"document/api/#documentprototypetoobject","text":"\u53c2\u6570 \u8fd4\u56de Converts this document into a plain javascript object, ready for storage in MongoDB. Buffers are converted to instances of mongodb.Binary for proper storage. \u9009\u9879: getters apply all getters (path and virtual getters) virtuals apply virtual getters (can override getters option) minimize remove empty objects (defaults to true) transform a transform function to apply to the resulting document before returning depopulate depopulate any populated paths, replacing them with their original refs (defaults to false) versionKey whether to include the version key (defaults to true) Getters/Virtuals Example of only applying path getters doc.toObject({ getters: true, virtuals: false }) Example of only applying virtual getters doc.toObject({ virtuals: true }) Example of applying both path and virtual getters doc.toObject({ getters: true }) To apply these options to every document of your schema by default, set your schemas toObject option to the same argument. schema.set('toObject', { virtuals: true }) \u8f6c\u53d8 We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional transform function. Transform functions receive three arguments function (doc, ret, options) {} doc The mongoose document which is being converted ret The plain object representation which has been converted options The options in use (either schema options or the options passed inline) \u793a\u4f8b if ( ! schema . options . toObject ) schema . options . toObject = {} ; schema . options . toObject . transform = function ( doc , ret , options ) { delete ret . _id ; return ret ; } doc . toObject () ; doc . toObject () ; With transformations we can do a lot more than remove properties. We can even return completely new customized objects: if (! schema . options . toObject ) schema . options . toObject = {} ; schema . options . toObject . transform = function ( doc , ret , options ) { return { movie : ret . name } } doc . toObject (); doc . toObject (); Note: if a transform function returns undefined , the return value will be ignored. Transformations may also be applied inline, overridding any transform set in the options: function xform ( doc , ret , options ) { return { inline : ret . name , custom : true } } doc . toObject ( { transform : xform } ); If you want to skip transformations, use transform: false : if ( ! schema . options . toObject ) schema . options . toObject = {}; schema . options . toObject . hide = '_id' ; schema . options . toObject . transform = function ( doc , ret , options ) { if ( options . hide ) { options . hide . split ( ' ' ) . forEach ( function ( prop ) { delete retprop ]; }); } return ret ; } var doc = new Doc ({ _id : 'anId' , secret : 47 , name : 'Wreck-it Ralph' }); doc . toObject (); doc . toObject ({ hide : 'secret _id' , transform : false }); doc . toObject ({ hide : 'secret _id' , transform : true }); Transforms are applied only to the document and are not applied to sub-documents . Transforms, like all of these options, are also available for toJSON . See schema options for some more details. During save, no custom options are applied to the document before being sent to the database.","title":"Document.prototype.toObject()"},{"location":"document/api/#documentprototypetojson","text":"\u53c2\u6570 \u8fd4\u56de The return value of this method is used in calls to JSON.stringify(doc). This method accepts the same options as Document#toObject. To apply the options to every document of your schema by default, set your schemas toJSON option to the same argument. schema.set('toJSON', { virtuals: true }) See schema options for details.","title":"Document.prototype.toJSON()"},{"location":"document/api/#documentprototypeinspect","text":"","title":"Document.prototype.inspect()"},{"location":"document/api/#documentprototypetostring","text":"","title":"Document.prototype.toString()"},{"location":"document/api/#documentprototypeequals","text":"\u53c2\u6570 doc \u00abDocument\u00bb a document to compare \u8fd4\u56de Returns true if the Document stores the same data as doc. Documents are considered equal when they have matching _id s, unless neither document has an _id , in which case this function falls back to using deepEqual() .","title":"Document.prototype.equals()"},{"location":"document/api/#documentprototypepopulate","text":"\u53c2\u6570 callback] \u00abFunction\u00bb When passed, population is invoked \u8fd4\u56de Populates document references, executing the callback when complete. If you want to use promises instead, use this function with execPopulate() \u793a\u4f8b doc .populate ( ' company ' ) .populate ( { path: ' notes ' , match: / airline / , select: ' text ' , model: ' modelName ' options: opts }, function ( err , user ) { assert ( doc._id === user._id ) }) doc.populate ( path ) doc.populate ( options ) ; doc.populate ( path , callback ) doc.populate ( options , callback ) ; doc.populate ( callback ) ; doc.populate ( options ). execPopulate () \u6ce8\u91ca Population does not occur unless a callback is passed or you explicitly call execPopulate() . Passing the same path a second time will overwrite the previous path options. See Model.populate() for explaination of options.","title":"Document.prototype.populate()"},{"location":"document/api/#documentprototypeexecpopulate","text":"\u8fd4\u56de \u00abPromise\u00bb promise that resolves to the document when population is done Explicitly executes population and returns a promise. Useful for ES2015 integration. \u793a\u4f8b var promise = doc . populate ( 'company' ) . populate ({ path : 'notes' , match : / airline / , select : 'text' , model : 'modelName' options : opts }) . execPopulate (); doc . execPopulate () . then ( resolve , reject );","title":"Document.prototype.execPopulate()"},{"location":"document/api/#documentprototypepopulated","text":"\u53c2\u6570 \u8fd4\u56de \u00abArray,ObjectId,Number,Buffer,String,undefined\u00bb Gets _id(s) used during population of the given path . \u793a\u4f8b Model . findOne () . populate ( ' author ' ) . exec ( function ( err , doc ) { console . log ( doc . author . name ) console . log ( doc . populated ( ' author ' )) } ) If the path was not populated, undefined is returned.","title":"Document.prototype.populated()"},{"location":"document/api/#documentprototypedepopulate","text":"\u53c2\u6570 \u8fd4\u56de Takes a populated field and returns it to its unpopulated state. \u793a\u4f8b Model . findOne () . populate ( ' author ' ) . exec ( function ( err , doc ) { console . log ( doc . author . name ) ; console . log ( doc . depopulate ( ' author ' )) ; console . log ( doc . author ) ; } ) If the path was not populated, this is a no-op.","title":"Document.prototype.depopulate()"},{"location":"document/guide/","text":"\u6587\u6863 \u00b6 Source Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its Model . \u68c0\u7d22 \u00b6 There are many ways to retrieve documents from MongoDB. We won't cover that in this section. See the chapter on querying for detail. \u66f4\u65b0 \u00b6 There are a number of ways to update documents. We'll first look at a traditional approach using findById : Tank . findById ( id , function ( err , tank ) { if ( err ) return handleError ( err ) ; tank . size = ' large ' ; tank . save ( function ( err , updatedTank ) { if ( err ) return handleError ( err ) ; res . send ( updatedTank ) ; } ) ; } ) ; You can also use .set() to modify documents. Under the hood, tank.size = 'large'; becomes tank.set({ size: 'large' }) . Tank . findById ( id , function ( err , tank ) { if (err) return handleError(err) ; tank.set({ size : 'large' } ); tank . save ( function ( err , updatedTank ) { if (err) return handleError(err) ; res.send(updatedTank) ; } ); } ); This approach involves first retrieving the document from Mongo, then issuing an update command (triggered by calling save ). However, if we don't need the document returned in our application and merely want to update a property in the database directly, Model#update is right for us: Tank . update ( { _id : id } , { $ set : { size : 'large' } } , callback ); If we do need the document returned in our application there is another, often better , option: Tank . findByIdAndUpdate ( id , { $ set : { size : 'large' } } , { new : true } , function ( err , tank ) { if (err) return handleError(err) ; res.send(tank) ; } ); The findAndUpdate/Remove static methods all make a change to at most one document, and return it with just one call to the database. There are several variations on the findAndModify theme. Read the API docs for more detail. Note that findAndUpdate/Remove do _not execute any hooks or validation before making the change in the database. You can use the runValidators option to access a limited subset of document validation. However, if you need hooks and full document validation, first query for the document and then save() it._ \u8bc1\u5b9e \u00b6 Documents are validated before they are saved. Read the api docs or the validation chapter for detail. \u8986\u76d6 \u00b6 You can overwrite an entire document using .set() . This is handy if you want to change what document is being saved in middleware . Tank . findById ( id , function ( err , tank ) { if ( err ) return handleError ( err ) ; otherTank . set ( tank ) ; } ) ; \u4e0b\u4e00\u4e2a \u00b6 Now that we've covered Documents, let's take a look at Sub-documents .","title":"\u6587\u6863\u624b\u518c"},{"location":"document/guide/#_1","text":"Source Mongoose documents represent a one-to-one mapping to documents as stored in MongoDB. Each document is an instance of its Model .","title":"\u6587\u6863"},{"location":"document/guide/#_2","text":"There are many ways to retrieve documents from MongoDB. We won't cover that in this section. See the chapter on querying for detail.","title":"\u68c0\u7d22"},{"location":"document/guide/#_3","text":"There are a number of ways to update documents. We'll first look at a traditional approach using findById : Tank . findById ( id , function ( err , tank ) { if ( err ) return handleError ( err ) ; tank . size = ' large ' ; tank . save ( function ( err , updatedTank ) { if ( err ) return handleError ( err ) ; res . send ( updatedTank ) ; } ) ; } ) ; You can also use .set() to modify documents. Under the hood, tank.size = 'large'; becomes tank.set({ size: 'large' }) . Tank . findById ( id , function ( err , tank ) { if (err) return handleError(err) ; tank.set({ size : 'large' } ); tank . save ( function ( err , updatedTank ) { if (err) return handleError(err) ; res.send(updatedTank) ; } ); } ); This approach involves first retrieving the document from Mongo, then issuing an update command (triggered by calling save ). However, if we don't need the document returned in our application and merely want to update a property in the database directly, Model#update is right for us: Tank . update ( { _id : id } , { $ set : { size : 'large' } } , callback ); If we do need the document returned in our application there is another, often better , option: Tank . findByIdAndUpdate ( id , { $ set : { size : 'large' } } , { new : true } , function ( err , tank ) { if (err) return handleError(err) ; res.send(tank) ; } ); The findAndUpdate/Remove static methods all make a change to at most one document, and return it with just one call to the database. There are several variations on the findAndModify theme. Read the API docs for more detail. Note that findAndUpdate/Remove do _not execute any hooks or validation before making the change in the database. You can use the runValidators option to access a limited subset of document validation. However, if you need hooks and full document validation, first query for the document and then save() it._","title":"\u66f4\u65b0"},{"location":"document/guide/#_4","text":"Documents are validated before they are saved. Read the api docs or the validation chapter for detail.","title":"\u8bc1\u5b9e"},{"location":"document/guide/#_5","text":"You can overwrite an entire document using .set() . This is handy if you want to change what document is being saved in middleware . Tank . findById ( id , function ( err , tank ) { if ( err ) return handleError ( err ) ; otherTank . set ( tank ) ; } ) ;","title":"\u8986\u76d6"},{"location":"document/guide/#_6","text":"Now that we've covered Documents, let's take a look at Sub-documents .","title":"\u4e0b\u4e00\u4e2a"},{"location":"document/subdocs/","text":"Subdocuments are documents embedded in other documents. In Mongoose, this means you can nest schemas in other schemas. Mongoose has two distinct notions of subdocuments: arrays of subdocuments and single nested subdocuments. JavaScript const childSchema = new Schema ({ name : \"string\" }); const parentSchema = new Schema ({ // Array of subdocuments children : [ childSchema ], // Single nested subdocuments. Caveat: single nested subdocs only work // in mongoose >= 4.2.0 child : childSchema , }); Aside from code reuse, one important reason to use subdocuments is to create a path where there would otherwise not be one to allow for validation over a group of fields (e.g. dateRange.fromDate <= dateRange.toDate). What is a Subdocument? Subdocuments versus Nested Paths Subdocument Defaults Finding a Subdocument Adding Subdocs to Arrays Removing Subdocs Parents of Subdocs Alternate declaration syntax for arrays Alternate declaration syntax for single subdocuments \u4ec0\u4e48\u662f\u5b50\u6587\u6863? \u00b6 Subdocuments are similar to normal documents. Nested schemas can have middleware , custom validation logic , virtuals, and any other feature top-level schemas can use. The major difference is that subdocuments are not saved individually, they are saved whenever their top-level parent document is saved. JavaScript const Parent = mongoose . model ( \"Parent\" , parentSchema ); const parent = new Parent ({ children : [{ name : \"Matt\" }, { name : \"Sarah\" }] }); parent . children [ 0 ]. name = \"Matthew\" ; // `parent.children[0].save()` is a no-op, it triggers middleware but // does **not** actually save the subdocument. You need to save the parent // doc. parent . save ( callback ); Subdocuments have save and validate middleware just like top-level documents. Calling save() on the parent document triggers the save() middleware for all its subdocuments, and the same for validate() middleware. JavaScript childSchema . pre ( \"save\" , function ( next ) { if ( \"invalid\" == this . name ) { return next ( new Error ( \"#sadpanda\" )); } next (); }); const parent = new Parent ({ children : [{ name : \"invalid\" }] }); parent . save ( function ( err ) { console . log ( err . message ); // #sadpanda }); Subdocuments' pre('save') and pre('validate') middleware execute before the top-level document's pre('save') but after the top-level document's pre('validate') middleware. This is because validating before save() is actually a piece of built-in middleware. JavaScript // Below code will print out 1-4 in order const childSchema = new mongoose . Schema ({ name : \"string\" }); childSchema . pre ( \"validate\" , function ( next ) { console . log ( \"2\" ); next (); }); childSchema . pre ( \"save\" , function ( next ) { console . log ( \"3\" ); next (); }); const parentSchema = new mongoose . Schema ({ child : childSchema , }); parentSchema . pre ( \"validate\" , function ( next ) { console . log ( \"1\" ); next (); }); parentSchema . pre ( \"save\" , function ( next ) { console . log ( \"4\" ); next (); }); \u5b50\u6587\u6863\u4e0e\u5d4c\u5957\u8def\u5f84 \u00b6 \u5728 Mongoose \u4e2d\uff0c\u5d4c\u5957\u8def\u5f84\u4e0e\u5b50\u6587\u6863\u7565\u6709\u4e0d\u540c\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u662f\u4e24\u4e2a\u6a21\u5f0f:\u4e00\u4e2a\u662f\u5c06 child \u4f5c\u4e3a\u5b50\u6587\u6863\uff0c\u53e6\u4e00\u4e2a\u662f\u5c06 child \u4f5c\u4e3a\u5d4c\u5957\u8def\u5f84\u3002 JavaScript // \u5b50\u6587\u6863 const subdocumentSchema = new mongoose . Schema ({ child : new mongoose . Schema ({ name : String , age : Number }), }); const Subdoc = mongoose . model ( \"Subdoc\" , subdocumentSchema ); // \u5d4c\u5957\u8def\u5f84 const nestedSchema = new mongoose . Schema ({ child : { name : String , age : Number }, }); const Nested = mongoose . model ( \"Nested\" , nestedSchema ); \u8fd9\u4e24\u4e2a\u6a21\u5f0f\u770b\u8d77\u6765\u5f88\u76f8\u4f3c\uff0cMongoDB \u4e2d\u7684\u6587\u6863\u5c06\u5177\u6709\u4e0e\u8fd9\u4e24\u4e2a\u6a21\u5f0f\u76f8\u540c\u7684\u7ed3\u6784\u3002 \u4f46 Mongoose \u4e5f\u6709\u4e00\u4e9b\u7279\u5b9a\u7684\u5dee\u5f02: \u9996\u5148\uff0c Nested \u7684\u5b9e\u4f8b\u4ece\u6765\u6ca1\u6709 child === undefined \u3002 \u4f60\u603b\u662f\u53ef\u4ee5\u8bbe\u7f6e child \u7684\u5b50\u5c5e\u6027\uff0c\u5373\u4f7f\u4f60\u6ca1\u6709\u8bbe\u7f6e child \u5c5e\u6027\u3002 \u4f46 Subdoc \u7684\u5b9e\u4f8b\u53ef\u4ee5\u6709 child === undefined \u3002 JavaScript const doc1 = new Subdoc ({}); doc1 . child === undefined ; // true doc1 . child . name = \"test\" ; // Throws TypeError: cannot read property... const doc2 = new Nested ({}); doc2 . child === undefined ; // false console . log ( doc2 . child ); // Prints 'MongooseDocument { undefined }' doc2 . child . name = \"test\" ; // Works \u5b50\u6587\u6863\u7684\u9ed8\u8ba4 \u00b6 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5b50\u6587\u6863\u8def\u5f84\u662f\u672a\u5b9a\u4e49\u7684\uff0c\u9664\u975e\u60a8\u5c06\u5b50\u6587\u6863\u8def\u5f84\u8bbe\u7f6e\u4e3a\u975e\u7a7a\u503c\uff0c\u5426\u5219 Mongoose \u4e0d\u4f1a\u5e94\u7528\u5b50\u6587\u6863\u9ed8\u8ba4\u503c\u3002 JavaScript const subdocumentSchema = new mongoose . Schema ({ child : new mongoose . Schema ({ name : String , age : { type : Number , default : 0 , }, }), }); const Subdoc = mongoose . model ( \"Subdoc\" , subdocumentSchema ); // \u6ce8\u610f' age '\u9ed8\u8ba4\u503c\u6ca1\u6709\u5f71\u54cd\uff0c\u56e0\u4e3a' child '\u662f' undefined '\u3002 const doc = new Subdoc (); doc . child ; // undefined \u7136\u800c\uff0c\u5982\u679c\u4f60\u5c06 doc.child \u8bbe\u7f6e\u4e3a\u4efb\u4f55\u5bf9\u8c61\uff0cMongoose \u5c06\u5728\u5fc5\u8981\u65f6\u5e94\u7528 age \u9ed8\u8ba4\u503c\u3002 JavaScript doc . child = {}; // Mongoose\u5e94\u7528\u9ed8\u8ba4\u7684`age` : doc . child . age ; // 0 Mongoose \u9012\u5f52\u5730\u5e94\u7528\u9ed8\u8ba4\u503c\uff0c\u8fd9\u610f\u5473\u7740\u5982\u679c\u60a8\u60f3\u786e\u4fdd Mongoose \u5e94\u7528\u5b50\u6587\u6863\u9ed8\u8ba4\u503c\uff0c\u6709\u4e00\u4e2a\u5f88\u597d\u7684\u89e3\u51b3\u65b9\u6848:\u5c06\u5b50\u6587\u6863\u8def\u5f84\u8bbe\u7f6e\u4e3a\u7a7a\u5bf9\u8c61\u7684\u9ed8\u8ba4\u503c\u3002 JavaScript const childSchema = new mongoose . Schema ({ name : String , age : { type : Number , default : 0 , }, }); const subdocumentSchema = new mongoose . Schema ({ child : { type : childSchema , default : () => ({}), }, }); const Subdoc = mongoose . model ( \"Subdoc\" , subdocumentSchema ); // \u8bf7\u6ce8\u610f\uff0cMongoose\u5c06 `age` \u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u503c0\uff0c\u56e0\u4e3a `child` \u9ed8\u8ba4\u4e3a\u7a7a\u5bf9\u8c61\uff0c\u800cMongoose\u5c06\u9ed8\u8ba4\u503c\u5e94\u7528\u4e8e\u8be5\u7a7a\u5bf9\u8c61\u3002 const doc = new Subdoc (); doc . child ; // { age: 0 } \u627e\u5230\u4e00\u4e2a\u5b50\u6587\u6863 \u00b6 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e2a\u5b50\u6587\u6863\u90fd\u6709\u4e00\u4e2a _id \u3002 Mongoose \u6587\u6863\u6570\u7ec4\u6709\u4e00\u4e2a\u7279\u6b8a\u7684 id \u65b9\u6cd5\u6765\u641c\u7d22\u6587\u6863\u6570\u7ec4\uff0c\u4ee5\u627e\u5230\u4e00\u4e2a\u7ed9\u5b9a\u7684 _id \u6587\u6863\u3002 JavaScript const doc = parent . children . id ( _id ); \u5411\u6570\u7ec4\u6dfb\u52a0\u5b50\u6587\u6863 \u00b6 MongooseArray \u65b9\u6cd5\uff0c\u5982 push \uff0c unshift \uff0c addToSet \uff0c \u4ee5\u53ca\u5176\u4ed6\u4e00\u4e9b\u65b9\u6cd5\u900f\u660e\u5730\u5c06\u53c2\u6570\u8f6c\u6362\u4e3a\u6b63\u786e\u7684\u7c7b\u578b: JavaScript const Parent = mongoose . model ( \"Parent\" ); const parent = new Parent (); // \u521b\u5efa\u4e00\u4e2a\u8bc4\u8bba parent . children . push ({ name : \"Liesl\" }); const subdoc = parent . children [ 0 ]; console . log ( subdoc ); // { _id: '501d86090d371bab2c0341c5', name: 'Liesl' } subdoc . isNew ; // true parent . save ( function ( err ) { if ( err ) return handleError ( err ); console . log ( \"Success!\" ); }); \u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528 Document Arrays \u7684 create() method \u521b\u5efa\u5b50\u6587\u6863\uff0c\u800c\u4e0d\u5c06\u5176\u6dfb\u52a0\u5230\u6570\u7ec4\u4e2d\u3002 JavaScript const newdoc = parent . children . create ({ name : \"Aaron\" }); \u5220\u9664\u5b50\u6587\u6863 \u00b6 \u6bcf\u4e2a\u5b50\u6587\u6863\u90fd\u6709\u81ea\u5df1\u7684 remove \u65b9\u6cd5\u3002 \u5bf9\u4e8e\u6570\u7ec4\u5b50\u6587\u6863\uff0c\u8fd9\u76f8\u5f53\u4e8e\u5728\u5b50\u6587\u6863\u4e0a\u8c03\u7528 .pull() \u3002 \u5bf9\u4e8e\u5355\u4e2a\u5d4c\u5957\u5b50\u6587\u6863\uff0c remove() \u76f8\u5f53\u4e8e\u5c06\u5b50\u6587\u6863\u8bbe\u7f6e\u4e3a null \u3002 JavaScript // \u76f8\u5f53\u4e8e `parent.children.pull(_id)` parent . children . id ( _id ). remove (); // \u76f8\u5f53\u4e8e `parent.child = null` parent . child . remove (); parent . save ( function ( err ) { if ( err ) return handleError ( err ); console . log ( \"the subdocs were removed\" ); }); \u5b50\u6587\u6863\u7236 \u6709\u65f6\uff0c\u60a8\u9700\u8981\u83b7\u53d6\u5b50\u6587\u6863\u7684\u7236\u6587\u6863\u3002 \u4f60\u53ef\u4ee5\u4f7f\u7528 parent() \u51fd\u6570\u6765\u8bbf\u95ee\u7236\u7c7b\u3002 JavaScript const schema = new Schema ({ docArr : [{ name : String }], singleNested : new Schema ({ name : String }), }); const Model = mongoose . model ( \"Test\" , schema ); const doc = new Model ({ docArr : [{ name : \"foo\" }], singleNested : { name : \"bar\" }, }); doc . singleNested . parent () === doc ; // true doc . docArr [ 0 ]. parent () === doc ; // true \u5982\u679c\u4f60\u6709\u4e00\u4e2a\u6df1\u5ea6\u5d4c\u5957\u7684\u5b50\u6587\u6863\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 ownerDocument() \u51fd\u6570\u8bbf\u95ee\u9876\u7ea7\u6587\u6863\u3002 JavaScript const schema = new Schema ({ level1 : new Schema ({ level2 : new Schema ({ test : String , }), }), }); const Model = mongoose . model ( \"Test\" , schema ); const doc = new Model ({ level1 : { level2 : \"test\" } }); doc . level1 . level2 . parent () === doc ; // false doc . level1 . level2 . parent () === doc . level1 ; // true doc . level1 . level2 . ownerDocument () === doc ; // true \u6570\u7ec4\u7684\u66ff\u4ee3\u58f0\u660e\u8bed\u6cd5 \u5982\u679c\u4f60\u521b\u5efa\u4e86\u4e00\u4e2a\u5305\u542b\u5bf9\u8c61\u6570\u7ec4\u7684\u6a21\u5f0f\uff0cMongoose \u4f1a\u81ea\u52a8\u5c06\u8be5\u5bf9\u8c61\u8f6c\u6362\u4e3a\u4e00\u4e2a\u6a21\u5f0f: JavaScript const parentSchema = new Schema ({ children : [{ name : \"string\" }], }); // \u7b49\u6548 const parentSchema = new Schema ({ children : [ new Schema ({ name : \"string\" })], }); \u5355\u5d4c\u5957\u5b50\u6587\u6863\u7684\u53ef\u9009\u58f0\u660e\u8bed\u6cd5 \u4e0e\u6587\u6863\u6570\u7ec4\u4e0d\u540c\uff0cMongoose 5 \u4e0d\u4f1a\u5c06\u6a21\u5f0f\u4e2d\u7684\u5bf9\u8c61\u8f6c\u6362\u4e3a\u5d4c\u5957\u6a21\u5f0f\u3002 \u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c nested \u662f\u4e00\u4e2a nested path \u800c\u4e0d\u662f\u5b50\u6587\u6863\u3002 JavaScript const schema = new Schema ({ nested : { prop : String , }, }); \u5f53\u60a8\u8bd5\u56fe\u7528\u9a8c\u8bc1\u5668\u6216 getter/setter \u5b9a\u4e49\u5d4c\u5957\u8def\u5f84\u65f6\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u4e00\u4e9b\u4ee4\u4eba\u60ca\u8bb6\u7684\u884c\u4e3a\u3002 JavaScript const schema = new Schema ({ nested : { // \u4e0d\u8981\u8fd9\u6837\u505a!\u8fd9\u4f7f\u5f97\u201c\u5d4c\u5957\u201d\u5728Mongoose 5\u4e2d\u6210\u4e3a\u4e00\u4e2a\u6df7\u5408\u8def\u5f84 type : { prop : String }, required : true , }, }); const schema = new Schema ({ nested : { // \u8fd9\u662f\u6b63\u786e\u7684 type : new Schema ({ prop : String }), required : true , }, }); \u63a5\u4e0b\u6765 \u00b6 \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5b50\u6587\u6863\uff0c\u8ba9\u6211\u4eec\u770b\u770b \u67e5\u8be2 .","title":"\u5b50\u6587\u6863"},{"location":"document/subdocs/#_1","text":"Subdocuments are similar to normal documents. Nested schemas can have middleware , custom validation logic , virtuals, and any other feature top-level schemas can use. The major difference is that subdocuments are not saved individually, they are saved whenever their top-level parent document is saved. JavaScript const Parent = mongoose . model ( \"Parent\" , parentSchema ); const parent = new Parent ({ children : [{ name : \"Matt\" }, { name : \"Sarah\" }] }); parent . children [ 0 ]. name = \"Matthew\" ; // `parent.children[0].save()` is a no-op, it triggers middleware but // does **not** actually save the subdocument. You need to save the parent // doc. parent . save ( callback ); Subdocuments have save and validate middleware just like top-level documents. Calling save() on the parent document triggers the save() middleware for all its subdocuments, and the same for validate() middleware. JavaScript childSchema . pre ( \"save\" , function ( next ) { if ( \"invalid\" == this . name ) { return next ( new Error ( \"#sadpanda\" )); } next (); }); const parent = new Parent ({ children : [{ name : \"invalid\" }] }); parent . save ( function ( err ) { console . log ( err . message ); // #sadpanda }); Subdocuments' pre('save') and pre('validate') middleware execute before the top-level document's pre('save') but after the top-level document's pre('validate') middleware. This is because validating before save() is actually a piece of built-in middleware. JavaScript // Below code will print out 1-4 in order const childSchema = new mongoose . Schema ({ name : \"string\" }); childSchema . pre ( \"validate\" , function ( next ) { console . log ( \"2\" ); next (); }); childSchema . pre ( \"save\" , function ( next ) { console . log ( \"3\" ); next (); }); const parentSchema = new mongoose . Schema ({ child : childSchema , }); parentSchema . pre ( \"validate\" , function ( next ) { console . log ( \"1\" ); next (); }); parentSchema . pre ( \"save\" , function ( next ) { console . log ( \"4\" ); next (); });","title":"\u4ec0\u4e48\u662f\u5b50\u6587\u6863?"},{"location":"document/subdocs/#_2","text":"\u5728 Mongoose \u4e2d\uff0c\u5d4c\u5957\u8def\u5f84\u4e0e\u5b50\u6587\u6863\u7565\u6709\u4e0d\u540c\u3002 \u4f8b\u5982\uff0c\u4e0b\u9762\u662f\u4e24\u4e2a\u6a21\u5f0f:\u4e00\u4e2a\u662f\u5c06 child \u4f5c\u4e3a\u5b50\u6587\u6863\uff0c\u53e6\u4e00\u4e2a\u662f\u5c06 child \u4f5c\u4e3a\u5d4c\u5957\u8def\u5f84\u3002 JavaScript // \u5b50\u6587\u6863 const subdocumentSchema = new mongoose . Schema ({ child : new mongoose . Schema ({ name : String , age : Number }), }); const Subdoc = mongoose . model ( \"Subdoc\" , subdocumentSchema ); // \u5d4c\u5957\u8def\u5f84 const nestedSchema = new mongoose . Schema ({ child : { name : String , age : Number }, }); const Nested = mongoose . model ( \"Nested\" , nestedSchema ); \u8fd9\u4e24\u4e2a\u6a21\u5f0f\u770b\u8d77\u6765\u5f88\u76f8\u4f3c\uff0cMongoDB \u4e2d\u7684\u6587\u6863\u5c06\u5177\u6709\u4e0e\u8fd9\u4e24\u4e2a\u6a21\u5f0f\u76f8\u540c\u7684\u7ed3\u6784\u3002 \u4f46 Mongoose \u4e5f\u6709\u4e00\u4e9b\u7279\u5b9a\u7684\u5dee\u5f02: \u9996\u5148\uff0c Nested \u7684\u5b9e\u4f8b\u4ece\u6765\u6ca1\u6709 child === undefined \u3002 \u4f60\u603b\u662f\u53ef\u4ee5\u8bbe\u7f6e child \u7684\u5b50\u5c5e\u6027\uff0c\u5373\u4f7f\u4f60\u6ca1\u6709\u8bbe\u7f6e child \u5c5e\u6027\u3002 \u4f46 Subdoc \u7684\u5b9e\u4f8b\u53ef\u4ee5\u6709 child === undefined \u3002 JavaScript const doc1 = new Subdoc ({}); doc1 . child === undefined ; // true doc1 . child . name = \"test\" ; // Throws TypeError: cannot read property... const doc2 = new Nested ({}); doc2 . child === undefined ; // false console . log ( doc2 . child ); // Prints 'MongooseDocument { undefined }' doc2 . child . name = \"test\" ; // Works","title":"\u5b50\u6587\u6863\u4e0e\u5d4c\u5957\u8def\u5f84"},{"location":"document/subdocs/#_3","text":"\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5b50\u6587\u6863\u8def\u5f84\u662f\u672a\u5b9a\u4e49\u7684\uff0c\u9664\u975e\u60a8\u5c06\u5b50\u6587\u6863\u8def\u5f84\u8bbe\u7f6e\u4e3a\u975e\u7a7a\u503c\uff0c\u5426\u5219 Mongoose \u4e0d\u4f1a\u5e94\u7528\u5b50\u6587\u6863\u9ed8\u8ba4\u503c\u3002 JavaScript const subdocumentSchema = new mongoose . Schema ({ child : new mongoose . Schema ({ name : String , age : { type : Number , default : 0 , }, }), }); const Subdoc = mongoose . model ( \"Subdoc\" , subdocumentSchema ); // \u6ce8\u610f' age '\u9ed8\u8ba4\u503c\u6ca1\u6709\u5f71\u54cd\uff0c\u56e0\u4e3a' child '\u662f' undefined '\u3002 const doc = new Subdoc (); doc . child ; // undefined \u7136\u800c\uff0c\u5982\u679c\u4f60\u5c06 doc.child \u8bbe\u7f6e\u4e3a\u4efb\u4f55\u5bf9\u8c61\uff0cMongoose \u5c06\u5728\u5fc5\u8981\u65f6\u5e94\u7528 age \u9ed8\u8ba4\u503c\u3002 JavaScript doc . child = {}; // Mongoose\u5e94\u7528\u9ed8\u8ba4\u7684`age` : doc . child . age ; // 0 Mongoose \u9012\u5f52\u5730\u5e94\u7528\u9ed8\u8ba4\u503c\uff0c\u8fd9\u610f\u5473\u7740\u5982\u679c\u60a8\u60f3\u786e\u4fdd Mongoose \u5e94\u7528\u5b50\u6587\u6863\u9ed8\u8ba4\u503c\uff0c\u6709\u4e00\u4e2a\u5f88\u597d\u7684\u89e3\u51b3\u65b9\u6848:\u5c06\u5b50\u6587\u6863\u8def\u5f84\u8bbe\u7f6e\u4e3a\u7a7a\u5bf9\u8c61\u7684\u9ed8\u8ba4\u503c\u3002 JavaScript const childSchema = new mongoose . Schema ({ name : String , age : { type : Number , default : 0 , }, }); const subdocumentSchema = new mongoose . Schema ({ child : { type : childSchema , default : () => ({}), }, }); const Subdoc = mongoose . model ( \"Subdoc\" , subdocumentSchema ); // \u8bf7\u6ce8\u610f\uff0cMongoose\u5c06 `age` \u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u503c0\uff0c\u56e0\u4e3a `child` \u9ed8\u8ba4\u4e3a\u7a7a\u5bf9\u8c61\uff0c\u800cMongoose\u5c06\u9ed8\u8ba4\u503c\u5e94\u7528\u4e8e\u8be5\u7a7a\u5bf9\u8c61\u3002 const doc = new Subdoc (); doc . child ; // { age: 0 }","title":"\u5b50\u6587\u6863\u7684\u9ed8\u8ba4"},{"location":"document/subdocs/#_4","text":"\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e2a\u5b50\u6587\u6863\u90fd\u6709\u4e00\u4e2a _id \u3002 Mongoose \u6587\u6863\u6570\u7ec4\u6709\u4e00\u4e2a\u7279\u6b8a\u7684 id \u65b9\u6cd5\u6765\u641c\u7d22\u6587\u6863\u6570\u7ec4\uff0c\u4ee5\u627e\u5230\u4e00\u4e2a\u7ed9\u5b9a\u7684 _id \u6587\u6863\u3002 JavaScript const doc = parent . children . id ( _id );","title":"\u627e\u5230\u4e00\u4e2a\u5b50\u6587\u6863"},{"location":"document/subdocs/#_5","text":"MongooseArray \u65b9\u6cd5\uff0c\u5982 push \uff0c unshift \uff0c addToSet \uff0c \u4ee5\u53ca\u5176\u4ed6\u4e00\u4e9b\u65b9\u6cd5\u900f\u660e\u5730\u5c06\u53c2\u6570\u8f6c\u6362\u4e3a\u6b63\u786e\u7684\u7c7b\u578b: JavaScript const Parent = mongoose . model ( \"Parent\" ); const parent = new Parent (); // \u521b\u5efa\u4e00\u4e2a\u8bc4\u8bba parent . children . push ({ name : \"Liesl\" }); const subdoc = parent . children [ 0 ]; console . log ( subdoc ); // { _id: '501d86090d371bab2c0341c5', name: 'Liesl' } subdoc . isNew ; // true parent . save ( function ( err ) { if ( err ) return handleError ( err ); console . log ( \"Success!\" ); }); \u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528 Document Arrays \u7684 create() method \u521b\u5efa\u5b50\u6587\u6863\uff0c\u800c\u4e0d\u5c06\u5176\u6dfb\u52a0\u5230\u6570\u7ec4\u4e2d\u3002 JavaScript const newdoc = parent . children . create ({ name : \"Aaron\" });","title":"\u5411\u6570\u7ec4\u6dfb\u52a0\u5b50\u6587\u6863"},{"location":"document/subdocs/#_6","text":"\u6bcf\u4e2a\u5b50\u6587\u6863\u90fd\u6709\u81ea\u5df1\u7684 remove \u65b9\u6cd5\u3002 \u5bf9\u4e8e\u6570\u7ec4\u5b50\u6587\u6863\uff0c\u8fd9\u76f8\u5f53\u4e8e\u5728\u5b50\u6587\u6863\u4e0a\u8c03\u7528 .pull() \u3002 \u5bf9\u4e8e\u5355\u4e2a\u5d4c\u5957\u5b50\u6587\u6863\uff0c remove() \u76f8\u5f53\u4e8e\u5c06\u5b50\u6587\u6863\u8bbe\u7f6e\u4e3a null \u3002 JavaScript // \u76f8\u5f53\u4e8e `parent.children.pull(_id)` parent . children . id ( _id ). remove (); // \u76f8\u5f53\u4e8e `parent.child = null` parent . child . remove (); parent . save ( function ( err ) { if ( err ) return handleError ( err ); console . log ( \"the subdocs were removed\" ); });","title":"\u5220\u9664\u5b50\u6587\u6863"},{"location":"document/subdocs/#_7","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u8ba8\u8bba\u4e86\u5b50\u6587\u6863\uff0c\u8ba9\u6211\u4eec\u770b\u770b \u67e5\u8be2 .","title":"\u63a5\u4e0b\u6765"},{"location":"guide/Discriminators/","text":"\u9274\u522b\u5668 \u00b6 \u8d44\u6e90 \u9274\u522b\u5668\u662f\u4e00\u4e2a\u6a21\u5f0f\u7ee7\u627f\u673a\u5236\u3002 \u5b83\u4eec\u4f7f\u60a8\u80fd\u591f\u5728\u76f8\u540c\u7684\u57fa\u7840MongoDB\u96c6\u5408\u4e4b\u4e0a\u62e5\u6709\u591a\u4e2a\u5177\u6709\u91cd\u53e0\u6a21\u5f0f\u7684\u6a21\u578b\u3002 \u5047\u8bbe\u60a8\u60f3\u8981\u5728\u5355\u4e2a\u96c6\u5408\u4e2d\u8ddf\u8e2a\u4e0d\u540c\u7c7b\u578b\u7684\u4e8b\u4ef6\u3002 \u6bcf\u4e2a\u4e8b\u4ef6\u90fd\u4f1a\u6709\u4e00\u4e2a\u65f6\u95f4\u6233\uff0c\u4f46\u4ee3\u8868\u70b9\u51fb\u94fe\u63a5\u200b\u200b\u7684\u4e8b\u4ef6\u5e94\u8be5\u6709\u4e00\u4e2aURL\u3002 \u4f60\u53ef\u4ee5\u4f7f\u7528 model.discriminator\uff08\uff09 \u51fd\u6570\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u3002 \u8be5\u529f\u80fd\u9700\u89812\u4e2a\u53c2\u6570\uff0c \u4e00\u4e2a\u6a21\u578b\u540d\u79f0\u548c\u4e00\u4e2a\u9274\u522b\u5668\u6a21\u5f0f \u5b83\u8fd4\u56de\u4e00\u4e2a\u6a21\u5f0f\uff0c\u5176\u6a21\u5f0f\u662f\u57fa\u672c\u6a21\u5f0f\u548c\u9274\u522b\u5668\u6a21\u5f0f\u7684\u8054\u5408\u3002 JavaScript var options = { discriminatorKey : 'kind' }; var eventSchema = new mongoose . Schema ({ time : Date }, options ); var Event = mongoose . model ( 'Event' , eventSchema ); var ClickedLinkEvent = Event . discriminator ( 'ClickedLink' , new mongoose . Schema ({ url : String }, options )); var genericEvent = new Event ({ time : Date . now (), url : 'google.com' }); assert . ok ( ! genericEvent . url ); var clickedEvent = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); assert . ok ( clickedEvent . url ); \u5047\u8bbe\u60a8\u521b\u5efa\u4e86\u53e6\u4e00\u4e2a\u9274\u522b\u5668\u6765\u8ddf\u8e2a\u65b0\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002\u8fd9\u4e9b SignedUpEvent \u5b9e\u4f8b\u5c06\u88ab\u5b58\u50a8\u5728\u4e0e\u901a\u7528\u4e8b\u4ef6\u548c ClickedLinkEvent \u5b9e\u4f8b\u76f8\u540c\u7684\u96c6\u5408\u4e2d\u3002 JavaScript var event1 = new Event ({ time : Date . now ()}); var event2 = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); var event3 = new SignedUpEvent ({ time : Date . now (), user : 'testuser' }); var save = function ( doc , callback ) { doc . save ( function ( error , doc ) { callback ( error , doc ); }); }; async . map ([ event1 , event2 , event3 ], save , function ( error ) { Event . count ({}, function ( error , count ) { assert . equal ( count , 3 ); }); }); \u732b\u9f2c\u7684\u65b9\u5f0f\u544a\u8bc9\u4e0d\u540c\u7684\u9274\u522b\u5668\u6a21\u578b\u4e4b\u95f4\u7684\u5dee\u5f02\u662f\u7531\u201c\u9274\u522b\u94a5\u5319\u201d, \u9ed8\u8ba4\u662f __t \u3002 ,Mongoose\u5c06\u4e00\u4e2a\u540d\u4e3a __t \u7684String\u8def\u5f84\u6dfb\u52a0\u5230\u60a8\u7684\u6a21\u5f0f\u4e2d\uff0c\u7528\u4e8e\u8ddf\u8e2a\u8be5\u6587\u6863\u662f\u54ea\u4e2a\u9274\u522b\u5668\u7684\u5b9e\u4f8b\u3002 JavaScript var event1 = new Event ({ time : Date . now ()}); var event2 = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); var event3 = new SignedUpEvent ({ time : Date . now (), user : 'testuser' }); assert . ok ( ! event1 . __t ); assert . equal ( event2 . __t , 'ClickedLink' ); assert . equal ( event3 . __t , 'SignedUp' ); \u8fa8\u522b\u5668\u6a21\u578b\u662f\u7279\u6b8a\u7684;\u4ed6\u4eec\u5c06\u9274\u522b\u952e\u9644\u52a0\u5230\u67e5\u8be2\u3002 \u6362\u4e00\u79cd\u8bf4\u6cd5\uff0c find() , count() , aggregate() , \u7b49\u7b49\u90fd\u8db3\u591f\u806a\u660e\u6765\u89e3\u91ca\u9274\u522b\u8005\u3002 JavaScript var event1 = new Event ({ time : Date . now ()}); var event2 = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); var event3 = new SignedUpEvent ({ time : Date . now (), user : 'testuser' }); var save = function ( doc , callback ) { doc . save ( function ( error , doc ) { callback ( error , doc ); }); }; async . map ([ event1 , event2 , event3 ], save , function ( error ) { ClickedLinkEvent . find ({}, function ( error , docs ) { assert . equal ( docs . length , 1 ); assert . equal ( docs [ 0 ]. _id . toString (), event2 . _id . toString ()); assert . equal ( docs [ 0 ]. url , 'google.com' ); }); }); \u9274\u522b\u8005\u4e5f\u91c7\u53d6\u4ed6\u4eec\u7684\u57fa\u672c\u6a21\u5f0f\u7684\u524d\u540e\u4e2d\u95f4\u4ef6\u3002 \u4f46\u662f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u5c06\u4e2d\u95f4\u4ef6\u9644\u52a0\u5230\u9274\u522b\u5668\u6a21\u5f0f\uff0c\u800c\u4e0d\u4f1a\u5f71\u54cd\u57fa\u672c\u6a21\u5f0f\u3002 JavaScript var options = { discriminatorKey : 'kind' }; var eventSchema = new mongoose . Schema ({ time : Date }, options ); var eventSchemaCalls = 0 ; eventSchema . pre ( 'validate' , function ( next ) { ++ eventSchemaCalls ; next (); }); var Event = mongoose . model ( 'GenericEvent' , eventSchema ); var clickedLinkSchema = new mongoose . Schema ({ url : String }, options ); var clickedSchemaCalls = 0 ; clickedLinkSchema . pre ( 'validate' , function ( next ) { ++ clickedSchemaCalls ; next (); }); var ClickedLinkEvent = Event . discriminator ( 'ClickedLinkEvent' , clickedLinkSchema ); var event1 = new ClickedLinkEvent (); event1 . validate ( function () { assert . equal ( eventSchemaCalls , 1 ); assert . equal ( clickedSchemaCalls , 1 ); var generic = new Event (); generic . validate ( function () { assert . equal ( eventSchemaCalls , 2 ); assert . equal ( clickedSchemaCalls , 1 ); }); }); \u9274\u522b\u5668\u7684\u5b57\u6bb5\u662f\u57fa\u672c\u6a21\u5f0f\u5b57\u6bb5\u548c\u9274\u522b\u5668\u6a21\u5f0f\u5b57\u6bb5\u7684\u8054\u5408\uff0c \u5e76\u4e14\u9274\u522b\u5668\u6a21\u5f0f\u7684\u5b57\u6bb5\u4f18\u5148\u3002,\u6709\u4e00\u4e2a\u4f8b\u5916\uff1a\u9ed8\u8ba4\u7684 _id \u5b57\u6bb5\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u9274\u522b\u5668\u6a21\u5f0f\u4e2d\u5c06_id\u9009\u9879\u8bbe\u7f6e\u4e3afalse\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5982\u4e0b\u6240\u793a\u3002 JavaScript var options = { discriminatorKey : 'kind' }; var eventSchema = new mongoose . Schema ({ _id : String , time : Date }, options ); var Event = mongoose . model ( 'BaseEvent' , eventSchema ); var clickedLinkSchema = new mongoose . Schema ({ url : String , time : String }, options ); assert . ok ( clickedLinkSchema . path ( '_id' )); assert . equal ( clickedLinkSchema . path ( '_id' ). instance , 'ObjectID' ); var ClickedLinkEvent = Event . discriminator ( 'ChildEventBad' , clickedLinkSchema ); var event1 = new ClickedLinkEvent ({ _id : 'custom id' , time : '4pm' }); assert . ok ( typeof event1 . _id === 'string' ); assert . ok ( typeof event1 . time === 'string' ); \u5f53\u4f60\u4f7f\u7528 Model.create\uff08\uff09 \u65f6\uff0c\u732b\u9f2c\u4f1a\u4ece\u4f60\u7684\u9274\u522b\u5668\u952e\u4e2d\u53d6\u51fa\u6b63\u786e\u7684\u7c7b\u578b\u3002 JavaScript var Schema = mongoose . Schema ; var shapeSchema = new Schema ({ name : String }, { discriminatorKey : 'kind' }); var Shape = db . model ( 'Shape' , shapeSchema ); var Circle = Shape . discriminator ( 'Circle' , new Schema ({ radius : Number })); var Square = Shape . discriminator ( 'Square' , new Schema ({ side : Number })); var shapes = [ { name : 'Test' }, { kind : 'Circle' , radius : 5 }, { kind : 'Square' , side : 10 } ]; Shape . create ( shapes , function ( error , shapes ) { assert . ifError ( error ); assert . ok ( shapes [ 0 ] instanceof Shape ); assert . ok ( shapes [ 1 ] instanceof Circle ); assert . equal ( shapes [ 1 ]. radius , 5 ); assert . ok ( shapes [ 2 ] instanceof Square ); assert . equal ( shapes [ 2 ]. side , 10 ); }); \u60a8\u4e5f\u53ef\u4ee5\u5728\u5d4c\u5165\u5f0f\u6587\u6863\u6570\u7ec4\u4e0a\u5b9a\u4e49\u9274\u522b\u5668\u3002 \u5d4c\u5165\u5f0f\u9274\u522b\u5668\u662f\u4e0d\u540c\u7684\uff0c\u56e0\u4e3a\u4e0d\u540c\u7684\u9274\u522b\u5668\u7c7b\u578b\u5b58\u50a8\u5728\u76f8\u540c\u7684\u6587\u6863\u6570\u7ec4\uff08\u5728\u6587\u6863\u4e2d\uff09\u800c\u4e0d\u662f\u76f8\u540c\u7684\u96c6\u5408\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5d4c\u5165\u5f0f\u9274\u522b\u5668\u53ef\u8ba9\u60a8\u5c06\u4e0e\u4e0d\u540c\u6a21\u5f0f\u5339\u914d\u7684\u5b50\u6587\u6863\u5b58\u50a8\u5728\u540c\u4e00\u4e2a\u6570\u7ec4\u4e2d\u3002 \u4f5c\u4e3a\u4e00\u4e2a\u901a\u7528\u7684\u6700\u4f73\u5b9e\u8df5\uff0c\u786e\u4fdd\u4f60\u5728\u4f7f\u7528\u5b83\u4eec\u4e4b\u524d\uff0c\u5728\u6a21\u5f0f**\u4e0a\u58f0\u660e\u4efb\u4f55\u94a9\u5b50\u3002 \u5728\u8c03\u7528discriminator\uff08\uff09\u4e4b\u540e\uff0c\u4f60\u4e0d\u5e94\u8be5\u8c03\u7528 pre\uff08\uff09 \u6216 post\uff08\uff09 JavaScript var eventSchema = new Schema ({ message : String }, { discriminatorKey : 'kind' , _id : false }); var batchSchema = new Schema ({ events : [ eventSchema ] }); var docArray = batchSchema . path ( 'events' ); var clickedSchema = new Schema ({ element : { type : String , required : true } }, { _id : false }); var Clicked = docArray . discriminator ( 'Clicked' , clickedSchema ); var Purchased = docArray . discriminator ( 'Purchased' , new Schema ({ product : { type : String , required : true } }, { _id : false })); var Batch = db . model ( 'EventBatch' , batchSchema ); var batch = { events : [ { kind : 'Clicked' , element : '#hero' , message : 'hello' }, { kind : 'Purchased' , product : 'action-figure-1' , message : 'world' } ] }; Batch . create ( batch ). then ( function ( doc ) { assert . equal ( doc . events . length , 2 ); assert . equal ( doc . events [ 0 ]. element , '#hero' ); assert . equal ( doc . events [ 0 ]. message , 'hello' ); assert . ok ( doc . events [ 0 ] instanceof Clicked ); assert . equal ( doc . events [ 1 ]. product , 'action-figure-1' ); assert . equal ( doc . events [ 1 ]. message , 'world' ); assert . ok ( doc . events [ 1 ] instanceof Purchased ); doc . events . push ({ kind : 'Purchased' , product : 'action-figure-2' }); return doc . save (); }). then ( function ( doc ) { assert . equal ( doc . events . length , 3 ); assert . equal ( doc . events [ 2 ]. product , 'action-figure-2' ); assert . ok ( doc . events [ 2 ] instanceof Purchased ); done (); }). catch ( done ); \u5d4c\u5165\u5f0f\u9012\u5f52\u9274\u522b\u5668 JavaScript var singleEventSchema = new Schema ({ message : String }, { discriminatorKey : 'kind' , _id : false }); var eventListSchema = new Schema ({ events : [ singleEventSchema ] }); var subEventSchema = new Schema ({ sub_events : [ singleEventSchema ] }, { _id : false }); var SubEvent = subEventSchema . path ( 'sub_events' ). discriminator ( 'SubEvent' , subEventSchema ) eventListSchema . path ( 'events' ). discriminator ( 'SubEvent' , subEventSchema ); var Eventlist = db . model ( 'EventList' , eventListSchema ); var list = { events : [ { kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [], message : 'test1' }], message : 'hello' }, { kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [], message : 'test3' }], message : 'test2' }], message : 'world' } ] }; Eventlist . create ( list ). then ( function ( doc ) { assert . equal ( doc . events . length , 2 ); assert . equal ( doc . events [ 0 ]. sub_events [ 0 ]. message , 'test1' ); assert . equal ( doc . events [ 0 ]. message , 'hello' ); assert . ok ( doc . events [ 0 ]. sub_events [ 0 ] instanceof SubEvent ); assert . equal ( doc . events [ 1 ]. sub_events [ 0 ]. sub_events [ 0 ]. message , 'test3' ); assert . equal ( doc . events [ 1 ]. message , 'world' ); assert . ok ( doc . events [ 1 ]. sub_events [ 0 ]. sub_events [ 0 ] instanceof SubEvent ); doc . events . push ({ kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [], message : 'test4' }], message : 'pushed' }); return doc . save (); }). then ( function ( doc ) { assert . equal ( doc . events . length , 3 ); assert . equal ( doc . events [ 2 ]. message , 'pushed' ); assert . ok ( doc . events [ 2 ]. sub_events [ 0 ] instanceof SubEvent ); done (); }). catch ( done );","title":"\u9274\u522b\u5668"},{"location":"guide/Discriminators/#_1","text":"\u8d44\u6e90 \u9274\u522b\u5668\u662f\u4e00\u4e2a\u6a21\u5f0f\u7ee7\u627f\u673a\u5236\u3002 \u5b83\u4eec\u4f7f\u60a8\u80fd\u591f\u5728\u76f8\u540c\u7684\u57fa\u7840MongoDB\u96c6\u5408\u4e4b\u4e0a\u62e5\u6709\u591a\u4e2a\u5177\u6709\u91cd\u53e0\u6a21\u5f0f\u7684\u6a21\u578b\u3002 \u5047\u8bbe\u60a8\u60f3\u8981\u5728\u5355\u4e2a\u96c6\u5408\u4e2d\u8ddf\u8e2a\u4e0d\u540c\u7c7b\u578b\u7684\u4e8b\u4ef6\u3002 \u6bcf\u4e2a\u4e8b\u4ef6\u90fd\u4f1a\u6709\u4e00\u4e2a\u65f6\u95f4\u6233\uff0c\u4f46\u4ee3\u8868\u70b9\u51fb\u94fe\u63a5\u200b\u200b\u7684\u4e8b\u4ef6\u5e94\u8be5\u6709\u4e00\u4e2aURL\u3002 \u4f60\u53ef\u4ee5\u4f7f\u7528 model.discriminator\uff08\uff09 \u51fd\u6570\u5b9e\u73b0\u8fd9\u4e2a\u529f\u80fd\u3002 \u8be5\u529f\u80fd\u9700\u89812\u4e2a\u53c2\u6570\uff0c \u4e00\u4e2a\u6a21\u578b\u540d\u79f0\u548c\u4e00\u4e2a\u9274\u522b\u5668\u6a21\u5f0f \u5b83\u8fd4\u56de\u4e00\u4e2a\u6a21\u5f0f\uff0c\u5176\u6a21\u5f0f\u662f\u57fa\u672c\u6a21\u5f0f\u548c\u9274\u522b\u5668\u6a21\u5f0f\u7684\u8054\u5408\u3002 JavaScript var options = { discriminatorKey : 'kind' }; var eventSchema = new mongoose . Schema ({ time : Date }, options ); var Event = mongoose . model ( 'Event' , eventSchema ); var ClickedLinkEvent = Event . discriminator ( 'ClickedLink' , new mongoose . Schema ({ url : String }, options )); var genericEvent = new Event ({ time : Date . now (), url : 'google.com' }); assert . ok ( ! genericEvent . url ); var clickedEvent = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); assert . ok ( clickedEvent . url ); \u5047\u8bbe\u60a8\u521b\u5efa\u4e86\u53e6\u4e00\u4e2a\u9274\u522b\u5668\u6765\u8ddf\u8e2a\u65b0\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002\u8fd9\u4e9b SignedUpEvent \u5b9e\u4f8b\u5c06\u88ab\u5b58\u50a8\u5728\u4e0e\u901a\u7528\u4e8b\u4ef6\u548c ClickedLinkEvent \u5b9e\u4f8b\u76f8\u540c\u7684\u96c6\u5408\u4e2d\u3002 JavaScript var event1 = new Event ({ time : Date . now ()}); var event2 = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); var event3 = new SignedUpEvent ({ time : Date . now (), user : 'testuser' }); var save = function ( doc , callback ) { doc . save ( function ( error , doc ) { callback ( error , doc ); }); }; async . map ([ event1 , event2 , event3 ], save , function ( error ) { Event . count ({}, function ( error , count ) { assert . equal ( count , 3 ); }); }); \u732b\u9f2c\u7684\u65b9\u5f0f\u544a\u8bc9\u4e0d\u540c\u7684\u9274\u522b\u5668\u6a21\u578b\u4e4b\u95f4\u7684\u5dee\u5f02\u662f\u7531\u201c\u9274\u522b\u94a5\u5319\u201d, \u9ed8\u8ba4\u662f __t \u3002 ,Mongoose\u5c06\u4e00\u4e2a\u540d\u4e3a __t \u7684String\u8def\u5f84\u6dfb\u52a0\u5230\u60a8\u7684\u6a21\u5f0f\u4e2d\uff0c\u7528\u4e8e\u8ddf\u8e2a\u8be5\u6587\u6863\u662f\u54ea\u4e2a\u9274\u522b\u5668\u7684\u5b9e\u4f8b\u3002 JavaScript var event1 = new Event ({ time : Date . now ()}); var event2 = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); var event3 = new SignedUpEvent ({ time : Date . now (), user : 'testuser' }); assert . ok ( ! event1 . __t ); assert . equal ( event2 . __t , 'ClickedLink' ); assert . equal ( event3 . __t , 'SignedUp' ); \u8fa8\u522b\u5668\u6a21\u578b\u662f\u7279\u6b8a\u7684;\u4ed6\u4eec\u5c06\u9274\u522b\u952e\u9644\u52a0\u5230\u67e5\u8be2\u3002 \u6362\u4e00\u79cd\u8bf4\u6cd5\uff0c find() , count() , aggregate() , \u7b49\u7b49\u90fd\u8db3\u591f\u806a\u660e\u6765\u89e3\u91ca\u9274\u522b\u8005\u3002 JavaScript var event1 = new Event ({ time : Date . now ()}); var event2 = new ClickedLinkEvent ({ time : Date . now (), url : 'google.com' }); var event3 = new SignedUpEvent ({ time : Date . now (), user : 'testuser' }); var save = function ( doc , callback ) { doc . save ( function ( error , doc ) { callback ( error , doc ); }); }; async . map ([ event1 , event2 , event3 ], save , function ( error ) { ClickedLinkEvent . find ({}, function ( error , docs ) { assert . equal ( docs . length , 1 ); assert . equal ( docs [ 0 ]. _id . toString (), event2 . _id . toString ()); assert . equal ( docs [ 0 ]. url , 'google.com' ); }); }); \u9274\u522b\u8005\u4e5f\u91c7\u53d6\u4ed6\u4eec\u7684\u57fa\u672c\u6a21\u5f0f\u7684\u524d\u540e\u4e2d\u95f4\u4ef6\u3002 \u4f46\u662f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u5c06\u4e2d\u95f4\u4ef6\u9644\u52a0\u5230\u9274\u522b\u5668\u6a21\u5f0f\uff0c\u800c\u4e0d\u4f1a\u5f71\u54cd\u57fa\u672c\u6a21\u5f0f\u3002 JavaScript var options = { discriminatorKey : 'kind' }; var eventSchema = new mongoose . Schema ({ time : Date }, options ); var eventSchemaCalls = 0 ; eventSchema . pre ( 'validate' , function ( next ) { ++ eventSchemaCalls ; next (); }); var Event = mongoose . model ( 'GenericEvent' , eventSchema ); var clickedLinkSchema = new mongoose . Schema ({ url : String }, options ); var clickedSchemaCalls = 0 ; clickedLinkSchema . pre ( 'validate' , function ( next ) { ++ clickedSchemaCalls ; next (); }); var ClickedLinkEvent = Event . discriminator ( 'ClickedLinkEvent' , clickedLinkSchema ); var event1 = new ClickedLinkEvent (); event1 . validate ( function () { assert . equal ( eventSchemaCalls , 1 ); assert . equal ( clickedSchemaCalls , 1 ); var generic = new Event (); generic . validate ( function () { assert . equal ( eventSchemaCalls , 2 ); assert . equal ( clickedSchemaCalls , 1 ); }); }); \u9274\u522b\u5668\u7684\u5b57\u6bb5\u662f\u57fa\u672c\u6a21\u5f0f\u5b57\u6bb5\u548c\u9274\u522b\u5668\u6a21\u5f0f\u5b57\u6bb5\u7684\u8054\u5408\uff0c \u5e76\u4e14\u9274\u522b\u5668\u6a21\u5f0f\u7684\u5b57\u6bb5\u4f18\u5148\u3002,\u6709\u4e00\u4e2a\u4f8b\u5916\uff1a\u9ed8\u8ba4\u7684 _id \u5b57\u6bb5\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u9274\u522b\u5668\u6a21\u5f0f\u4e2d\u5c06_id\u9009\u9879\u8bbe\u7f6e\u4e3afalse\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5982\u4e0b\u6240\u793a\u3002 JavaScript var options = { discriminatorKey : 'kind' }; var eventSchema = new mongoose . Schema ({ _id : String , time : Date }, options ); var Event = mongoose . model ( 'BaseEvent' , eventSchema ); var clickedLinkSchema = new mongoose . Schema ({ url : String , time : String }, options ); assert . ok ( clickedLinkSchema . path ( '_id' )); assert . equal ( clickedLinkSchema . path ( '_id' ). instance , 'ObjectID' ); var ClickedLinkEvent = Event . discriminator ( 'ChildEventBad' , clickedLinkSchema ); var event1 = new ClickedLinkEvent ({ _id : 'custom id' , time : '4pm' }); assert . ok ( typeof event1 . _id === 'string' ); assert . ok ( typeof event1 . time === 'string' ); \u5f53\u4f60\u4f7f\u7528 Model.create\uff08\uff09 \u65f6\uff0c\u732b\u9f2c\u4f1a\u4ece\u4f60\u7684\u9274\u522b\u5668\u952e\u4e2d\u53d6\u51fa\u6b63\u786e\u7684\u7c7b\u578b\u3002 JavaScript var Schema = mongoose . Schema ; var shapeSchema = new Schema ({ name : String }, { discriminatorKey : 'kind' }); var Shape = db . model ( 'Shape' , shapeSchema ); var Circle = Shape . discriminator ( 'Circle' , new Schema ({ radius : Number })); var Square = Shape . discriminator ( 'Square' , new Schema ({ side : Number })); var shapes = [ { name : 'Test' }, { kind : 'Circle' , radius : 5 }, { kind : 'Square' , side : 10 } ]; Shape . create ( shapes , function ( error , shapes ) { assert . ifError ( error ); assert . ok ( shapes [ 0 ] instanceof Shape ); assert . ok ( shapes [ 1 ] instanceof Circle ); assert . equal ( shapes [ 1 ]. radius , 5 ); assert . ok ( shapes [ 2 ] instanceof Square ); assert . equal ( shapes [ 2 ]. side , 10 ); }); \u60a8\u4e5f\u53ef\u4ee5\u5728\u5d4c\u5165\u5f0f\u6587\u6863\u6570\u7ec4\u4e0a\u5b9a\u4e49\u9274\u522b\u5668\u3002 \u5d4c\u5165\u5f0f\u9274\u522b\u5668\u662f\u4e0d\u540c\u7684\uff0c\u56e0\u4e3a\u4e0d\u540c\u7684\u9274\u522b\u5668\u7c7b\u578b\u5b58\u50a8\u5728\u76f8\u540c\u7684\u6587\u6863\u6570\u7ec4\uff08\u5728\u6587\u6863\u4e2d\uff09\u800c\u4e0d\u662f\u76f8\u540c\u7684\u96c6\u5408\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5d4c\u5165\u5f0f\u9274\u522b\u5668\u53ef\u8ba9\u60a8\u5c06\u4e0e\u4e0d\u540c\u6a21\u5f0f\u5339\u914d\u7684\u5b50\u6587\u6863\u5b58\u50a8\u5728\u540c\u4e00\u4e2a\u6570\u7ec4\u4e2d\u3002 \u4f5c\u4e3a\u4e00\u4e2a\u901a\u7528\u7684\u6700\u4f73\u5b9e\u8df5\uff0c\u786e\u4fdd\u4f60\u5728\u4f7f\u7528\u5b83\u4eec\u4e4b\u524d\uff0c\u5728\u6a21\u5f0f**\u4e0a\u58f0\u660e\u4efb\u4f55\u94a9\u5b50\u3002 \u5728\u8c03\u7528discriminator\uff08\uff09\u4e4b\u540e\uff0c\u4f60\u4e0d\u5e94\u8be5\u8c03\u7528 pre\uff08\uff09 \u6216 post\uff08\uff09 JavaScript var eventSchema = new Schema ({ message : String }, { discriminatorKey : 'kind' , _id : false }); var batchSchema = new Schema ({ events : [ eventSchema ] }); var docArray = batchSchema . path ( 'events' ); var clickedSchema = new Schema ({ element : { type : String , required : true } }, { _id : false }); var Clicked = docArray . discriminator ( 'Clicked' , clickedSchema ); var Purchased = docArray . discriminator ( 'Purchased' , new Schema ({ product : { type : String , required : true } }, { _id : false })); var Batch = db . model ( 'EventBatch' , batchSchema ); var batch = { events : [ { kind : 'Clicked' , element : '#hero' , message : 'hello' }, { kind : 'Purchased' , product : 'action-figure-1' , message : 'world' } ] }; Batch . create ( batch ). then ( function ( doc ) { assert . equal ( doc . events . length , 2 ); assert . equal ( doc . events [ 0 ]. element , '#hero' ); assert . equal ( doc . events [ 0 ]. message , 'hello' ); assert . ok ( doc . events [ 0 ] instanceof Clicked ); assert . equal ( doc . events [ 1 ]. product , 'action-figure-1' ); assert . equal ( doc . events [ 1 ]. message , 'world' ); assert . ok ( doc . events [ 1 ] instanceof Purchased ); doc . events . push ({ kind : 'Purchased' , product : 'action-figure-2' }); return doc . save (); }). then ( function ( doc ) { assert . equal ( doc . events . length , 3 ); assert . equal ( doc . events [ 2 ]. product , 'action-figure-2' ); assert . ok ( doc . events [ 2 ] instanceof Purchased ); done (); }). catch ( done ); \u5d4c\u5165\u5f0f\u9012\u5f52\u9274\u522b\u5668 JavaScript var singleEventSchema = new Schema ({ message : String }, { discriminatorKey : 'kind' , _id : false }); var eventListSchema = new Schema ({ events : [ singleEventSchema ] }); var subEventSchema = new Schema ({ sub_events : [ singleEventSchema ] }, { _id : false }); var SubEvent = subEventSchema . path ( 'sub_events' ). discriminator ( 'SubEvent' , subEventSchema ) eventListSchema . path ( 'events' ). discriminator ( 'SubEvent' , subEventSchema ); var Eventlist = db . model ( 'EventList' , eventListSchema ); var list = { events : [ { kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [], message : 'test1' }], message : 'hello' }, { kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [], message : 'test3' }], message : 'test2' }], message : 'world' } ] }; Eventlist . create ( list ). then ( function ( doc ) { assert . equal ( doc . events . length , 2 ); assert . equal ( doc . events [ 0 ]. sub_events [ 0 ]. message , 'test1' ); assert . equal ( doc . events [ 0 ]. message , 'hello' ); assert . ok ( doc . events [ 0 ]. sub_events [ 0 ] instanceof SubEvent ); assert . equal ( doc . events [ 1 ]. sub_events [ 0 ]. sub_events [ 0 ]. message , 'test3' ); assert . equal ( doc . events [ 1 ]. message , 'world' ); assert . ok ( doc . events [ 1 ]. sub_events [ 0 ]. sub_events [ 0 ] instanceof SubEvent ); doc . events . push ({ kind : 'SubEvent' , sub_events : [{ kind : 'SubEvent' , sub_events : [], message : 'test4' }], message : 'pushed' }); return doc . save (); }). then ( function ( doc ) { assert . equal ( doc . events . length , 3 ); assert . equal ( doc . events [ 2 ]. message , 'pushed' ); assert . ok ( doc . events [ 2 ]. sub_events [ 0 ] instanceof SubEvent ); done (); }). catch ( done );","title":"\u9274\u522b\u5668"},{"location":"guide/Middleware/","text":"\u4e2d\u95f4\u4ef6 \u00b6 Source Middleware (also called pre and post hooks ) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing plugins . Mongoose 4.x has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware. Document middleware is supported for the following document functions. In document middleware functions, this refers to the document. Query middleware is supported for the following Model and Query functions. In query middleware functions, this refers to the query. Aggregate middleware is for MyModel.aggregate() . Aggregate middleware executes when you call exec() on an aggregate object. In aggregate middleware, this refers to the aggregation object . Model middleware is supported for the following model functions. In model middleware functions, this refers to the model. All middleware types support pre and post hooks. How pre and post hooks work is described in more detail below. Note: There is no query hook for remove() , only for documents. If you set a 'remove' hook, it will be fired when you call myDoc.remove() , not when you call MyModel.remove() . Note: The create() function fires save() hooks. Pre \u00b6 There are two types of pre hooks, serial and parallel. \u4e32\u884c \u00b6 Serial middleware functions are executed one after another, when each middleware calls next . var schema = new Schema ( .. ); schema . pre ( 'save' , function ( next ) { next (); }); The next() call does not stop the rest of the code in your middleware function from executing. Use the early return pattern to prevent the rest of your middleware function from running when you call next() . var schema = new Schema ( .. ); schema . pre ( 'save' , function ( next ) { if ( foo ()) { console . log ( 'calling next!' ); next (); } console . log ( 'after next' ); }); \u5e73\u884c \u00b6 Parallel middleware offer more fine-grained flow control. var schema = new Schema ( .. ); schema . pre ( 'save' , true , function ( next , done ) { next (); setTimeout ( done , 100 ); }); The hooked method, in this case save , will not be executed until done is called by each middleware. \u7528\u4f8b \u00b6 Middleware are useful for atomizing model logic. Here are some other ideas: complex validation removing dependent documents (removing a user removes all his blogposts) asynchronous defaults asynchronous tasks that a certain action triggers \u9519\u8bef\u5904\u7406 \u00b6 If any middleware calls next or done with a parameter of type Error , the flow is interrupted, and the error is passed to the callback. schema . pre ( 'save' , function ( next ) { var err = new Error ( 'something went wrong' ); next ( err ); }); myDoc . save ( function ( err ) { console . log ( err . message ) }); \u53d1\u5e03\u4e2d\u95f4\u4ef6 \u00b6 post middleware are executed after the hooked method and all of its pre middleware have completed. schema.post('init', function(doc) { console.log('%s has been initialized from the db', doc._id); }); schema.post('validate', function(doc) { console.log('%s has been validated (but not saved yet)', doc._id); }); schema.post('save', function(doc) { console.log('%s has been saved', doc._id); }); schema.post('remove', function(doc) { console.log('%s has been removed', doc._id); }); \u5f02\u6b65\u53d1\u5e03\u94a9 \u00b6 If your post hook function takes at least 2 parameters, mongoose will assume the second parameter is a next() function that you will call to trigger the next middleware in the sequence. schema . post ( ' save ' , function ( doc , next ) { setTimeout ( function () { console . log ( ' post1 ' ) ; next () ; }, 10 ) ; } ) ; schema . post ( ' save ' , function ( doc , next ) { console . log ( ' post2 ' ) ; next () ; } ) ; \u4fdd\u5b58/\u9a8c\u8bc1\u94a9\u5b50 \u00b6 The save() function triggers validate() hooks, because mongoose has a built-in pre('save') hook that calls validate() . This means that all pre('validate') and post('validate') hooks get called before any pre('save') hooks. schema.pre('validate', function() { console.log('this gets printed first'); }); schema.post('validate', function() { console.log('this gets printed second'); }); schema.pre('save', function() { console.log('this gets printed third'); }); schema.post('save', function() { console.log('this gets printed fourth'); }); findAndUpdate\uff08\uff09\u548c\u67e5\u8be2\u4e2d\u95f4\u4ef6\u7684\u6ce8\u91ca \u00b6 Pre and post save() hooks are not executed on update() , findOneAndUpdate() , etc. You can see a more detailed discussion why in this GitHub issue . Mongoose 4.0 introduced distinct hooks for these functions. schema.pre('find', function() { console.log(this instanceof mongoose.Query); this.start = Date.now(); }); schema.post('find', function(result) { console.log(this instanceof mongoose.Query); console.log('find() returned ' + JSON.stringify(result)); console.log('find() took ' + (Date.now() - this.start) + ' millis'); }); Query middleware differs from document middleware in a subtle but important way: in document middleware, this refers to the document being updated. In query middleware, mongoose doesn't necessarily have a reference to the document being updated, so this refers to the query object rather than the document being updated. For instance, if you wanted to add an updatedAt timestamp to every update() call, you would use the following pre hook. schema . pre ( 'update' , function () { this.update({ } , { $ set : { updatedAt : new Date () } } ); } ); \u9519\u8bef\u5904\u7406\u4e2d\u95f4\u4ef6 \u00b6 New in 4.5.0 Middleware execution normally stops the first time a piece of middleware calls next() with an error. However, there is a special kind of post middleware called \"error handling middleware\" that executes specifically when an error occurs. Error handling middleware is defined as middleware that takes one extra parameter: the 'error' that occurred as the first parameter to the function. Error handling middleware can then transform the error however you want. var schema = new Schema ({ name : { type : String , unique : true } }); schema . post ( 'save' , function ( error , doc , next ) { if ( error . name === 'MongoError' && error . code === 11000 ) { next ( new Error ( 'There was a duplicate key error' )); } else { next ( error ); } }); Person . create ([{ name : 'Axl Rose' }, { name : 'Axl Rose' }]); Error handling middleware also works with query middleware. You can also define a post update() hook that will catch MongoDB duplicate key errors. schema . post ( 'update' , function ( error , res , next ) { if ( error . name === 'MongoError' && error . code === 11000 ) { next ( new Error ( 'There was a duplicate key error' )); } else { next ( error ); } }); var people = [{ name : 'Axl Rose' }, { name : 'Slash' }]; Person . create ( people , function ( error ) { Person . update ({ name : 'Slash' }, { $ set : { name : 'Axl Rose' } }, function ( error ) { }); }); \u63a5\u4e0b\u6765 \u00b6 Now that we've covered middleware, let's take a look at Mongoose's approach to faking JOINs with its query population helper.","title":"\u4e2d\u95f4\u4ef6"},{"location":"guide/Middleware/#_1","text":"Source Middleware (also called pre and post hooks ) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing plugins . Mongoose 4.x has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware. Document middleware is supported for the following document functions. In document middleware functions, this refers to the document. Query middleware is supported for the following Model and Query functions. In query middleware functions, this refers to the query. Aggregate middleware is for MyModel.aggregate() . Aggregate middleware executes when you call exec() on an aggregate object. In aggregate middleware, this refers to the aggregation object . Model middleware is supported for the following model functions. In model middleware functions, this refers to the model. All middleware types support pre and post hooks. How pre and post hooks work is described in more detail below. Note: There is no query hook for remove() , only for documents. If you set a 'remove' hook, it will be fired when you call myDoc.remove() , not when you call MyModel.remove() . Note: The create() function fires save() hooks.","title":"\u4e2d\u95f4\u4ef6"},{"location":"guide/Middleware/#pre","text":"There are two types of pre hooks, serial and parallel.","title":"Pre"},{"location":"guide/Middleware/#_2","text":"Serial middleware functions are executed one after another, when each middleware calls next . var schema = new Schema ( .. ); schema . pre ( 'save' , function ( next ) { next (); }); The next() call does not stop the rest of the code in your middleware function from executing. Use the early return pattern to prevent the rest of your middleware function from running when you call next() . var schema = new Schema ( .. ); schema . pre ( 'save' , function ( next ) { if ( foo ()) { console . log ( 'calling next!' ); next (); } console . log ( 'after next' ); });","title":"\u4e32\u884c"},{"location":"guide/Middleware/#_3","text":"Parallel middleware offer more fine-grained flow control. var schema = new Schema ( .. ); schema . pre ( 'save' , true , function ( next , done ) { next (); setTimeout ( done , 100 ); }); The hooked method, in this case save , will not be executed until done is called by each middleware.","title":"\u5e73\u884c"},{"location":"guide/Middleware/#_4","text":"Middleware are useful for atomizing model logic. Here are some other ideas: complex validation removing dependent documents (removing a user removes all his blogposts) asynchronous defaults asynchronous tasks that a certain action triggers","title":"\u7528\u4f8b"},{"location":"guide/Middleware/#_5","text":"If any middleware calls next or done with a parameter of type Error , the flow is interrupted, and the error is passed to the callback. schema . pre ( 'save' , function ( next ) { var err = new Error ( 'something went wrong' ); next ( err ); }); myDoc . save ( function ( err ) { console . log ( err . message ) });","title":"\u9519\u8bef\u5904\u7406"},{"location":"guide/Middleware/#_6","text":"post middleware are executed after the hooked method and all of its pre middleware have completed. schema.post('init', function(doc) { console.log('%s has been initialized from the db', doc._id); }); schema.post('validate', function(doc) { console.log('%s has been validated (but not saved yet)', doc._id); }); schema.post('save', function(doc) { console.log('%s has been saved', doc._id); }); schema.post('remove', function(doc) { console.log('%s has been removed', doc._id); });","title":"\u53d1\u5e03\u4e2d\u95f4\u4ef6"},{"location":"guide/Middleware/#_7","text":"If your post hook function takes at least 2 parameters, mongoose will assume the second parameter is a next() function that you will call to trigger the next middleware in the sequence. schema . post ( ' save ' , function ( doc , next ) { setTimeout ( function () { console . log ( ' post1 ' ) ; next () ; }, 10 ) ; } ) ; schema . post ( ' save ' , function ( doc , next ) { console . log ( ' post2 ' ) ; next () ; } ) ;","title":"\u5f02\u6b65\u53d1\u5e03\u94a9"},{"location":"guide/Middleware/#_8","text":"The save() function triggers validate() hooks, because mongoose has a built-in pre('save') hook that calls validate() . This means that all pre('validate') and post('validate') hooks get called before any pre('save') hooks. schema.pre('validate', function() { console.log('this gets printed first'); }); schema.post('validate', function() { console.log('this gets printed second'); }); schema.pre('save', function() { console.log('this gets printed third'); }); schema.post('save', function() { console.log('this gets printed fourth'); });","title":"\u4fdd\u5b58/\u9a8c\u8bc1\u94a9\u5b50"},{"location":"guide/Middleware/#findandupdate","text":"Pre and post save() hooks are not executed on update() , findOneAndUpdate() , etc. You can see a more detailed discussion why in this GitHub issue . Mongoose 4.0 introduced distinct hooks for these functions. schema.pre('find', function() { console.log(this instanceof mongoose.Query); this.start = Date.now(); }); schema.post('find', function(result) { console.log(this instanceof mongoose.Query); console.log('find() returned ' + JSON.stringify(result)); console.log('find() took ' + (Date.now() - this.start) + ' millis'); }); Query middleware differs from document middleware in a subtle but important way: in document middleware, this refers to the document being updated. In query middleware, mongoose doesn't necessarily have a reference to the document being updated, so this refers to the query object rather than the document being updated. For instance, if you wanted to add an updatedAt timestamp to every update() call, you would use the following pre hook. schema . pre ( 'update' , function () { this.update({ } , { $ set : { updatedAt : new Date () } } ); } );","title":"findAndUpdate\uff08\uff09\u548c\u67e5\u8be2\u4e2d\u95f4\u4ef6\u7684\u6ce8\u91ca"},{"location":"guide/Middleware/#_9","text":"New in 4.5.0 Middleware execution normally stops the first time a piece of middleware calls next() with an error. However, there is a special kind of post middleware called \"error handling middleware\" that executes specifically when an error occurs. Error handling middleware is defined as middleware that takes one extra parameter: the 'error' that occurred as the first parameter to the function. Error handling middleware can then transform the error however you want. var schema = new Schema ({ name : { type : String , unique : true } }); schema . post ( 'save' , function ( error , doc , next ) { if ( error . name === 'MongoError' && error . code === 11000 ) { next ( new Error ( 'There was a duplicate key error' )); } else { next ( error ); } }); Person . create ([{ name : 'Axl Rose' }, { name : 'Axl Rose' }]); Error handling middleware also works with query middleware. You can also define a post update() hook that will catch MongoDB duplicate key errors. schema . post ( 'update' , function ( error , res , next ) { if ( error . name === 'MongoError' && error . code === 11000 ) { next ( new Error ( 'There was a duplicate key error' )); } else { next ( error ); } }); var people = [{ name : 'Axl Rose' }, { name : 'Slash' }]; Person . create ( people , function ( error ) { Person . update ({ name : 'Slash' }, { $ set : { name : 'Axl Rose' } }, function ( error ) { }); });","title":"\u9519\u8bef\u5904\u7406\u4e2d\u95f4\u4ef6"},{"location":"guide/Middleware/#_10","text":"Now that we've covered middleware, let's take a look at Mongoose's approach to faking JOINs with its query population helper.","title":"\u63a5\u4e0b\u6765"},{"location":"guide/Plugins/","text":"\u63d2\u4ef6 \u00b6 \u8d44\u6e90 Schemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature. Suppose that we have several collections in our database and want to add last-modified functionality to each one. With plugins this is easy. Just create a plugin once and apply it to each Schema : module . exports = exports = function lastModifiedPlugin ( schema , options ) { schema . add ({ lastMod : Date }); schema . pre ( 'save' , function ( next ) { this . lastMod = new Date (); next (); }); if ( options && options . index ) { schema . path ( 'lastMod' ) . index ( options . index ); } } var lastMod = require ( './lastMod' ); var Game = new Schema ({ ... }); Game . plugin ( lastMod , { index : true }); var lastMod = require ( './lastMod' ); var Player = new Schema ({ ... }); Player . plugin ( lastMod ); We just added last-modified behavior to both our Game and Player schemas and declared an index on the lastMod path of our Games to boot. Not bad for a few lines of code. \u5168\u7403\u63d2\u4ef6 \u00b6 Want to register a plugin for all schemas? The mongoose singleton has a .plugin() function that registers a plugin for every schema. For example: var mongoose = require ( 'mongoose' ); mongoose . plugin ( require ( './lastMod' )); var gameSchema = new Schema ({ ... }); var playerSchema = new Schema ({ ... }); var Game = mongoose . model ( 'Game' , gameSchema ); var Player = mongoose . model ( 'Player' , playerSchema ); Not only can you re-use schema functionality in your own projects but you also reap the benefits of the Mongoose community as well. Any plugin published to npm and tagged with mongoose will show up on our search results page.","title":"\u63d2\u4ef6"},{"location":"guide/Plugins/#_1","text":"\u8d44\u6e90 Schemas are pluggable, that is, they allow for applying pre-packaged capabilities to extend their functionality. This is a very powerful feature. Suppose that we have several collections in our database and want to add last-modified functionality to each one. With plugins this is easy. Just create a plugin once and apply it to each Schema : module . exports = exports = function lastModifiedPlugin ( schema , options ) { schema . add ({ lastMod : Date }); schema . pre ( 'save' , function ( next ) { this . lastMod = new Date (); next (); }); if ( options && options . index ) { schema . path ( 'lastMod' ) . index ( options . index ); } } var lastMod = require ( './lastMod' ); var Game = new Schema ({ ... }); Game . plugin ( lastMod , { index : true }); var lastMod = require ( './lastMod' ); var Player = new Schema ({ ... }); Player . plugin ( lastMod ); We just added last-modified behavior to both our Game and Player schemas and declared an index on the lastMod path of our Games to boot. Not bad for a few lines of code.","title":"\u63d2\u4ef6"},{"location":"guide/Plugins/#_2","text":"Want to register a plugin for all schemas? The mongoose singleton has a .plugin() function that registers a plugin for every schema. For example: var mongoose = require ( 'mongoose' ); mongoose . plugin ( require ( './lastMod' )); var gameSchema = new Schema ({ ... }); var playerSchema = new Schema ({ ... }); var Game = mongoose . model ( 'Game' , gameSchema ); var Player = mongoose . model ( 'Player' , playerSchema ); Not only can you re-use schema functionality in your own projects but you also reap the benefits of the Mongoose community as well. Any plugin published to npm and tagged with mongoose will show up on our search results page.","title":"\u5168\u7403\u63d2\u4ef6"},{"location":"guide/Populate/","text":"\u586b\u5145 \u00b6 \u8d44\u6e90 MongoDB has the join-like $lookup aggregation operator in versions >= 3.2. Mongoose has a more powerful alternative called populate() , which lets you reference documents in other collections. Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples. var mongoose = require ( 'mongoose' ); var Schema = mongoose . Schema ; var personSchema = Schema ({ _id : Schema . Types . ObjectId , name : String , age : Number , stories : [{ type : Schema . Types . ObjectId , ref : 'Story' }] }); var storySchema = Schema ({ author : { type : Schema . Types . ObjectId , ref : 'Person' }, title : String , fans : [{ type : Schema . Types . ObjectId , ref : 'Person' }] }); var Story = mongoose . model ( 'Story' , storySchema ); var Person = mongoose . model ( 'Person' , personSchema ); So far we've created two Models . Our Person model has its stories field set to an array of ObjectId s. The ref option is what tells Mongoose which model to use during population, in our case the Story model. All _id s we store here must be document _id s from the Story model. Note : ObjectId , Number , String , and Buffer are valid for use as refs. However, you should use ObjectId unless you are an advanced user and have a good reason for doing so. \u4fdd\u5b58\u53c2\u8003 \u00b6 Saving refs to other documents works the same way you normally save properties, just assign the _id value: var author = new Person ({ _id : new mongoose . Types . ObjectId (), name : 'Ian Fleming' , age : 50 }); author . save ( function ( err ) { if ( err ) return handleError ( err ); var story1 = new Story ({ title : 'Casino Royale' , author : author . _id }); story1 . save ( function ( err ) { if ( err ) return handleError ( err ); }); }); Population \u00b6 So far we haven't done anything much different. We've merely created a Person and a Story . Now let's take a look at populating our story's author using the query builder: Story . findOne ( { title : 'Casino Royale' } ). populate ( 'author' ). exec ( function ( err , story ) { if (err) return handleError(err) ; console.log('The author is %s', story.author.name) ; } ); Populated paths are no longer set to their original _id , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results. Arrays of refs work the same way. Just call the populate method on the query and an array of documents will be returned in place of the original _id s. \u8bbe\u7f6e\u586b\u5145\u7684\u5b57\u6bb5 \u00b6 In Mongoose >= 4.0, you can manually populate a field as well. Story . findOne ( { title : 'Casino Royale' } , function ( error , story ) { if (error) { return handleError(error) ; } story . author = author ; console . log ( story . author . name ); } ); \u5b57\u6bb5\u9009\u62e9 \u00b6 What if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual field name syntax as the second argument to the populate method: Story . findOne ( { title : / casino royale / i } ). populate ( 'author' , 'name' ). exec ( function ( err , story ) { if (err) return handleError(err) ; console.log('The author is %s', story.author.name) ; console.log('The authors age is %s', story.author.age) ; } ); \u586b\u5145\u591a\u4e2a\u8def\u5f84 \u00b6 What if we wanted to populate multiple paths at the same time? Story . find ( ... ) . populate ( ' fans ' ) . populate ( ' author ' ) . exec () ; If you call populate() multiple times with the same path, only the last one will take effect. Story . find (). populate ( { path : 'fans' , select : 'name' } ). populate ( { path : 'fans' , select : 'email' } ); Story . find () . populate ( { path : 'fans' , select : 'email' } ); \u67e5\u8be2\u6761\u4ef6\u548c\u5176\u4ed6\u9009\u9879 \u00b6 What if we wanted to populate our fans array based on their age, select just their names, and return at most, any 5 of them? Story . find (...). populate ( { path : 'fans' , match : { age : { $ gte : 21 } } , select : 'name -_id' , options : { limit : 5 } } ). exec (); Refs to children \u00b6 We may find however, if we use the author object, we are unable to get a list of the stories. This is because no story objects were ever 'pushed' onto author.stories . There are two perspectives here. First, you may want the author know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can push() documents onto the array as shown below. author.stories.push(story1); author.save(callback); This allows us to perform a find and populate combo: Person . findOne ( { name : 'Ian Fleming' } ). populate ( 'stories' ). exec ( function ( err , person ) { if (err) return handleError(err) ; console.log(person) ; } ); It is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly find() the stories we are interested in. Story . find ( { author : author . _id } ). exec ( function ( err , stories ) { if (err) return handleError(err) ; console.log('The stories are an array : ' , stories ); } ); The documents returned from query population become fully functional, remove able, save able documents unless the lean option is specified. Do not confuse them with sub docs . Take caution when calling its remove method because you'll be removing it from the database, not just the array. \u586b\u5145\u73b0\u6709\u7684\u6587\u6863 \u00b6 If we have an existing mongoose document and want to populate some of its paths, mongoose >= 3.6 supports the document#populate() method. \u586b\u5145\u591a\u4e2a\u73b0\u6709\u7684\u6587\u4ef6 \u00b6 If we have one or many mongoose documents or even plain objects ( like mapReduce output ), we may populate them using the Model.populate() method available in mongoose >= 3.6 . This is what document#populate() and query#populate() use to populate documents. \u586b\u5145\u591a\u4e2a\u7ea7\u522b \u00b6 Say you have a user schema which keeps track of the user's friends. var userSchema = new Schema ({ name : String , friends : [{ type : ObjectId , ref : 'User' }] }); Populate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the populate option to tell mongoose to populate the friends array of all the user's friends: User . findOne ( { name : 'Val' } ). populate ( { path : 'friends' , populate : { path : 'friends' } } ); \u586b\u5145\u6570\u636e\u5e93 \u00b6 Let's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread. var eventSchema = new Schema ({ name : String , conversation : ObjectId }); var conversationSchema = new Schema ({ numMessages : Number }); Also, suppose that events and conversations are stored in separate MongoDB instances. var db1 = mongoose . createConnection ( 'localhost:27000/db1' ); var db2 = mongoose . createConnection ( 'localhost:27001/db2' ); var Event = db1 . model ( 'Event' , eventSchema ); var Conversation = db2 . model ( 'Conversation' , conversationSchema ); In this situation, you will not be able to populate() normally. The conversation field will always be null, because populate() doesn't know which model to use. However, you can specify the model explicitly . Event . find (). populate ( { path : 'conversation' , model : Conversation } ). exec ( function ( error , docs ) { } ); This is known as a \"cross-database populate,\" because it enables you to populate across MongoDB databases and even across MongoDB instances. \u52a8\u6001\u53c2\u8003 \u00b6 Mongoose can also populate from multiple collections at the same time. Let's say you have a user schema that has an array of \"connections\" - a user can be connected to either other users or an organization. var userSchema = new Schema ({ name : String , connections : [{ kind : String , item : { type : ObjectId , refPath : 'connections.kind' } }] }); var organizationSchema = new Schema ({ name : String , kind : String }); var User = mongoose . model ( 'User' , userSchema ); var Organization = mongoose . model ( 'Organization' , organizationSchema ); The refPath property above means that mongoose will look at the connections.kind path to determine which model to use for populate() . In other words, the refPath property enables you to make the ref property dynamic. User . findOne ( { name : 'Axl Rose' } ). populate ( 'connections.item' ). exec ( function ( error , doc ) { } ); \u586b\u5145\u865a\u62df\u673a \u00b6 New in 4.5.0 So far you've only populated based on the _id field. However, that's sometimes not the right choice. In particular, arrays that grow without bound are a MongoDB anti-pattern . Using mongoose virtuals, you can define more sophisticated relationships between documents. var PersonSchema = new Schema ({ name : String , band : String }); var BandSchema = new Schema ({ name : String }); BandSchema . virtual ( 'members' , { ref : 'Person' , localField : 'name' , foreignField : 'band' , justOne : false }); var Person = mongoose . model ( 'Person' , PersonSchema ); var Band = mongoose . model ( 'Band' , BandSchema ); Band . find ({}) . populate ( 'members' ) . exec ( function ( error , bands ) { }); Keep in mind that virtuals are not included in toJSON() output by default. If you want populate virtuals to show up when using functions that rely on JSON.stringify() , like Express' res.json() function , set the virtuals: true option on your schema's toJSON options. var BandSchema = new Schema ({ name : String }, { toJSON : { virtuals : true } }); If you're using populate projections, make sure foreignField is included in the projection. Band . find ( {} ). populate ( { path : 'members' , select : 'name' } ). exec ( function ( error , bands ) { } ); Band . find ( {} ). populate ( { path : 'members' , select : 'name band' } ). exec ( function ( error , bands ) { } ); \u63a5\u4e0b\u6765 \u00b6 \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 populate\uff08\uff09 \uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b \u9274\u522b\u5668 \u3002","title":"\u586b\u5145"},{"location":"guide/Populate/#_1","text":"\u8d44\u6e90 MongoDB has the join-like $lookup aggregation operator in versions >= 3.2. Mongoose has a more powerful alternative called populate() , which lets you reference documents in other collections. Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples. var mongoose = require ( 'mongoose' ); var Schema = mongoose . Schema ; var personSchema = Schema ({ _id : Schema . Types . ObjectId , name : String , age : Number , stories : [{ type : Schema . Types . ObjectId , ref : 'Story' }] }); var storySchema = Schema ({ author : { type : Schema . Types . ObjectId , ref : 'Person' }, title : String , fans : [{ type : Schema . Types . ObjectId , ref : 'Person' }] }); var Story = mongoose . model ( 'Story' , storySchema ); var Person = mongoose . model ( 'Person' , personSchema ); So far we've created two Models . Our Person model has its stories field set to an array of ObjectId s. The ref option is what tells Mongoose which model to use during population, in our case the Story model. All _id s we store here must be document _id s from the Story model. Note : ObjectId , Number , String , and Buffer are valid for use as refs. However, you should use ObjectId unless you are an advanced user and have a good reason for doing so.","title":"\u586b\u5145"},{"location":"guide/Populate/#_2","text":"Saving refs to other documents works the same way you normally save properties, just assign the _id value: var author = new Person ({ _id : new mongoose . Types . ObjectId (), name : 'Ian Fleming' , age : 50 }); author . save ( function ( err ) { if ( err ) return handleError ( err ); var story1 = new Story ({ title : 'Casino Royale' , author : author . _id }); story1 . save ( function ( err ) { if ( err ) return handleError ( err ); }); });","title":"\u4fdd\u5b58\u53c2\u8003"},{"location":"guide/Populate/#population","text":"So far we haven't done anything much different. We've merely created a Person and a Story . Now let's take a look at populating our story's author using the query builder: Story . findOne ( { title : 'Casino Royale' } ). populate ( 'author' ). exec ( function ( err , story ) { if (err) return handleError(err) ; console.log('The author is %s', story.author.name) ; } ); Populated paths are no longer set to their original _id , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results. Arrays of refs work the same way. Just call the populate method on the query and an array of documents will be returned in place of the original _id s.","title":"Population"},{"location":"guide/Populate/#_3","text":"In Mongoose >= 4.0, you can manually populate a field as well. Story . findOne ( { title : 'Casino Royale' } , function ( error , story ) { if (error) { return handleError(error) ; } story . author = author ; console . log ( story . author . name ); } );","title":"\u8bbe\u7f6e\u586b\u5145\u7684\u5b57\u6bb5"},{"location":"guide/Populate/#_4","text":"What if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual field name syntax as the second argument to the populate method: Story . findOne ( { title : / casino royale / i } ). populate ( 'author' , 'name' ). exec ( function ( err , story ) { if (err) return handleError(err) ; console.log('The author is %s', story.author.name) ; console.log('The authors age is %s', story.author.age) ; } );","title":"\u5b57\u6bb5\u9009\u62e9"},{"location":"guide/Populate/#_5","text":"What if we wanted to populate multiple paths at the same time? Story . find ( ... ) . populate ( ' fans ' ) . populate ( ' author ' ) . exec () ; If you call populate() multiple times with the same path, only the last one will take effect. Story . find (). populate ( { path : 'fans' , select : 'name' } ). populate ( { path : 'fans' , select : 'email' } ); Story . find () . populate ( { path : 'fans' , select : 'email' } );","title":"\u586b\u5145\u591a\u4e2a\u8def\u5f84"},{"location":"guide/Populate/#_6","text":"What if we wanted to populate our fans array based on their age, select just their names, and return at most, any 5 of them? Story . find (...). populate ( { path : 'fans' , match : { age : { $ gte : 21 } } , select : 'name -_id' , options : { limit : 5 } } ). exec ();","title":"\u67e5\u8be2\u6761\u4ef6\u548c\u5176\u4ed6\u9009\u9879"},{"location":"guide/Populate/#refs-to-children","text":"We may find however, if we use the author object, we are unable to get a list of the stories. This is because no story objects were ever 'pushed' onto author.stories . There are two perspectives here. First, you may want the author know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can push() documents onto the array as shown below. author.stories.push(story1); author.save(callback); This allows us to perform a find and populate combo: Person . findOne ( { name : 'Ian Fleming' } ). populate ( 'stories' ). exec ( function ( err , person ) { if (err) return handleError(err) ; console.log(person) ; } ); It is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly find() the stories we are interested in. Story . find ( { author : author . _id } ). exec ( function ( err , stories ) { if (err) return handleError(err) ; console.log('The stories are an array : ' , stories ); } ); The documents returned from query population become fully functional, remove able, save able documents unless the lean option is specified. Do not confuse them with sub docs . Take caution when calling its remove method because you'll be removing it from the database, not just the array.","title":"Refs to children"},{"location":"guide/Populate/#_7","text":"If we have an existing mongoose document and want to populate some of its paths, mongoose >= 3.6 supports the document#populate() method.","title":"\u586b\u5145\u73b0\u6709\u7684\u6587\u6863"},{"location":"guide/Populate/#_8","text":"If we have one or many mongoose documents or even plain objects ( like mapReduce output ), we may populate them using the Model.populate() method available in mongoose >= 3.6 . This is what document#populate() and query#populate() use to populate documents.","title":"\u586b\u5145\u591a\u4e2a\u73b0\u6709\u7684\u6587\u4ef6"},{"location":"guide/Populate/#_9","text":"Say you have a user schema which keeps track of the user's friends. var userSchema = new Schema ({ name : String , friends : [{ type : ObjectId , ref : 'User' }] }); Populate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the populate option to tell mongoose to populate the friends array of all the user's friends: User . findOne ( { name : 'Val' } ). populate ( { path : 'friends' , populate : { path : 'friends' } } );","title":"\u586b\u5145\u591a\u4e2a\u7ea7\u522b"},{"location":"guide/Populate/#_10","text":"Let's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread. var eventSchema = new Schema ({ name : String , conversation : ObjectId }); var conversationSchema = new Schema ({ numMessages : Number }); Also, suppose that events and conversations are stored in separate MongoDB instances. var db1 = mongoose . createConnection ( 'localhost:27000/db1' ); var db2 = mongoose . createConnection ( 'localhost:27001/db2' ); var Event = db1 . model ( 'Event' , eventSchema ); var Conversation = db2 . model ( 'Conversation' , conversationSchema ); In this situation, you will not be able to populate() normally. The conversation field will always be null, because populate() doesn't know which model to use. However, you can specify the model explicitly . Event . find (). populate ( { path : 'conversation' , model : Conversation } ). exec ( function ( error , docs ) { } ); This is known as a \"cross-database populate,\" because it enables you to populate across MongoDB databases and even across MongoDB instances.","title":"\u586b\u5145\u6570\u636e\u5e93"},{"location":"guide/Populate/#_11","text":"Mongoose can also populate from multiple collections at the same time. Let's say you have a user schema that has an array of \"connections\" - a user can be connected to either other users or an organization. var userSchema = new Schema ({ name : String , connections : [{ kind : String , item : { type : ObjectId , refPath : 'connections.kind' } }] }); var organizationSchema = new Schema ({ name : String , kind : String }); var User = mongoose . model ( 'User' , userSchema ); var Organization = mongoose . model ( 'Organization' , organizationSchema ); The refPath property above means that mongoose will look at the connections.kind path to determine which model to use for populate() . In other words, the refPath property enables you to make the ref property dynamic. User . findOne ( { name : 'Axl Rose' } ). populate ( 'connections.item' ). exec ( function ( error , doc ) { } );","title":"\u52a8\u6001\u53c2\u8003"},{"location":"guide/Populate/#_12","text":"New in 4.5.0 So far you've only populated based on the _id field. However, that's sometimes not the right choice. In particular, arrays that grow without bound are a MongoDB anti-pattern . Using mongoose virtuals, you can define more sophisticated relationships between documents. var PersonSchema = new Schema ({ name : String , band : String }); var BandSchema = new Schema ({ name : String }); BandSchema . virtual ( 'members' , { ref : 'Person' , localField : 'name' , foreignField : 'band' , justOne : false }); var Person = mongoose . model ( 'Person' , PersonSchema ); var Band = mongoose . model ( 'Band' , BandSchema ); Band . find ({}) . populate ( 'members' ) . exec ( function ( error , bands ) { }); Keep in mind that virtuals are not included in toJSON() output by default. If you want populate virtuals to show up when using functions that rely on JSON.stringify() , like Express' res.json() function , set the virtuals: true option on your schema's toJSON options. var BandSchema = new Schema ({ name : String }, { toJSON : { virtuals : true } }); If you're using populate projections, make sure foreignField is included in the projection. Band . find ( {} ). populate ( { path : 'members' , select : 'name' } ). exec ( function ( error , bands ) { } ); Band . find ( {} ). populate ( { path : 'members' , select : 'name band' } ). exec ( function ( error , bands ) { } );","title":"\u586b\u5145\u865a\u62df\u673a"},{"location":"guide/Populate/#_13","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 populate\uff08\uff09 \uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b \u9274\u522b\u5668 \u3002","title":"\u63a5\u4e0b\u6765"},{"location":"guide/Validation/","text":"\u9a8c\u8bc1 \u00b6 Source \u9a8c\u8bc1\u8bed\u6cd5\u89c4\u5219 \u00b6 \u9a8c\u8bc1\u5728 SchemaType \u4e2d\u5b9a\u4e49 \u9a8c\u8bc1\u662f \u4e2d\u95f4\u4ef6 . \u5728\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cMongoose\u5c06\u9a8c\u8bc1\u6ce8\u518c\u4e3a\u6bcf\u4e2a\u6a21\u5f0f\u7684\u201cpre\u201d\uff08'save'\uff09`\u94a9\u5b50\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 doc.validate\uff08callback\uff09 \u6216 doc.validateSync\uff08\uff09 \u624b\u52a8\u8fd0\u884c\u9a8c\u8bc1 \u9a8c\u8bc1\u5668\u4e0d\u5728\u672a\u5b9a\u4e49\u7684\u503c\u4e0a\u8fd0\u884c\u3002 \u552f\u4e00\u7684\u4f8b\u5916\u662f required validator \u3002 \u9a8c\u8bc1\u662f\u5f02\u6b65\u9012\u5f52\u7684; \u5f53\u4f60\u8c03\u7528 Model\uff03save , \u5b50\u6587\u6863\u9a8c\u8bc1\u4e5f\u88ab\u6267\u884c. \u5982\u679c\u53d1\u751f\u9519\u8bef\uff0c\u4f60\u7684 Model\uff03save \u56de\u8c03\u63a5\u6536\u5230\u5b83 \u9a8c\u8bc1\u662f\u53ef\u5b9a\u5236\u7684 JavaScript var schema = new Schema ({ name : { type : String , required : true } }); var Cat = db . model ( 'Cat' , schema ); var cat = new Cat (); cat . save ( function ( error ) { assert . equal ( error . errors [ 'name' ]. message , 'Path `name` is required.' ); error = cat . validateSync (); assert . equal ( error . errors [ 'name' ]. message , 'Path `name` is required.' ); }); \u5185\u7f6e\u9a8c\u8bc1\u5668 \u00b6 \u6240\u6709\u7684 SchemaTypes \u90fd\u6709\u5185\u7f6e\u7684 required \u9a8c\u8bc1\u5668. \u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f\u4f7f\u7528 SchemaType \u7684 checkRequired() \u51fd\u6570\u6765\u786e\u5b9a\u8be5\u503c\u662f\u5426\u6ee1\u8db3\u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f Numbers \u6709 min \u548c max \u9a8c\u8bc1\u5668. Strings \u6709 enum , match , maxlength \u4f55 minlength \u9a8c\u8bc1\u5668. \u4e0a\u9762\u7684\u6bcf\u4e2a\u9a8c\u8bc1\u5668\u94fe\u63a5\u90fd\u63d0\u4f9b\u4e86\u6709\u5173\u5982\u4f55\u542f\u7528\u5b83\u4eec\u5e76\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u66f4\u591a\u4fe1\u606f. JavaScript var breakfastSchema = new Schema ({ eggs : { type : Number , min : [ 6 , 'Too few eggs' ], max : 12 }, bacon : { type : Number , required : [ true , 'Why no bacon?' ] }, drink : { type : String , enum : [ 'Coffee' , 'Tea' ], required : function () { return this . bacon > 3 ; } } }); var Breakfast = db . model ( 'Breakfast' , breakfastSchema ); var badBreakfast = new Breakfast ({ eggs : 2 , bacon : 0 , drink : 'Milk' }); var error = badBreakfast . validateSync (); assert . equal ( error . errors [ 'eggs' ]. message , 'Too few eggs' ); assert . ok ( ! error . errors [ 'bacon' ]); assert . equal ( error . errors [ 'drink' ]. message , '`Milk` is not a valid enum value for path `drink`.' ); badBreakfast . bacon = 5 ; badBreakfast . drink = null ; error = badBreakfast . validateSync (); assert . equal ( error . errors [ 'drink' ]. message , 'Path `drink` is required.' ); badBreakfast . bacon = null ; error = badBreakfast . validateSync (); assert . equal ( error . errors [ 'bacon' ]. message , 'Why no bacon?' ); unique \u00b6 \u5bf9\u4e8e\u521d\u5b66\u8005\u6765\u8bf4\uff0c\u4e00\u4e2a\u5e38\u89c1\u7684\u95ee\u9898\u662f\u6a21\u5f0f\u7684 unique \u9009\u9879\u4e0d\u662f\u9a8c\u8bc1\u5668\u3002 \u8fd9\u662f\u6784\u5efa MongoDB\u72ec\u7279\u7d22\u5f15 \u7684\u4fbf\u5229\u5e2e\u624b\u3002 \u8bf7\u53c2\u9605 \u5e38\u89c1\u95ee\u9898 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 JavaScript var uniqueUsernameSchema = new Schema ({ username : { type : String , unique : true } }); var U1 = db . model ( 'U1' , uniqueUsernameSchema ); var U2 = db . model ( 'U2' , uniqueUsernameSchema ); var dup = [{ username : 'Val' }, { username : 'Val' }]; U1 . create ( dup , function ( error ) { }); U2 . once ( 'index' , function ( error ) { assert . ifError ( error ); U2 . create ( dup , function ( error ) { assert . ok ( error ); assert . ok ( ! error . errors ); assert . ok ( error . message . indexOf ( 'duplicate key error' ) !== - 1 ); }); }); U2 . init (). then ( function () { U2 . create ( dup , function ( error ) { assert . ok ( error ); assert . ok ( ! error . errors ); assert . ok ( error . message . indexOf ( 'duplicate key error' ) !== - 1 ); }); }); \u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668 \u00b6 \u5982\u679c\u5185\u7f6e\u7684\u9a8c\u8bc1\u5668\u662f\u4e0d\u591f\u7684, \u60a8\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4ee5\u6ee1\u8db3\u60a8\u7684\u9700\u6c42. \u81ea\u5b9a\u4e49\u9a8c\u8bc1\u662f\u901a\u8fc7\u4f20\u9012\u9a8c\u8bc1\u51fd\u6570\u6765\u58f0\u660e\u7684. \u4f60\u53ef\u4ee5\u627e\u5230\u8be6\u7ec6\u7684\u8bf4\u660e \u5173\u4e8e\u5982\u4f55\u5728 SchemaType\uff03validate()API\u6587\u6863 \u4e2d\u505a\u5230\u8fd9\u4e00\u70b9. JavaScript var userSchema = new Schema ({ phone : { type : String , validate : { validator : function ( v ) { return /d{3}-d{3}-d{4}/ . test ( v ); }, message : '{VALUE} is not a valid phone number!' }, required : [ true , 'User phone number required' ] } }); var User = db . model ( 'user' , userSchema ); var user = new User (); var error ; user . phone = '555.0123' ; error = user . validateSync (); assert . equal ( error . errors [ 'phone' ]. message , '555.0123 is not a valid phone number!' ); user . phone = '' ; error = user . validateSync (); assert . equal ( error . errors [ 'phone' ]. message , 'User phone number required' ); user . phone = '201-555-0123' ; error = user . validateSync (); assert . equal ( error , null ); \u56de\u8c03 \u00b6 \u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e5f\u53ef\u4ee5\u662f\u5f02\u6b65\u7684\u3002\u5982\u679c\u4f60\u7684\u9a8c\u8bc1\u5668\u51fd\u6570\u6709\u4e24\u4e2a\u53c2\u6570\uff0c\u732b\u9f2c\u4f1a\u5047\u8bbe\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u56de\u8c03\u3002 \u5373\u4f7f\u4f60\u4e0d\u60f3\u4f7f\u7528\u5f02\u6b65\u9a8c\u8bc1\u5668\uff0c\u4e5f\u8981\u5c0f\u5fc3\uff0c\u56e0\u4e3amongoose 4\u4f1a\u5047\u8bbe**\u6240\u6709\u5e26\u67092\u4e2a\u53c2\u6570\u7684\u51fd\u6570\u90fd\u662f\u5f02\u6b65\u7684\uff0c\u6bd4\u5982 validator.isEmail \u51fd\u6570 \u3002 \u8fd9\u79cd\u884c\u4e3a\u4ece4.9.0\u5f00\u59cb\u88ab\u89c6\u4e3a\u5f03\u7528\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e0a\u6307\u5b9a\u201cisAsync\uff1afalse\u201d\u6765\u5173\u95ed\u5b83\u3002 JavaScript var userSchema = new Schema ({ phone : { type : String , validate : { isAsync : true , validator : function ( v , cb ) { setTimeout ( function () { var phoneRegex = /d{3}-d{3}-d{4}/ ; var msg = v + ' is not a valid phone number!' ; cb ( phoneRegex . test ( v ), msg ); }, 5 ); }, message : 'Default error message' }, required : [ true , 'User phone number required' ] }, name : { type : String , validate : function ( v ) { return new Promise ( function ( resolve , reject ) { setTimeout ( function () { resolve ( false ); }, 5 ); }); } } }); var User = db . model ( 'User' , userSchema ); var user = new User (); var error ; user . phone = '555.0123' ; user . name = 'test' ; user . validate ( function ( error ) { assert . ok ( error ); assert . equal ( error . errors [ 'phone' ]. message , '555.0123 is not a valid phone number!' ); assert . equal ( error . errors [ 'name' ]. message , 'Validator failed for path `name` with value `test`' ); }); \u8fd4\u56de\u9519\u8bef \u00b6 \u9a8c\u8bc1\u5931\u8d25\u540e\u8fd4\u56de\u7684\u9519\u8bef\u5305\u542b error \u5bf9\u8c61\uff0c\u5176\u503c\u662f ValidatorError \u5bf9\u8c61\u3002 \u6bcf\u4e2a ValidatorError \u90fd\u6709 kind \uff0c path \uff0c value , \u548c message \u5c5e\u6027. \u4e00\u4e2a ValidatorError \u4e5f\u53ef\u80fd\u6709\u4e00\u4e2a reason \u5c5e\u6027\u3002 \u5982\u679c\u5728\u9a8c\u8bc1\u5668\u4e2d\u53d1\u751f\u9519\u8bef\uff0c \u8fd9\u4e2a\u5c5e\u6027\u5c06\u5305\u542b\u629b\u51fa\u7684\u9519\u8bef\u3002 JavaScript var toySchema = new Schema ({ color : String , name : String }); var validator = function ( value ) { return /red|white|gold/i . test ( value ); }; toySchema . path ( 'color' ). validate ( validator , 'Color `{VALUE}` not valid' , 'Invalid color' ); toySchema . path ( 'name' ). validate ( function ( v ) { if ( v !== 'Turbo Man' ) { throw new Error ( 'Need to get a Turbo Man for Christmas' ); } return true ; }, 'Name `{VALUE}` is not valid' ); var Toy = db . model ( 'Toy' , toySchema ); var toy = new Toy ({ color : 'Green' , name : 'Power Ranger' }); toy . save ( function ( err ) { assert . equal ( err . errors . color . message , 'Color `Green` not valid' ); assert . equal ( err . errors . color . kind , 'Invalid color' ); assert . equal ( err . errors . color . path , 'color' ); assert . equal ( err . errors . color . value , 'Green' ); assert . equal ( err . errors . name . message , 'Need to get a Turbo Man for Christmas' ); assert . equal ( err . errors . name . value , 'Power Ranger' ); assert . equal ( err . errors . name . reason . message , 'Need to get a Turbo Man for Christmas' ); assert . equal ( err . name , 'ValidationError' ); }); \u5d4c\u5957\u5bf9\u8c61 \u00b6 \u5728\u732b\u9f2c\u7684\u5d4c\u5957\u5bf9\u8c61\u5b9a\u4e49\u9a8c\u8bc1\u662f\u68d8\u624b\u7684\uff0c \u56e0\u4e3a\u5d4c\u5957\u7684\u5bf9\u8c61\u4e0d\u662f\u5b8c\u5168\u6210\u719f\u7684\u8def\u5f84\u3002 JavaScript var personSchema = new Schema ({ name : { first : String , last : String } }); assert . throws ( function () { personSchema . path ( 'name' ). required ( true ); }, /Cannot.*'required'/ ); var nameSchema = new Schema ({ first : String , last : String }); personSchema = new Schema ({ name : { type : nameSchema , required : true } }); var Person = db . model ( 'Person' , personSchema ); var person = new Person (); var error = person . validateSync (); assert . ok ( error . errors [ 'name' ]); \u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u60a8\u4e86\u89e3\u4e86\u6587\u6863\u9a8c\u8bc1\u3002 Mongoose also supports validation for update() and findOneAndUpdate() operations. In Mongoose 4.x, update validators are off by default - you need to specify the runValidators option. \u8981\u6253\u5f00\u66f4\u65b0\u9a8c\u8bc1\u5668\uff0c\u4e3a update\uff08\uff09 \u6216 findOneAndUpdate\uff08\uff09 \u8bbe\u7f6e runValidators \u9009\u9879\u3002 \u5c0f\u5fc3\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u9ed8\u8ba4\u5173\u95ed\uff0c\u56e0\u4e3a\u4ed6\u4eec\u6709\u51e0\u4e2a\u8b66\u544a\u3002 JavaScript var toySchema = new Schema ({ color : String , name : String }); var Toy = db . model ( 'Toys' , toySchema ); Toy . schema . path ( 'color' ). validate ( function ( value ) { return /blue|green|white|red|orange|periwinkle/i . test ( value ); }, 'Invalid color' ); var opts = { runValidators : true }; Toy . update ({}, { color : 'bacon' }, opts , function ( err ) { assert . equal ( err . errors . color . message , 'Invalid color' ); }); \u66f4\u65b0\u9a8c\u8bc1\u5668\u548c\u6587\u6863\u9a8c\u8bc1\u5668\u4e4b\u95f4\u6709\u51e0\u4e2a\u5173\u952e\u7684\u533a\u522b\u3002 \u5728\u4e0a\u9762\u7684\u989c\u8272\u9a8c\u8bc1\u529f\u80fd\u4e2d\uff0c this \u662f\u6307\u5728\u4f7f\u7528\u6587\u6863\u9a8c\u8bc1\u65f6\u6b63\u5728\u9a8c\u8bc1\u7684\u6587\u6863\u3002 \u4f46\u662f\uff0c\u5f53\u8fd0\u884c\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c \u6b63\u5728\u66f4\u65b0\u7684\u6587\u6863\u53ef\u80fd\u4e0d\u5728\u670d\u52a1\u5668\u7684\u5185\u5b58\u4e2d\uff0c\u6240\u4ee5\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u201cthis\u201d\u7684\u503c\u6ca1\u6709\u88ab\u5b9a\u4e49\u3002 JavaScript var toySchema = new Schema ({ color : String , name : String }); toySchema . path ( 'color' ). validate ( function ( value ) { if ( this . name . toLowerCase (). indexOf ( 'red' ) !== - 1 ) { return value !== 'red' ; } return true ; }); var Toy = db . model ( 'ActionFigure' , toySchema ); var toy = new Toy ({ color : 'red' , name : 'Red Power Ranger' }); var error = toy . validateSync (); assert . ok ( error . errors [ 'color' ]); var update = { color : 'red' , name : 'Red Power Ranger' }; var opts = { runValidators : true }; Toy . update ({}, update , opts , function ( error ) { assert . ok ( error ); }); context \u00b6 context \u9009\u9879\u53ef\u4ee5\u8ba9\u4f60\u5728\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e2d\u5c06 this \u7684\u503c\u8bbe\u7f6e\u4e3a\u5e95\u5c42\u67e5\u8be2\u3002 JavaScript toySchema . path ( 'color' ). validate ( function ( value ) { if ( this . getUpdate (). $set . name . toLowerCase (). indexOf ( 'red' ) !== - 1 ) { return value === 'red' ; } return true ; }); var Toy = db . model ( 'Figure' , toySchema ); var update = { color : 'blue' , name : 'Red Power Ranger' }; var opts = { runValidators : true , context : 'query' }; Toy . update ({}, update , opts , function ( error ) { assert . ok ( error . errors [ 'color' ]); }); $unset \u00b6 \u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f\u7684\u53e6\u4e00\u4e2a\u5173\u952e\u533a\u522b\u4ec5\u5728\u66f4\u65b0\u4e2d\u6307\u5b9a\u7684\u8def\u5f84\u4e0a\u8fd0\u884c\u3002 \u4f8b\u5982\uff0c\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a\u66f4\u65b0\u64cd\u4f5c\u4e2d\u6ca1\u6709\u6307\u5b9a\u201cname\u201d\uff0c\u6240\u4ee5\u66f4\u65b0\u9a8c\u8bc1\u5c06\u6210\u529f\u3002 \u5f53\u4f7f\u7528\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c\u53ea\u6709\u5f53\u60a8\u8bd5\u56fe\u663e\u5f0f\u5730\u4f7f\u7528 $unset \u65f6\uff0c\u6240\u9700\u7684\u9a8c\u8bc1\u5668**\u5931\u8d25\u3002 JavaScript var kittenSchema = new Schema ({ name : { type : String , required : true }, age : Number }); var Kitten = db . model ( 'Kitten' , kittenSchema ); var update = { color : 'blue' }; var opts = { runValidators : true }; Kitten . update ({}, update , opts , function ( err ) { }); var unset = { $unset : { name : 1 } }; Kitten . update ({}, unset , opts , function ( err ) { assert . ok ( err ); assert . ok ( err . errors [ 'name' ]); }); \u6700\u540e\u4e00\u4e2a\u7ec6\u8282\u503c\u5f97\u6ce8\u610f\uff1a\u4ec5\u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f**\u8fd0\u884c\u5728\u4ee5\u4e0b\u66f4\u65b0\u64cd\u4f5c\u7b26\u4e0a\uff1a $set * $unset * $push (>= 4.8.0) * $addToSet (>= 4.8.0) * $pull (>= 4.12.0) * $pullAll (>= 4.12.0) \u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u66f4\u65b0\u4f1a\u6210\u529f\uff0c\u4e0d\u7ba1 number \u7684\u503c\u662f\u4ec0\u4e48\uff0c\u56e0\u4e3aupdate\u9a8c\u8bc1\u5668\u5ffd\u7565\u4e86 $inc \u3002 \u53e6\u5916\uff0c $push \uff0c $addToSet \uff0c $pull \u548c $pullAll \u9a8c\u8bc1\u4e0d\u4f1a**\u5728\u6570\u7ec4\u672c\u8eab\u4e0a\u8fd0\u884c\u4efb\u4f55\u9a8c\u8bc1\uff0c \u53ea\u6709\u6570\u7ec4\u7684\u5355\u4e2a\u5143\u7d20\u3002 JavaScript var testSchema = new Schema ({ number : { type : Number , max : 0 }, arr : [{ message : { type : String , maxLength : 10 } }] }); testSchema . path ( 'arr' ). validate ( function ( v ) { return v . length < 2 ; }); var Test = db . model ( 'Test' , testSchema ); var update = { $inc : { number : 1 } }; var opts = { runValidators : true }; Test . update ({}, update , opts , function ( error ) { update = { $push : [{ message : 'hello' }, { message : 'world' }] }; Test . update ({}, update , opts , function ( error ) { }); }); $push \u548c $addToSet \u00b6 4.8.0\u4e2d\u7684\u65b0\u589e\u529f\u80fd\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e5f\u5728 $push \u548c $addToSet \u4e0a\u8fd0\u884c JavaScript var testSchema = new Schema ({ numbers : [{ type : Number , max : 0 }], docs : [{ name : { type : String , required : true } }] }); var Test = db . model ( 'TestPush' , testSchema ); var update = { $push : { numbers : 1 , docs : { name : null } } }; var opts = { runValidators : true }; Test . update ({}, update , opts , function ( error ) { assert . ok ( error . errors [ 'numbers' ]); assert . ok ( error . errors [ 'docs' ]); });","title":"\u9a8c\u8bc1"},{"location":"guide/Validation/#_1","text":"Source","title":"\u9a8c\u8bc1"},{"location":"guide/Validation/#_2","text":"\u9a8c\u8bc1\u5728 SchemaType \u4e2d\u5b9a\u4e49 \u9a8c\u8bc1\u662f \u4e2d\u95f4\u4ef6 . \u5728\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cMongoose\u5c06\u9a8c\u8bc1\u6ce8\u518c\u4e3a\u6bcf\u4e2a\u6a21\u5f0f\u7684\u201cpre\u201d\uff08'save'\uff09`\u94a9\u5b50\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 doc.validate\uff08callback\uff09 \u6216 doc.validateSync\uff08\uff09 \u624b\u52a8\u8fd0\u884c\u9a8c\u8bc1 \u9a8c\u8bc1\u5668\u4e0d\u5728\u672a\u5b9a\u4e49\u7684\u503c\u4e0a\u8fd0\u884c\u3002 \u552f\u4e00\u7684\u4f8b\u5916\u662f required validator \u3002 \u9a8c\u8bc1\u662f\u5f02\u6b65\u9012\u5f52\u7684; \u5f53\u4f60\u8c03\u7528 Model\uff03save , \u5b50\u6587\u6863\u9a8c\u8bc1\u4e5f\u88ab\u6267\u884c. \u5982\u679c\u53d1\u751f\u9519\u8bef\uff0c\u4f60\u7684 Model\uff03save \u56de\u8c03\u63a5\u6536\u5230\u5b83 \u9a8c\u8bc1\u662f\u53ef\u5b9a\u5236\u7684 JavaScript var schema = new Schema ({ name : { type : String , required : true } }); var Cat = db . model ( 'Cat' , schema ); var cat = new Cat (); cat . save ( function ( error ) { assert . equal ( error . errors [ 'name' ]. message , 'Path `name` is required.' ); error = cat . validateSync (); assert . equal ( error . errors [ 'name' ]. message , 'Path `name` is required.' ); });","title":"\u9a8c\u8bc1\u8bed\u6cd5\u89c4\u5219"},{"location":"guide/Validation/#_3","text":"\u6240\u6709\u7684 SchemaTypes \u90fd\u6709\u5185\u7f6e\u7684 required \u9a8c\u8bc1\u5668. \u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f\u4f7f\u7528 SchemaType \u7684 checkRequired() \u51fd\u6570\u6765\u786e\u5b9a\u8be5\u503c\u662f\u5426\u6ee1\u8db3\u6240\u9700\u7684\u9a8c\u8bc1\u7a0b\u5e8f Numbers \u6709 min \u548c max \u9a8c\u8bc1\u5668. Strings \u6709 enum , match , maxlength \u4f55 minlength \u9a8c\u8bc1\u5668. \u4e0a\u9762\u7684\u6bcf\u4e2a\u9a8c\u8bc1\u5668\u94fe\u63a5\u90fd\u63d0\u4f9b\u4e86\u6709\u5173\u5982\u4f55\u542f\u7528\u5b83\u4eec\u5e76\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u66f4\u591a\u4fe1\u606f. JavaScript var breakfastSchema = new Schema ({ eggs : { type : Number , min : [ 6 , 'Too few eggs' ], max : 12 }, bacon : { type : Number , required : [ true , 'Why no bacon?' ] }, drink : { type : String , enum : [ 'Coffee' , 'Tea' ], required : function () { return this . bacon > 3 ; } } }); var Breakfast = db . model ( 'Breakfast' , breakfastSchema ); var badBreakfast = new Breakfast ({ eggs : 2 , bacon : 0 , drink : 'Milk' }); var error = badBreakfast . validateSync (); assert . equal ( error . errors [ 'eggs' ]. message , 'Too few eggs' ); assert . ok ( ! error . errors [ 'bacon' ]); assert . equal ( error . errors [ 'drink' ]. message , '`Milk` is not a valid enum value for path `drink`.' ); badBreakfast . bacon = 5 ; badBreakfast . drink = null ; error = badBreakfast . validateSync (); assert . equal ( error . errors [ 'drink' ]. message , 'Path `drink` is required.' ); badBreakfast . bacon = null ; error = badBreakfast . validateSync (); assert . equal ( error . errors [ 'bacon' ]. message , 'Why no bacon?' );","title":"\u5185\u7f6e\u9a8c\u8bc1\u5668"},{"location":"guide/Validation/#unique","text":"\u5bf9\u4e8e\u521d\u5b66\u8005\u6765\u8bf4\uff0c\u4e00\u4e2a\u5e38\u89c1\u7684\u95ee\u9898\u662f\u6a21\u5f0f\u7684 unique \u9009\u9879\u4e0d\u662f\u9a8c\u8bc1\u5668\u3002 \u8fd9\u662f\u6784\u5efa MongoDB\u72ec\u7279\u7d22\u5f15 \u7684\u4fbf\u5229\u5e2e\u624b\u3002 \u8bf7\u53c2\u9605 \u5e38\u89c1\u95ee\u9898 \u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 JavaScript var uniqueUsernameSchema = new Schema ({ username : { type : String , unique : true } }); var U1 = db . model ( 'U1' , uniqueUsernameSchema ); var U2 = db . model ( 'U2' , uniqueUsernameSchema ); var dup = [{ username : 'Val' }, { username : 'Val' }]; U1 . create ( dup , function ( error ) { }); U2 . once ( 'index' , function ( error ) { assert . ifError ( error ); U2 . create ( dup , function ( error ) { assert . ok ( error ); assert . ok ( ! error . errors ); assert . ok ( error . message . indexOf ( 'duplicate key error' ) !== - 1 ); }); }); U2 . init (). then ( function () { U2 . create ( dup , function ( error ) { assert . ok ( error ); assert . ok ( ! error . errors ); assert . ok ( error . message . indexOf ( 'duplicate key error' ) !== - 1 ); }); });","title":"unique"},{"location":"guide/Validation/#_4","text":"\u5982\u679c\u5185\u7f6e\u7684\u9a8c\u8bc1\u5668\u662f\u4e0d\u591f\u7684, \u60a8\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4ee5\u6ee1\u8db3\u60a8\u7684\u9700\u6c42. \u81ea\u5b9a\u4e49\u9a8c\u8bc1\u662f\u901a\u8fc7\u4f20\u9012\u9a8c\u8bc1\u51fd\u6570\u6765\u58f0\u660e\u7684. \u4f60\u53ef\u4ee5\u627e\u5230\u8be6\u7ec6\u7684\u8bf4\u660e \u5173\u4e8e\u5982\u4f55\u5728 SchemaType\uff03validate()API\u6587\u6863 \u4e2d\u505a\u5230\u8fd9\u4e00\u70b9. JavaScript var userSchema = new Schema ({ phone : { type : String , validate : { validator : function ( v ) { return /d{3}-d{3}-d{4}/ . test ( v ); }, message : '{VALUE} is not a valid phone number!' }, required : [ true , 'User phone number required' ] } }); var User = db . model ( 'user' , userSchema ); var user = new User (); var error ; user . phone = '555.0123' ; error = user . validateSync (); assert . equal ( error . errors [ 'phone' ]. message , '555.0123 is not a valid phone number!' ); user . phone = '' ; error = user . validateSync (); assert . equal ( error . errors [ 'phone' ]. message , 'User phone number required' ); user . phone = '201-555-0123' ; error = user . validateSync (); assert . equal ( error , null );","title":"\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668"},{"location":"guide/Validation/#_5","text":"\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e5f\u53ef\u4ee5\u662f\u5f02\u6b65\u7684\u3002\u5982\u679c\u4f60\u7684\u9a8c\u8bc1\u5668\u51fd\u6570\u6709\u4e24\u4e2a\u53c2\u6570\uff0c\u732b\u9f2c\u4f1a\u5047\u8bbe\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u56de\u8c03\u3002 \u5373\u4f7f\u4f60\u4e0d\u60f3\u4f7f\u7528\u5f02\u6b65\u9a8c\u8bc1\u5668\uff0c\u4e5f\u8981\u5c0f\u5fc3\uff0c\u56e0\u4e3amongoose 4\u4f1a\u5047\u8bbe**\u6240\u6709\u5e26\u67092\u4e2a\u53c2\u6570\u7684\u51fd\u6570\u90fd\u662f\u5f02\u6b65\u7684\uff0c\u6bd4\u5982 validator.isEmail \u51fd\u6570 \u3002 \u8fd9\u79cd\u884c\u4e3a\u4ece4.9.0\u5f00\u59cb\u88ab\u89c6\u4e3a\u5f03\u7528\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e0a\u6307\u5b9a\u201cisAsync\uff1afalse\u201d\u6765\u5173\u95ed\u5b83\u3002 JavaScript var userSchema = new Schema ({ phone : { type : String , validate : { isAsync : true , validator : function ( v , cb ) { setTimeout ( function () { var phoneRegex = /d{3}-d{3}-d{4}/ ; var msg = v + ' is not a valid phone number!' ; cb ( phoneRegex . test ( v ), msg ); }, 5 ); }, message : 'Default error message' }, required : [ true , 'User phone number required' ] }, name : { type : String , validate : function ( v ) { return new Promise ( function ( resolve , reject ) { setTimeout ( function () { resolve ( false ); }, 5 ); }); } } }); var User = db . model ( 'User' , userSchema ); var user = new User (); var error ; user . phone = '555.0123' ; user . name = 'test' ; user . validate ( function ( error ) { assert . ok ( error ); assert . equal ( error . errors [ 'phone' ]. message , '555.0123 is not a valid phone number!' ); assert . equal ( error . errors [ 'name' ]. message , 'Validator failed for path `name` with value `test`' ); });","title":"\u56de\u8c03"},{"location":"guide/Validation/#_6","text":"\u9a8c\u8bc1\u5931\u8d25\u540e\u8fd4\u56de\u7684\u9519\u8bef\u5305\u542b error \u5bf9\u8c61\uff0c\u5176\u503c\u662f ValidatorError \u5bf9\u8c61\u3002 \u6bcf\u4e2a ValidatorError \u90fd\u6709 kind \uff0c path \uff0c value , \u548c message \u5c5e\u6027. \u4e00\u4e2a ValidatorError \u4e5f\u53ef\u80fd\u6709\u4e00\u4e2a reason \u5c5e\u6027\u3002 \u5982\u679c\u5728\u9a8c\u8bc1\u5668\u4e2d\u53d1\u751f\u9519\u8bef\uff0c \u8fd9\u4e2a\u5c5e\u6027\u5c06\u5305\u542b\u629b\u51fa\u7684\u9519\u8bef\u3002 JavaScript var toySchema = new Schema ({ color : String , name : String }); var validator = function ( value ) { return /red|white|gold/i . test ( value ); }; toySchema . path ( 'color' ). validate ( validator , 'Color `{VALUE}` not valid' , 'Invalid color' ); toySchema . path ( 'name' ). validate ( function ( v ) { if ( v !== 'Turbo Man' ) { throw new Error ( 'Need to get a Turbo Man for Christmas' ); } return true ; }, 'Name `{VALUE}` is not valid' ); var Toy = db . model ( 'Toy' , toySchema ); var toy = new Toy ({ color : 'Green' , name : 'Power Ranger' }); toy . save ( function ( err ) { assert . equal ( err . errors . color . message , 'Color `Green` not valid' ); assert . equal ( err . errors . color . kind , 'Invalid color' ); assert . equal ( err . errors . color . path , 'color' ); assert . equal ( err . errors . color . value , 'Green' ); assert . equal ( err . errors . name . message , 'Need to get a Turbo Man for Christmas' ); assert . equal ( err . errors . name . value , 'Power Ranger' ); assert . equal ( err . errors . name . reason . message , 'Need to get a Turbo Man for Christmas' ); assert . equal ( err . name , 'ValidationError' ); });","title":"\u8fd4\u56de\u9519\u8bef"},{"location":"guide/Validation/#_7","text":"\u5728\u732b\u9f2c\u7684\u5d4c\u5957\u5bf9\u8c61\u5b9a\u4e49\u9a8c\u8bc1\u662f\u68d8\u624b\u7684\uff0c \u56e0\u4e3a\u5d4c\u5957\u7684\u5bf9\u8c61\u4e0d\u662f\u5b8c\u5168\u6210\u719f\u7684\u8def\u5f84\u3002 JavaScript var personSchema = new Schema ({ name : { first : String , last : String } }); assert . throws ( function () { personSchema . path ( 'name' ). required ( true ); }, /Cannot.*'required'/ ); var nameSchema = new Schema ({ first : String , last : String }); personSchema = new Schema ({ name : { type : nameSchema , required : true } }); var Person = db . model ( 'Person' , personSchema ); var person = new Person (); var error = person . validateSync (); assert . ok ( error . errors [ 'name' ]); \u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u60a8\u4e86\u89e3\u4e86\u6587\u6863\u9a8c\u8bc1\u3002 Mongoose also supports validation for update() and findOneAndUpdate() operations. In Mongoose 4.x, update validators are off by default - you need to specify the runValidators option. \u8981\u6253\u5f00\u66f4\u65b0\u9a8c\u8bc1\u5668\uff0c\u4e3a update\uff08\uff09 \u6216 findOneAndUpdate\uff08\uff09 \u8bbe\u7f6e runValidators \u9009\u9879\u3002 \u5c0f\u5fc3\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u9ed8\u8ba4\u5173\u95ed\uff0c\u56e0\u4e3a\u4ed6\u4eec\u6709\u51e0\u4e2a\u8b66\u544a\u3002 JavaScript var toySchema = new Schema ({ color : String , name : String }); var Toy = db . model ( 'Toys' , toySchema ); Toy . schema . path ( 'color' ). validate ( function ( value ) { return /blue|green|white|red|orange|periwinkle/i . test ( value ); }, 'Invalid color' ); var opts = { runValidators : true }; Toy . update ({}, { color : 'bacon' }, opts , function ( err ) { assert . equal ( err . errors . color . message , 'Invalid color' ); }); \u66f4\u65b0\u9a8c\u8bc1\u5668\u548c\u6587\u6863\u9a8c\u8bc1\u5668\u4e4b\u95f4\u6709\u51e0\u4e2a\u5173\u952e\u7684\u533a\u522b\u3002 \u5728\u4e0a\u9762\u7684\u989c\u8272\u9a8c\u8bc1\u529f\u80fd\u4e2d\uff0c this \u662f\u6307\u5728\u4f7f\u7528\u6587\u6863\u9a8c\u8bc1\u65f6\u6b63\u5728\u9a8c\u8bc1\u7684\u6587\u6863\u3002 \u4f46\u662f\uff0c\u5f53\u8fd0\u884c\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c \u6b63\u5728\u66f4\u65b0\u7684\u6587\u6863\u53ef\u80fd\u4e0d\u5728\u670d\u52a1\u5668\u7684\u5185\u5b58\u4e2d\uff0c\u6240\u4ee5\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u201cthis\u201d\u7684\u503c\u6ca1\u6709\u88ab\u5b9a\u4e49\u3002 JavaScript var toySchema = new Schema ({ color : String , name : String }); toySchema . path ( 'color' ). validate ( function ( value ) { if ( this . name . toLowerCase (). indexOf ( 'red' ) !== - 1 ) { return value !== 'red' ; } return true ; }); var Toy = db . model ( 'ActionFigure' , toySchema ); var toy = new Toy ({ color : 'red' , name : 'Red Power Ranger' }); var error = toy . validateSync (); assert . ok ( error . errors [ 'color' ]); var update = { color : 'red' , name : 'Red Power Ranger' }; var opts = { runValidators : true }; Toy . update ({}, update , opts , function ( error ) { assert . ok ( error ); });","title":"\u5d4c\u5957\u5bf9\u8c61"},{"location":"guide/Validation/#context","text":"context \u9009\u9879\u53ef\u4ee5\u8ba9\u4f60\u5728\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e2d\u5c06 this \u7684\u503c\u8bbe\u7f6e\u4e3a\u5e95\u5c42\u67e5\u8be2\u3002 JavaScript toySchema . path ( 'color' ). validate ( function ( value ) { if ( this . getUpdate (). $set . name . toLowerCase (). indexOf ( 'red' ) !== - 1 ) { return value === 'red' ; } return true ; }); var Toy = db . model ( 'Figure' , toySchema ); var update = { color : 'blue' , name : 'Red Power Ranger' }; var opts = { runValidators : true , context : 'query' }; Toy . update ({}, update , opts , function ( error ) { assert . ok ( error . errors [ 'color' ]); });","title":"context"},{"location":"guide/Validation/#unset","text":"\u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f\u7684\u53e6\u4e00\u4e2a\u5173\u952e\u533a\u522b\u4ec5\u5728\u66f4\u65b0\u4e2d\u6307\u5b9a\u7684\u8def\u5f84\u4e0a\u8fd0\u884c\u3002 \u4f8b\u5982\uff0c\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u56e0\u4e3a\u66f4\u65b0\u64cd\u4f5c\u4e2d\u6ca1\u6709\u6307\u5b9a\u201cname\u201d\uff0c\u6240\u4ee5\u66f4\u65b0\u9a8c\u8bc1\u5c06\u6210\u529f\u3002 \u5f53\u4f7f\u7528\u66f4\u65b0\u9a8c\u8bc1\u5668\u65f6\uff0c\u53ea\u6709\u5f53\u60a8\u8bd5\u56fe\u663e\u5f0f\u5730\u4f7f\u7528 $unset \u65f6\uff0c\u6240\u9700\u7684\u9a8c\u8bc1\u5668**\u5931\u8d25\u3002 JavaScript var kittenSchema = new Schema ({ name : { type : String , required : true }, age : Number }); var Kitten = db . model ( 'Kitten' , kittenSchema ); var update = { color : 'blue' }; var opts = { runValidators : true }; Kitten . update ({}, update , opts , function ( err ) { }); var unset = { $unset : { name : 1 } }; Kitten . update ({}, unset , opts , function ( err ) { assert . ok ( err ); assert . ok ( err . errors [ 'name' ]); }); \u6700\u540e\u4e00\u4e2a\u7ec6\u8282\u503c\u5f97\u6ce8\u610f\uff1a\u4ec5\u66f4\u65b0\u9a8c\u8bc1\u7a0b\u5e8f**\u8fd0\u884c\u5728\u4ee5\u4e0b\u66f4\u65b0\u64cd\u4f5c\u7b26\u4e0a\uff1a $set * $unset * $push (>= 4.8.0) * $addToSet (>= 4.8.0) * $pull (>= 4.12.0) * $pullAll (>= 4.12.0) \u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u66f4\u65b0\u4f1a\u6210\u529f\uff0c\u4e0d\u7ba1 number \u7684\u503c\u662f\u4ec0\u4e48\uff0c\u56e0\u4e3aupdate\u9a8c\u8bc1\u5668\u5ffd\u7565\u4e86 $inc \u3002 \u53e6\u5916\uff0c $push \uff0c $addToSet \uff0c $pull \u548c $pullAll \u9a8c\u8bc1\u4e0d\u4f1a**\u5728\u6570\u7ec4\u672c\u8eab\u4e0a\u8fd0\u884c\u4efb\u4f55\u9a8c\u8bc1\uff0c \u53ea\u6709\u6570\u7ec4\u7684\u5355\u4e2a\u5143\u7d20\u3002 JavaScript var testSchema = new Schema ({ number : { type : Number , max : 0 }, arr : [{ message : { type : String , maxLength : 10 } }] }); testSchema . path ( 'arr' ). validate ( function ( v ) { return v . length < 2 ; }); var Test = db . model ( 'Test' , testSchema ); var update = { $inc : { number : 1 } }; var opts = { runValidators : true }; Test . update ({}, update , opts , function ( error ) { update = { $push : [{ message : 'hello' }, { message : 'world' }] }; Test . update ({}, update , opts , function ( error ) { }); });","title":"$unset"},{"location":"guide/Validation/#pushaddtoset","text":"4.8.0\u4e2d\u7684\u65b0\u589e\u529f\u80fd\uff1a\u66f4\u65b0\u9a8c\u8bc1\u5668\u4e5f\u5728 $push \u548c $addToSet \u4e0a\u8fd0\u884c JavaScript var testSchema = new Schema ({ numbers : [{ type : Number , max : 0 }], docs : [{ name : { type : String , required : true } }] }); var Test = db . model ( 'TestPush' , testSchema ); var update = { $push : { numbers : 1 , docs : { name : null } } }; var opts = { runValidators : true }; Test . update ({}, update , opts , function ( error ) { assert . ok ( error . errors [ 'numbers' ]); assert . ok ( error . errors [ 'docs' ]); });","title":"$push\u548c$addToSet"},{"location":"model/api/","text":"\u6a21\u578b \u00b6 Model() \u00b6 \u53c2\u6570 doc \u00abObject\u00bb values with which to create the document Model constructor Provides the interface to MongoDB collections as well as creates document instances. Model.prototype.db \u00b6 Connection the model uses. Model.prototype.collection \u00b6 Collection the model uses. Model.prototype.modelName \u00b6 Model.prototype.$where \u00b6 Additional properties to attach to the query when calling save() and isNew is false. Model.prototype.baseModelName \u00b6 If this is a discriminator model, baseModelName is the name of the base model. Model.prototype.save() \u00b6 \u53c2\u6570 [fn] \u00abFunction\u00bb optional callback \u8fd4\u56de Saves this document. \u793a\u4f8b product . sold = Date . now () ; product . save ( function ( err , product ) { if ( err ) .. } ) The callback will receive three parameters err if an error occurred product which is the saved product As an extra measure of flow control, save will return a Promise. \u793a\u4f8b product . save () . then ( function ( product ) { ... } ) ; Model.prototype.increment() \u00b6 Signal that we desire an increment of this documents version. \u793a\u4f8b Model.findById(id, function (err, doc) { doc.increment(); doc.save(function (err) { .. }) }) Model.prototype.remove() \u00b6 \u53c2\u6570 [fn] \u00abfunction(err,product)\u00bb optional callback \u8fd4\u56de Removes this document from the db. \u793a\u4f8b product . remove ( function ( err , product ) { if ( err ) return handleError ( err ) ; Product . findById ( product . _id , function ( err , product ) { console . log ( product ) } ) } ) As an extra measure of flow control, remove will return a Promise (bound to fn if passed) so it could be chained, or hooked to recive errors \u793a\u4f8b product . remove () . then ( function ( product ) { ... } ) . catch ( function ( err ) { assert . ok ( err ) } ) Model.prototype.model() \u00b6 \u53c2\u6570 name \u00abString\u00bb model name Returns another Model instance. \u793a\u4f8b var doc = new Tank ; doc . model ( 'User' ) . findById ( id , callback ); Model.discriminator() \u00b6 \u53c2\u6570 schema \u00abSchema\u00bb discriminator model schema Adds a discriminator type. \u793a\u4f8b function BaseSchema () { Schema . apply ( this , arguments ); this . add ({ name : String , createdAt : Date }); } util . inherits ( BaseSchema , Schema ); var PersonSchema = new BaseSchema (); var BossSchema = new BaseSchema ({ department : String }); var Person = mongoose . model ( 'Person' , PersonSchema ); var Boss = Person . discriminator ( 'Boss' , BossSchema ); Model.init() \u00b6 \u53c2\u6570 Performs any async initialization of this model against MongoDB. Currently, this function is only responsible for building [indexes, unless [ autoIndex is turned off. This function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to MyModel.on('index') \u793a\u4f8b var eventSchema = new Schema ({ thing : { type : 'string' , unique : true }}) var Event = mongoose . model ( 'Event' , eventSchema ); Event . init () . then ( function ( Event ) { console . log ( 'Indexes are done building!' ); }); Model.ensureIndexes() \u00b6 \u53c2\u6570 [cb] \u00abFunction\u00bb optional callback \u8fd4\u56de Sends createIndex commands to mongo for each index declared in the schema. The createIndex commands are sent in series. \u793a\u4f8b Event . ensureIndexes ( function ( err ) { if ( err ) return handleError ( err ) ; } ) ; After completion, an index event is emitted on this Model passing an error if one occurred. \u793a\u4f8b var eventSchema = new Schema ({ thing : { type : 'string' , unique : true }}) var Event = mongoose . model ( 'Event' , eventSchema ); Event . on ( 'index' , function ( err ) { if ( err ) console . error ( err ); }) NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution. Model.createIndexes() \u00b6 \u53c2\u6570 [cb] \u00abFunction\u00bb optional callback \u8fd4\u56de Similar to ensureIndexes() , except for it uses the [ createIndex function. The ensureIndex() function checks to see if an index with that name already exists, and, if not, does not attempt to create the index. createIndex() bypasses this check. Model.prototype.schema \u00b6 Model.prototype.base \u00b6 Base Mongoose instance the model uses. Model.prototype.discriminators \u00b6 Registered discriminators for this model. Model.translateAliases() \u00b6 \u53c2\u6570 raw \u00abObject\u00bb fields/conditions that may contain aliased keys \u8fd4\u56de \u00abObject\u00bb the translated 'pure' fields/conditions Translate any aliases fields/conditions so the final query or document object is pure \u793a\u4f8b Character . find ( Character . translateAliases ( { ' \u540d ' : ' Eddard Stark ' } ) . exec ( function ( err , characters ) {} ) \u6ce8\u91ca Only translate arguments of object type anything else is returned raw Model.remove() \u00b6 \u53c2\u6570 \u8fd4\u56de Removes all documents that match conditions from the collection. To remove just the first document that matches conditions , set the single option to true. \u793a\u4f8b Character . remove ( { name : 'Eddard Stark' } , function ( err ) {} ); \u6ce8\u91ca This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, no middleware (hooks) are executed . Model.deleteOne() \u00b6 \u53c2\u6570 \u8fd4\u56de Deletes the first document that matches conditions from the collection. Behaves like remove() , but deletes at most one document regardless of the single option. \u793a\u4f8b Character . deleteOne ( { name : 'Eddard Stark' } , function ( err ) {} ); \u6ce8\u91ca Like Model.remove() , this function does not trigger pre('remove') or post('remove') hooks. Model.deleteMany() \u00b6 \u53c2\u6570 \u8fd4\u56de Deletes all of the documents that match conditions from the collection. Behaves like remove() , but deletes all documents that match conditions regardless of the single option. \u793a\u4f8b Character . deleteMany ( { name : / Stark / , age : { $ gte : 18 } } , function ( err ) {} ); \u6ce8\u91ca Like Model.remove() , this function does not trigger pre('remove') or post('remove') hooks. Model.find() \u00b6 \u53c2\u6570 \u8fd4\u56de Finds documents The conditions are cast to their respective SchemaTypes before the command is sent. \u793a\u4f8b MyModel . find ({ name : 'john' , age : { $ gte : 18 }}); MyModel . find ({ name : 'john' , age : { $ gte : 18 }}, function ( err , docs ) {}); MyModel . find ({ name : / john / i }, 'name friends' , function ( err , docs ) { }) MyModel . find ({ name : / john / i }, null , { skip : 10 }) MyModel . find ({ name : / john / i }, null , { skip : 10 }, function ( err , docs ) {}); var query = MyModel . find ({ name : / john / i }, null , { skip : 10 }) query . exec ( function ( err , docs ) {}); var query = MyModel . find ({ name : / john / i }, null , { skip : 10 }); var promise = query . exec (); promise . addBack ( function ( err , docs ) {}); Model.findById() \u00b6 \u53c2\u6570 \u8fd4\u56de Finds a single document by its _id field. findById(id) is almost* equivalent to findOne({ _id: id }) . If you want to query by a document's _id , use findById() instead of findOne() . The id is cast based on the Schema before sending the command. This function triggers the following middleware. Except for how it treats undefined . If you use findOne() , you'll see that findOne(undefined) and findOne({ _id: undefined }) are equivalent to findOne({}) and return arbitrary documents. However, mongoose translates findById(undefined) into findOne({ _id: null }) . \u793a\u4f8b Adventure . findById ( id , function ( err , adventure ) {} ); Adventure . findById ( id ) . exec ( callback ); Adventure . findById ( id , 'name length' , function ( err , adventure ) {} ); Adventure . findById ( id , 'name length' ) . exec ( callback ); Adventure . findById ( id , '-length' ) . exec ( function ( err , adventure ) {} ); Adventure . findById ( id , 'name' , { lean : true } , function ( err , doc ) {} ); Adventure . findById ( id , 'name' ) . lean () . exec ( function ( err , doc ) {} ); Model.findOne() \u00b6 \u53c2\u6570 \u8fd4\u56de Finds one document. The conditions are cast to their respective SchemaTypes before the command is sent. Note: conditions is optional, and if conditions is null or undefined, mongoose will send an empty findOne command to MongoDB, which will return an arbitrary document. If you're querying by _id , use findById() instead. \u793a\u4f8b Adventure . findOne ( { type : 'iphone' } , function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } ) . exec ( function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } , 'name' , function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } , 'name' ) . exec ( function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } , 'name' , { lean : true } , callback ); Adventure . findOne ( { type : 'iphone' } , 'name' , { lean : true } ) . exec ( callback ); Adventure . findOne ( { type : 'iphone' } ) . select ( 'name' ) . lean () . exec ( callback ); Model.count() \u00b6 \u53c2\u6570 \u8fd4\u56de Counts number of matching documents in a database collection. \u793a\u4f8b Adventure . count ( { type : 'jungle' } , function ( err , count ) { if (err) .. console.log('there are %d jungle adventures', count) ; } ); Model.distinct() \u00b6 \u53c2\u6570 \u8fd4\u56de Creates a Query for a distinct operation. Passing a callback immediately executes the query. \u793a\u4f8b Link . distinct ( 'url' , { clicks : { $ gt : 100 }}, function ( err , result ) { if ( err ) return handleError ( err ); assert ( Array . isArray ( result )); console . log ( 'unique urls with more than 100 clicks' , result ); }) var query = Link . distinct ( 'url' ); query . exec ( callback ); Model.where() \u00b6 \u53c2\u6570 [val] \u00abObject\u00bb optional value \u8fd4\u56de Creates a Query, applies the passed conditions, and returns the Query. For example, instead of writing: User . find ( { age : {$ gte : 21 , $ lte : 65 } } , callback ); we can instead write: User . where ( ' age ' ) . gte ( 21 ) . lte ( 65 ) . exec ( callback ) ; Since the Query class also supports where you can continue chaining User .where ( ' age ' ). gte ( 21 ). lte ( 65 ) .where ( ' name ' , /^ b / i ) ... etc Model.prototype.$where() \u00b6 \u53c2\u6570 argument \u00abString,Function\u00bb is a javascript string or anonymous function \u8fd4\u56de Creates a Query and specifies a $where condition. Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via find({ $where: javascript }) , or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model. Blog .$ where ( ' this.username.indexOf(\"val\") !== -1 ' ) . exec ( function ( err , docs ) {} ) ; Model.findOneAndUpdate() \u00b6 \u53c2\u6570 \u8fd4\u56de Issues a mongodb findAndModify update command. Finds a matching document, updates it according to the update arg, passing any options , and returns the found document (if any) to the callback. The query executes immediately if callback is passed else a Query object is returned. \u9009\u9879 new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0) upsert : bool - creates the object if it doesn't exist. defaults to false. fields : {Object|String} - Field selection. Equivalent to .select(fields).findOneAndUpdate() maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findOneAndUpdate(conditions, update, options, callback) A.findOneAndUpdate(conditions, update, options) A.findOneAndUpdate(conditions, update, callback) A.findOneAndUpdate(conditions, update) A.findOneAndUpdate() \u6ce8\u91ca All top level update keys which are not atomic operation names are treated as set operations: \u793a\u4f8b var query = { name : 'borne' }; Model . findOneAndUpdate ( query , { name : 'jason bourne' }, options , callback ) Model . findOneAndUpdate ( query , { $ set : { name : 'jason bourne' }}, options , callback ) This helps prevent accidentally overwriting your document with { name: 'jason bourne' } . \u6ce8\u91ca Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default. defaults. Use the setDefaultsOnInsert option to override. findAndModify helpers support limited validation. You can enable these by setting the runValidators options, respectively. If you need full-fledged validation, use the traditional approach of first retrieving the document. Model . findById ( id , function ( err , doc ) { if ( err ) .. doc . name = ' jason bourne ' ; doc . save ( callback ) ; } ) ; Model.findByIdAndUpdate() \u00b6 \u53c2\u6570 \u8fd4\u56de Issues a mongodb findAndModify update command by a document's _id field. findByIdAndUpdate(id, ...) is equivalent to findOneAndUpdate({ _id: id }, ...) . Finds a matching document, updates it according to the update arg, passing any options , and returns the found document (if any) to the callback. The query executes immediately if callback is passed else a Query object is returned. This function triggers the following middleware. \u9009\u9879 new : bool - true to return the modified document rather than the original. defaults to false upsert : bool - creates the object if it doesn't exist. defaults to false. runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update select : sets the document fields to return rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findByIdAndUpdate(id, update, options, callback) A.findByIdAndUpdate(id, update, options) A.findByIdAndUpdate(id, update, callback) A.findByIdAndUpdate(id, update) A.findByIdAndUpdate() \u6ce8\u91ca All top level update keys which are not atomic operation names are treated as set operations: \u793a\u4f8b Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback) Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback) This helps prevent accidentally overwriting your document with { name: 'jason bourne' } . \u6ce8\u91ca Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default. defaults. Use the setDefaultsOnInsert option to override. findAndModify helpers support limited validation. You can enable these by setting the runValidators options, respectively. If you need full-fledged validation, use the traditional approach of first retrieving the document. Model . findById ( id , function ( err , doc ) { if ( err ) .. doc . name = ' jason bourne ' ; doc . save ( callback ) ; } ) ; Model.findOneAndRemove() \u00b6 \u53c2\u6570 \u8fd4\u56de Issue a mongodb findAndModify remove command. Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if callback is passed else a Query object is returned. This function triggers the following middleware. \u9009\u9879 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 select : sets the document fields to return rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findOneAndRemove(conditions, options, callback) A.findOneAndRemove(conditions, options) A.findOneAndRemove(conditions, callback) A.findOneAndRemove(conditions) A.findOneAndRemove() Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default. defaults. Use the setDefaultsOnInsert option to override. findAndModify helpers support limited validation. You can enable these by setting the runValidators options, respectively. If you need full-fledged validation, use the traditional approach of first retrieving the document. Model . findById ( id , function ( err , doc ) { if ( err ) .. doc . name = ' jason bourne ' ; doc . save ( callback ) ; } ) ; Model.findByIdAndRemove() \u00b6 \u53c2\u6570 \u8fd4\u56de Issue a mongodb findAndModify remove command by a document's _id field. findByIdAndRemove(id, ...) is equivalent to findOneAndRemove({ _id: id }, ...) . Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if callback is passed, else a Query object is returned. This function triggers the following middleware. \u9009\u9879 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update select : sets the document fields to return rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findByIdAndRemove(id, options, callback) A.findByIdAndRemove(id, options) A.findByIdAndRemove(id, callback) A.findByIdAndRemove(id) A.findByIdAndRemove() Model.create() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb callback \u8fd4\u56de Shortcut for saving one or more documents to the database. MyModel.create(docs) does new MyModel(doc).save() for every doc in docs. This function triggers the following middleware. \u793a\u4f8b Candy . create ({ type : 'jelly bean' }, { type : 'snickers' }, function ( err , jellybean , snickers ) { if ( err ) }); var array = [{ type : 'jelly bean' }, { type : 'snickers' }]; Candy . create ( array , function ( err , candies ) { if ( err ) var jellybean = candies [ 0 ]; var snickers = candies [ 1 ]; }); var promise = Candy . create ({ type : 'jawbreaker' }); promise . then ( function ( jawbreaker ) { }) Model.watch() \u00b6 \u53c2\u6570 \u8fd4\u56de \u00abChangeStream\u00bb mongoose-specific change stream wrapper Requires a replica set running MongoDB >= 3.6.0. Watches the underlying collection for changes using [MongoDB change streams. This function does not trigger any middleware. In particular, it does not trigger aggregate middleware. \u793a\u4f8b const doc = await Person . create ({ name : 'Ned Stark' }); Person . watch () . on ( 'change' , change => console . log ( change )); await doc . remove (); Model.insertMany() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb callback \u8fd4\u56de Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than .create() because it only sends one operation to the server, rather than one for each document. Mongoose always validates each document before sending insertMany to MongoDB. So if one document has a validation error, no documents will be saved, unless you set [the ordered option to false. This function does not trigger save middleware. This function triggers the following middleware. \u793a\u4f8b var arr = [{ name : 'Star Wars' }, { name : 'The Empire Strikes Back' }]; Movies . insertMany ( arr , function ( error , docs ) {}); Model.bulkWrite() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb callback function(error, bulkWriteOpResult) {} \u8fd4\u56de \u00abPromise\u00bb resolves to a BulkWriteOpResult if the operation succeeds Sends multiple insertOne , updateOne , updateMany , replaceOne , deleteOne , and/or deleteMany operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use create() ) because with bulkWrite() there is only one round trip to MongoDB. Mongoose will perform casting on all operations you provide. This function does not trigger any middleware, not save() nor update() . If you need to trigger save() middleware for every document use [ create() instead. \u793a\u4f8b Character . bulkWrite ( [ { insertOne : { document : { name : 'Eddard Stark' , title : 'Warden of the North' } } }, { updateOne : { filter : { name : 'Eddard Stark' }, update : { title : 'Hand of the King' } } }, { deleteOne : { { filter : { name : 'Eddard Stark' } } } } ] ) . then ( handleResult ); Model.hydrate() \u00b6 \u53c2\u6570 \u8fd4\u56de \u00abModel\u00bb document instance Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially. \u793a\u4f8b var mongooseCandy = Candy . hydrate ({ _id : '54108337212ffb6d459f854c' , type : 'jelly bean' }); Model.update() \u00b6 \u53c2\u6570 \u8fd4\u56de Updates one document in the database without returning it. This function triggers the following middleware. \u793a\u4f8b MyModel . update ( { age : { $ gt : 18 } } , { oldEnough : true } , fn ); MyModel . update ( { name : 'Tobi' } , { ferret : true } , { multi : true } , function ( err , raw ) { if (err) return handleError(err) ; console.log('The raw response from Mongo was ', raw) ; } ); \u6709\u6548\u7684\u9009\u9879 safe (boolean) safe mode (defaults to value set in schema (true)) upsert (boolean) whether to create the doc if it doesn't match (false) multi (boolean) whether multiple documents should be updated (false) runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. strict (boolean) overrides the strict option for this update overwrite (boolean) disables update-only mode, allowing you to overwrite the doc (false) All update values are cast to their appropriate SchemaTypes before being sent. The callback function receives (err, rawResponse) . err is the error if any occurred rawResponse is the full response from Mongo \u6ce8\u91ca All top level keys which are not atomic operation names are treated as set operations: \u793a\u4f8b var query = { name : 'borne' }; Model . update ( query , { name : 'jason bourne' }, options , callback ) Model . update ( query , { $ set : { name : 'jason bourne' }}, options , callback ) This helps prevent accidentally overwriting all documents in your collection with { name: 'jason bourne' } . \u6ce8\u91ca Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error. \u6ce8\u91ca To update documents without waiting for a response from MongoDB, do not pass a callback , then call exec on the returned [Query: Comment . update ( { _id : id } , { $ set : { text : 'changed' } } ) . exec (); \u6ce8\u91ca Although values are casted to their appropriate types when using update, the following are not applied: defaults setters validators middleware If you need those features, use the traditional approach of first retrieving the document. Model . findOne ( { name : 'borne' } , function ( err , doc ) { if (err) .. doc.name = 'jason bourne' ; doc.save(callback) ; } ) Model.updateMany() \u00b6 \u53c2\u6570 \u8fd4\u56de Same as update() , except MongoDB will update all documents that match criteria (as opposed to just the first one) regardless of the value of the multi option. Note updateMany will not fire update middleware. Use pre('updateMany') and post('updateMany') instead. This function triggers the following middleware. Model.updateOne() \u00b6 \u53c2\u6570 \u8fd4\u56de Same as update() , except MongoDB will update only the first document that matches criteria regardless of the value of the multi option. This function triggers the following middleware. Model.replaceOne() \u00b6 \u53c2\u6570 \u8fd4\u56de Same as update() , except MongoDB replace the existing document with the given document (no atomic operators like $set ). This function triggers the following middleware. Model.mapReduce() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional callback \u8fd4\u56de Executes a mapReduce command. o is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation for more detail about options. This function does not trigger any middleware. \u793a\u4f8b var o = {}; o . map = function () { emit ( this . name , 1 ) } o . reduce = function ( k , vals ) { return vals . length } User . mapReduce ( o , function ( err , results ) { console . log ( results ) }) \u5176\u4ed6\u9009\u9879 query {Object} query filter object. sort {Object} sort input objects using this key limit {Number} max number of documents keeptemp {Boolean, default:false} keep temporary data finalize {Function} finalize function scope {Object} scope variables exposed to map/reduce/finalize during execution jsMode {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X verbose {Boolean, default:false} provide statistics on job execution time. readPreference {String} out* {Object, default: {inline:1}} sets the output target for the map reduce job. \u8f93\u51fa\u9009\u9879 {inline:1} the results are returned in an array {replace: 'collectionName'} add the results to collectionName: the results replace the collection {reduce: 'collectionName'} add the results to collectionName: if dups are detected, uses the reducer / finalize functions {merge: 'collectionName'} add the results to collectionName: if dups exist the new docs overwrite the old If options.out is set to replace , merge , or reduce , a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the lean option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc). \u793a\u4f8b var o = {}; o . map = function () { emit ( this . name , 1 ) } o . reduce = function ( k , vals ) { return vals . length } o . out = { replace : 'createdCollectionNameForResults' } o . verbose = true ; User . mapReduce ( o , function ( err , model , stats ) { console . log ( 'map reduce took %d ms' , stats . processtime ) model . find () . where ( 'value' ) . gt ( 10 ) . exec ( function ( err , docs ) { console . log ( docs ); }); }) o . resolveToObject = true ; var promise = User . mapReduce ( o ); promise . then ( function ( res ) { var model = res . model ; var stats = res . stats ; console . log ( 'map reduce took %d ms' , stats . processtime ) return model . find () . where ( 'value' ) . gt ( 10 ) . exec (); }) . then ( function ( docs ) { console . log ( docs ); }) . then ( null , handleError ) . end () Model.aggregate() \u00b6 \u53c2\u6570 \u8fd4\u56de Performs [aggregations on the models collection. If a callback is passed, the aggregate is executed and a Promise is returned. If a callback is not passed, the aggregate itself is returned. This function does not trigger any middleware. \u793a\u4f8b Users . aggregate ( { $group : { _id: null , maxBalance: { $max : ' $balance ' }}}, { $project : { _id: 0 , maxBalance: 1 }}, function ( err , res ) { if ( err ) return handleError ( err ); console . log ( res ); }); Users . aggregate () . group ({ _id: null , maxBalance: { $max : ' $balance ' } }) . select (' - id maxBalance ') . exec ( function ( err , res ) { if ( err ) return handleError ( err ); console . log ( res ); }); \u6ce8\u91ca Arguments are not cast to the model's schema because $project operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned). Requires MongoDB >= 2.1 Model.geoSearch() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional callback \u8fd4\u56de Implements $geoSearch functionality for Mongoose This function does not trigger any middleware \u793a\u4f8b var options = { near : [ 10 , 10 ], maxDistance : 5 }; Locations . geoSearch ({ type : \"house\" }, options , function ( err , res ) { console . log ( res ); }); \u9009\u9879 near {Array} x,y point to search for maxDistance {Number} the maximum distance from the point near that a result can be limit {Number} The maximum number of results to return lean {Boolean} return the raw object instead of the Mongoose Model Model.populate() \u00b6 \u53c2\u6570 [callback(err,doc)] \u00abFunction\u00bb Optional callback, executed upon completion. Receives err and the doc(s) . \u8fd4\u56de Populates document references. \u53ef\u7528\u7684\u9009\u9879 path: space delimited path(s) to populate select: optional fields to select match: optional query conditions to match model: optional name of the model to use for population options: optional query options like sort, limit, etc \u793a\u4f8b User . findById ( id , function ( err , user ) { var opts = [ { path : 'company' , match : { x : 1 }, select : 'name' } , { path : 'notes' , options : { limit : 10 }, model : 'override' } ] User . populate ( user , opts , function ( err , user ) { console . log ( user ); }); }); User . find ( match , function ( err , users ) { var opts = [{ path : 'company' , match : { x : 1 }, select : 'name' }] var promise = User . populate ( users , opts ); promise . then ( console . log ) . end (); }) var user = { name : 'Indiana Jones' , weapon : 389 } Weapon . populate ( user , { path : 'weapon' , model : 'Weapon' }, function ( err , user ) { console . log ( user . weapon . name ) }) var users = [{ name : 'Indiana Jones' , weapon : 389 }] users . push ({ name : 'Batman' , weapon : 8921 }) Weapon . populate ( users , { path : 'weapon' }, function ( err , users ) { users . forEach ( function ( user ) { console . log ( ' %s uses a %s ' , users . name , user . weapon . name ) }); });","title":"\u6a21\u578bAPI"},{"location":"model/api/#_1","text":"","title":"\u6a21\u578b"},{"location":"model/api/#model","text":"\u53c2\u6570 doc \u00abObject\u00bb values with which to create the document Model constructor Provides the interface to MongoDB collections as well as creates document instances.","title":"Model()"},{"location":"model/api/#modelprototypedb","text":"Connection the model uses.","title":"Model.prototype.db"},{"location":"model/api/#modelprototypecollection","text":"Collection the model uses.","title":"Model.prototype.collection"},{"location":"model/api/#modelprototypemodelname","text":"","title":"Model.prototype.modelName"},{"location":"model/api/#modelprototypewhere","text":"Additional properties to attach to the query when calling save() and isNew is false.","title":"Model.prototype.$where"},{"location":"model/api/#modelprototypebasemodelname","text":"If this is a discriminator model, baseModelName is the name of the base model.","title":"Model.prototype.baseModelName"},{"location":"model/api/#modelprototypesave","text":"\u53c2\u6570 [fn] \u00abFunction\u00bb optional callback \u8fd4\u56de Saves this document. \u793a\u4f8b product . sold = Date . now () ; product . save ( function ( err , product ) { if ( err ) .. } ) The callback will receive three parameters err if an error occurred product which is the saved product As an extra measure of flow control, save will return a Promise. \u793a\u4f8b product . save () . then ( function ( product ) { ... } ) ;","title":"Model.prototype.save()"},{"location":"model/api/#modelprototypeincrement","text":"Signal that we desire an increment of this documents version. \u793a\u4f8b Model.findById(id, function (err, doc) { doc.increment(); doc.save(function (err) { .. }) })","title":"Model.prototype.increment()"},{"location":"model/api/#modelprototyperemove","text":"\u53c2\u6570 [fn] \u00abfunction(err,product)\u00bb optional callback \u8fd4\u56de Removes this document from the db. \u793a\u4f8b product . remove ( function ( err , product ) { if ( err ) return handleError ( err ) ; Product . findById ( product . _id , function ( err , product ) { console . log ( product ) } ) } ) As an extra measure of flow control, remove will return a Promise (bound to fn if passed) so it could be chained, or hooked to recive errors \u793a\u4f8b product . remove () . then ( function ( product ) { ... } ) . catch ( function ( err ) { assert . ok ( err ) } )","title":"Model.prototype.remove()"},{"location":"model/api/#modelprototypemodel","text":"\u53c2\u6570 name \u00abString\u00bb model name Returns another Model instance. \u793a\u4f8b var doc = new Tank ; doc . model ( 'User' ) . findById ( id , callback );","title":"Model.prototype.model()"},{"location":"model/api/#modeldiscriminator","text":"\u53c2\u6570 schema \u00abSchema\u00bb discriminator model schema Adds a discriminator type. \u793a\u4f8b function BaseSchema () { Schema . apply ( this , arguments ); this . add ({ name : String , createdAt : Date }); } util . inherits ( BaseSchema , Schema ); var PersonSchema = new BaseSchema (); var BossSchema = new BaseSchema ({ department : String }); var Person = mongoose . model ( 'Person' , PersonSchema ); var Boss = Person . discriminator ( 'Boss' , BossSchema );","title":"Model.discriminator()"},{"location":"model/api/#modelinit","text":"\u53c2\u6570 Performs any async initialization of this model against MongoDB. Currently, this function is only responsible for building [indexes, unless [ autoIndex is turned off. This function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to MyModel.on('index') \u793a\u4f8b var eventSchema = new Schema ({ thing : { type : 'string' , unique : true }}) var Event = mongoose . model ( 'Event' , eventSchema ); Event . init () . then ( function ( Event ) { console . log ( 'Indexes are done building!' ); });","title":"Model.init()"},{"location":"model/api/#modelensureindexes","text":"\u53c2\u6570 [cb] \u00abFunction\u00bb optional callback \u8fd4\u56de Sends createIndex commands to mongo for each index declared in the schema. The createIndex commands are sent in series. \u793a\u4f8b Event . ensureIndexes ( function ( err ) { if ( err ) return handleError ( err ) ; } ) ; After completion, an index event is emitted on this Model passing an error if one occurred. \u793a\u4f8b var eventSchema = new Schema ({ thing : { type : 'string' , unique : true }}) var Event = mongoose . model ( 'Event' , eventSchema ); Event . on ( 'index' , function ( err ) { if ( err ) console . error ( err ); }) NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.","title":"Model.ensureIndexes()"},{"location":"model/api/#modelcreateindexes","text":"\u53c2\u6570 [cb] \u00abFunction\u00bb optional callback \u8fd4\u56de Similar to ensureIndexes() , except for it uses the [ createIndex function. The ensureIndex() function checks to see if an index with that name already exists, and, if not, does not attempt to create the index. createIndex() bypasses this check.","title":"Model.createIndexes()"},{"location":"model/api/#modelprototypeschema","text":"","title":"Model.prototype.schema"},{"location":"model/api/#modelprototypebase","text":"Base Mongoose instance the model uses.","title":"Model.prototype.base"},{"location":"model/api/#modelprototypediscriminators","text":"Registered discriminators for this model.","title":"Model.prototype.discriminators"},{"location":"model/api/#modeltranslatealiases","text":"\u53c2\u6570 raw \u00abObject\u00bb fields/conditions that may contain aliased keys \u8fd4\u56de \u00abObject\u00bb the translated 'pure' fields/conditions Translate any aliases fields/conditions so the final query or document object is pure \u793a\u4f8b Character . find ( Character . translateAliases ( { ' \u540d ' : ' Eddard Stark ' } ) . exec ( function ( err , characters ) {} ) \u6ce8\u91ca Only translate arguments of object type anything else is returned raw","title":"Model.translateAliases()"},{"location":"model/api/#modelremove","text":"\u53c2\u6570 \u8fd4\u56de Removes all documents that match conditions from the collection. To remove just the first document that matches conditions , set the single option to true. \u793a\u4f8b Character . remove ( { name : 'Eddard Stark' } , function ( err ) {} ); \u6ce8\u91ca This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, no middleware (hooks) are executed .","title":"Model.remove()"},{"location":"model/api/#modeldeleteone","text":"\u53c2\u6570 \u8fd4\u56de Deletes the first document that matches conditions from the collection. Behaves like remove() , but deletes at most one document regardless of the single option. \u793a\u4f8b Character . deleteOne ( { name : 'Eddard Stark' } , function ( err ) {} ); \u6ce8\u91ca Like Model.remove() , this function does not trigger pre('remove') or post('remove') hooks.","title":"Model.deleteOne()"},{"location":"model/api/#modeldeletemany","text":"\u53c2\u6570 \u8fd4\u56de Deletes all of the documents that match conditions from the collection. Behaves like remove() , but deletes all documents that match conditions regardless of the single option. \u793a\u4f8b Character . deleteMany ( { name : / Stark / , age : { $ gte : 18 } } , function ( err ) {} ); \u6ce8\u91ca Like Model.remove() , this function does not trigger pre('remove') or post('remove') hooks.","title":"Model.deleteMany()"},{"location":"model/api/#modelfind","text":"\u53c2\u6570 \u8fd4\u56de Finds documents The conditions are cast to their respective SchemaTypes before the command is sent. \u793a\u4f8b MyModel . find ({ name : 'john' , age : { $ gte : 18 }}); MyModel . find ({ name : 'john' , age : { $ gte : 18 }}, function ( err , docs ) {}); MyModel . find ({ name : / john / i }, 'name friends' , function ( err , docs ) { }) MyModel . find ({ name : / john / i }, null , { skip : 10 }) MyModel . find ({ name : / john / i }, null , { skip : 10 }, function ( err , docs ) {}); var query = MyModel . find ({ name : / john / i }, null , { skip : 10 }) query . exec ( function ( err , docs ) {}); var query = MyModel . find ({ name : / john / i }, null , { skip : 10 }); var promise = query . exec (); promise . addBack ( function ( err , docs ) {});","title":"Model.find()"},{"location":"model/api/#modelfindbyid","text":"\u53c2\u6570 \u8fd4\u56de Finds a single document by its _id field. findById(id) is almost* equivalent to findOne({ _id: id }) . If you want to query by a document's _id , use findById() instead of findOne() . The id is cast based on the Schema before sending the command. This function triggers the following middleware. Except for how it treats undefined . If you use findOne() , you'll see that findOne(undefined) and findOne({ _id: undefined }) are equivalent to findOne({}) and return arbitrary documents. However, mongoose translates findById(undefined) into findOne({ _id: null }) . \u793a\u4f8b Adventure . findById ( id , function ( err , adventure ) {} ); Adventure . findById ( id ) . exec ( callback ); Adventure . findById ( id , 'name length' , function ( err , adventure ) {} ); Adventure . findById ( id , 'name length' ) . exec ( callback ); Adventure . findById ( id , '-length' ) . exec ( function ( err , adventure ) {} ); Adventure . findById ( id , 'name' , { lean : true } , function ( err , doc ) {} ); Adventure . findById ( id , 'name' ) . lean () . exec ( function ( err , doc ) {} );","title":"Model.findById()"},{"location":"model/api/#modelfindone","text":"\u53c2\u6570 \u8fd4\u56de Finds one document. The conditions are cast to their respective SchemaTypes before the command is sent. Note: conditions is optional, and if conditions is null or undefined, mongoose will send an empty findOne command to MongoDB, which will return an arbitrary document. If you're querying by _id , use findById() instead. \u793a\u4f8b Adventure . findOne ( { type : 'iphone' } , function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } ) . exec ( function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } , 'name' , function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } , 'name' ) . exec ( function ( err , adventure ) {} ); Adventure . findOne ( { type : 'iphone' } , 'name' , { lean : true } , callback ); Adventure . findOne ( { type : 'iphone' } , 'name' , { lean : true } ) . exec ( callback ); Adventure . findOne ( { type : 'iphone' } ) . select ( 'name' ) . lean () . exec ( callback );","title":"Model.findOne()"},{"location":"model/api/#modelcount","text":"\u53c2\u6570 \u8fd4\u56de Counts number of matching documents in a database collection. \u793a\u4f8b Adventure . count ( { type : 'jungle' } , function ( err , count ) { if (err) .. console.log('there are %d jungle adventures', count) ; } );","title":"Model.count()"},{"location":"model/api/#modeldistinct","text":"\u53c2\u6570 \u8fd4\u56de Creates a Query for a distinct operation. Passing a callback immediately executes the query. \u793a\u4f8b Link . distinct ( 'url' , { clicks : { $ gt : 100 }}, function ( err , result ) { if ( err ) return handleError ( err ); assert ( Array . isArray ( result )); console . log ( 'unique urls with more than 100 clicks' , result ); }) var query = Link . distinct ( 'url' ); query . exec ( callback );","title":"Model.distinct()"},{"location":"model/api/#modelwhere","text":"\u53c2\u6570 [val] \u00abObject\u00bb optional value \u8fd4\u56de Creates a Query, applies the passed conditions, and returns the Query. For example, instead of writing: User . find ( { age : {$ gte : 21 , $ lte : 65 } } , callback ); we can instead write: User . where ( ' age ' ) . gte ( 21 ) . lte ( 65 ) . exec ( callback ) ; Since the Query class also supports where you can continue chaining User .where ( ' age ' ). gte ( 21 ). lte ( 65 ) .where ( ' name ' , /^ b / i ) ... etc","title":"Model.where()"},{"location":"model/api/#modelprototypewhere_1","text":"\u53c2\u6570 argument \u00abString,Function\u00bb is a javascript string or anonymous function \u8fd4\u56de Creates a Query and specifies a $where condition. Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via find({ $where: javascript }) , or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model. Blog .$ where ( ' this.username.indexOf(\"val\") !== -1 ' ) . exec ( function ( err , docs ) {} ) ;","title":"Model.prototype.$where()"},{"location":"model/api/#modelfindoneandupdate","text":"\u53c2\u6570 \u8fd4\u56de Issues a mongodb findAndModify update command. Finds a matching document, updates it according to the update arg, passing any options , and returns the found document (if any) to the callback. The query executes immediately if callback is passed else a Query object is returned. \u9009\u9879 new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0) upsert : bool - creates the object if it doesn't exist. defaults to false. fields : {Object|String} - Field selection. Equivalent to .select(fields).findOneAndUpdate() maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findOneAndUpdate(conditions, update, options, callback) A.findOneAndUpdate(conditions, update, options) A.findOneAndUpdate(conditions, update, callback) A.findOneAndUpdate(conditions, update) A.findOneAndUpdate() \u6ce8\u91ca All top level update keys which are not atomic operation names are treated as set operations: \u793a\u4f8b var query = { name : 'borne' }; Model . findOneAndUpdate ( query , { name : 'jason bourne' }, options , callback ) Model . findOneAndUpdate ( query , { $ set : { name : 'jason bourne' }}, options , callback ) This helps prevent accidentally overwriting your document with { name: 'jason bourne' } . \u6ce8\u91ca Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default. defaults. Use the setDefaultsOnInsert option to override. findAndModify helpers support limited validation. You can enable these by setting the runValidators options, respectively. If you need full-fledged validation, use the traditional approach of first retrieving the document. Model . findById ( id , function ( err , doc ) { if ( err ) .. doc . name = ' jason bourne ' ; doc . save ( callback ) ; } ) ;","title":"Model.findOneAndUpdate()"},{"location":"model/api/#modelfindbyidandupdate","text":"\u53c2\u6570 \u8fd4\u56de Issues a mongodb findAndModify update command by a document's _id field. findByIdAndUpdate(id, ...) is equivalent to findOneAndUpdate({ _id: id }, ...) . Finds a matching document, updates it according to the update arg, passing any options , and returns the found document (if any) to the callback. The query executes immediately if callback is passed else a Query object is returned. This function triggers the following middleware. \u9009\u9879 new : bool - true to return the modified document rather than the original. defaults to false upsert : bool - creates the object if it doesn't exist. defaults to false. runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update select : sets the document fields to return rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findByIdAndUpdate(id, update, options, callback) A.findByIdAndUpdate(id, update, options) A.findByIdAndUpdate(id, update, callback) A.findByIdAndUpdate(id, update) A.findByIdAndUpdate() \u6ce8\u91ca All top level update keys which are not atomic operation names are treated as set operations: \u793a\u4f8b Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback) Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback) This helps prevent accidentally overwriting your document with { name: 'jason bourne' } . \u6ce8\u91ca Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default. defaults. Use the setDefaultsOnInsert option to override. findAndModify helpers support limited validation. You can enable these by setting the runValidators options, respectively. If you need full-fledged validation, use the traditional approach of first retrieving the document. Model . findById ( id , function ( err , doc ) { if ( err ) .. doc . name = ' jason bourne ' ; doc . save ( callback ) ; } ) ;","title":"Model.findByIdAndUpdate()"},{"location":"model/api/#modelfindoneandremove","text":"\u53c2\u6570 \u8fd4\u56de Issue a mongodb findAndModify remove command. Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if callback is passed else a Query object is returned. This function triggers the following middleware. \u9009\u9879 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 select : sets the document fields to return rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findOneAndRemove(conditions, options, callback) A.findOneAndRemove(conditions, options) A.findOneAndRemove(conditions, callback) A.findOneAndRemove(conditions) A.findOneAndRemove() Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default. defaults. Use the setDefaultsOnInsert option to override. findAndModify helpers support limited validation. You can enable these by setting the runValidators options, respectively. If you need full-fledged validation, use the traditional approach of first retrieving the document. Model . findById ( id , function ( err , doc ) { if ( err ) .. doc . name = ' jason bourne ' ; doc . save ( callback ) ; } ) ;","title":"Model.findOneAndRemove()"},{"location":"model/api/#modelfindbyidandremove","text":"\u53c2\u6570 \u8fd4\u56de Issue a mongodb findAndModify remove command by a document's _id field. findByIdAndRemove(id, ...) is equivalent to findOneAndRemove({ _id: id }, ...) . Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if callback is passed, else a Query object is returned. This function triggers the following middleware. \u9009\u9879 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update select : sets the document fields to return rawResult : if true, returns the [raw result from the MongoDB driver strict : overwrites the schema's [strict mode option for this update \u793a\u4f8b A.findByIdAndRemove(id, options, callback) A.findByIdAndRemove(id, options) A.findByIdAndRemove(id, callback) A.findByIdAndRemove(id) A.findByIdAndRemove()","title":"Model.findByIdAndRemove()"},{"location":"model/api/#modelcreate","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb callback \u8fd4\u56de Shortcut for saving one or more documents to the database. MyModel.create(docs) does new MyModel(doc).save() for every doc in docs. This function triggers the following middleware. \u793a\u4f8b Candy . create ({ type : 'jelly bean' }, { type : 'snickers' }, function ( err , jellybean , snickers ) { if ( err ) }); var array = [{ type : 'jelly bean' }, { type : 'snickers' }]; Candy . create ( array , function ( err , candies ) { if ( err ) var jellybean = candies [ 0 ]; var snickers = candies [ 1 ]; }); var promise = Candy . create ({ type : 'jawbreaker' }); promise . then ( function ( jawbreaker ) { })","title":"Model.create()"},{"location":"model/api/#modelwatch","text":"\u53c2\u6570 \u8fd4\u56de \u00abChangeStream\u00bb mongoose-specific change stream wrapper Requires a replica set running MongoDB >= 3.6.0. Watches the underlying collection for changes using [MongoDB change streams. This function does not trigger any middleware. In particular, it does not trigger aggregate middleware. \u793a\u4f8b const doc = await Person . create ({ name : 'Ned Stark' }); Person . watch () . on ( 'change' , change => console . log ( change )); await doc . remove ();","title":"Model.watch()"},{"location":"model/api/#modelinsertmany","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb callback \u8fd4\u56de Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than .create() because it only sends one operation to the server, rather than one for each document. Mongoose always validates each document before sending insertMany to MongoDB. So if one document has a validation error, no documents will be saved, unless you set [the ordered option to false. This function does not trigger save middleware. This function triggers the following middleware. \u793a\u4f8b var arr = [{ name : 'Star Wars' }, { name : 'The Empire Strikes Back' }]; Movies . insertMany ( arr , function ( error , docs ) {});","title":"Model.insertMany()"},{"location":"model/api/#modelbulkwrite","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb callback function(error, bulkWriteOpResult) {} \u8fd4\u56de \u00abPromise\u00bb resolves to a BulkWriteOpResult if the operation succeeds Sends multiple insertOne , updateOne , updateMany , replaceOne , deleteOne , and/or deleteMany operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use create() ) because with bulkWrite() there is only one round trip to MongoDB. Mongoose will perform casting on all operations you provide. This function does not trigger any middleware, not save() nor update() . If you need to trigger save() middleware for every document use [ create() instead. \u793a\u4f8b Character . bulkWrite ( [ { insertOne : { document : { name : 'Eddard Stark' , title : 'Warden of the North' } } }, { updateOne : { filter : { name : 'Eddard Stark' }, update : { title : 'Hand of the King' } } }, { deleteOne : { { filter : { name : 'Eddard Stark' } } } } ] ) . then ( handleResult );","title":"Model.bulkWrite()"},{"location":"model/api/#modelhydrate","text":"\u53c2\u6570 \u8fd4\u56de \u00abModel\u00bb document instance Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially. \u793a\u4f8b var mongooseCandy = Candy . hydrate ({ _id : '54108337212ffb6d459f854c' , type : 'jelly bean' });","title":"Model.hydrate()"},{"location":"model/api/#modelupdate","text":"\u53c2\u6570 \u8fd4\u56de Updates one document in the database without returning it. This function triggers the following middleware. \u793a\u4f8b MyModel . update ( { age : { $ gt : 18 } } , { oldEnough : true } , fn ); MyModel . update ( { name : 'Tobi' } , { ferret : true } , { multi : true } , function ( err , raw ) { if (err) return handleError(err) ; console.log('The raw response from Mongo was ', raw) ; } ); \u6709\u6548\u7684\u9009\u9879 safe (boolean) safe mode (defaults to value set in schema (true)) upsert (boolean) whether to create the doc if it doesn't match (false) multi (boolean) whether multiple documents should be updated (false) runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. strict (boolean) overrides the strict option for this update overwrite (boolean) disables update-only mode, allowing you to overwrite the doc (false) All update values are cast to their appropriate SchemaTypes before being sent. The callback function receives (err, rawResponse) . err is the error if any occurred rawResponse is the full response from Mongo \u6ce8\u91ca All top level keys which are not atomic operation names are treated as set operations: \u793a\u4f8b var query = { name : 'borne' }; Model . update ( query , { name : 'jason bourne' }, options , callback ) Model . update ( query , { $ set : { name : 'jason bourne' }}, options , callback ) This helps prevent accidentally overwriting all documents in your collection with { name: 'jason bourne' } . \u6ce8\u91ca Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error. \u6ce8\u91ca To update documents without waiting for a response from MongoDB, do not pass a callback , then call exec on the returned [Query: Comment . update ( { _id : id } , { $ set : { text : 'changed' } } ) . exec (); \u6ce8\u91ca Although values are casted to their appropriate types when using update, the following are not applied: defaults setters validators middleware If you need those features, use the traditional approach of first retrieving the document. Model . findOne ( { name : 'borne' } , function ( err , doc ) { if (err) .. doc.name = 'jason bourne' ; doc.save(callback) ; } )","title":"Model.update()"},{"location":"model/api/#modelupdatemany","text":"\u53c2\u6570 \u8fd4\u56de Same as update() , except MongoDB will update all documents that match criteria (as opposed to just the first one) regardless of the value of the multi option. Note updateMany will not fire update middleware. Use pre('updateMany') and post('updateMany') instead. This function triggers the following middleware.","title":"Model.updateMany()"},{"location":"model/api/#modelupdateone","text":"\u53c2\u6570 \u8fd4\u56de Same as update() , except MongoDB will update only the first document that matches criteria regardless of the value of the multi option. This function triggers the following middleware.","title":"Model.updateOne()"},{"location":"model/api/#modelreplaceone","text":"\u53c2\u6570 \u8fd4\u56de Same as update() , except MongoDB replace the existing document with the given document (no atomic operators like $set ). This function triggers the following middleware.","title":"Model.replaceOne()"},{"location":"model/api/#modelmapreduce","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional callback \u8fd4\u56de Executes a mapReduce command. o is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation for more detail about options. This function does not trigger any middleware. \u793a\u4f8b var o = {}; o . map = function () { emit ( this . name , 1 ) } o . reduce = function ( k , vals ) { return vals . length } User . mapReduce ( o , function ( err , results ) { console . log ( results ) }) \u5176\u4ed6\u9009\u9879 query {Object} query filter object. sort {Object} sort input objects using this key limit {Number} max number of documents keeptemp {Boolean, default:false} keep temporary data finalize {Function} finalize function scope {Object} scope variables exposed to map/reduce/finalize during execution jsMode {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X verbose {Boolean, default:false} provide statistics on job execution time. readPreference {String} out* {Object, default: {inline:1}} sets the output target for the map reduce job. \u8f93\u51fa\u9009\u9879 {inline:1} the results are returned in an array {replace: 'collectionName'} add the results to collectionName: the results replace the collection {reduce: 'collectionName'} add the results to collectionName: if dups are detected, uses the reducer / finalize functions {merge: 'collectionName'} add the results to collectionName: if dups exist the new docs overwrite the old If options.out is set to replace , merge , or reduce , a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the lean option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc). \u793a\u4f8b var o = {}; o . map = function () { emit ( this . name , 1 ) } o . reduce = function ( k , vals ) { return vals . length } o . out = { replace : 'createdCollectionNameForResults' } o . verbose = true ; User . mapReduce ( o , function ( err , model , stats ) { console . log ( 'map reduce took %d ms' , stats . processtime ) model . find () . where ( 'value' ) . gt ( 10 ) . exec ( function ( err , docs ) { console . log ( docs ); }); }) o . resolveToObject = true ; var promise = User . mapReduce ( o ); promise . then ( function ( res ) { var model = res . model ; var stats = res . stats ; console . log ( 'map reduce took %d ms' , stats . processtime ) return model . find () . where ( 'value' ) . gt ( 10 ) . exec (); }) . then ( function ( docs ) { console . log ( docs ); }) . then ( null , handleError ) . end ()","title":"Model.mapReduce()"},{"location":"model/api/#modelaggregate","text":"\u53c2\u6570 \u8fd4\u56de Performs [aggregations on the models collection. If a callback is passed, the aggregate is executed and a Promise is returned. If a callback is not passed, the aggregate itself is returned. This function does not trigger any middleware. \u793a\u4f8b Users . aggregate ( { $group : { _id: null , maxBalance: { $max : ' $balance ' }}}, { $project : { _id: 0 , maxBalance: 1 }}, function ( err , res ) { if ( err ) return handleError ( err ); console . log ( res ); }); Users . aggregate () . group ({ _id: null , maxBalance: { $max : ' $balance ' } }) . select (' - id maxBalance ') . exec ( function ( err , res ) { if ( err ) return handleError ( err ); console . log ( res ); }); \u6ce8\u91ca Arguments are not cast to the model's schema because $project operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned). Requires MongoDB >= 2.1","title":"Model.aggregate()"},{"location":"model/api/#modelgeosearch","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional callback \u8fd4\u56de Implements $geoSearch functionality for Mongoose This function does not trigger any middleware \u793a\u4f8b var options = { near : [ 10 , 10 ], maxDistance : 5 }; Locations . geoSearch ({ type : \"house\" }, options , function ( err , res ) { console . log ( res ); }); \u9009\u9879 near {Array} x,y point to search for maxDistance {Number} the maximum distance from the point near that a result can be limit {Number} The maximum number of results to return lean {Boolean} return the raw object instead of the Mongoose Model","title":"Model.geoSearch()"},{"location":"model/api/#modelpopulate","text":"\u53c2\u6570 [callback(err,doc)] \u00abFunction\u00bb Optional callback, executed upon completion. Receives err and the doc(s) . \u8fd4\u56de Populates document references. \u53ef\u7528\u7684\u9009\u9879 path: space delimited path(s) to populate select: optional fields to select match: optional query conditions to match model: optional name of the model to use for population options: optional query options like sort, limit, etc \u793a\u4f8b User . findById ( id , function ( err , user ) { var opts = [ { path : 'company' , match : { x : 1 }, select : 'name' } , { path : 'notes' , options : { limit : 10 }, model : 'override' } ] User . populate ( user , opts , function ( err , user ) { console . log ( user ); }); }); User . find ( match , function ( err , users ) { var opts = [{ path : 'company' , match : { x : 1 }, select : 'name' }] var promise = User . populate ( users , opts ); promise . then ( console . log ) . end (); }) var user = { name : 'Indiana Jones' , weapon : 389 } Weapon . populate ( user , { path : 'weapon' , model : 'Weapon' }, function ( err , user ) { console . log ( user . weapon . name ) }) var users = [{ name : 'Indiana Jones' , weapon : 389 }] users . push ({ name : 'Batman' , weapon : 8921 }) Weapon . populate ( users , { path : 'weapon' }, function ( err , users ) { users . forEach ( function ( user ) { console . log ( ' %s uses a %s ' , users . name , user . weapon . name ) }); });","title":"Model.populate()"},{"location":"model/guide/","text":"\u6a21\u578b \u00b6 \u8d44\u6e90 \u6a21\u578bs are fancy constructors compiled from our Schema definitions. Instances of these models represent documents which can be saved and retrieved from our database. All document creation and retrieval from the database is handled by these models. \u7f16\u8bd1\u4f60\u7684\u7b2c\u4e00\u4e2a\u6a21\u578b \u00b6 var schema = new mongoose.Schema({ name: 'string', size: 'string' }); var Tank = mongoose.model('Tank', schema); The first argument is the singular name of the collection your model is for. Mongoose automatically looks for the plural version of your model name. Thus, for the example above, the model Tank is for the tanks collection in the database. The .model() function makes a copy of schema . Make sure that you've added everything you want to schema before calling .model() ! \u6784\u5efa\u6587\u6863 \u00b6 Documents are instances of our model. Creating them and saving to the database is easy: var Tank = mongoose.model('Tank', yourSchema); var small = new Tank({ size: 'small' }); small.save(function (err) { if (err) return handleError(err); // saved! }) // or Tank.create({ size: 'small' }, function (err, small) { if (err) return handleError(err); // saved! }) Note that no tanks will be created/removed until the connection your model uses is open. Every model has an associated connection. When you use mongoose.model() , your model will use the default mongoose connection. mongoose.connect('localhost', 'gettingstarted'); If you create a custom connection, use that connection's model() function instead. var connection = mongoose.createConnection('mongodb://localhost:27017/test'); var Tank = connection.model('Tank', yourSchema); \u67e5\u8be2 \u00b6 Finding documents is easy with Mongoose, which supports the rich query syntax of MongoDB. Documents can be retreived using each models find , findById , findOne , or where static methods. Tank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback); See the chapter on querying for more details on how to use the Query api. \u5220\u9664 \u00b6 Models have a static remove method available for removing all documents matching conditions . Tank.remove({ size: 'large' }, function (err) { if (err) return handleError(err); // removed! }); \u66f4\u65b0 \u00b6 Each model has its own update method for modifying documents in the database without returning them to your application. See the API docs for more detail. If you want to update a single document in the db and return it to your application, use findOneAndUpdate instead. \u8fd8\u6709\u66f4\u591a \u00b6 The API docs cover many additional methods available like count , mapReduce , aggregate , and more . \u63a5\u4e0b\u6765 \u00b6 \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 Models \uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b Documents .","title":"\u6a21\u578b\u624b\u518c"},{"location":"model/guide/#_1","text":"\u8d44\u6e90 \u6a21\u578bs are fancy constructors compiled from our Schema definitions. Instances of these models represent documents which can be saved and retrieved from our database. All document creation and retrieval from the database is handled by these models.","title":"\u6a21\u578b"},{"location":"model/guide/#_2","text":"var schema = new mongoose.Schema({ name: 'string', size: 'string' }); var Tank = mongoose.model('Tank', schema); The first argument is the singular name of the collection your model is for. Mongoose automatically looks for the plural version of your model name. Thus, for the example above, the model Tank is for the tanks collection in the database. The .model() function makes a copy of schema . Make sure that you've added everything you want to schema before calling .model() !","title":"\u7f16\u8bd1\u4f60\u7684\u7b2c\u4e00\u4e2a\u6a21\u578b"},{"location":"model/guide/#_3","text":"Documents are instances of our model. Creating them and saving to the database is easy: var Tank = mongoose.model('Tank', yourSchema); var small = new Tank({ size: 'small' }); small.save(function (err) { if (err) return handleError(err); // saved! }) // or Tank.create({ size: 'small' }, function (err, small) { if (err) return handleError(err); // saved! }) Note that no tanks will be created/removed until the connection your model uses is open. Every model has an associated connection. When you use mongoose.model() , your model will use the default mongoose connection. mongoose.connect('localhost', 'gettingstarted'); If you create a custom connection, use that connection's model() function instead. var connection = mongoose.createConnection('mongodb://localhost:27017/test'); var Tank = connection.model('Tank', yourSchema);","title":"\u6784\u5efa\u6587\u6863"},{"location":"model/guide/#_4","text":"Finding documents is easy with Mongoose, which supports the rich query syntax of MongoDB. Documents can be retreived using each models find , findById , findOne , or where static methods. Tank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback); See the chapter on querying for more details on how to use the Query api.","title":"\u67e5\u8be2"},{"location":"model/guide/#_5","text":"Models have a static remove method available for removing all documents matching conditions . Tank.remove({ size: 'large' }, function (err) { if (err) return handleError(err); // removed! });","title":"\u5220\u9664"},{"location":"model/guide/#_6","text":"Each model has its own update method for modifying documents in the database without returning them to your application. See the API docs for more detail. If you want to update a single document in the db and return it to your application, use findOneAndUpdate instead.","title":"\u66f4\u65b0"},{"location":"model/guide/#_7","text":"The API docs cover many additional methods available like count , mapReduce , aggregate , and more .","title":"\u8fd8\u6709\u66f4\u591a"},{"location":"model/guide/#_8","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86 Models \uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b Documents .","title":"\u63a5\u4e0b\u6765"},{"location":"query/api/","text":"\u67e5\u8be2 \u00b6 Query() \u00b6 \u53c2\u6570 [collection] \u00abObject\u00bb Mongoose collection Query constructor used for building queries. You do not need to instantiate a Query directly. Instead use Model functions like [ Model.find() . \u793a\u4f8b const query = MyModel . find (); query . setOptions ({ lean : true }); query . collection ( model . collection ); query . where ( 'age' ) . gte ( 21 ) . exec ( callback ); const query = new mongoose . Query (); Query.prototype.use$geoWithin \u00b6 Flag to opt out of using $geoWithin . mongoose.Query.use$geoWithin = false; MongoDB 2.4 deprecated the use of $within , replacing it with $geoWithin . Mongoose uses $geoWithin by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to false so your within() queries continue to work. Query.prototype.toConstructor() \u00b6 \u8fd4\u56de \u00abQuery\u00bb subclass-of-Query Converts this query to a customized, reusable query constructor with all arguments and options retained. \u793a\u4f8b var query = Movie . find ({ tags : 'adventure' }) . read ( 'primaryPreferred' ); var Adventure = query . toConstructor (); Adventure () . exec ( callback ) Adventure () . where ({ name : /^ Life / }) . exec ( callback ); Adventure . prototype . startsWith = function ( prefix ) { this . where ({ name : new RegExp ( '^' + prefix ) }) return this ; } Object . defineProperty ( Adventure . prototype , 'highlyRated' , { get : function () { this . where ({ rating : { $ gt : 4.5 }}); return this ; } }) Adventure () . highlyRated . startsWith ( 'Life' ) . exec ( callback ) New in 3.7.3 Query.prototype.$where() \u00b6 \u53c2\u6570 js \u00abString,Function\u00bb javascript string or function \u8fd4\u56de Specifies a javascript function or expression to pass to MongoDBs query system. \u793a\u4f8b query .$ where ( ' this.comments.length === 10 || this.name.length === 5 ' ) query .$ where ( function () { return this . comments . length === 10 || this . name . length === 5 ; } ) \u6ce8\u91ca Only use $where when you have a condition that cannot be met using other MongoDB operators like $lt . Be sure to read about all of [its caveats before using. Query.prototype.where() \u00b6 \u53c2\u6570 \u8fd4\u56de Specifies a path for use with chaining. \u793a\u4f8b User.find ( { age : { $gte : 21 , $lte : 65 }} , callback ) ; User.where ( ' age ' ). gte ( 21 ). lte ( 65 ) ; User.find (). where ( { name : ' vonderful ' } ) User .where ( ' age ' ). gte ( 21 ). lte ( 65 ) .where ( ' name ' , /^ vonderful / i ) .where ( ' friends ' ). slice ( 10 ) .exec ( callback ) Query.prototype.equals() \u00b6 \u53c2\u6570 \u8fd4\u56de Specifies the complementary comparison value for paths specified with where() \u793a\u4f8b User.where('age').equals(49); User.where('age', 49); Query.prototype.or() \u00b6 \u53c2\u6570 array \u00abArray\u00bb array of conditions \u8fd4\u56de Specifies arguments for an $or condition. \u793a\u4f8b query.or([{ color: 'red' }, { status: 'emergency' }]) Query.prototype.nor() \u00b6 \u53c2\u6570 array \u00abArray\u00bb array of conditions \u8fd4\u56de Specifies arguments for a $nor condition. \u793a\u4f8b query.nor([{ color: 'green' }, { status: 'ok' }]) Query.prototype.and() \u00b6 \u53c2\u6570 array \u00abArray\u00bb array of conditions \u8fd4\u56de Specifies arguments for a $and condition. \u793a\u4f8b query.and([{ color: 'green' }, { status: 'ok' }]) Query.prototype.gt() \u00b6 \u53c2\u6570 Specifies a $gt query condition. When called with one argument, the most recent path passed to where() is used. \u793a\u4f8b Thing.find().where('age').gt(21) Thing.find().gt('age', 21) Query.prototype.gte() \u00b6 \u53c2\u6570 Specifies a $gte query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.lt() \u00b6 \u53c2\u6570 Specifies a $lt query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.lte() \u00b6 \u53c2\u6570 Specifies a $lte query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.ne() \u00b6 \u53c2\u6570 Specifies a $ne query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.in() \u00b6 \u53c2\u6570 Specifies an $in query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.nin() \u00b6 \u53c2\u6570 Specifies an $nin query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.all() \u00b6 \u53c2\u6570 Specifies an $all query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.size() \u00b6 \u53c2\u6570 Specifies a $size query condition. When called with one argument, the most recent path passed to where() is used. \u793a\u4f8b MyModel . where ( ' tags ' ) . size ( 0 ) . exec ( function ( err , docs ) { if ( err ) return handleError ( err ) ; assert ( Array . isArray ( docs )) ; console . log ( ' documents with 0 tags ' , docs ) ; } ) Query.prototype.regex() \u00b6 \u53c2\u6570 Specifies a $regex query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.maxDistance() \u00b6 \u53c2\u6570 Specifies a $maxDistance query condition. When called with one argument, the most recent path passed to where() is used. Query.prototype.mod() \u00b6 \u53c2\u6570 val \u00abArray\u00bb must be of length 2, first element is divisor , 2nd element is remainder . \u8fd4\u56de Specifies a $mod condition, filters documents for documents whose path property is a number that is equal to remainder modulo divisor . \u793a\u4f8b Product.find().mod('inventory', [2, 1]); Product.find().where('inventory').mod([2, 1]); Product.find().where('inventory').mod(2, 1); Query.prototype.exists() \u00b6 \u53c2\u6570 \u8fd4\u56de Specifies an $exists condition \u793a\u4f8b Thing.where('name').exists() Thing.where('name').exists(true) Thing.find().exists('name') Thing.where('name').exists(false); Thing.find().exists('name', false); Query.prototype.elemMatch() \u00b6 \u53c2\u6570 criteria \u00abObject,Function\u00bb \u8fd4\u56de Specifies an $elemMatch condition \u793a\u4f8b query . elemMatch ( 'comment' , { author : 'autobot' , votes : {$ gte : 5 } } ) query . where ( 'comment' ) . elemMatch ( { author : 'autobot' , votes : {$ gte : 5 } } ) query . elemMatch ( 'comment' , function ( elem ) { elem.where('author').equals('autobot') ; elem.where('votes').gte(5) ; } ) query . where ( 'comment' ) . elemMatch ( function ( elem ) { elem.where({ author : 'autobot' } ); elem . where ( 'votes' ) . gte ( 5 ); } ) Query.prototype.within() \u00b6 \u8fd4\u56de Defines a $within or $geoWithin argument for geo-spatial queries. \u793a\u4f8b query . where ( path ) . within () . box () query . where ( path ) . within () . circle () query . where ( path ) . within () . geometry () query . where ( 'loc' ) . within ( { center : [ 50 , 50 ] , radius : 10 , unique : true , spherical : true } ); query . where ( 'loc' ) . within ( { box : [ [ 40.73 , - 73.9 ] , [ 40.7 , - 73.988 ] ] } ); query . where ( 'loc' ) . within ( { polygon : [ [ ] , [] , [] , [] ] } ); query . where ( 'loc' ) . within ( [] , [] , [] ) query . where ( 'loc' ) . within ( [] , [] ) query . where ( 'loc' ) . within ( { type : 'LineString' , coordinates : [ ... ] } ); MUST be used after where() . \u6ce8\u91ca As of Mongoose 3.7, $geoWithin is always used for queries. To change this behavior, see [Query.use$geoWithin. \u6ce8\u91ca In Mongoose 3.7, within changed from a getter to a function. If you need the old syntax, use [this. Query.prototype.slice() \u00b6 \u53c2\u6570 val \u00abNumber\u00bb number/range of elements to slice \u8fd4\u56de Specifies a $slice projection for an array. \u793a\u4f8b query.slice('comments', 5) query.slice('comments', -5) query.slice('comments', [10, 5]) query.where('comments').slice(5) query.where('comments').slice([-10, 5]) Query.prototype.limit() \u00b6 \u53c2\u6570 Specifies the maximum number of documents the query will return. \u793a\u4f8b query.limit(20) \u6ce8\u91ca Cannot be used with distinct() Query.prototype.skip() \u00b6 \u53c2\u6570 Specifies the number of documents to skip. \u793a\u4f8b query.skip(100).limit(20) \u6ce8\u91ca Cannot be used with distinct() Query.prototype.maxScan() \u00b6 \u53c2\u6570 Specifies the maxScan option. \u793a\u4f8b query.maxScan(100) \u6ce8\u91ca Cannot be used with distinct() Query.prototype.batchSize() \u00b6 \u53c2\u6570 Specifies the batchSize option. \u793a\u4f8b query.batchSize(100) \u6ce8\u91ca Cannot be used with distinct() \u53c2\u6570 Specifies the comment option. \u793a\u4f8b query.comment('login query') \u6ce8\u91ca Cannot be used with distinct() Query.prototype.snapshot() \u00b6 \u8fd4\u56de Specifies this query as a snapshot query. \u793a\u4f8b query.snapshot() query.snapshot(true) query.snapshot(false) \u6ce8\u91ca Cannot be used with distinct() Query.prototype.hint() \u00b6 \u53c2\u6570 val \u00abObject\u00bb a hint object \u8fd4\u56de Sets query hints. \u793a\u4f8b query.hint({ indexA: 1, indexB: -1}) \u6ce8\u91ca Cannot be used with distinct() Query.prototype.select() \u00b6 \u53c2\u6570 \u8fd4\u56de Specifies which document fields to include or exclude (also known as the query \"projection\") When using string syntax, prefixing a path with - will flag that path as excluded. When a path does not have the - prefix, it is included. Lastly, if a path is prefixed with + , it forces inclusion of the path, which is useful for paths excluded at the [schema level. A projection must be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The [ _id field is the only exception because MongoDB includes it by default. \u793a\u4f8b query . select ( 'a b' ); query . select ( '-c -d' ); query . select ( { a : 1 , b : 1 } ); query . select ( { c : 0 , d : 0 } ); query . select ( '+path' ) Query.prototype.slaveOk() \u00b6 \u53c2\u6570 v \u00abBoolean\u00bb defaults to true \u8fd4\u56de DEPRECATED Sets the slaveOk option. Deprecated in MongoDB 2.2 in favor of [read preferences. \u793a\u4f8b query.slaveOk() query.slaveOk(true) query.slaveOk(false) Query.prototype.read() \u00b6 \u53c2\u6570 [tags] \u00abArray\u00bb optional tags for this query \u8fd4\u56de Determines the MongoDB nodes from which to read. \u559c\u597d primary - ( default ) Read from primary only . Operations will produce an error if primary is unavailable . Cannot be combined with tags . secondary Read from secondary if available , otherwise error . primaryPreferred Read from primary if available , otherwise a secondary . secondaryPreferred Read from a secondary if available , otherwise read from the primary . nearest All operations read from among the nearest candidates , but unlike other modes , this option will include both the primary and all secondaries in the random selection . \u522b\u540d p primary pp primaryPreferred s secondary sp secondaryPreferred n nearest \u793a\u4f8b new Query().read('primary') new Query().read('p') new Query().read('primaryPreferred') new Query().read('pp') new Query().read('secondary') new Query().read('s') new Query().read('secondaryPreferred') new Query().read('sp') new Query().read('nearest') new Query().read('n') new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]) Read more about how to use read preferrences [here and [here. Query.prototype.merge() \u00b6 \u53c2\u6570 \u8fd4\u56de Merges another Query or conditions object into this one. When a Query is passed, conditions, field selection and options are merged. New in 3.7.0 Query.prototype.setOptions() \u00b6 \u53c2\u6570 Sets query options. Some options only make sense for certain operations. \u9009\u9879 The following options are only for find() : - [tailable - [sort - [limit - [skip - [maxscan - [batchSize - [comment - [snapshot - [readPreference - [hint The following options are only for update() , updateOne() , updateMany() , replaceOne() , findOneAndUpdate() , and findByIdAndUpdate() : - [upsert - [writeConcern The following options are only for find() , findOne() , findById() , findOneAndUpdate() , findByIdAndUpdate() , and geoSearch() : - [lean The following options are for all operations Query.prototype.getQuery() \u00b6 \u8fd4\u56de \u00abObject\u00bb current query conditions Returns the current query conditions as a JSON object. \u793a\u4f8b var query = new Query (); query . find ({ a : 1 }) . where ( 'b' ) . gt ( 2 ); query . getQuery (); Query.prototype.getUpdate() \u00b6 \u8fd4\u56de \u00abObject\u00bb current update operations Returns the current update operations as a JSON object. \u793a\u4f8b var query = new Query (); query . update ({}, { $ set : { a : 5 } }); query . getUpdate (); Query.prototype.lean() \u00b6 \u53c2\u6570 bool \u00abBoolean,Object\u00bb defaults to true \u8fd4\u56de Sets the lean option. Documents returned from queries with the lean option enabled are plain javascript objects, not [MongooseDocuments. They have no save method, getters/setters or other Mongoose magic applied. \u793a\u4f8b new Query () . lean () new Query () . lean ( true ) new Query () . lean ( false ) Model . find () . lean () . exec ( function ( err , docs ) { docs [ 0 ] instanceof mongoose . Document } ) ; This is a [great option in high-performance read-only scenarios, especially when combined with [stream. Query.prototype.error() \u00b6 \u53c2\u6570 err \u00abError,null\u00bb if set, exec() will fail fast before sending the query to MongoDB Gets/sets the error flag on this query. If this flag is not null or undefined, the exec() promise will reject without executing. \u793a\u4f8b Query () . error () ; Query () . error ( null ) ; Query () . error ( new Error ( ' test ' )) ; Schema . pre ( ' find ' , function () { if ( ! this . getQuery () . userId ) { this . error ( new Error ( ' Not allowed to query without setting userId ' )) ; } } ) ; Note that query casting runs after hooks, so cast errors will override custom errors. \u793a\u4f8b var TestSchema = new Schema ({ num : Number }); var TestModel = db . model ( 'Test' , TestSchema ); TestModel . find ({ num : 'not a number' }) . error ( new Error ( 'woops' )) . exec ( function ( error ) { }); Query.prototype.mongooseOptions() \u00b6 \u53c2\u6570 options \u00abObject\u00bb if specified, overwrites the current options Getter/setter around the current mongoose-specific options for this query (populate, lean, etc.) Query.prototype.find() \u00b6 \u53c2\u6570 \u8fd4\u56de Finds documents. When no callback is passed, the query is not executed. When the query is executed, the result will be an array of documents. \u793a\u4f8b query.find({ name: 'Los Pollos Hermanos' }).find(callback) Query.prototype.merge() \u00b6 \u53c2\u6570 \u8fd4\u56de Merges another Query or conditions object into this one. When a Query is passed, conditions, field selection and options are merged. Query.prototype.collation() \u00b6 \u53c2\u6570 \u8fd4\u56de Adds a collation to this op (MongoDB 3.4 and up) Query.prototype.findOne() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, document) \u8fd4\u56de Declares the query a findOne operation. When executed, the first found document is passed to the callback. Passing a callback executes the query. The result of the query is a single document. Note: conditions is optional, and if conditions is null or undefined, mongoose will send an empty findOne command to MongoDB, which will return an arbitrary document. If you're querying by _id , use Model.findById() instead. This function triggers the following middleware. \u793a\u4f8b var query = Kitten . where ({ color : 'white' }); query . findOne ( function ( err , kitten ) { if ( err ) return handleError ( err ); if ( kitten ) { } }); Query.prototype.count() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, count) \u8fd4\u56de Specifying this query as a count query. Passing a callback executes the query. This function triggers the following middleware. \u793a\u4f8b var countQuery = model . where ({ 'color' : 'black' }) . count (); query . count ({ color : 'black' }) . count ( callback ) query . count ({ color : 'black' }, callback ) query . where ( 'color' , 'black' ) . count ( function ( err , count ) { if ( err ) return handleError ( err ); console . log ( 'there are %d kittens' , count ); }) Query.prototype.distinct() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, arr) \u8fd4\u56de Declares or executes a distict() operation. Passing a callback executes the query. This function does not trigger any middleware. \u793a\u4f8b distinct(field, conditions, callback) distinct(field, conditions) distinct(field, callback) distinct(field) distinct(callback) distinct() Query.prototype.sort() \u00b6 \u53c2\u6570 \u8fd4\u56de Sets the sort order If an object is passed, values allowed are asc , desc , ascending , descending , 1 , and -1 . If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with - which will be treated as descending. \u793a\u4f8b query . sort ( { field : 'asc' , test : -1 } ); query . sort ( 'field -test' ); \u6ce8\u91ca Cannot be used with distinct() Query.prototype.remove() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a remove() operation. This function does not trigger any middleware \u793a\u4f8b Model.remove({ artist: 'Anne Murray' }, callback) \u6ce8\u91ca The operation is only executed when a callback is passed. To force execution without a callback, you must first call remove() and then execute it by using the exec() method. var query = Model . find () . remove ({ name : 'Anne Murray' }) query . remove ({ name : 'Anne Murray' }, callback ) query . remove ({ name : 'Anne Murray' }) . remove ( callback ) query . exec () query . remove ( conds , fn ); query . remove ( conds ) query . remove ( fn ) query . remove () Query.prototype.deleteOne() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a deleteOne() operation. Works like remove, except it deletes at most one document regardless of the single option. This function does not trigger any middleware. \u793a\u4f8b Character . deleteOne ( { name : ' Eddard Stark ' }, callback ) Character . deleteOne ( { name : ' Eddard Stark ' } ) . then ( next ) Query.prototype.deleteMany() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a deleteMany() operation. Works like remove, except it deletes every document that matches criteria in the collection, regardless of the value of single . This function does not trigger any middleware \u793a\u4f8b Character . deleteMany ( { name : / Stark / , age : { $ gte : 18 } }, callback ) Character . deleteMany ( { name : / Stark / , age : { $ gte : 18 } } ) . then ( next ) Query.prototype.findOneAndUpdate() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, doc), unless rawResult is used, in which case params are (error, writeOpResult) \u8fd4\u56de Issues a mongodb [findAndModify update command. Finds a matching document, updates it according to the update arg, passing any options , and returns the found document (if any) to the callback. The query executes immediately if callback is passed. This function triggers the following middleware. \u9009\u9879 new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0) upsert : bool - creates the object if it doesn't exist. defaults to false. fields : {Object|String} - Field selection. Equivalent to .select(fields).findOneAndUpdate() sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. rawResult : if true, returns the [raw result from the MongoDB driver context (string) if set to 'query' and runValidators is on, this will refer to the query in custom validator functions that update validation runs. Does nothing if runValidators is false. \u56de\u8c03\u7b7e\u540d function(error, doc) { } \u793a\u4f8b query.findOneAndUpdate(conditions, update, options, callback) query.findOneAndUpdate(conditions, update, options) query.findOneAndUpdate(conditions, update, callback) query.findOneAndUpdate(conditions, update) query.findOneAndUpdate(update, callback) query.findOneAndUpdate(update) query.findOneAndUpdate(callback) query.findOneAndUpdate() Query.prototype.findOneAndRemove() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, document) \u8fd4\u56de Issues a mongodb [findAndModify remove command. Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if callback is passed. This function triggers the following middleware. \u9009\u9879 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 rawResult : if true, resolves to the [raw result from the MongoDB driver \u56de\u8c03\u7b7e\u540d function(error, doc) { } \u793a\u4f8b s A.where().findOneAndRemove(conditions, options, callback) A.where().findOneAndRemove(conditions, options) A.where().findOneAndRemove(conditions, callback) A.where().findOneAndRemove(conditions) A.where().findOneAndRemove(callback) A.where().findOneAndRemove() Query.prototype.update() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional, params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as an update() operation. All paths passed that are not $atomic operations will become $set ops. This function triggers the following middleware. \u793a\u4f8b Model.where({ _id: id }).update({ title: 'words' }) Model.where({ _id: id }).update({ $set: { title: 'words' }}) \u9009\u9879 safe (boolean) safe mode (defaults to value set in schema (true)) upsert (boolean) whether to create the doc if it doesn't match (false) multi (boolean) whether multiple documents should be updated (false) runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. strict (boolean) overrides the strict option for this update overwrite (boolean) disables update-only mode, allowing you to overwrite the doc (false) context (string) if set to 'query' and runValidators is on, this will refer to the query in custom validator functions that update validation runs. Does nothing if runValidators is false. \u6ce8\u91ca Passing an empty object {} as the doc will result in a no-op unless the overwrite option is passed. Without the overwrite option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection. \u6ce8\u91ca The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the exec() method. var q = Model . where ({ _id : id }); q . update ({ $ set : { name : 'bob' }}) . update (); // not executed q . update ({ $ set : { name : 'bob' }}) . exec (); // executed // keys that are not $ atomic ops become $ set . // this executes the same command as the previous example . q . update ({ name : 'bob' }) . exec (); // overwriting with empty docs var q = Model . where ({ _id : id }) . setOptions ({ overwrite : true }) q . update ({ }, callback ); // executes // multi update with overwrite to empty doc var q = Model . where ({ _id : id }); q . setOptions ({ multi : true , overwrite : true }) q . update ({ }); q . update ( callback ); // executed // multi updates Model . where () . update ({ name : /^ match / }, { $ set : { arr : [] }}, { multi : true }, callback ) // more multi updates Model . where () . setOptions ({ multi : true }) . update ({ $ set : { arr : [] }}, callback ) // single update by default Model . where ({ email : '[address@example.com' }) . update ({ $ inc : { counter : 1 }}, callback ) API summary update(criteria, doc, options, cb) update(criteria, doc, options) update(criteria, doc, cb) update(criteria, doc) update(doc, cb) update(doc) update(cb) update(true) update() Query.prototype.updateMany() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as an updateMany() operation. Same as update() , except MongoDB will update all documents that match criteria (as opposed to just the first one) regardless of the value of the multi option. Note updateMany will not fire update middleware. Use pre('updateMany') and post('updateMany') instead. This function triggers the following middleware. Query.prototype.updateOne() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as an updateOne() operation. Same as update() , except MongoDB will update only the first document that matches criteria regardless of the value of the multi option. Note updateOne will not fire update middleware. Use pre('updateOne') and post('updateOne') instead. This function triggers the following middleware. Query.prototype.replaceOne() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a replaceOne() operation. Same as update() , except MongoDB will replace the existing document and will not accept any atomic operators ( $set , etc.) Note replaceOne will not fire update middleware. Use pre('replaceOne') and post('replaceOne') instead. This function triggers the following middleware. Query.prototype.exec() \u00b6 \u53c2\u6570 [callback] \u00abFunction\u00bb optional params depend on the function being called \u8fd4\u56de Executes the query \u793a\u4f8b var promise = query . exec (); var promise = query . exec ( 'update' ); query . exec ( callback ); query . exec ( 'find' , callback ); Query.prototype.then() \u00b6 \u53c2\u6570 \u8fd4\u56de Executes the query returning a Promise which will be resolved with either the doc(s) or rejected with the error. Query.prototype.catch() \u00b6 \u53c2\u6570 \u8fd4\u56de Executes the query returning a Promise which will be resolved with either the doc(s) or rejected with the error. Like .then() , but only takes a rejection handler. Query.prototype.populate() \u00b6 \u53c2\u6570 [options] \u00abObject\u00bb Options for the population query (sort, etc) \u8fd4\u56de Specifies paths which should be populated with other documents. \u793a\u4f8b Kitten . findOne () . populate ( ' owner ' ) . exec ( function ( err , kitten ) { console . log ( kitten . owner . name ) } ) Kitten . find () . populate ( { path : ' owner ' , select : ' name ' , match : { color : ' black ' } , options : { sort : { name : - 1 }} } ) . exec ( function ( err , kittens ) { console . log ( kittens [ 0 ]. owner . name ) } ) Kitten . find () . populate ( ' owner ' , ' name ' , null , { sort : { name : - 1 }} ) . exec ( function ( err , kittens ) { console . log ( kittens [ 0 ]. owner . name ) } ) Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback. Query.prototype.cast() \u00b6 \u53c2\u6570 \u8fd4\u56de Casts this query to the schema of model \u6ce8\u91ca If obj is present, it is cast instead of this query. Query.prototype.cursor() \u00b6 \u53c2\u6570 \u8fd4\u56de Returns a wrapper around a [mongodb driver cursor. A QueryCursor exposes a [Streams3-compatible interface, as well as a .next() function. The .cursor() function triggers pre find hooks, but not post find hooks. \u793a\u4f8b Thing . find ({ name : /^ hello / }) . cursor () . on ( 'data' , function ( doc ) { console . log ( doc ); }) . on ( 'end' , function () { console . log ( 'Done!' ); }); var cursor = Thing . find ({ name : /^ hello / }) . cursor (); cursor . next ( function ( error , doc ) { console . log ( doc ); }); co ( function * () { const cursor = Thing . find ({ name : /^ hello / }) . cursor (); for ( let doc = yield cursor . next (); doc != null ; doc = yield cursor . next ()) { console . log ( doc ); } }); \u9009\u9879 transform : optional function which accepts a mongoose document. The return value of the function will be emitted on data and returned by .next() . Query.prototype.maxscan() \u00b6 DEPRECATED Alias of maxScan Query.prototype.tailable() \u00b6 \u53c2\u6570 [opts.tailableRetryInterval] \u00abNumber\u00bb if cursor is exhausted, wait this many milliseconds before retrying Sets the tailable option (for use with capped collections). \u793a\u4f8b query.tailable() query.tailable(true) query.tailable(false) \u6ce8\u91ca Cannot be used with distinct() Query.prototype.intersects() \u00b6 \u53c2\u6570 \u8fd4\u56de Declares an intersects query for geometry() . \u793a\u4f8b query.where('path').intersects().geometry({ type: 'LineString' , coordinates: [[180.0, 11.0], [180, 9.0]] }) query.where('path').intersects({ type: 'LineString' , coordinates: [[180.0, 11.0], [180, 9.0]] }) \u6ce8\u91ca MUST be used after where() . \u6ce8\u91ca In Mongoose 3.7, intersects changed from a getter to a function. If you need the old syntax, use [this. Query.prototype.geometry() \u00b6 \u53c2\u6570 object \u00abObject\u00bb Must contain a type property which is a String and a coordinates property which is an Array. See the examples. \u8fd4\u56de Specifies a $geometry condition \u793a\u4f8b var polyA = [[[ 10 , 20 ], [ 10 , 40 ], [ 30 , 40 ], [ 30 , 20 ]]] query . where ( 'loc' ) . within () . geometry ({ type : 'Polygon' , coordinates : polyA }) var polyB = [[ 0 , 0 ], [ 1 , 1 ]] query . where ( 'loc' ) . within () . geometry ({ type : 'LineString' , coordinates : polyB }) var polyC = [ 0 , 0 ] query . where ( 'loc' ) . within () . geometry ({ type : 'Point' , coordinates : polyC }) query . where ( 'loc' ) . intersects () . geometry ({ type : 'Point' , coordinates : polyC }) The argument is assigned to the most recent path passed to where() . \u6ce8\u91ca geometry() must come after either intersects() or within() . The object argument must contain type and coordinates properties. - type {String} - coordinates {Array} Query.prototype.near() \u00b6 \u53c2\u6570 \u8fd4\u56de Specifies a $near or $nearSphere condition These operators return documents sorted by distance. \u793a\u4f8b query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] } ); query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] , maxDistance : 5 } ); query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] , maxDistance : 5 , spherical : true } ); query . near ( 'loc' , { center : [ 10 , 10 ] , maxDistance : 5 } ); Query.prototype.nearSphere() \u00b6 DEPRECATED Specifies a $nearSphere condition \u793a\u4f8b query . where ( 'loc' ) . nearSphere ( { center : [ 10 , 10 ] , maxDistance : 5 } ); Deprecated. Use query.near() instead with the spherical option set to true . \u793a\u4f8b query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] , spherical : true } ); Query.prototype.polygon() \u00b6 \u53c2\u6570 [coordinatePairs...] \u00abArray,Object\u00bb \u8fd4\u56de Specifies a $polygon condition \u793a\u4f8b query.where('loc').within().polygon([10,20], [13, 25], [7,15]) query.polygon('loc', [10,20], [13, 25], [7,15]) Query.prototype.box() \u00b6 \u53c2\u6570 Upper \u00ab[Array]\u00bb Right Coords \u8fd4\u56de Specifies a $box condition \u793a\u4f8b var lowerLeft = [ 40.73083 , - 73.99756 ] var upperRight = [ 40.741404 , - 73.988135 ] query . where ( 'loc' ) . within () . box ( lowerLeft , upperRight ) query . box ({ ll : lowerLeft , ur : upperRight }) Query.prototype.circle() \u00b6 \u53c2\u6570 \u8fd4\u56de Specifies a $center or $centerSphere condition. \u793a\u4f8b var area = { center : [ 50 , 50 ], radius : 10 , unique : true } query . where ( 'loc' ) . within () . circle ( area ) query . circle ( 'loc' , area ); var area = { center : [ 50 , 50 ], radius : 10 , unique : true , spherical : true } query . where ( 'loc' ) . within () . circle ( area ) query . circle ( 'loc' , area ); New in 3.7.0 Query.prototype.center() \u00b6 Query.prototype.centerSphere() \u00b6 \u53c2\u6570 \u8fd4\u56de DEPRECATED Specifies a $centerSphere condition Deprecated. Use [circle instead. \u793a\u4f8b var area = { center : [ 50 , 50 ], radius : 10 }; query . where ( 'loc' ) . within () . centerSphere ( area ); Query.prototype.selected() \u00b6 \u8fd4\u56de Determines if field selection has been made. Query.prototype.selectedInclusively() \u00b6 \u8fd4\u56de Determines if inclusive field selection has been made. query.selectedInclusively() query.select('name') query.selectedInclusively() Query.prototype.selectedExclusively() \u00b6 \u8fd4\u56de Determines if exclusive field selection has been made. query.selectedExclusively() query.select('-name') query.selectedExclusively() query.selectedInclusively()","title":"\u67e5\u8be2API"},{"location":"query/api/#_1","text":"","title":"\u67e5\u8be2"},{"location":"query/api/#query","text":"\u53c2\u6570 [collection] \u00abObject\u00bb Mongoose collection Query constructor used for building queries. You do not need to instantiate a Query directly. Instead use Model functions like [ Model.find() . \u793a\u4f8b const query = MyModel . find (); query . setOptions ({ lean : true }); query . collection ( model . collection ); query . where ( 'age' ) . gte ( 21 ) . exec ( callback ); const query = new mongoose . Query ();","title":"Query()"},{"location":"query/api/#queryprototypeusegeowithin","text":"Flag to opt out of using $geoWithin . mongoose.Query.use$geoWithin = false; MongoDB 2.4 deprecated the use of $within , replacing it with $geoWithin . Mongoose uses $geoWithin by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to false so your within() queries continue to work.","title":"Query.prototype.use$geoWithin"},{"location":"query/api/#queryprototypetoconstructor","text":"\u8fd4\u56de \u00abQuery\u00bb subclass-of-Query Converts this query to a customized, reusable query constructor with all arguments and options retained. \u793a\u4f8b var query = Movie . find ({ tags : 'adventure' }) . read ( 'primaryPreferred' ); var Adventure = query . toConstructor (); Adventure () . exec ( callback ) Adventure () . where ({ name : /^ Life / }) . exec ( callback ); Adventure . prototype . startsWith = function ( prefix ) { this . where ({ name : new RegExp ( '^' + prefix ) }) return this ; } Object . defineProperty ( Adventure . prototype , 'highlyRated' , { get : function () { this . where ({ rating : { $ gt : 4.5 }}); return this ; } }) Adventure () . highlyRated . startsWith ( 'Life' ) . exec ( callback ) New in 3.7.3","title":"Query.prototype.toConstructor()"},{"location":"query/api/#queryprototypewhere","text":"\u53c2\u6570 js \u00abString,Function\u00bb javascript string or function \u8fd4\u56de Specifies a javascript function or expression to pass to MongoDBs query system. \u793a\u4f8b query .$ where ( ' this.comments.length === 10 || this.name.length === 5 ' ) query .$ where ( function () { return this . comments . length === 10 || this . name . length === 5 ; } ) \u6ce8\u91ca Only use $where when you have a condition that cannot be met using other MongoDB operators like $lt . Be sure to read about all of [its caveats before using.","title":"Query.prototype.$where()"},{"location":"query/api/#queryprototypewhere_1","text":"\u53c2\u6570 \u8fd4\u56de Specifies a path for use with chaining. \u793a\u4f8b User.find ( { age : { $gte : 21 , $lte : 65 }} , callback ) ; User.where ( ' age ' ). gte ( 21 ). lte ( 65 ) ; User.find (). where ( { name : ' vonderful ' } ) User .where ( ' age ' ). gte ( 21 ). lte ( 65 ) .where ( ' name ' , /^ vonderful / i ) .where ( ' friends ' ). slice ( 10 ) .exec ( callback )","title":"Query.prototype.where()"},{"location":"query/api/#queryprototypeequals","text":"\u53c2\u6570 \u8fd4\u56de Specifies the complementary comparison value for paths specified with where() \u793a\u4f8b User.where('age').equals(49); User.where('age', 49);","title":"Query.prototype.equals()"},{"location":"query/api/#queryprototypeor","text":"\u53c2\u6570 array \u00abArray\u00bb array of conditions \u8fd4\u56de Specifies arguments for an $or condition. \u793a\u4f8b query.or([{ color: 'red' }, { status: 'emergency' }])","title":"Query.prototype.or()"},{"location":"query/api/#queryprototypenor","text":"\u53c2\u6570 array \u00abArray\u00bb array of conditions \u8fd4\u56de Specifies arguments for a $nor condition. \u793a\u4f8b query.nor([{ color: 'green' }, { status: 'ok' }])","title":"Query.prototype.nor()"},{"location":"query/api/#queryprototypeand","text":"\u53c2\u6570 array \u00abArray\u00bb array of conditions \u8fd4\u56de Specifies arguments for a $and condition. \u793a\u4f8b query.and([{ color: 'green' }, { status: 'ok' }])","title":"Query.prototype.and()"},{"location":"query/api/#queryprototypegt","text":"\u53c2\u6570 Specifies a $gt query condition. When called with one argument, the most recent path passed to where() is used. \u793a\u4f8b Thing.find().where('age').gt(21) Thing.find().gt('age', 21)","title":"Query.prototype.gt()"},{"location":"query/api/#queryprototypegte","text":"\u53c2\u6570 Specifies a $gte query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.gte()"},{"location":"query/api/#queryprototypelt","text":"\u53c2\u6570 Specifies a $lt query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.lt()"},{"location":"query/api/#queryprototypelte","text":"\u53c2\u6570 Specifies a $lte query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.lte()"},{"location":"query/api/#queryprototypene","text":"\u53c2\u6570 Specifies a $ne query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.ne()"},{"location":"query/api/#queryprototypein","text":"\u53c2\u6570 Specifies an $in query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.in()"},{"location":"query/api/#queryprototypenin","text":"\u53c2\u6570 Specifies an $nin query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.nin()"},{"location":"query/api/#queryprototypeall","text":"\u53c2\u6570 Specifies an $all query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.all()"},{"location":"query/api/#queryprototypesize","text":"\u53c2\u6570 Specifies a $size query condition. When called with one argument, the most recent path passed to where() is used. \u793a\u4f8b MyModel . where ( ' tags ' ) . size ( 0 ) . exec ( function ( err , docs ) { if ( err ) return handleError ( err ) ; assert ( Array . isArray ( docs )) ; console . log ( ' documents with 0 tags ' , docs ) ; } )","title":"Query.prototype.size()"},{"location":"query/api/#queryprototyperegex","text":"\u53c2\u6570 Specifies a $regex query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.regex()"},{"location":"query/api/#queryprototypemaxdistance","text":"\u53c2\u6570 Specifies a $maxDistance query condition. When called with one argument, the most recent path passed to where() is used.","title":"Query.prototype.maxDistance()"},{"location":"query/api/#queryprototypemod","text":"\u53c2\u6570 val \u00abArray\u00bb must be of length 2, first element is divisor , 2nd element is remainder . \u8fd4\u56de Specifies a $mod condition, filters documents for documents whose path property is a number that is equal to remainder modulo divisor . \u793a\u4f8b Product.find().mod('inventory', [2, 1]); Product.find().where('inventory').mod([2, 1]); Product.find().where('inventory').mod(2, 1);","title":"Query.prototype.mod()"},{"location":"query/api/#queryprototypeexists","text":"\u53c2\u6570 \u8fd4\u56de Specifies an $exists condition \u793a\u4f8b Thing.where('name').exists() Thing.where('name').exists(true) Thing.find().exists('name') Thing.where('name').exists(false); Thing.find().exists('name', false);","title":"Query.prototype.exists()"},{"location":"query/api/#queryprototypeelemmatch","text":"\u53c2\u6570 criteria \u00abObject,Function\u00bb \u8fd4\u56de Specifies an $elemMatch condition \u793a\u4f8b query . elemMatch ( 'comment' , { author : 'autobot' , votes : {$ gte : 5 } } ) query . where ( 'comment' ) . elemMatch ( { author : 'autobot' , votes : {$ gte : 5 } } ) query . elemMatch ( 'comment' , function ( elem ) { elem.where('author').equals('autobot') ; elem.where('votes').gte(5) ; } ) query . where ( 'comment' ) . elemMatch ( function ( elem ) { elem.where({ author : 'autobot' } ); elem . where ( 'votes' ) . gte ( 5 ); } )","title":"Query.prototype.elemMatch()"},{"location":"query/api/#queryprototypewithin","text":"\u8fd4\u56de Defines a $within or $geoWithin argument for geo-spatial queries. \u793a\u4f8b query . where ( path ) . within () . box () query . where ( path ) . within () . circle () query . where ( path ) . within () . geometry () query . where ( 'loc' ) . within ( { center : [ 50 , 50 ] , radius : 10 , unique : true , spherical : true } ); query . where ( 'loc' ) . within ( { box : [ [ 40.73 , - 73.9 ] , [ 40.7 , - 73.988 ] ] } ); query . where ( 'loc' ) . within ( { polygon : [ [ ] , [] , [] , [] ] } ); query . where ( 'loc' ) . within ( [] , [] , [] ) query . where ( 'loc' ) . within ( [] , [] ) query . where ( 'loc' ) . within ( { type : 'LineString' , coordinates : [ ... ] } ); MUST be used after where() . \u6ce8\u91ca As of Mongoose 3.7, $geoWithin is always used for queries. To change this behavior, see [Query.use$geoWithin. \u6ce8\u91ca In Mongoose 3.7, within changed from a getter to a function. If you need the old syntax, use [this.","title":"Query.prototype.within()"},{"location":"query/api/#queryprototypeslice","text":"\u53c2\u6570 val \u00abNumber\u00bb number/range of elements to slice \u8fd4\u56de Specifies a $slice projection for an array. \u793a\u4f8b query.slice('comments', 5) query.slice('comments', -5) query.slice('comments', [10, 5]) query.where('comments').slice(5) query.where('comments').slice([-10, 5])","title":"Query.prototype.slice()"},{"location":"query/api/#queryprototypelimit","text":"\u53c2\u6570 Specifies the maximum number of documents the query will return. \u793a\u4f8b query.limit(20) \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.limit()"},{"location":"query/api/#queryprototypeskip","text":"\u53c2\u6570 Specifies the number of documents to skip. \u793a\u4f8b query.skip(100).limit(20) \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.skip()"},{"location":"query/api/#queryprototypemaxscan","text":"\u53c2\u6570 Specifies the maxScan option. \u793a\u4f8b query.maxScan(100) \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.maxScan()"},{"location":"query/api/#queryprototypebatchsize","text":"\u53c2\u6570 Specifies the batchSize option. \u793a\u4f8b query.batchSize(100) \u6ce8\u91ca Cannot be used with distinct() \u53c2\u6570 Specifies the comment option. \u793a\u4f8b query.comment('login query') \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.batchSize()"},{"location":"query/api/#queryprototypesnapshot","text":"\u8fd4\u56de Specifies this query as a snapshot query. \u793a\u4f8b query.snapshot() query.snapshot(true) query.snapshot(false) \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.snapshot()"},{"location":"query/api/#queryprototypehint","text":"\u53c2\u6570 val \u00abObject\u00bb a hint object \u8fd4\u56de Sets query hints. \u793a\u4f8b query.hint({ indexA: 1, indexB: -1}) \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.hint()"},{"location":"query/api/#queryprototypeselect","text":"\u53c2\u6570 \u8fd4\u56de Specifies which document fields to include or exclude (also known as the query \"projection\") When using string syntax, prefixing a path with - will flag that path as excluded. When a path does not have the - prefix, it is included. Lastly, if a path is prefixed with + , it forces inclusion of the path, which is useful for paths excluded at the [schema level. A projection must be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The [ _id field is the only exception because MongoDB includes it by default. \u793a\u4f8b query . select ( 'a b' ); query . select ( '-c -d' ); query . select ( { a : 1 , b : 1 } ); query . select ( { c : 0 , d : 0 } ); query . select ( '+path' )","title":"Query.prototype.select()"},{"location":"query/api/#queryprototypeslaveok","text":"\u53c2\u6570 v \u00abBoolean\u00bb defaults to true \u8fd4\u56de DEPRECATED Sets the slaveOk option. Deprecated in MongoDB 2.2 in favor of [read preferences. \u793a\u4f8b query.slaveOk() query.slaveOk(true) query.slaveOk(false)","title":"Query.prototype.slaveOk()"},{"location":"query/api/#queryprototyperead","text":"\u53c2\u6570 [tags] \u00abArray\u00bb optional tags for this query \u8fd4\u56de Determines the MongoDB nodes from which to read. \u559c\u597d primary - ( default ) Read from primary only . Operations will produce an error if primary is unavailable . Cannot be combined with tags . secondary Read from secondary if available , otherwise error . primaryPreferred Read from primary if available , otherwise a secondary . secondaryPreferred Read from a secondary if available , otherwise read from the primary . nearest All operations read from among the nearest candidates , but unlike other modes , this option will include both the primary and all secondaries in the random selection . \u522b\u540d p primary pp primaryPreferred s secondary sp secondaryPreferred n nearest \u793a\u4f8b new Query().read('primary') new Query().read('p') new Query().read('primaryPreferred') new Query().read('pp') new Query().read('secondary') new Query().read('s') new Query().read('secondaryPreferred') new Query().read('sp') new Query().read('nearest') new Query().read('n') new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]) Read more about how to use read preferrences [here and [here.","title":"Query.prototype.read()"},{"location":"query/api/#queryprototypemerge","text":"\u53c2\u6570 \u8fd4\u56de Merges another Query or conditions object into this one. When a Query is passed, conditions, field selection and options are merged. New in 3.7.0","title":"Query.prototype.merge()"},{"location":"query/api/#queryprototypesetoptions","text":"\u53c2\u6570 Sets query options. Some options only make sense for certain operations. \u9009\u9879 The following options are only for find() : - [tailable - [sort - [limit - [skip - [maxscan - [batchSize - [comment - [snapshot - [readPreference - [hint The following options are only for update() , updateOne() , updateMany() , replaceOne() , findOneAndUpdate() , and findByIdAndUpdate() : - [upsert - [writeConcern The following options are only for find() , findOne() , findById() , findOneAndUpdate() , findByIdAndUpdate() , and geoSearch() : - [lean The following options are for all operations","title":"Query.prototype.setOptions()"},{"location":"query/api/#queryprototypegetquery","text":"\u8fd4\u56de \u00abObject\u00bb current query conditions Returns the current query conditions as a JSON object. \u793a\u4f8b var query = new Query (); query . find ({ a : 1 }) . where ( 'b' ) . gt ( 2 ); query . getQuery ();","title":"Query.prototype.getQuery()"},{"location":"query/api/#queryprototypegetupdate","text":"\u8fd4\u56de \u00abObject\u00bb current update operations Returns the current update operations as a JSON object. \u793a\u4f8b var query = new Query (); query . update ({}, { $ set : { a : 5 } }); query . getUpdate ();","title":"Query.prototype.getUpdate()"},{"location":"query/api/#queryprototypelean","text":"\u53c2\u6570 bool \u00abBoolean,Object\u00bb defaults to true \u8fd4\u56de Sets the lean option. Documents returned from queries with the lean option enabled are plain javascript objects, not [MongooseDocuments. They have no save method, getters/setters or other Mongoose magic applied. \u793a\u4f8b new Query () . lean () new Query () . lean ( true ) new Query () . lean ( false ) Model . find () . lean () . exec ( function ( err , docs ) { docs [ 0 ] instanceof mongoose . Document } ) ; This is a [great option in high-performance read-only scenarios, especially when combined with [stream.","title":"Query.prototype.lean()"},{"location":"query/api/#queryprototypeerror","text":"\u53c2\u6570 err \u00abError,null\u00bb if set, exec() will fail fast before sending the query to MongoDB Gets/sets the error flag on this query. If this flag is not null or undefined, the exec() promise will reject without executing. \u793a\u4f8b Query () . error () ; Query () . error ( null ) ; Query () . error ( new Error ( ' test ' )) ; Schema . pre ( ' find ' , function () { if ( ! this . getQuery () . userId ) { this . error ( new Error ( ' Not allowed to query without setting userId ' )) ; } } ) ; Note that query casting runs after hooks, so cast errors will override custom errors. \u793a\u4f8b var TestSchema = new Schema ({ num : Number }); var TestModel = db . model ( 'Test' , TestSchema ); TestModel . find ({ num : 'not a number' }) . error ( new Error ( 'woops' )) . exec ( function ( error ) { });","title":"Query.prototype.error()"},{"location":"query/api/#queryprototypemongooseoptions","text":"\u53c2\u6570 options \u00abObject\u00bb if specified, overwrites the current options Getter/setter around the current mongoose-specific options for this query (populate, lean, etc.)","title":"Query.prototype.mongooseOptions()"},{"location":"query/api/#queryprototypefind","text":"\u53c2\u6570 \u8fd4\u56de Finds documents. When no callback is passed, the query is not executed. When the query is executed, the result will be an array of documents. \u793a\u4f8b query.find({ name: 'Los Pollos Hermanos' }).find(callback)","title":"Query.prototype.find()"},{"location":"query/api/#queryprototypemerge_1","text":"\u53c2\u6570 \u8fd4\u56de Merges another Query or conditions object into this one. When a Query is passed, conditions, field selection and options are merged.","title":"Query.prototype.merge()"},{"location":"query/api/#queryprototypecollation","text":"\u53c2\u6570 \u8fd4\u56de Adds a collation to this op (MongoDB 3.4 and up)","title":"Query.prototype.collation()"},{"location":"query/api/#queryprototypefindone","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, document) \u8fd4\u56de Declares the query a findOne operation. When executed, the first found document is passed to the callback. Passing a callback executes the query. The result of the query is a single document. Note: conditions is optional, and if conditions is null or undefined, mongoose will send an empty findOne command to MongoDB, which will return an arbitrary document. If you're querying by _id , use Model.findById() instead. This function triggers the following middleware. \u793a\u4f8b var query = Kitten . where ({ color : 'white' }); query . findOne ( function ( err , kitten ) { if ( err ) return handleError ( err ); if ( kitten ) { } });","title":"Query.prototype.findOne()"},{"location":"query/api/#queryprototypecount","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, count) \u8fd4\u56de Specifying this query as a count query. Passing a callback executes the query. This function triggers the following middleware. \u793a\u4f8b var countQuery = model . where ({ 'color' : 'black' }) . count (); query . count ({ color : 'black' }) . count ( callback ) query . count ({ color : 'black' }, callback ) query . where ( 'color' , 'black' ) . count ( function ( err , count ) { if ( err ) return handleError ( err ); console . log ( 'there are %d kittens' , count ); })","title":"Query.prototype.count()"},{"location":"query/api/#queryprototypedistinct","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, arr) \u8fd4\u56de Declares or executes a distict() operation. Passing a callback executes the query. This function does not trigger any middleware. \u793a\u4f8b distinct(field, conditions, callback) distinct(field, conditions) distinct(field, callback) distinct(field) distinct(callback) distinct()","title":"Query.prototype.distinct()"},{"location":"query/api/#queryprototypesort","text":"\u53c2\u6570 \u8fd4\u56de Sets the sort order If an object is passed, values allowed are asc , desc , ascending , descending , 1 , and -1 . If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with - which will be treated as descending. \u793a\u4f8b query . sort ( { field : 'asc' , test : -1 } ); query . sort ( 'field -test' ); \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.sort()"},{"location":"query/api/#queryprototyperemove","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a remove() operation. This function does not trigger any middleware \u793a\u4f8b Model.remove({ artist: 'Anne Murray' }, callback) \u6ce8\u91ca The operation is only executed when a callback is passed. To force execution without a callback, you must first call remove() and then execute it by using the exec() method. var query = Model . find () . remove ({ name : 'Anne Murray' }) query . remove ({ name : 'Anne Murray' }, callback ) query . remove ({ name : 'Anne Murray' }) . remove ( callback ) query . exec () query . remove ( conds , fn ); query . remove ( conds ) query . remove ( fn ) query . remove ()","title":"Query.prototype.remove()"},{"location":"query/api/#queryprototypedeleteone","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a deleteOne() operation. Works like remove, except it deletes at most one document regardless of the single option. This function does not trigger any middleware. \u793a\u4f8b Character . deleteOne ( { name : ' Eddard Stark ' }, callback ) Character . deleteOne ( { name : ' Eddard Stark ' } ) . then ( next )","title":"Query.prototype.deleteOne()"},{"location":"query/api/#queryprototypedeletemany","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a deleteMany() operation. Works like remove, except it deletes every document that matches criteria in the collection, regardless of the value of single . This function does not trigger any middleware \u793a\u4f8b Character . deleteMany ( { name : / Stark / , age : { $ gte : 18 } }, callback ) Character . deleteMany ( { name : / Stark / , age : { $ gte : 18 } } ) . then ( next )","title":"Query.prototype.deleteMany()"},{"location":"query/api/#queryprototypefindoneandupdate","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, doc), unless rawResult is used, in which case params are (error, writeOpResult) \u8fd4\u56de Issues a mongodb [findAndModify update command. Finds a matching document, updates it according to the update arg, passing any options , and returns the found document (if any) to the callback. The query executes immediately if callback is passed. This function triggers the following middleware. \u9009\u9879 new : bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0) upsert : bool - creates the object if it doesn't exist. defaults to false. fields : {Object|String} - Field selection. Equivalent to .select(fields).findOneAndUpdate() sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. rawResult : if true, returns the [raw result from the MongoDB driver context (string) if set to 'query' and runValidators is on, this will refer to the query in custom validator functions that update validation runs. Does nothing if runValidators is false. \u56de\u8c03\u7b7e\u540d function(error, doc) { } \u793a\u4f8b query.findOneAndUpdate(conditions, update, options, callback) query.findOneAndUpdate(conditions, update, options) query.findOneAndUpdate(conditions, update, callback) query.findOneAndUpdate(conditions, update) query.findOneAndUpdate(update, callback) query.findOneAndUpdate(update) query.findOneAndUpdate(callback) query.findOneAndUpdate()","title":"Query.prototype.findOneAndUpdate()"},{"location":"query/api/#queryprototypefindoneandremove","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, document) \u8fd4\u56de Issues a mongodb [findAndModify remove command. Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if callback is passed. This function triggers the following middleware. \u9009\u9879 sort : if multiple docs are found by the conditions, sets the sort order to choose which doc to update maxTimeMS : puts a time limit on the query - requires mongodb >= 2.6.0 rawResult : if true, resolves to the [raw result from the MongoDB driver \u56de\u8c03\u7b7e\u540d function(error, doc) { } \u793a\u4f8b s A.where().findOneAndRemove(conditions, options, callback) A.where().findOneAndRemove(conditions, options) A.where().findOneAndRemove(conditions, callback) A.where().findOneAndRemove(conditions) A.where().findOneAndRemove(callback) A.where().findOneAndRemove()","title":"Query.prototype.findOneAndRemove()"},{"location":"query/api/#queryprototypeupdate","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional, params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as an update() operation. All paths passed that are not $atomic operations will become $set ops. This function triggers the following middleware. \u793a\u4f8b Model.where({ _id: id }).update({ title: 'words' }) Model.where({ _id: id }).update({ $set: { title: 'words' }}) \u9009\u9879 safe (boolean) safe mode (defaults to value set in schema (true)) upsert (boolean) whether to create the doc if it doesn't match (false) multi (boolean) whether multiple documents should be updated (false) runValidators : if true, runs [update validators on this command. Update validators validate the update operation against the model's schema. setDefaultsOnInsert : if this and upsert are true, mongoose will apply the [defaults specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's $setOnInsert operator. strict (boolean) overrides the strict option for this update overwrite (boolean) disables update-only mode, allowing you to overwrite the doc (false) context (string) if set to 'query' and runValidators is on, this will refer to the query in custom validator functions that update validation runs. Does nothing if runValidators is false. \u6ce8\u91ca Passing an empty object {} as the doc will result in a no-op unless the overwrite option is passed. Without the overwrite option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection. \u6ce8\u91ca The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the exec() method. var q = Model . where ({ _id : id }); q . update ({ $ set : { name : 'bob' }}) . update (); // not executed q . update ({ $ set : { name : 'bob' }}) . exec (); // executed // keys that are not $ atomic ops become $ set . // this executes the same command as the previous example . q . update ({ name : 'bob' }) . exec (); // overwriting with empty docs var q = Model . where ({ _id : id }) . setOptions ({ overwrite : true }) q . update ({ }, callback ); // executes // multi update with overwrite to empty doc var q = Model . where ({ _id : id }); q . setOptions ({ multi : true , overwrite : true }) q . update ({ }); q . update ( callback ); // executed // multi updates Model . where () . update ({ name : /^ match / }, { $ set : { arr : [] }}, { multi : true }, callback ) // more multi updates Model . where () . setOptions ({ multi : true }) . update ({ $ set : { arr : [] }}, callback ) // single update by default Model . where ({ email : '[address@example.com' }) . update ({ $ inc : { counter : 1 }}, callback ) API summary update(criteria, doc, options, cb) update(criteria, doc, options) update(criteria, doc, cb) update(criteria, doc) update(doc, cb) update(doc) update(cb) update(true) update()","title":"Query.prototype.update()"},{"location":"query/api/#queryprototypeupdatemany","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as an updateMany() operation. Same as update() , except MongoDB will update all documents that match criteria (as opposed to just the first one) regardless of the value of the multi option. Note updateMany will not fire update middleware. Use pre('updateMany') and post('updateMany') instead. This function triggers the following middleware.","title":"Query.prototype.updateMany()"},{"location":"query/api/#queryprototypeupdateone","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as an updateOne() operation. Same as update() , except MongoDB will update only the first document that matches criteria regardless of the value of the multi option. Note updateOne will not fire update middleware. Use pre('updateOne') and post('updateOne') instead. This function triggers the following middleware.","title":"Query.prototype.updateOne()"},{"location":"query/api/#queryprototypereplaceone","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params are (error, writeOpResult) \u8fd4\u56de Declare and/or execute this query as a replaceOne() operation. Same as update() , except MongoDB will replace the existing document and will not accept any atomic operators ( $set , etc.) Note replaceOne will not fire update middleware. Use pre('replaceOne') and post('replaceOne') instead. This function triggers the following middleware.","title":"Query.prototype.replaceOne()"},{"location":"query/api/#queryprototypeexec","text":"\u53c2\u6570 [callback] \u00abFunction\u00bb optional params depend on the function being called \u8fd4\u56de Executes the query \u793a\u4f8b var promise = query . exec (); var promise = query . exec ( 'update' ); query . exec ( callback ); query . exec ( 'find' , callback );","title":"Query.prototype.exec()"},{"location":"query/api/#queryprototypethen","text":"\u53c2\u6570 \u8fd4\u56de Executes the query returning a Promise which will be resolved with either the doc(s) or rejected with the error.","title":"Query.prototype.then()"},{"location":"query/api/#queryprototypecatch","text":"\u53c2\u6570 \u8fd4\u56de Executes the query returning a Promise which will be resolved with either the doc(s) or rejected with the error. Like .then() , but only takes a rejection handler.","title":"Query.prototype.catch()"},{"location":"query/api/#queryprototypepopulate","text":"\u53c2\u6570 [options] \u00abObject\u00bb Options for the population query (sort, etc) \u8fd4\u56de Specifies paths which should be populated with other documents. \u793a\u4f8b Kitten . findOne () . populate ( ' owner ' ) . exec ( function ( err , kitten ) { console . log ( kitten . owner . name ) } ) Kitten . find () . populate ( { path : ' owner ' , select : ' name ' , match : { color : ' black ' } , options : { sort : { name : - 1 }} } ) . exec ( function ( err , kittens ) { console . log ( kittens [ 0 ]. owner . name ) } ) Kitten . find () . populate ( ' owner ' , ' name ' , null , { sort : { name : - 1 }} ) . exec ( function ( err , kittens ) { console . log ( kittens [ 0 ]. owner . name ) } ) Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.","title":"Query.prototype.populate()"},{"location":"query/api/#queryprototypecast","text":"\u53c2\u6570 \u8fd4\u56de Casts this query to the schema of model \u6ce8\u91ca If obj is present, it is cast instead of this query.","title":"Query.prototype.cast()"},{"location":"query/api/#queryprototypecursor","text":"\u53c2\u6570 \u8fd4\u56de Returns a wrapper around a [mongodb driver cursor. A QueryCursor exposes a [Streams3-compatible interface, as well as a .next() function. The .cursor() function triggers pre find hooks, but not post find hooks. \u793a\u4f8b Thing . find ({ name : /^ hello / }) . cursor () . on ( 'data' , function ( doc ) { console . log ( doc ); }) . on ( 'end' , function () { console . log ( 'Done!' ); }); var cursor = Thing . find ({ name : /^ hello / }) . cursor (); cursor . next ( function ( error , doc ) { console . log ( doc ); }); co ( function * () { const cursor = Thing . find ({ name : /^ hello / }) . cursor (); for ( let doc = yield cursor . next (); doc != null ; doc = yield cursor . next ()) { console . log ( doc ); } }); \u9009\u9879 transform : optional function which accepts a mongoose document. The return value of the function will be emitted on data and returned by .next() .","title":"Query.prototype.cursor()"},{"location":"query/api/#queryprototypemaxscan_1","text":"DEPRECATED Alias of maxScan","title":"Query.prototype.maxscan()"},{"location":"query/api/#queryprototypetailable","text":"\u53c2\u6570 [opts.tailableRetryInterval] \u00abNumber\u00bb if cursor is exhausted, wait this many milliseconds before retrying Sets the tailable option (for use with capped collections). \u793a\u4f8b query.tailable() query.tailable(true) query.tailable(false) \u6ce8\u91ca Cannot be used with distinct()","title":"Query.prototype.tailable()"},{"location":"query/api/#queryprototypeintersects","text":"\u53c2\u6570 \u8fd4\u56de Declares an intersects query for geometry() . \u793a\u4f8b query.where('path').intersects().geometry({ type: 'LineString' , coordinates: [[180.0, 11.0], [180, 9.0]] }) query.where('path').intersects({ type: 'LineString' , coordinates: [[180.0, 11.0], [180, 9.0]] }) \u6ce8\u91ca MUST be used after where() . \u6ce8\u91ca In Mongoose 3.7, intersects changed from a getter to a function. If you need the old syntax, use [this.","title":"Query.prototype.intersects()"},{"location":"query/api/#queryprototypegeometry","text":"\u53c2\u6570 object \u00abObject\u00bb Must contain a type property which is a String and a coordinates property which is an Array. See the examples. \u8fd4\u56de Specifies a $geometry condition \u793a\u4f8b var polyA = [[[ 10 , 20 ], [ 10 , 40 ], [ 30 , 40 ], [ 30 , 20 ]]] query . where ( 'loc' ) . within () . geometry ({ type : 'Polygon' , coordinates : polyA }) var polyB = [[ 0 , 0 ], [ 1 , 1 ]] query . where ( 'loc' ) . within () . geometry ({ type : 'LineString' , coordinates : polyB }) var polyC = [ 0 , 0 ] query . where ( 'loc' ) . within () . geometry ({ type : 'Point' , coordinates : polyC }) query . where ( 'loc' ) . intersects () . geometry ({ type : 'Point' , coordinates : polyC }) The argument is assigned to the most recent path passed to where() . \u6ce8\u91ca geometry() must come after either intersects() or within() . The object argument must contain type and coordinates properties. - type {String} - coordinates {Array}","title":"Query.prototype.geometry()"},{"location":"query/api/#queryprototypenear","text":"\u53c2\u6570 \u8fd4\u56de Specifies a $near or $nearSphere condition These operators return documents sorted by distance. \u793a\u4f8b query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] } ); query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] , maxDistance : 5 } ); query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] , maxDistance : 5 , spherical : true } ); query . near ( 'loc' , { center : [ 10 , 10 ] , maxDistance : 5 } );","title":"Query.prototype.near()"},{"location":"query/api/#queryprototypenearsphere","text":"DEPRECATED Specifies a $nearSphere condition \u793a\u4f8b query . where ( 'loc' ) . nearSphere ( { center : [ 10 , 10 ] , maxDistance : 5 } ); Deprecated. Use query.near() instead with the spherical option set to true . \u793a\u4f8b query . where ( 'loc' ) . near ( { center : [ 10 , 10 ] , spherical : true } );","title":"Query.prototype.nearSphere()"},{"location":"query/api/#queryprototypepolygon","text":"\u53c2\u6570 [coordinatePairs...] \u00abArray,Object\u00bb \u8fd4\u56de Specifies a $polygon condition \u793a\u4f8b query.where('loc').within().polygon([10,20], [13, 25], [7,15]) query.polygon('loc', [10,20], [13, 25], [7,15])","title":"Query.prototype.polygon()"},{"location":"query/api/#queryprototypebox","text":"\u53c2\u6570 Upper \u00ab[Array]\u00bb Right Coords \u8fd4\u56de Specifies a $box condition \u793a\u4f8b var lowerLeft = [ 40.73083 , - 73.99756 ] var upperRight = [ 40.741404 , - 73.988135 ] query . where ( 'loc' ) . within () . box ( lowerLeft , upperRight ) query . box ({ ll : lowerLeft , ur : upperRight })","title":"Query.prototype.box()"},{"location":"query/api/#queryprototypecircle","text":"\u53c2\u6570 \u8fd4\u56de Specifies a $center or $centerSphere condition. \u793a\u4f8b var area = { center : [ 50 , 50 ], radius : 10 , unique : true } query . where ( 'loc' ) . within () . circle ( area ) query . circle ( 'loc' , area ); var area = { center : [ 50 , 50 ], radius : 10 , unique : true , spherical : true } query . where ( 'loc' ) . within () . circle ( area ) query . circle ( 'loc' , area ); New in 3.7.0","title":"Query.prototype.circle()"},{"location":"query/api/#queryprototypecenter","text":"","title":"Query.prototype.center()"},{"location":"query/api/#queryprototypecentersphere","text":"\u53c2\u6570 \u8fd4\u56de DEPRECATED Specifies a $centerSphere condition Deprecated. Use [circle instead. \u793a\u4f8b var area = { center : [ 50 , 50 ], radius : 10 }; query . where ( 'loc' ) . within () . centerSphere ( area );","title":"Query.prototype.centerSphere()"},{"location":"query/api/#queryprototypeselected","text":"\u8fd4\u56de Determines if field selection has been made.","title":"Query.prototype.selected()"},{"location":"query/api/#queryprototypeselectedinclusively","text":"\u8fd4\u56de Determines if inclusive field selection has been made. query.selectedInclusively() query.select('name') query.selectedInclusively()","title":"Query.prototype.selectedInclusively()"},{"location":"query/api/#queryprototypeselectedexclusively","text":"\u8fd4\u56de Determines if exclusive field selection has been made. query.selectedExclusively() query.select('-name') query.selectedExclusively() query.selectedInclusively()","title":"Query.prototype.selectedExclusively()"},{"location":"query/guide/","text":"\u67e5\u8be2 \u00b6 Source Documents can be retrieved through several static helper methods of models . Any model method which involves specifying query conditions can be executed two ways: When a callback function: is passed, the operation will be executed immediately with the results passed to the callback. is not passed, an instance of Query is returned, which provides a special query builder interface. A Query has a .then() function, and thus can be used as a promise. When executing a query with a callback function, you specify your query as a JSON document. The JSON document's syntax is the same as the MongoDB shell . var Person = mongoose . model ( 'Person' , yourSchema ); Person . findOne ({ 'name.last' : 'Ghost' }, 'name occupation' , function ( err , person ) { if ( err ) return handleError ( err ); console . log ( ' %s %s is a %s .' , person . name . first , person . name . last , person . occupation ); }); Here we see that the query was executed immediately and the results passed to our callback. All callbacks in Mongoose use the pattern: callback(error, result) . If an error occurs executing the query, the error parameter will contain an error document, and result will be null. If the query is successful, the error parameter will be null, and the result will be populated with the results of the query. Anywhere a callback is passed to a query in Mongoose, the callback follows the pattern callback(error, results) . What results is depends on the operation: For findOne() it is a potentially-null single document , find() a list of documents , count() the number of documents , update() the number of documents affected , etc. The API docs for Models provide more detail on what is passed to the callbacks. Now let's look at what happens when no callback is passed: var query = Person . findOne ({ 'name.last' : 'Ghost' }); query . select ( 'name occupation' ); query . exec ( function ( err , person ) { if ( err ) return handleError ( err ); console . log ( ' %s %s is a %s .' , person . name . first , person . name . last , person . occupation ); }); In the above code, the query variable is of type Query . A Query enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent. Person . find ( { occupation : / host / , 'name.last' : 'Ghost' , age : { $ gt : 17 , $ lt : 66 } , likes : { $ in : [ 'vaporizing' , 'talking' ] } } ). limit ( 10 ). sort ( { occupation : -1 } ). select ( { name : 1 , occupation : 1 } ). exec ( callback ); Person . find ( { occupation : / host / } ). where ( 'name.last' ) . equals ( 'Ghost' ). where ( 'age' ) . gt ( 17 ) . lt ( 66 ). where ( 'likes' ) . in ( [ 'vaporizing' , 'talking' ] ). limit ( 10 ). sort ( '-occupation' ). select ( 'name occupation' ). exec ( callback ); A full list of Query helper functions can be found in the API docs . \u53c2\u8003\u5176\u4ed6\u6587\u4ef6 \u00b6 There are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where population comes in. Read more about how to include documents from other collections in your query results here . \u6d41 \u00b6 You can stream query results from MongoDB. You need to call the Query#cursor() function to return an instance of QueryCursor . var cursor = Person . find ({ occupation : / host / }) . cursor (); cursor . on ( 'data' , function ( doc ) { }); cursor . on ( 'close' , function () { });","title":"\u67e5\u8be2\u624b\u518c"},{"location":"query/guide/#_1","text":"Source Documents can be retrieved through several static helper methods of models . Any model method which involves specifying query conditions can be executed two ways: When a callback function: is passed, the operation will be executed immediately with the results passed to the callback. is not passed, an instance of Query is returned, which provides a special query builder interface. A Query has a .then() function, and thus can be used as a promise. When executing a query with a callback function, you specify your query as a JSON document. The JSON document's syntax is the same as the MongoDB shell . var Person = mongoose . model ( 'Person' , yourSchema ); Person . findOne ({ 'name.last' : 'Ghost' }, 'name occupation' , function ( err , person ) { if ( err ) return handleError ( err ); console . log ( ' %s %s is a %s .' , person . name . first , person . name . last , person . occupation ); }); Here we see that the query was executed immediately and the results passed to our callback. All callbacks in Mongoose use the pattern: callback(error, result) . If an error occurs executing the query, the error parameter will contain an error document, and result will be null. If the query is successful, the error parameter will be null, and the result will be populated with the results of the query. Anywhere a callback is passed to a query in Mongoose, the callback follows the pattern callback(error, results) . What results is depends on the operation: For findOne() it is a potentially-null single document , find() a list of documents , count() the number of documents , update() the number of documents affected , etc. The API docs for Models provide more detail on what is passed to the callbacks. Now let's look at what happens when no callback is passed: var query = Person . findOne ({ 'name.last' : 'Ghost' }); query . select ( 'name occupation' ); query . exec ( function ( err , person ) { if ( err ) return handleError ( err ); console . log ( ' %s %s is a %s .' , person . name . first , person . name . last , person . occupation ); }); In the above code, the query variable is of type Query . A Query enables you to build up a query using chaining syntax, rather than specifying a JSON object. The below 2 examples are equivalent. Person . find ( { occupation : / host / , 'name.last' : 'Ghost' , age : { $ gt : 17 , $ lt : 66 } , likes : { $ in : [ 'vaporizing' , 'talking' ] } } ). limit ( 10 ). sort ( { occupation : -1 } ). select ( { name : 1 , occupation : 1 } ). exec ( callback ); Person . find ( { occupation : / host / } ). where ( 'name.last' ) . equals ( 'Ghost' ). where ( 'age' ) . gt ( 17 ) . lt ( 66 ). where ( 'likes' ) . in ( [ 'vaporizing' , 'talking' ] ). limit ( 10 ). sort ( '-occupation' ). select ( 'name occupation' ). exec ( callback ); A full list of Query helper functions can be found in the API docs .","title":"\u67e5\u8be2"},{"location":"query/guide/#_2","text":"There are no joins in MongoDB but sometimes we still want references to documents in other collections. This is where population comes in. Read more about how to include documents from other collections in your query results here .","title":"\u53c2\u8003\u5176\u4ed6\u6587\u4ef6"},{"location":"query/guide/#_3","text":"You can stream query results from MongoDB. You need to call the Query#cursor() function to return an instance of QueryCursor . var cursor = Person . find ({ occupation : / host / }) . cursor (); cursor . on ( 'data' , function ( doc ) { }); cursor . on ( 'close' , function () { });","title":"\u6d41"},{"location":"schema/api/","text":"\u6a21\u5f0f \u00b6 Schema() \u00b6 \u53c2\u6570 \u6a21\u5f0f\u6784\u9020\u51fd\u6570 \u793a\u4f8b var child = new Schema ( { name : String } ); var schema = new Schema ( { name : String , age : Number , children : [ child ] } ); var Tree = mongoose . model ( 'Tree' , schema ); new Schema ( { name : String } , { _id : false , autoIndex : false } ) \u9009\u9879 \u6ce8\u610f When nesting schemas, ( children in the \u793a\u4f8b above), always declare the child schema first before passing it into its parent. Schema.prototype.childSchemas \u00b6 Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: schema and model . This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose. Schema.prototype.obj \u00b6 The original object passed to the schema constructor \u793a\u4f8b var schema = new Schema ({ a : String }) . add ({ b : String }); schema . obj ; Schema.prototype.clone() \u00b6 \u8fd4\u56de \u00abSchema\u00bb the cloned schema \u8fd4\u56de a deep copy of the schema Schema.prototype.add() \u00b6 \u53c2\u6570 Adds key path / schema type pairs to this schema. \u793a\u4f8b var ToySchema = new Schema ; ToySchema . add ({ name : 'string' , color : 'string' , price : 'number' }); Schema.reserved \u00b6 Reserved document keys. Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error. on, emit, _events, db, get, set, init, isNew, errors, schema, \u9009\u9879, modelName, collection, _pres, _posts, toObject \u6ce8\u610f: Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on. var schema = new Schema ( .. ); schema . methods . init = function () {} Schema.prototype.path() \u00b6 \u53c2\u6570 Gets/sets schema paths. Sets a path (if arity 2) Gets a path (if arity 1) \u793a\u4f8b schema.path('name') schema.path('name', Number) Schema.prototype.eachPath() \u00b6 \u53c2\u6570 fn \u00abFunction\u00bb callback function \u8fd4\u56de Iterates the schemas paths similar to Array#forEach. The callback is passed the pathname and schemaType as arguments on each iteration. Schema.prototype.requiredPaths() \u00b6 \u53c2\u6570 invalidate \u00abBoolean\u00bb refresh the cache \u8fd4\u56de \u8fd4\u56de an Array of path strings that are required by this schema. Schema.prototype.pathType() \u00b6 \u53c2\u6570 \u8fd4\u56de \u8fd4\u56de the pathType of path for this schema. Given a path, \u8fd4\u56de whether it is a real, virtual, nested, or ad-hoc/undefined path. Schema.prototype.queue() \u00b6 \u53c2\u6570 args \u00abArray\u00bb arguments to pass to the method Adds a method call to the queue. Schema.prototype.pre() \u00b6 \u53c2\u6570 Defines a pre hook for the document. \u793a\u4f8b var toySchema = new Schema ( .. ); toySchema . pre ( 'save' , function ( next ) { if ( ! this . created ) this . created = new Date ; next (); }) toySchema . pre ( 'validate' , function ( next ) { if ( this . name !== 'Woody' ) this . name = 'Woody' ; next (); }) Schema.prototype.post() \u00b6 \u53c2\u6570 Defines a post hook for the document var schema = new Schema (..); schema . post ( 'save' , function ( doc ) { console . log ( 'this fired after a document was saved' ); } ); schema . post ( 'find' , function ( docs ) { console . log ( 'this fired after you run a find query' ); } ); var Model = mongoose . model ( 'Model' , schema ); var m = new Model (..); m . save ( function ( err ) { console . log ( 'this fires after the `post` hook' ); } ); m . find ( function ( err , docs ) { console . log ( 'this fires after the post find hook' ); } ); Schema.prototype.plugin() \u00b6 \u53c2\u6570 Registers a plugin for this schema. Schema.prototype.method() \u00b6 \u53c2\u6570 Adds an instance method to documents constructed from Models compiled from this schema. \u793a\u4f8b var schema = kittySchema = new Schema ( .. ); schema . method ( 'meow' , function () { console . log ( 'meeeeeoooooooooooow' ); }) var Kitty = mongoose . model ( 'Kitty' , schema ); var fizz = new Kitty ; fizz . meow (); If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods. schema . method ( { purr : function () { } , scratch : function () {} } ); fizz . purr (); fizz . scratch (); Schema.prototype.static() \u00b6 \u53c2\u6570 Adds static \"class\" methods to Models compiled from this schema. \u793a\u4f8b var schema = new Schema ( .. ); schema . static ( 'findByName' , function ( name , callback ) { return this . find ({ name : name }, callback ); }); var Drink = mongoose . model ( 'Drink' , schema ); Drink . findByName ( 'sanpellegrino' , function ( err , drinks ) { }); If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics. Schema.prototype.index() \u00b6 \u53c2\u6570 [\u9009\u9879.expires=null] \u00abString\u00bb Mongoose-specific syntactic sugar, uses [ms to convert expires option into seconds for the expireAfterSeconds in the above link. Defines an index (most likely compound) for this schema. \u793a\u4f8b schema.index({ first: 1, last: -1 }) Schema.prototype.set() \u00b6 \u53c2\u6570 [value] \u00abObject\u00bb if not passed, the current option value is returned Sets/gets a schema option. \u793a\u4f8b schema.set('strict'); schema.set('strict', false); schema.set('strict'); Schema.prototype.get() \u00b6 \u53c2\u6570 key \u00abString\u00bb option name indexTypes \u00b6 Schema.prototype.indexes() \u00b6 Compiles indexes from fields and schema-level indexes Schema.prototype.virtual() \u00b6 \u53c2\u6570 \u8fd4\u56de Creates a virtual type with the given name. Schema.prototype.virtualpath() \u00b6 \u53c2\u6570 \u8fd4\u56de \u8fd4\u56de the virtual type with the given name . Schema.prototype.remove() \u00b6 \u53c2\u6570 Removes the given path (or [ paths ]). Schema.prototype.loadClass() \u00b6 \u53c2\u6570 Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods. Schema.Types \u00b6 The various built-in Mongoose Schema Types. \u793a\u4f8b var mongoose = require ( 'mongoose' ); var ObjectId = mongoose . Schema . Types . ObjectId ; \u7c7b\u578b Using this exposed access to the Mixed SchemaType, we can use them in our schema. var Mixed = mongoose . Schema . Types . Mixed ; new mongoose . Schema ({ _user : Mixed })","title":"\u6a21\u5f0fAPI"},{"location":"schema/api/#_1","text":"","title":"\u6a21\u5f0f"},{"location":"schema/api/#schema","text":"\u53c2\u6570 \u6a21\u5f0f\u6784\u9020\u51fd\u6570 \u793a\u4f8b var child = new Schema ( { name : String } ); var schema = new Schema ( { name : String , age : Number , children : [ child ] } ); var Tree = mongoose . model ( 'Tree' , schema ); new Schema ( { name : String } , { _id : false , autoIndex : false } ) \u9009\u9879 \u6ce8\u610f When nesting schemas, ( children in the \u793a\u4f8b above), always declare the child schema first before passing it into its parent.","title":"Schema()"},{"location":"schema/api/#schemaprototypechildschemas","text":"Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: schema and model . This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.","title":"Schema.prototype.childSchemas"},{"location":"schema/api/#schemaprototypeobj","text":"The original object passed to the schema constructor \u793a\u4f8b var schema = new Schema ({ a : String }) . add ({ b : String }); schema . obj ;","title":"Schema.prototype.obj"},{"location":"schema/api/#schemaprototypeclone","text":"\u8fd4\u56de \u00abSchema\u00bb the cloned schema \u8fd4\u56de a deep copy of the schema","title":"Schema.prototype.clone()"},{"location":"schema/api/#schemaprototypeadd","text":"\u53c2\u6570 Adds key path / schema type pairs to this schema. \u793a\u4f8b var ToySchema = new Schema ; ToySchema . add ({ name : 'string' , color : 'string' , price : 'number' });","title":"Schema.prototype.add()"},{"location":"schema/api/#schemareserved","text":"Reserved document keys. Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error. on, emit, _events, db, get, set, init, isNew, errors, schema, \u9009\u9879, modelName, collection, _pres, _posts, toObject \u6ce8\u610f: Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on. var schema = new Schema ( .. ); schema . methods . init = function () {}","title":"Schema.reserved"},{"location":"schema/api/#schemaprototypepath","text":"\u53c2\u6570 Gets/sets schema paths. Sets a path (if arity 2) Gets a path (if arity 1) \u793a\u4f8b schema.path('name') schema.path('name', Number)","title":"Schema.prototype.path()"},{"location":"schema/api/#schemaprototypeeachpath","text":"\u53c2\u6570 fn \u00abFunction\u00bb callback function \u8fd4\u56de Iterates the schemas paths similar to Array#forEach. The callback is passed the pathname and schemaType as arguments on each iteration.","title":"Schema.prototype.eachPath()"},{"location":"schema/api/#schemaprototyperequiredpaths","text":"\u53c2\u6570 invalidate \u00abBoolean\u00bb refresh the cache \u8fd4\u56de \u8fd4\u56de an Array of path strings that are required by this schema.","title":"Schema.prototype.requiredPaths()"},{"location":"schema/api/#schemaprototypepathtype","text":"\u53c2\u6570 \u8fd4\u56de \u8fd4\u56de the pathType of path for this schema. Given a path, \u8fd4\u56de whether it is a real, virtual, nested, or ad-hoc/undefined path.","title":"Schema.prototype.pathType()"},{"location":"schema/api/#schemaprototypequeue","text":"\u53c2\u6570 args \u00abArray\u00bb arguments to pass to the method Adds a method call to the queue.","title":"Schema.prototype.queue()"},{"location":"schema/api/#schemaprototypepre","text":"\u53c2\u6570 Defines a pre hook for the document. \u793a\u4f8b var toySchema = new Schema ( .. ); toySchema . pre ( 'save' , function ( next ) { if ( ! this . created ) this . created = new Date ; next (); }) toySchema . pre ( 'validate' , function ( next ) { if ( this . name !== 'Woody' ) this . name = 'Woody' ; next (); })","title":"Schema.prototype.pre()"},{"location":"schema/api/#schemaprototypepost","text":"\u53c2\u6570 Defines a post hook for the document var schema = new Schema (..); schema . post ( 'save' , function ( doc ) { console . log ( 'this fired after a document was saved' ); } ); schema . post ( 'find' , function ( docs ) { console . log ( 'this fired after you run a find query' ); } ); var Model = mongoose . model ( 'Model' , schema ); var m = new Model (..); m . save ( function ( err ) { console . log ( 'this fires after the `post` hook' ); } ); m . find ( function ( err , docs ) { console . log ( 'this fires after the post find hook' ); } );","title":"Schema.prototype.post()"},{"location":"schema/api/#schemaprototypeplugin","text":"\u53c2\u6570 Registers a plugin for this schema.","title":"Schema.prototype.plugin()"},{"location":"schema/api/#schemaprototypemethod","text":"\u53c2\u6570 Adds an instance method to documents constructed from Models compiled from this schema. \u793a\u4f8b var schema = kittySchema = new Schema ( .. ); schema . method ( 'meow' , function () { console . log ( 'meeeeeoooooooooooow' ); }) var Kitty = mongoose . model ( 'Kitty' , schema ); var fizz = new Kitty ; fizz . meow (); If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods. schema . method ( { purr : function () { } , scratch : function () {} } ); fizz . purr (); fizz . scratch ();","title":"Schema.prototype.method()"},{"location":"schema/api/#schemaprototypestatic","text":"\u53c2\u6570 Adds static \"class\" methods to Models compiled from this schema. \u793a\u4f8b var schema = new Schema ( .. ); schema . static ( 'findByName' , function ( name , callback ) { return this . find ({ name : name }, callback ); }); var Drink = mongoose . model ( 'Drink' , schema ); Drink . findByName ( 'sanpellegrino' , function ( err , drinks ) { }); If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.","title":"Schema.prototype.static()"},{"location":"schema/api/#schemaprototypeindex","text":"\u53c2\u6570 [\u9009\u9879.expires=null] \u00abString\u00bb Mongoose-specific syntactic sugar, uses [ms to convert expires option into seconds for the expireAfterSeconds in the above link. Defines an index (most likely compound) for this schema. \u793a\u4f8b schema.index({ first: 1, last: -1 })","title":"Schema.prototype.index()"},{"location":"schema/api/#schemaprototypeset","text":"\u53c2\u6570 [value] \u00abObject\u00bb if not passed, the current option value is returned Sets/gets a schema option. \u793a\u4f8b schema.set('strict'); schema.set('strict', false); schema.set('strict');","title":"Schema.prototype.set()"},{"location":"schema/api/#schemaprototypeget","text":"\u53c2\u6570 key \u00abString\u00bb option name","title":"Schema.prototype.get()"},{"location":"schema/api/#indextypes","text":"","title":"indexTypes"},{"location":"schema/api/#schemaprototypeindexes","text":"Compiles indexes from fields and schema-level indexes","title":"Schema.prototype.indexes()"},{"location":"schema/api/#schemaprototypevirtual","text":"\u53c2\u6570 \u8fd4\u56de Creates a virtual type with the given name.","title":"Schema.prototype.virtual()"},{"location":"schema/api/#schemaprototypevirtualpath","text":"\u53c2\u6570 \u8fd4\u56de \u8fd4\u56de the virtual type with the given name .","title":"Schema.prototype.virtualpath()"},{"location":"schema/api/#schemaprototyperemove","text":"\u53c2\u6570 Removes the given path (or [ paths ]).","title":"Schema.prototype.remove()"},{"location":"schema/api/#schemaprototypeloadclass","text":"\u53c2\u6570 Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.","title":"Schema.prototype.loadClass()"},{"location":"schema/api/#schematypes","text":"The various built-in Mongoose Schema Types. \u793a\u4f8b var mongoose = require ( 'mongoose' ); var ObjectId = mongoose . Schema . Types . ObjectId ; \u7c7b\u578b Using this exposed access to the Mixed SchemaType, we can use them in our schema. var Mixed = mongoose . Schema . Types . Mixed ; new mongoose . Schema ({ _user : Mixed })","title":"Schema.Types"},{"location":"schema/guide/","text":"\u6a21\u5f0f \u00b6 Source If you haven't yet done so, please take a minute to read the quickstart to get an idea of how Mongoose works. If you are migrating from 4.x to 5.x please take a moment to read the migration guide . \u5b9a\u4e49\u4f60\u7684\u6a21\u5f0f \u00b6 Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection. JavaScript var mongoose = require ( 'mongoose' ); var Schema = mongoose . Schema ; var blogSchema = new Schema ({ title : String , author : String , body : String , comments : [{ body : String , date : Date }], date : { type : Date , default : Date . now }, hidden : Boolean , meta : { votes : Number , favs : Number } }); If you want to add additional keys later, use the Schema#add method. Each key in our code blogSchema defines a property in our documents which will be cast to its associated SchemaType . For example, we've defined a property title which will be cast to the String SchemaType and property date which will be cast to a Date SchemaType. Keys may also be assigned nested objects containing further key/type definitions like the meta property above. The permitted SchemaTypes are: String Number Date Buffer Boolean Mixed ObjectId Array Read more about SchemaTypes here . Schemas not only define the structure of your document and casting of properties, they also define document [instance methods][8], [static Model methods][9], [compound indexes][10], and document lifecycle hooks called middleware \u521b\u5efa\u4e00\u4e2a\u6a21\u5f0f \u00b6 To use our schema definition, we need to convert our blogSchema into a Model we can work with. To do so, we pass it into mongoose.model(modelName, schema) : JavaScript var Blog = mongoose . model ( 'Blog' , blogSchema ); \u5b9e\u4f8b\u65b9\u6cd5 \u00b6 Instances of Models are documents . Documents have many of their own built-in instance methods . We may also define our own custom document instance methods too. var animalSchema = new Schema ({ name : String , type : String }); animalSchema . methods . findSimilarTypes = function ( cb ) { return this . model ( 'Animal' ) . find ({ type : this . type }, cb ); }; Now all of our animal instances have a findSimilarTypes method available to them. var Animal = mongoose . model ( 'Animal' , animalSchema ); var dog = new Animal ({ type : 'dog' }); dog . findSimilarTypes ( function ( err , dogs ) { console . log ( dogs ); }); Overwriting a default mongoose document method may lead to unpredictable results. See this for more details. Do not declare methods using ES6 arrow functions ( => ). Arrow functions explicitly prevent binding this , so your method will not have access to the document and the above examples will not work. \u9759\u6001\u65b9\u6cd5 \u00b6 Adding static methods to a Model is simple as well. Continuing with our animalSchema : animalSchema . statics . findByName = function ( name , cb ) { return this . find ({ name : new RegExp ( name , 'i' ) }, cb ); }; var Animal = mongoose . model ( 'Animal' , animalSchema ); Animal . findByName ( 'fido' , function ( err , animals ) { console . log ( animals ); }); Do not declare statics using ES6 arrow functions ( => ). Arrow functions explicitly prevent binding this , so the above examples will not work because of the value of this . \u67e5\u8be2\u52a9\u624b \u00b6 You can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's chainable query builder API . animalSchema . query . byName = function ( name ) { return this . find ({ name : new RegExp ( name , 'i' ) }); }; var Animal = mongoose . model ( 'Animal' , animalSchema ); Animal . find () . byName ( 'fido' ) . exec ( function ( err , animals ) { console . log ( animals ); }); \u7d22\u5f15 \u00b6 MongoDB supports secondary indexes . With mongoose, we define these indexes within our Schema at the path level or the schema level. Defining indexes at the schema level is necessary when creating compound indexes . var animalSchema = new Schema ( { name : String , type : String , tags : { type : [ String ] , index : true } } ); animalSchema . index ( { name : 1 , type : - 1 } ); When your application starts up, Mongoose automatically calls createIndex for each defined index in your schema. Mongoose will call createIndex for each index sequentially, and emit an 'index' event on the model when all the createIndex calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a significant performance impact . Disable the behavior by setting the autoIndex option of your schema to false , or globally on the connection by setting the option autoIndex to false . mongoose . connect ( 'mongodb://user:pass@localhost:port/database' , { autoIndex : false } ); mongoose . createConnection ( 'mongodb://user:pass@localhost:port/database' , { autoIndex : false } ); animalSchema . set ( 'autoIndex' , false ); new Schema ( { .. } , { autoIndex : false } ); Mongoose will emit an index event on the model when indexes are done building or an error occurred. animalSchema . index ({ _id : 1 }, { sparse : true }); var Animal = mongoose . model ( 'Animal' , animalSchema ); Animal . on ( 'index' , function ( error ) { console . log ( error . message ); }); See also the Model#ensureIndexes method. \u865a\u62df\u5b57\u6bb5 \u00b6 Virtuals are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage. var personSchema = new Schema ({ name : { first : String , last : String } }); var Person = mongoose . model ( 'Person' , personSchema ); var axl = new Person ({ name : { first : 'Axl' , last : 'Rose' } }); Suppose you want to print out the person's full name. You could do it yourself: console.log(axl.name.first + ' ' + axl.name.last); But concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like removing diacritics? . A virtual property getter lets you define a fullName property that won't get persisted to MongoDB. personSchema . virtual ( ' fullName ' ) . get ( function () { return this . name . first + ' ' + this . name . last ; } ) ; Now, mongoose will call your getter function every time you access the fullName property: console.log(axl.fullName); If you use toJSON() or toObject() (or use JSON.stringify() on a mongoose document) mongoose will not include virtuals by default. Pass { virtuals: true } to either toObject() or toJSON() . You can also add a custom setter to your virtual that will let you set both first name and last name via the fullName virtual. personSchema . virtual ( ' fullName ' ) . get ( function () { return this . name . first + ' ' + this . name . last ; }). set ( function ( v ) { this . name . first = v . substr ( 0 , v . indexOf ( ' ' )) ; this . name . last = v . substr ( v . indexOf ( ' ' ) + 1 ) ; } ) ; axl . fullName = ' William Rose ' ; Virtual property setters are applied before other validation. So the example above would still work even if the first and last name fields were required. Only non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them. \u522b\u540d \u00b6 Aliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability. var personSchema = new Schema ({ n : { type : String , alias : 'name' } }); var person = new Person ({ name : 'Val' }); console . log ( person ); console . log ( person . toObject ({ virtuals : true })); console . log ( person . name ); person . name = 'Not Val' ; console . log ( person ); \u9009\u9879 \u00b6 Schemas have a few configurable options which can be passed to the constructor or set directly: new Schema ({ .. }, options ); var schema = new Schema ({ .. }); schema . set ( option , value ); Valid options: autoIndex \u00b6 At application startup, Mongoose sends a createIndex command for each index declared in your Schema . As of Mongoose v3, indexes are created in the background by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your Schema s autoIndex option to false and use the ensureIndexes method on your model. var schema = new Schema ({ .. }, { autoIndex : false }); var Clock = mongoose . model ( 'Clock' , schema ); Clock . ensureIndexes ( callback ); bufferCommands \u00b6 By default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set bufferCommands to false. var schema = new Schema ({ .. }, { bufferCommands : false }); The schema bufferCommands option overrides the global bufferCommands option. mongoose . set ( 'bufferCommands' , true ); var schema = new Schema ({ .. }, { bufferCommands : false }); capped \u00b6 Mongoose supports MongoDBs capped collections. To specify the underlying MongoDB collection be capped , set the capped option to the maximum size of the collection in bytes . new Schema ( { .. } , { capped : 1024 } ); The capped option may also be set to an object if you want to pass additional options like max or autoIndexId . In this case you must explicitly pass the size option, which is required. new Schema ( { .. } , { capped : { size : 1024 , max : 1000 , autoIndexId : true } } ); collection \u00b6 Mongoose by default produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. Set this option if you need a different name for your collection. var dataSchema = new Schema ({ .. }, { collection : 'data' }); id \u00b6 Mongoose assigns each of your schemas an id virtual getter by default which returns the documents _id field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an id getter added to your schema, you may disable it passing this option at schema construction time. var schema = new Schema ({ name : String }); var Page = mongoose . model ( 'Page' , schema ); var p = new Page ({ name : 'mongodb.org' }); console . log ( p . id ); var schema = new Schema ({ name : String }, { id : false }); var Page = mongoose . model ( 'Page' , schema ); var p = new Page ({ name : 'mongodb.org' }); console . log ( p . id ); _id \u00b6 Mongoose assigns each of your schemas an _id field by default if one is not passed into the Schema constructor. The type assigned is an ObjectId to coincide with MongoDB's default behavior. If you don't want an _id added to your schema at all, you may disable it using this option. You can only use this option on sub-documents. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an _id . var schema = new Schema ( { name : String } ); var Page = mongoose . model ( 'Page' , schema ); var p = new Page ( { name : 'mongodb.org' } ); console . log ( p ); var childSchema = new Schema ( { name : String } , { _id : false } ); var parentSchema = new Schema ( { children : [ childSchema ] } ); var Model = mongoose . model ( 'Model' , parentSchema ); Model . create ( { children : [ { name: 'Luke' } ] } , function ( error , doc ) { } ); minimize \u00b6 Mongoose will, by default, \"minimize\" schemas by removing empty objects. var schema = new Schema ({ name : String , inventory : {} }); var Character = mongoose . model ( 'Character' , schema ); var frodo = new Character ({ name : 'Frodo' , inventory : { ringOfPower : 1 }}); Character . findOne ({ name : 'Frodo' }, function ( err , character ) { console . log ( character ); }); var sam = new Character ({ name : 'Sam' , inventory : {}}); Character . findOne ({ name : 'Sam' }, function ( err , character ) { console . log ( character ); }); This behavior can be overridden by setting minimize option to false . It will then store empty objects. var schema = new Schema ({ name : String , inventory : {} }, { minimize : false }); var Character = mongoose . model ( 'Character' , schema ); var sam = new Character ({ name : 'Sam' , inventory : {}}); Character . findOne ({ name : 'Sam' }, function ( err , character ) { console . log ( character ); }); read \u00b6 Allows setting query#read options at the schema level, providing us a way to apply default ReadPreferences to all queries derived from a model. var schema = new Schema ({ .. }, { read : 'primary' }); var schema = new Schema ({ .. }, { read : 'primaryPreferred' }); var schema = new Schema ({ .. }, { read : 'secondary' }); var schema = new Schema ({ .. }, { read : 'secondaryPreferred' }); var schema = new Schema ({ .. }, { read : 'nearest' }); The alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'. The read option also allows us to specify tag sets . These tell the driver from which members of the replica-set it should attempt to read. Read more about tag sets here and here . NOTE: you may also specify the driver read pref strategy option when connecting: var options = { replset : { strategy : 'ping' }}; mongoose . connect ( uri , options ); var schema = new Schema ({ .. }, { read : [ 'nearest' , { disk : 'ssd' }] }); mongoose . model ( 'JellyBean' , schema ); shardKey \u00b6 The shardKey option is used when we have a sharded MongoDB architecture . Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we'll be all set. new Schema({ .. }, { shardKey: { tag: 1, name: 1 }}) Note that Mongoose does not send the shardcollection command for you. You must configure your shards yourself. strict \u00b6 The strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db. var thingSchema = new Schema ({ .. }) var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing ({ iAmNotInTheSchema : true }); thing . save (); var thingSchema = new Schema ({ .. }, { strict : false }); var thing = new Thing ({ iAmNotInTheSchema : true }); thing . save (); This also affects the use of doc.set() to set a property value. var thingSchema = new Schema ({ .. }) var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing ; thing . set ( 'iAmNotInTheSchema' , true ); thing . save (); This value can be overridden at the model instance level by passing a second boolean argument: var Thing = mongoose . model ( 'Thing' ); var thing = new Thing ( doc , true ); var thing = new Thing ( doc , false ); The strict option may also be set to \"throw\" which will cause errors to be produced instead of dropping the bad data. NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option. var thingSchema = new Schema ({ .. }) var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing ; thing . iAmNotInTheSchema = true ; thing . save (); toJSON \u00b6 Exactly the same as the [toObject][60] option but only applies when the documents toJSON method is called. var schema = new Schema ({ name : String }); schema . path ( 'name' ) . get ( function ( v ) { return v + ' is my name' ; }); schema . set ( 'toJSON' , { getters : true , virtuals : false }); var M = mongoose . model ( 'Person' , schema ); var m = new M ({ name : 'Max Headroom' }); console . log ( m . toObject ()); console . log ( m . toJSON ()); console . log ( JSON . stringify ( m )); To see all available toJSON/toObject options, read this . toObject \u00b6 Documents have a toObject method which converts the mongoose document into a plain javascript object. This method accepts a few options. Instead of applying these options on a per-document basis we may declare the options here and have it applied to all of this schemas documents by default. To have all virtuals show up in your console.log output, set the toObject option to { getters: true } : var schema = new Schema ({ name : String }); schema . path ( 'name' ) . get ( function ( v ) { return v + ' is my name' ; }); schema . set ( 'toObject' , { getters : true }); var M = mongoose . model ( 'Person' , schema ); var m = new M ({ name : 'Max Headroom' }); console . log ( m ); To see all available toObject options, read this . typeKey \u00b6 By default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration. var schema = new Schema ( { loc : { type : String , coordinates : [ Number ] } } ); However, for applications like geoJSON , the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option. var schema = new Schema ( { loc : { type : String , coordinates : [ Number ] } , name : { $ type : String } } , { typeKey : '$type' } ); validateBeforeSave \u00b6 By default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set validateBeforeSave to false. var schema = new Schema ({ name : String }); schema . set ( 'validateBeforeSave' , false ); schema . path ( 'name' ) . validate ( function ( value ) { return v != null ; }); var M = mongoose . model ( 'Person' , schema ); var m = new M ({ name : null }); m . validate ( function ( err ) { console . log ( err ); }); m . save (); versionKey \u00b6 The versionKey is a property set on each document when first created by Mongoose. This keys value contains the internal revision of the document. The versionKey option is a string that represents the path to use for versioning. The default is __v . If this conflicts with your application you can configure as such: var schema = new Schema ({ name : 'string' }); var Thing = mongoose . model ( 'Thing' , schema ); var thing = new Thing ({ name : 'mongoose v3' }); thing . save (); new Schema ({ .. }, { versionKey : '_somethingElse' }) var Thing = mongoose . model ( 'Thing' , schema ); var thing = new Thing ({ name : 'mongoose v3' }); thing . save (); Document versioning can also be disabled by setting the versionKey to false . DO NOT disable versioning unless you know what you are doing . new Schema ({ .. }, { versionKey : false }); var Thing = mongoose . model ( 'Thing' , schema ); var thing = new Thing ({ name : 'no versioning please' }); thing . save (); collation \u00b6 Sets a default collation for every query and aggregation. Here's a beginner-friendly overview of collations . var schema = new Schema ({ name : String }, { collation : { locale : 'en_US' , strength : 1 } }); var MyModel = db . model ( 'MyModel' , schema ); MyModel . create ([{ name : 'val' }, { name : 'Val' }]) . then ( function () { return MyModel . find ({ name : 'val' }); }) . then ( function ( docs ) { }); skipVersioning \u00b6 skipVersioning allows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For sub-documents, include this on the parent document using the fully qualified path. new Schema ( { .. } , { skipVersioning : { dontVersionMe : true } } ); thing . dontVersionMe . push ( 'hey' ); thing . save (); timestamps \u00b6 If set timestamps , mongoose assigns createdAt and updatedAt fields to your schema, the type assigned is Date . By default, the name of two fields are createdAt and updatedAt , customize the field name by setting timestamps.createdAt and timestamps.updatedAt . var thingSchema = new Schema ({ .. }, { timestamps : { createdAt : 'created_at' } }); var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing (); thing . save (); useNestedStrict \u00b6 In mongoose 4, update() and findOneAndUpdate() only check the top-level schema's strict mode setting. var childSchema = new Schema ({}, { strict : false }); var parentSchema = new Schema ({ child : childSchema }, { strict : 'throw' }); var Parent = mongoose . model ( 'Parent' , parentSchema ); Parent . update ({}, { 'child.name' : 'Luke Skywalker' }, function ( error ) { }); var update = { 'child.name' : 'Luke Skywalker' }; var opts = { strict : false }; Parent . update ({}, update , opts , function ( error ) { }); If you set useNestedStrict to true, mongoose will use the child schema's strict option for casting updates. var childSchema = new Schema ({}, { strict : false }); var parentSchema = new Schema ({ child : childSchema }, { strict : 'throw' , useNestedStrict : true }); var Parent = mongoose . model ( 'Parent' , parentSchema ); Parent . update ({}, { 'child.name' : 'Luke Skywalker' }, function ( error ) { }); \u53ef\u63d2\u62d4 \u00b6 Schema\u4e5f\u662f \u53ef\u63d2\u62d4 \uff0c\u5b83\u5141\u8bb8\u6211\u4eec\u5c06\u53ef\u91cd\u7528\u7684\u7279\u6027\u6253\u5305\u6210\u53ef\u4e0e\u793e\u533a\u5171\u4eab\u6216\u53ea\u5728\u60a8\u7684\u9879\u76ee\u4e4b\u95f4\u5171\u4eab\u7684\u63d2\u4ef6\u3002 \u63a5\u4e0b\u6765 \u00b6 \u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u6a21\u5f0f\uff0c\u6211\u4eec\u6765\u770b\u770b \u6a21\u5f0f\u7c7b\u578b .","title":"\u6a21\u5f0f\u624b\u518c"},{"location":"schema/guide/#_1","text":"Source If you haven't yet done so, please take a minute to read the quickstart to get an idea of how Mongoose works. If you are migrating from 4.x to 5.x please take a moment to read the migration guide .","title":"\u6a21\u5f0f"},{"location":"schema/guide/#_2","text":"Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection. JavaScript var mongoose = require ( 'mongoose' ); var Schema = mongoose . Schema ; var blogSchema = new Schema ({ title : String , author : String , body : String , comments : [{ body : String , date : Date }], date : { type : Date , default : Date . now }, hidden : Boolean , meta : { votes : Number , favs : Number } }); If you want to add additional keys later, use the Schema#add method. Each key in our code blogSchema defines a property in our documents which will be cast to its associated SchemaType . For example, we've defined a property title which will be cast to the String SchemaType and property date which will be cast to a Date SchemaType. Keys may also be assigned nested objects containing further key/type definitions like the meta property above. The permitted SchemaTypes are: String Number Date Buffer Boolean Mixed ObjectId Array Read more about SchemaTypes here . Schemas not only define the structure of your document and casting of properties, they also define document [instance methods][8], [static Model methods][9], [compound indexes][10], and document lifecycle hooks called middleware","title":"\u5b9a\u4e49\u4f60\u7684\u6a21\u5f0f"},{"location":"schema/guide/#_3","text":"To use our schema definition, we need to convert our blogSchema into a Model we can work with. To do so, we pass it into mongoose.model(modelName, schema) : JavaScript var Blog = mongoose . model ( 'Blog' , blogSchema );","title":"\u521b\u5efa\u4e00\u4e2a\u6a21\u5f0f"},{"location":"schema/guide/#_4","text":"Instances of Models are documents . Documents have many of their own built-in instance methods . We may also define our own custom document instance methods too. var animalSchema = new Schema ({ name : String , type : String }); animalSchema . methods . findSimilarTypes = function ( cb ) { return this . model ( 'Animal' ) . find ({ type : this . type }, cb ); }; Now all of our animal instances have a findSimilarTypes method available to them. var Animal = mongoose . model ( 'Animal' , animalSchema ); var dog = new Animal ({ type : 'dog' }); dog . findSimilarTypes ( function ( err , dogs ) { console . log ( dogs ); }); Overwriting a default mongoose document method may lead to unpredictable results. See this for more details. Do not declare methods using ES6 arrow functions ( => ). Arrow functions explicitly prevent binding this , so your method will not have access to the document and the above examples will not work.","title":"\u5b9e\u4f8b\u65b9\u6cd5"},{"location":"schema/guide/#_5","text":"Adding static methods to a Model is simple as well. Continuing with our animalSchema : animalSchema . statics . findByName = function ( name , cb ) { return this . find ({ name : new RegExp ( name , 'i' ) }, cb ); }; var Animal = mongoose . model ( 'Animal' , animalSchema ); Animal . findByName ( 'fido' , function ( err , animals ) { console . log ( animals ); }); Do not declare statics using ES6 arrow functions ( => ). Arrow functions explicitly prevent binding this , so the above examples will not work because of the value of this .","title":"\u9759\u6001\u65b9\u6cd5"},{"location":"schema/guide/#_6","text":"You can also add query helper functions, which are like instance methods but for mongoose queries. Query helper methods let you extend mongoose's chainable query builder API . animalSchema . query . byName = function ( name ) { return this . find ({ name : new RegExp ( name , 'i' ) }); }; var Animal = mongoose . model ( 'Animal' , animalSchema ); Animal . find () . byName ( 'fido' ) . exec ( function ( err , animals ) { console . log ( animals ); });","title":"\u67e5\u8be2\u52a9\u624b"},{"location":"schema/guide/#_7","text":"MongoDB supports secondary indexes . With mongoose, we define these indexes within our Schema at the path level or the schema level. Defining indexes at the schema level is necessary when creating compound indexes . var animalSchema = new Schema ( { name : String , type : String , tags : { type : [ String ] , index : true } } ); animalSchema . index ( { name : 1 , type : - 1 } ); When your application starts up, Mongoose automatically calls createIndex for each defined index in your schema. Mongoose will call createIndex for each index sequentially, and emit an 'index' event on the model when all the createIndex calls succeeded or when there was an error. While nice for development, it is recommended this behavior be disabled in production since index creation can cause a significant performance impact . Disable the behavior by setting the autoIndex option of your schema to false , or globally on the connection by setting the option autoIndex to false . mongoose . connect ( 'mongodb://user:pass@localhost:port/database' , { autoIndex : false } ); mongoose . createConnection ( 'mongodb://user:pass@localhost:port/database' , { autoIndex : false } ); animalSchema . set ( 'autoIndex' , false ); new Schema ( { .. } , { autoIndex : false } ); Mongoose will emit an index event on the model when indexes are done building or an error occurred. animalSchema . index ({ _id : 1 }, { sparse : true }); var Animal = mongoose . model ( 'Animal' , animalSchema ); Animal . on ( 'index' , function ( error ) { console . log ( error . message ); }); See also the Model#ensureIndexes method.","title":"\u7d22\u5f15"},{"location":"schema/guide/#_8","text":"Virtuals are document properties that you can get and set but that do not get persisted to MongoDB. The getters are useful for formatting or combining fields, while setters are useful for de-composing a single value into multiple values for storage. var personSchema = new Schema ({ name : { first : String , last : String } }); var Person = mongoose . model ( 'Person' , personSchema ); var axl = new Person ({ name : { first : 'Axl' , last : 'Rose' } }); Suppose you want to print out the person's full name. You could do it yourself: console.log(axl.name.first + ' ' + axl.name.last); But concatenating the first and last name every time can get cumbersome. And what if you want to do some extra processing on the name, like removing diacritics? . A virtual property getter lets you define a fullName property that won't get persisted to MongoDB. personSchema . virtual ( ' fullName ' ) . get ( function () { return this . name . first + ' ' + this . name . last ; } ) ; Now, mongoose will call your getter function every time you access the fullName property: console.log(axl.fullName); If you use toJSON() or toObject() (or use JSON.stringify() on a mongoose document) mongoose will not include virtuals by default. Pass { virtuals: true } to either toObject() or toJSON() . You can also add a custom setter to your virtual that will let you set both first name and last name via the fullName virtual. personSchema . virtual ( ' fullName ' ) . get ( function () { return this . name . first + ' ' + this . name . last ; }). set ( function ( v ) { this . name . first = v . substr ( 0 , v . indexOf ( ' ' )) ; this . name . last = v . substr ( v . indexOf ( ' ' ) + 1 ) ; } ) ; axl . fullName = ' William Rose ' ; Virtual property setters are applied before other validation. So the example above would still work even if the first and last name fields were required. Only non-virtual properties work as part of queries and for field selection. Since virtuals are not stored in MongoDB, you can't query with them.","title":"\u865a\u62df\u5b57\u6bb5"},{"location":"schema/guide/#_9","text":"Aliases are a particular type of virtual where the getter and setter seamlessly get and set another property. This is handy for saving network bandwidth, so you can convert a short property name stored in the database into a longer name for code readability. var personSchema = new Schema ({ n : { type : String , alias : 'name' } }); var person = new Person ({ name : 'Val' }); console . log ( person ); console . log ( person . toObject ({ virtuals : true })); console . log ( person . name ); person . name = 'Not Val' ; console . log ( person );","title":"\u522b\u540d"},{"location":"schema/guide/#_10","text":"Schemas have a few configurable options which can be passed to the constructor or set directly: new Schema ({ .. }, options ); var schema = new Schema ({ .. }); schema . set ( option , value ); Valid options:","title":"\u9009\u9879"},{"location":"schema/guide/#autoindex","text":"At application startup, Mongoose sends a createIndex command for each index declared in your Schema . As of Mongoose v3, indexes are created in the background by default. If you wish to disable the auto-creation feature and manually handle when indexes are created, set your Schema s autoIndex option to false and use the ensureIndexes method on your model. var schema = new Schema ({ .. }, { autoIndex : false }); var Clock = mongoose . model ( 'Clock' , schema ); Clock . ensureIndexes ( callback );","title":"autoIndex"},{"location":"schema/guide/#buffercommands","text":"By default, mongoose buffers commands when the connection goes down until the driver manages to reconnect. To disable buffering, set bufferCommands to false. var schema = new Schema ({ .. }, { bufferCommands : false }); The schema bufferCommands option overrides the global bufferCommands option. mongoose . set ( 'bufferCommands' , true ); var schema = new Schema ({ .. }, { bufferCommands : false });","title":"bufferCommands"},{"location":"schema/guide/#capped","text":"Mongoose supports MongoDBs capped collections. To specify the underlying MongoDB collection be capped , set the capped option to the maximum size of the collection in bytes . new Schema ( { .. } , { capped : 1024 } ); The capped option may also be set to an object if you want to pass additional options like max or autoIndexId . In this case you must explicitly pass the size option, which is required. new Schema ( { .. } , { capped : { size : 1024 , max : 1000 , autoIndexId : true } } );","title":"capped"},{"location":"schema/guide/#collection","text":"Mongoose by default produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. Set this option if you need a different name for your collection. var dataSchema = new Schema ({ .. }, { collection : 'data' });","title":"collection"},{"location":"schema/guide/#id","text":"Mongoose assigns each of your schemas an id virtual getter by default which returns the documents _id field cast to a string, or in the case of ObjectIds, its hexString. If you don't want an id getter added to your schema, you may disable it passing this option at schema construction time. var schema = new Schema ({ name : String }); var Page = mongoose . model ( 'Page' , schema ); var p = new Page ({ name : 'mongodb.org' }); console . log ( p . id ); var schema = new Schema ({ name : String }, { id : false }); var Page = mongoose . model ( 'Page' , schema ); var p = new Page ({ name : 'mongodb.org' }); console . log ( p . id );","title":"id"},{"location":"schema/guide/#_id","text":"Mongoose assigns each of your schemas an _id field by default if one is not passed into the Schema constructor. The type assigned is an ObjectId to coincide with MongoDB's default behavior. If you don't want an _id added to your schema at all, you may disable it using this option. You can only use this option on sub-documents. Mongoose can't save a document without knowing its id, so you will get an error if you try to save a document without an _id . var schema = new Schema ( { name : String } ); var Page = mongoose . model ( 'Page' , schema ); var p = new Page ( { name : 'mongodb.org' } ); console . log ( p ); var childSchema = new Schema ( { name : String } , { _id : false } ); var parentSchema = new Schema ( { children : [ childSchema ] } ); var Model = mongoose . model ( 'Model' , parentSchema ); Model . create ( { children : [ { name: 'Luke' } ] } , function ( error , doc ) { } );","title":"_id"},{"location":"schema/guide/#minimize","text":"Mongoose will, by default, \"minimize\" schemas by removing empty objects. var schema = new Schema ({ name : String , inventory : {} }); var Character = mongoose . model ( 'Character' , schema ); var frodo = new Character ({ name : 'Frodo' , inventory : { ringOfPower : 1 }}); Character . findOne ({ name : 'Frodo' }, function ( err , character ) { console . log ( character ); }); var sam = new Character ({ name : 'Sam' , inventory : {}}); Character . findOne ({ name : 'Sam' }, function ( err , character ) { console . log ( character ); }); This behavior can be overridden by setting minimize option to false . It will then store empty objects. var schema = new Schema ({ name : String , inventory : {} }, { minimize : false }); var Character = mongoose . model ( 'Character' , schema ); var sam = new Character ({ name : 'Sam' , inventory : {}}); Character . findOne ({ name : 'Sam' }, function ( err , character ) { console . log ( character ); });","title":"minimize"},{"location":"schema/guide/#read","text":"Allows setting query#read options at the schema level, providing us a way to apply default ReadPreferences to all queries derived from a model. var schema = new Schema ({ .. }, { read : 'primary' }); var schema = new Schema ({ .. }, { read : 'primaryPreferred' }); var schema = new Schema ({ .. }, { read : 'secondary' }); var schema = new Schema ({ .. }, { read : 'secondaryPreferred' }); var schema = new Schema ({ .. }, { read : 'nearest' }); The alias of each pref is also permitted so instead of having to type out 'secondaryPreferred' and getting the spelling wrong, we can simply pass 'sp'. The read option also allows us to specify tag sets . These tell the driver from which members of the replica-set it should attempt to read. Read more about tag sets here and here . NOTE: you may also specify the driver read pref strategy option when connecting: var options = { replset : { strategy : 'ping' }}; mongoose . connect ( uri , options ); var schema = new Schema ({ .. }, { read : [ 'nearest' , { disk : 'ssd' }] }); mongoose . model ( 'JellyBean' , schema );","title":"read"},{"location":"schema/guide/#shardkey","text":"The shardKey option is used when we have a sharded MongoDB architecture . Each sharded collection is given a shard key which must be present in all insert/update operations. We just need to set this schema option to the same shard key and we'll be all set. new Schema({ .. }, { shardKey: { tag: 1, name: 1 }}) Note that Mongoose does not send the shardcollection command for you. You must configure your shards yourself.","title":"shardKey"},{"location":"schema/guide/#strict","text":"The strict option, (enabled by default), ensures that values passed to our model constructor that were not specified in our schema do not get saved to the db. var thingSchema = new Schema ({ .. }) var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing ({ iAmNotInTheSchema : true }); thing . save (); var thingSchema = new Schema ({ .. }, { strict : false }); var thing = new Thing ({ iAmNotInTheSchema : true }); thing . save (); This also affects the use of doc.set() to set a property value. var thingSchema = new Schema ({ .. }) var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing ; thing . set ( 'iAmNotInTheSchema' , true ); thing . save (); This value can be overridden at the model instance level by passing a second boolean argument: var Thing = mongoose . model ( 'Thing' ); var thing = new Thing ( doc , true ); var thing = new Thing ( doc , false ); The strict option may also be set to \"throw\" which will cause errors to be produced instead of dropping the bad data. NOTE: Any key/val set on the instance that does not exist in your schema is always ignored, regardless of schema option. var thingSchema = new Schema ({ .. }) var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing ; thing . iAmNotInTheSchema = true ; thing . save ();","title":"strict"},{"location":"schema/guide/#tojson","text":"Exactly the same as the [toObject][60] option but only applies when the documents toJSON method is called. var schema = new Schema ({ name : String }); schema . path ( 'name' ) . get ( function ( v ) { return v + ' is my name' ; }); schema . set ( 'toJSON' , { getters : true , virtuals : false }); var M = mongoose . model ( 'Person' , schema ); var m = new M ({ name : 'Max Headroom' }); console . log ( m . toObject ()); console . log ( m . toJSON ()); console . log ( JSON . stringify ( m )); To see all available toJSON/toObject options, read this .","title":"toJSON"},{"location":"schema/guide/#toobject","text":"Documents have a toObject method which converts the mongoose document into a plain javascript object. This method accepts a few options. Instead of applying these options on a per-document basis we may declare the options here and have it applied to all of this schemas documents by default. To have all virtuals show up in your console.log output, set the toObject option to { getters: true } : var schema = new Schema ({ name : String }); schema . path ( 'name' ) . get ( function ( v ) { return v + ' is my name' ; }); schema . set ( 'toObject' , { getters : true }); var M = mongoose . model ( 'Person' , schema ); var m = new M ({ name : 'Max Headroom' }); console . log ( m ); To see all available toObject options, read this .","title":"toObject"},{"location":"schema/guide/#typekey","text":"By default, if you have an object with key 'type' in your schema, mongoose will interpret it as a type declaration. var schema = new Schema ( { loc : { type : String , coordinates : [ Number ] } } ); However, for applications like geoJSON , the 'type' property is important. If you want to control which key mongoose uses to find type declarations, set the 'typeKey' schema option. var schema = new Schema ( { loc : { type : String , coordinates : [ Number ] } , name : { $ type : String } } , { typeKey : '$type' } );","title":"typeKey"},{"location":"schema/guide/#validatebeforesave","text":"By default, documents are automatically validated before they are saved to the database. This is to prevent saving an invalid document. If you want to handle validation manually, and be able to save objects which don't pass validation, you can set validateBeforeSave to false. var schema = new Schema ({ name : String }); schema . set ( 'validateBeforeSave' , false ); schema . path ( 'name' ) . validate ( function ( value ) { return v != null ; }); var M = mongoose . model ( 'Person' , schema ); var m = new M ({ name : null }); m . validate ( function ( err ) { console . log ( err ); }); m . save ();","title":"validateBeforeSave"},{"location":"schema/guide/#versionkey","text":"The versionKey is a property set on each document when first created by Mongoose. This keys value contains the internal revision of the document. The versionKey option is a string that represents the path to use for versioning. The default is __v . If this conflicts with your application you can configure as such: var schema = new Schema ({ name : 'string' }); var Thing = mongoose . model ( 'Thing' , schema ); var thing = new Thing ({ name : 'mongoose v3' }); thing . save (); new Schema ({ .. }, { versionKey : '_somethingElse' }) var Thing = mongoose . model ( 'Thing' , schema ); var thing = new Thing ({ name : 'mongoose v3' }); thing . save (); Document versioning can also be disabled by setting the versionKey to false . DO NOT disable versioning unless you know what you are doing . new Schema ({ .. }, { versionKey : false }); var Thing = mongoose . model ( 'Thing' , schema ); var thing = new Thing ({ name : 'no versioning please' }); thing . save ();","title":"versionKey"},{"location":"schema/guide/#collation","text":"Sets a default collation for every query and aggregation. Here's a beginner-friendly overview of collations . var schema = new Schema ({ name : String }, { collation : { locale : 'en_US' , strength : 1 } }); var MyModel = db . model ( 'MyModel' , schema ); MyModel . create ([{ name : 'val' }, { name : 'Val' }]) . then ( function () { return MyModel . find ({ name : 'val' }); }) . then ( function ( docs ) { });","title":"collation"},{"location":"schema/guide/#skipversioning","text":"skipVersioning allows excluding paths from versioning (i.e., the internal revision will not be incremented even if these paths are updated). DO NOT do this unless you know what you're doing. For sub-documents, include this on the parent document using the fully qualified path. new Schema ( { .. } , { skipVersioning : { dontVersionMe : true } } ); thing . dontVersionMe . push ( 'hey' ); thing . save ();","title":"skipVersioning"},{"location":"schema/guide/#timestamps","text":"If set timestamps , mongoose assigns createdAt and updatedAt fields to your schema, the type assigned is Date . By default, the name of two fields are createdAt and updatedAt , customize the field name by setting timestamps.createdAt and timestamps.updatedAt . var thingSchema = new Schema ({ .. }, { timestamps : { createdAt : 'created_at' } }); var Thing = mongoose . model ( 'Thing' , thingSchema ); var thing = new Thing (); thing . save ();","title":"timestamps"},{"location":"schema/guide/#usenestedstrict","text":"In mongoose 4, update() and findOneAndUpdate() only check the top-level schema's strict mode setting. var childSchema = new Schema ({}, { strict : false }); var parentSchema = new Schema ({ child : childSchema }, { strict : 'throw' }); var Parent = mongoose . model ( 'Parent' , parentSchema ); Parent . update ({}, { 'child.name' : 'Luke Skywalker' }, function ( error ) { }); var update = { 'child.name' : 'Luke Skywalker' }; var opts = { strict : false }; Parent . update ({}, update , opts , function ( error ) { }); If you set useNestedStrict to true, mongoose will use the child schema's strict option for casting updates. var childSchema = new Schema ({}, { strict : false }); var parentSchema = new Schema ({ child : childSchema }, { strict : 'throw' , useNestedStrict : true }); var Parent = mongoose . model ( 'Parent' , parentSchema ); Parent . update ({}, { 'child.name' : 'Luke Skywalker' }, function ( error ) { });","title":"useNestedStrict"},{"location":"schema/guide/#_11","text":"Schema\u4e5f\u662f \u53ef\u63d2\u62d4 \uff0c\u5b83\u5141\u8bb8\u6211\u4eec\u5c06\u53ef\u91cd\u7528\u7684\u7279\u6027\u6253\u5305\u6210\u53ef\u4e0e\u793e\u533a\u5171\u4eab\u6216\u53ea\u5728\u60a8\u7684\u9879\u76ee\u4e4b\u95f4\u5171\u4eab\u7684\u63d2\u4ef6\u3002","title":"\u53ef\u63d2\u62d4"},{"location":"schema/guide/#_12","text":"\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u4e86\u6a21\u5f0f\uff0c\u6211\u4eec\u6765\u770b\u770b \u6a21\u5f0f\u7c7b\u578b .","title":"\u63a5\u4e0b\u6765"},{"location":"schema/type-5/","text":"\u6a21\u5f0f\u7c7b\u578b \u00b6 SchemaType() \u00b6 \u53c2\u6570 SchemaType constructor. Do not instantiate SchemaType directly. Mongoose converts your schema paths into SchemaTypes automatically. \u793a\u4f8b const schema = new Schema ({ name : String }); schema . path ( 'name' ) instanceof SchemaType ; SchemaType.prototype.default() \u00b6 \u53c2\u6570 val \u00abFunction,any\u00bb the default value \u8fd4\u56de Sets a default value for this SchemaType. \u793a\u4f8b var schema = new Schema ({ n : { type : Number , default : 10 }) var M = db . model ( 'M' , schema ) var m = new M ; console . log ( m . n ) Defaults can be either functions which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation. \u793a\u4f8b var schema = new Schema ({ aNumber : { type : Number , default : 4.815162342 }}) var M = db . model ( 'M' , schema ) var m = new M ; console . log ( m . aNumber ) var schema = new Schema ({ mixed : Schema . Types . Mixed }); schema . path ( 'mixed' ) . default ( function () { return {}; }); var schema = new Schema ({ mixed : Schema . Types . Mixed }); schema . path ( 'mixed' ) . default ({}); var M = db . model ( 'M' , schema ); var m1 = new M ; m1 . mixed . added = 1 ; console . log ( m1 . mixed ); var m2 = new M ; console . log ( m2 . mixed ); SchemaType.prototype.index() \u00b6 \u53c2\u6570 options \u00abObject,Boolean,String\u00bb \u8fd4\u56de Declares the index options for this schematype. \u793a\u4f8b var s = new Schema ( { name : { type : String , index : true } ) var s = new Schema ( { loc : { type : [ Number ] , index : 'hashed' } ) var s = new Schema ( { loc : { type : [ Number ] , index : '2d' , sparse : true } ) var s = new Schema ( { loc : { type : [ Number ] , index : { type : '2dsphere' , sparse : true }} ) var s = new Schema ( { date : { type : Date , index : { unique : true , expires : '1d' }} ) Schema . path ( 'my.path' ). index ( true ); Schema . path ( 'my.date' ). index ( { expires : 60 } ); Schema . path ( 'my.path' ). index ( { unique : true , sparse : true } ); \u6ce8\u91ca Indexes are created in the background by default. Specify background: false to override. [Direction doesn't matter for single key indexes SchemaType.prototype.unique() \u00b6 \u53c2\u6570 \u8fd4\u56de Declares an unique index. \u793a\u4f8b var s = new Schema ({ name : { type : String , unique : true }}); Schema . path ( 'name' ) . index ({ unique : true }); NOTE: violating the constraint returns an E11000 error from MongoDB when saving, not a Mongoose validation error. SchemaType.prototype.text() \u00b6 \u53c2\u6570 \u8fd4\u56de Declares a full text index. \u793a\u4f8b var s = new Schema ({ name : { type : String , text : true }) Schema . path ( 'name' ) . index ({ text : true }); SchemaType.prototype.sparse() \u00b6 \u53c2\u6570 \u8fd4\u56de Declares a sparse index. \u793a\u4f8b var s = new Schema ({ name : { type : String , sparse : true }) Schema . path ( 'name' ) . index ({ sparse : true }); SchemaType.prototype.set() \u00b6 \u53c2\u6570 \u8fd4\u56de Adds a setter to this schematype. \u793a\u4f8b function capitalize ( val ) { if ( typeof val !== 'string' ) val = '' ; return val . charAt ( 0 ) . toUpperCase () + val . substring ( 1 ); } var s = new Schema ({ name : { type : String , set : capitalize }}) var s = new Schema ({ name : String }) s . path ( 'name' ) . set ( capitalize ) Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key. Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, [avenue@q.com can be registered for 2 accounts via [avenue@q.com and [AvEnUe@Q.CoM. You can set up email lower case normalization easily via a Mongoose setter. function toLower ( v ) { return v . toLowerCase (); } var UserSchema = new Schema ({ email : { type : String , set : toLower } }); var User = db . model ( 'User' , UserSchema ); var user = new User ({ email : '[AVENUE@Q.COM' }); console . log ( user . email ); // '[avenue@q.com' // or var user = new User (); user . email = '[Avenue@Q.com' ; console . log ( user . email ); // '[avenue@q.com' User . updateOne ({ _id : _id }, { $ set : { email : '[AVENUE@Q.COM' } }); // update to '[avenue@q.com' As you can see above, setters allow you to transform the data before it stored in MongoDB. NOTE: we could have also just used the built-in lowercase: true SchemaType option instead of defining our own function. new Schema({ email: { type: String, lowercase: true }}) Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema. function inspector ( val , schematype ) { if ( schematype . options . required ) { return schematype . path + ' is required' ; } else { return val ; } } var VirusSchema = new Schema ({ name : { type : String , required : true , set : inspector }, taxonomy : { type : String , set : inspector } }) var Virus = db . model ( 'Virus' , VirusSchema ); var v = new Virus ({ name : 'Parvoviridae' , taxonomy : 'Parvovirinae' }); console . log ( v . name ); console . log ( v . taxonomy ); SchemaType.prototype.get() \u00b6 \u53c2\u6570 \u8fd4\u56de Adds a getter to this schematype. \u793a\u4f8b function dob ( val ) { if ( ! val ) return val ; return ( val . getMonth () + 1 ) + \"/\" + val . getDate () + \"/\" + val . getFullYear (); } var s = new Schema ({ born : { type : Date , get : dob }) var s = new Schema ({ born : Date }) s . path ( 'born' ) . get ( dob ) Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see. Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way: function obfuscate ( cc ) { return '****-****-****-' + cc . slice ( cc . length - 4 , cc . length ); } var AccountSchema = new Schema ({ creditCardNumber : { type : String , get : obfuscate } }); var Account = db . model ( 'Account' , AccountSchema ); Account . findById ( id , function ( err , found ) { console . log ( found . creditCardNumber ); }); Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema. function inspector ( val , schematype ) { if ( schematype . options . required ) { return schematype . path + ' is required' ; } else { return schematype . path + ' is not' ; } } var VirusSchema = new Schema ({ name : { type : String , required : true , get : inspector }, taxonomy : { type : String , get : inspector } }) var Virus = db . model ( 'Virus' , VirusSchema ); Virus . findById ( id , function ( err , virus ) { console . log ( virus . name ); console . log ( virus . taxonomy ); }) SchemaType.prototype.validate() \u00b6 \u53c2\u6570 [type] \u00abString\u00bb optional validator type \u8fd4\u56de Adds validator(s) for this document path. Validators always receive the value to validate as their first argument and must return Boolean . Returning false means validation failed. The error message argument is optional. If not passed, the [default generic error message template will be used. \u793a\u4f8b function validator ( val ) { return val == 'something' ; } new Schema ({ name : { type : String , validate : validator }}); var custom = [ validator , 'Uh oh, {PATH} does not equal \"something\".' ] new Schema ({ name : { type : String , validate : custom }}); var many = [ { validator : validator , msg : 'uh oh' } , { validator : anotherValidator , msg : 'failed' } ] new Schema ({ name : { type : String , validate : many }}); var schema = new Schema ({ name : 'string' }); schema . path ( 'name' ) . validate ( validator , 'validation of `{PATH}` failed with value `{VALUE}`' ); \u9519\u8bef\u6d88\u606f\u6a21\u677f From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides {PATH} and {VALUE} too. To find out more, details are available [here \u5f02\u6b65\u9a8c\u8bc1 Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either true or false to communicate either success or failure respectively. schema . path ( 'name' ) . validate ( { isAsync : true , validator : function ( value , respond ) { doStuff ( value , function ( ) { ... respond ( false ); } ); } , message : 'Custom error message!' } ); schema . path ( 'name' ) . validate ( { validator : function ( value ) { return new Promise ( function ( resolve , reject ) { resolve ( false ); } ); } } ); You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs. Validation occurs pre('save') or whenever you manually execute [document#validate. If validation fails during pre('save') and no callback was passed to receive the error, an error event will be emitted on your Models associated db [connection, passing the validation error object along. var conn = mongoose . createConnection ( .. ); conn . on ( 'error' , handleError ); var Product = conn . model ( 'Product' , yourSchema ); var dvd = new Product ( .. ); dvd . save (); If you desire handling these errors at the Model level, attach an error listener to your Model and the event will instead be emitted there. Product.on('error', handleError); SchemaType.prototype.required() \u00b6 \u53c2\u6570 [message] \u00abString\u00bb optional custom error message \u8fd4\u56de Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using unshift() . \u793a\u4f8b var s = new Schema ({ born : { type : Date , required : true }) var s = new Schema ({ born : { type : Date , required : '{PATH} is required!' }) var s = new Schema ({ userId : ObjectId , username : { type : String , required : function () { return this . userId != null ; } } }) var s = new Schema ({ userId : ObjectId , username : { type : String , required : [ function () { return this . userId != null ; }, 'username is required if id is specified' ] } }) Schema . path ( 'name' ) . required ( true ); Schema . path ( 'name' ) . required ( true , 'grrr :( ' ); var isOver18 = function () { return this . age >= 18 ; }; Schema . path ( 'voterRegistrationId' ) . required ( isOver18 ); The required validator uses the SchemaType's checkRequired function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if val != null (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default checkRequired function: SchemaType.prototype.select() \u00b6 \u53c2\u6570 \u8fd4\u56de Sets default select() behavior for this path. Set to true if this path should always be included in the results, false if it should be excluded by default. This setting can be overridden at the query level. \u793a\u4f8b T = db . model ( 'T' , new Schema ( { x : { type : String , select : true } } )); T . find (..); T . find () . select ( '-x' ) . exec ( callback );","title":"\u6a21\u5f0f\u7c7b\u578b"},{"location":"schema/type-5/#_1","text":"","title":"\u6a21\u5f0f\u7c7b\u578b"},{"location":"schema/type-5/#schematype","text":"\u53c2\u6570 SchemaType constructor. Do not instantiate SchemaType directly. Mongoose converts your schema paths into SchemaTypes automatically. \u793a\u4f8b const schema = new Schema ({ name : String }); schema . path ( 'name' ) instanceof SchemaType ;","title":"SchemaType()"},{"location":"schema/type-5/#schematypeprototypedefault","text":"\u53c2\u6570 val \u00abFunction,any\u00bb the default value \u8fd4\u56de Sets a default value for this SchemaType. \u793a\u4f8b var schema = new Schema ({ n : { type : Number , default : 10 }) var M = db . model ( 'M' , schema ) var m = new M ; console . log ( m . n ) Defaults can be either functions which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation. \u793a\u4f8b var schema = new Schema ({ aNumber : { type : Number , default : 4.815162342 }}) var M = db . model ( 'M' , schema ) var m = new M ; console . log ( m . aNumber ) var schema = new Schema ({ mixed : Schema . Types . Mixed }); schema . path ( 'mixed' ) . default ( function () { return {}; }); var schema = new Schema ({ mixed : Schema . Types . Mixed }); schema . path ( 'mixed' ) . default ({}); var M = db . model ( 'M' , schema ); var m1 = new M ; m1 . mixed . added = 1 ; console . log ( m1 . mixed ); var m2 = new M ; console . log ( m2 . mixed );","title":"SchemaType.prototype.default()"},{"location":"schema/type-5/#schematypeprototypeindex","text":"\u53c2\u6570 options \u00abObject,Boolean,String\u00bb \u8fd4\u56de Declares the index options for this schematype. \u793a\u4f8b var s = new Schema ( { name : { type : String , index : true } ) var s = new Schema ( { loc : { type : [ Number ] , index : 'hashed' } ) var s = new Schema ( { loc : { type : [ Number ] , index : '2d' , sparse : true } ) var s = new Schema ( { loc : { type : [ Number ] , index : { type : '2dsphere' , sparse : true }} ) var s = new Schema ( { date : { type : Date , index : { unique : true , expires : '1d' }} ) Schema . path ( 'my.path' ). index ( true ); Schema . path ( 'my.date' ). index ( { expires : 60 } ); Schema . path ( 'my.path' ). index ( { unique : true , sparse : true } ); \u6ce8\u91ca Indexes are created in the background by default. Specify background: false to override. [Direction doesn't matter for single key indexes","title":"SchemaType.prototype.index()"},{"location":"schema/type-5/#schematypeprototypeunique","text":"\u53c2\u6570 \u8fd4\u56de Declares an unique index. \u793a\u4f8b var s = new Schema ({ name : { type : String , unique : true }}); Schema . path ( 'name' ) . index ({ unique : true }); NOTE: violating the constraint returns an E11000 error from MongoDB when saving, not a Mongoose validation error.","title":"SchemaType.prototype.unique()"},{"location":"schema/type-5/#schematypeprototypetext","text":"\u53c2\u6570 \u8fd4\u56de Declares a full text index. \u793a\u4f8b var s = new Schema ({ name : { type : String , text : true }) Schema . path ( 'name' ) . index ({ text : true });","title":"SchemaType.prototype.text()"},{"location":"schema/type-5/#schematypeprototypesparse","text":"\u53c2\u6570 \u8fd4\u56de Declares a sparse index. \u793a\u4f8b var s = new Schema ({ name : { type : String , sparse : true }) Schema . path ( 'name' ) . index ({ sparse : true });","title":"SchemaType.prototype.sparse()"},{"location":"schema/type-5/#schematypeprototypeset","text":"\u53c2\u6570 \u8fd4\u56de Adds a setter to this schematype. \u793a\u4f8b function capitalize ( val ) { if ( typeof val !== 'string' ) val = '' ; return val . charAt ( 0 ) . toUpperCase () + val . substring ( 1 ); } var s = new Schema ({ name : { type : String , set : capitalize }}) var s = new Schema ({ name : String }) s . path ( 'name' ) . set ( capitalize ) Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key. Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, [avenue@q.com can be registered for 2 accounts via [avenue@q.com and [AvEnUe@Q.CoM. You can set up email lower case normalization easily via a Mongoose setter. function toLower ( v ) { return v . toLowerCase (); } var UserSchema = new Schema ({ email : { type : String , set : toLower } }); var User = db . model ( 'User' , UserSchema ); var user = new User ({ email : '[AVENUE@Q.COM' }); console . log ( user . email ); // '[avenue@q.com' // or var user = new User (); user . email = '[Avenue@Q.com' ; console . log ( user . email ); // '[avenue@q.com' User . updateOne ({ _id : _id }, { $ set : { email : '[AVENUE@Q.COM' } }); // update to '[avenue@q.com' As you can see above, setters allow you to transform the data before it stored in MongoDB. NOTE: we could have also just used the built-in lowercase: true SchemaType option instead of defining our own function. new Schema({ email: { type: String, lowercase: true }}) Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema. function inspector ( val , schematype ) { if ( schematype . options . required ) { return schematype . path + ' is required' ; } else { return val ; } } var VirusSchema = new Schema ({ name : { type : String , required : true , set : inspector }, taxonomy : { type : String , set : inspector } }) var Virus = db . model ( 'Virus' , VirusSchema ); var v = new Virus ({ name : 'Parvoviridae' , taxonomy : 'Parvovirinae' }); console . log ( v . name ); console . log ( v . taxonomy );","title":"SchemaType.prototype.set()"},{"location":"schema/type-5/#schematypeprototypeget","text":"\u53c2\u6570 \u8fd4\u56de Adds a getter to this schematype. \u793a\u4f8b function dob ( val ) { if ( ! val ) return val ; return ( val . getMonth () + 1 ) + \"/\" + val . getDate () + \"/\" + val . getFullYear (); } var s = new Schema ({ born : { type : Date , get : dob }) var s = new Schema ({ born : Date }) s . path ( 'born' ) . get ( dob ) Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see. Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way: function obfuscate ( cc ) { return '****-****-****-' + cc . slice ( cc . length - 4 , cc . length ); } var AccountSchema = new Schema ({ creditCardNumber : { type : String , get : obfuscate } }); var Account = db . model ( 'Account' , AccountSchema ); Account . findById ( id , function ( err , found ) { console . log ( found . creditCardNumber ); }); Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema. function inspector ( val , schematype ) { if ( schematype . options . required ) { return schematype . path + ' is required' ; } else { return schematype . path + ' is not' ; } } var VirusSchema = new Schema ({ name : { type : String , required : true , get : inspector }, taxonomy : { type : String , get : inspector } }) var Virus = db . model ( 'Virus' , VirusSchema ); Virus . findById ( id , function ( err , virus ) { console . log ( virus . name ); console . log ( virus . taxonomy ); })","title":"SchemaType.prototype.get()"},{"location":"schema/type-5/#schematypeprototypevalidate","text":"\u53c2\u6570 [type] \u00abString\u00bb optional validator type \u8fd4\u56de Adds validator(s) for this document path. Validators always receive the value to validate as their first argument and must return Boolean . Returning false means validation failed. The error message argument is optional. If not passed, the [default generic error message template will be used. \u793a\u4f8b function validator ( val ) { return val == 'something' ; } new Schema ({ name : { type : String , validate : validator }}); var custom = [ validator , 'Uh oh, {PATH} does not equal \"something\".' ] new Schema ({ name : { type : String , validate : custom }}); var many = [ { validator : validator , msg : 'uh oh' } , { validator : anotherValidator , msg : 'failed' } ] new Schema ({ name : { type : String , validate : many }}); var schema = new Schema ({ name : 'string' }); schema . path ( 'name' ) . validate ( validator , 'validation of `{PATH}` failed with value `{VALUE}`' ); \u9519\u8bef\u6d88\u606f\u6a21\u677f From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides {PATH} and {VALUE} too. To find out more, details are available [here \u5f02\u6b65\u9a8c\u8bc1 Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either true or false to communicate either success or failure respectively. schema . path ( 'name' ) . validate ( { isAsync : true , validator : function ( value , respond ) { doStuff ( value , function ( ) { ... respond ( false ); } ); } , message : 'Custom error message!' } ); schema . path ( 'name' ) . validate ( { validator : function ( value ) { return new Promise ( function ( resolve , reject ) { resolve ( false ); } ); } } ); You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs. Validation occurs pre('save') or whenever you manually execute [document#validate. If validation fails during pre('save') and no callback was passed to receive the error, an error event will be emitted on your Models associated db [connection, passing the validation error object along. var conn = mongoose . createConnection ( .. ); conn . on ( 'error' , handleError ); var Product = conn . model ( 'Product' , yourSchema ); var dvd = new Product ( .. ); dvd . save (); If you desire handling these errors at the Model level, attach an error listener to your Model and the event will instead be emitted there. Product.on('error', handleError);","title":"SchemaType.prototype.validate()"},{"location":"schema/type-5/#schematypeprototyperequired","text":"\u53c2\u6570 [message] \u00abString\u00bb optional custom error message \u8fd4\u56de Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using unshift() . \u793a\u4f8b var s = new Schema ({ born : { type : Date , required : true }) var s = new Schema ({ born : { type : Date , required : '{PATH} is required!' }) var s = new Schema ({ userId : ObjectId , username : { type : String , required : function () { return this . userId != null ; } } }) var s = new Schema ({ userId : ObjectId , username : { type : String , required : [ function () { return this . userId != null ; }, 'username is required if id is specified' ] } }) Schema . path ( 'name' ) . required ( true ); Schema . path ( 'name' ) . required ( true , 'grrr :( ' ); var isOver18 = function () { return this . age >= 18 ; }; Schema . path ( 'voterRegistrationId' ) . required ( isOver18 ); The required validator uses the SchemaType's checkRequired function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if val != null (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default checkRequired function:","title":"SchemaType.prototype.required()"},{"location":"schema/type-5/#schematypeprototypeselect","text":"\u53c2\u6570 \u8fd4\u56de Sets default select() behavior for this path. Set to true if this path should always be included in the results, false if it should be excluded by default. This setting can be overridden at the query level. \u793a\u4f8b T = db . model ( 'T' , new Schema ( { x : { type : String , select : true } } )); T . find (..); T . find () . select ( '-x' ) . exec ( callback );","title":"SchemaType.prototype.select()"},{"location":"schema/type/","text":"\u6a21\u5f0f \u00b6 SchemaTypes handle definition of path defaults , validation , getters , setters , field selection defaults for queries ,and other general characteristics for Mongoose document properties. \u4ec0\u4e48\u662f SchemaType? \u00b6 You can think of a Mongoose schema as the configuration object for a Mongoose model. A SchemaType is then a configuration object for an individual property. A SchemaType says what type a given path should have, whether it has any getters/setters, and what values are valid for that path. JavaScript const schema = new Schema ({ name : String }); schema . path ( \"name\" ) instanceof mongoose . SchemaType ; // true schema . path ( \"name\" ) instanceof mongoose . Schema . Types . String ; // true schema . path ( \"name\" ). instance ; // 'String' A SchemaType is different from a type. In other words, mongoose.ObjectId !== mongoose.Types.ObjectId . A SchemaType is just a configuration object for Mongoose. An instance of the mongoose.ObjectId SchemaType doesn't actually create MongoDB ObjectIds, it is just a configuration for a path in a schema. The following are all the valid SchemaTypes in Mongoose. Mongoose plugins can also add custom SchemaTypes like int32 . Check out Mongoose's plugins search to find plugins. String Number Date Buffer Boolean Mixed ObjectId Array Decimal128 Map Schema \u793a\u4f8b \u00b6 JavaScript const schema = new Schema ({ name : String , binary : Buffer , living : Boolean , updated : { type : Date , default : Date . now }, age : { type : Number , min : 18 , max : 65 }, mixed : Schema . Types . Mixed , _someId : Schema . Types . ObjectId , decimal : Schema . Types . Decimal128 , array : [], ofString : [ String ], ofNumber : [ Number ], ofDates : [ Date ], ofBuffer : [ Buffer ], ofBoolean : [ Boolean ], ofMixed : [ Schema . Types . Mixed ], ofObjectId : [ Schema . Types . ObjectId ], ofArrays : [[]], ofArrayOfNumbers : [[ Number ]], nested : { stuff : { type : String , lowercase : true , trim : true }, }, map : Map , mapOfString : { type : Map , of : String , }, }); // example use const Thing = mongoose . model ( \"Thing\" , schema ); const m = new Thing (); m . name = \"Statue of Liberty\" ; m . age = 125 ; m . updated = new Date (); m . binary = Buffer . alloc ( 0 ); m . living = false ; m . mixed = { any : { thing : \"i want\" } }; m . markModified ( \"mixed\" ); m . _someId = new mongoose . Types . ObjectId (); m . array . push ( 1 ); m . ofString . push ( \"strings!\" ); m . ofNumber . unshift ( 1 , 2 , 3 , 4 ); m . ofDates . addToSet ( new Date ()); m . ofBuffer . pop (); m . ofMixed = [ 1 , [], \"three\" , { four : 5 }]; m . nested . stuff = \"good\" ; m . map = new Map ([[ \"key\" , \"value\" ]]); m . save ( callback ); type \u952e \u00b6 type is a special property in Mongoose schemas. When Mongoose finds a nested property named type in your schema, Mongoose assumes that it needs to define a SchemaType with the given type. JavaScript // 3 string SchemaTypes: 'name', 'nested.firstName', 'nested.lastName' const schema = new Schema ({ name : { type : String }, nested : { firstName : { type : String }, lastName : { type : String }, }, }); As a consequence, you need a little extra work to define a property named type in your schema . For example, suppose you're building a stock portfolio app, and you want to store the asset's type (stock, bond, ETF, etc.). Naively, you might define your schema as shown below: JavaScript const holdingSchema = new Schema ({ // You might expect `asset` to be an object that has 2 properties, // but unfortunately `type` is special in Mongoose so mongoose // interprets this schema to mean that `asset` is a string asset : { type : String , ticker : String , }, }); However, when Mongoose sees type: String , it assumes that you mean asset should be a string, not an object with a property type . The correct way to define an object with a property type is shown below. JavaScript const holdingSchema = new Schema ({ asset : { // Workaround to make sure Mongoose knows `asset` is an object // and `asset.type` is a string, rather than thinking `asset` // is a string. type : { type : String }, ticker : String , }, }); SchemaType \u9009\u9879 \u00b6 You can declare a schema type using the type directly, or an object with a type property. JavaScript const schema1 = new Schema ({ test : String , // `test` is a path of type String }); const schema2 = new Schema ({ // The `test` object contains the \"SchemaType options\" test : { type : String }, // `test` is a path of type string }); In addition to the type property, you can specify additional properties for a path. For example, if you want to lowercase a string before saving: JavaScript const schema2 = new Schema ({ test : { type : String , lowercase : true , // Always convert `test` to lowercase }, }); You can add any property you want to your SchemaType options. Many plugins rely on custom SchemaType options. For example, the mongoose-autopopulate plugin automatically populates paths if you set autopopulate: true in your SchemaType options. Mongoose comes with support for several built-in SchemaType options, like lowercase in the above example. The lowercase option only works for strings. There are certain options which apply for all schema types, and some that apply for specific schema types. \u6a21\u5f0f\u9009\u9879 \u00b6 required : boolean \u6216\u51fd\u6570\uff0c\u5982\u679c\u4e3a true\uff0c\u5219\u4e3a\u8be5\u5c5e\u6027\u6dfb\u52a0 \u9700\u8981\u9a8c\u8bc1\u5668 default : \u4efb\u610f\u6216\u51fd\u6570\uff0c\u4e3a\u8def\u5f84\u8bbe\u7f6e\u9ed8\u8ba4\u503c\u3002\u5982\u679c\u8be5\u503c\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5219\u9ed8\u8ba4\u4f7f\u7528\u8be5\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 select : boolean, \u4e3a\u67e5\u8be2\u6307\u5b9a\u9ed8\u8ba4\u7684 \u6295\u5f71 validate : \u51fd\u6570\uff0c\u4e3a\u8fd9\u4e2a\u5c5e\u6027\u6dfb\u52a0\u4e00\u4e2a \u9a8c\u8bc1\u5668\u51fd\u6570 get : \u51fd\u6570\uff0c\u4f7f\u7528 Object.defineProperty() \u4e3a\u8be5\u5c5e\u6027\u5b9a\u4e49\u4e00\u4e2a\u81ea\u5b9a\u4e49 getter. set : \u51fd\u6570\uff0c\u4f7f\u7528 Object.defineProperty() \u4e3a\u8be5\u5c5e\u6027\u5b9a\u4e49\u81ea\u5b9a\u4e49 setter. alias : \u5b57\u7b26\u4e32\uff0c\u4ec5 mongoose >= 4.10.0 \u3002\u7528\u7ed9\u5b9a\u7684\u540d\u79f0\u5b9a\u4e49\u4e00\u4e2a virtual \u6765\u83b7\u53d6/\u8bbe\u7f6e\u8fd9\u4e2a\u8def\u5f84\u3002 immutable : \u5e03\u5c14\u503c\uff0c\u5b9a\u4e49\u8def\u5f84\u4e3a\u4e0d\u53ef\u53d8\u7684\u3002Mongoose \u963b\u6b62\u4f60\u6539\u53d8\u4e0d\u53ef\u53d8\u7684\u8def\u5f84\uff0c\u9664\u975e\u7236\u6587\u6863\u6709 isNew: true \u3002 transform : \u5f53\u4f60\u8c03\u7528 Document#toJSON() \u51fd\u6570\u65f6\uff0c\u5305\u62ec\u5f53\u4f60 JSON.stringify() \u4e00\u4e2a\u6587\u6863\u65f6\uff0cMongoose \u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\u3002 JavaScript const numberSchema = new Schema ({ integerOnly : { type : Number , get : ( v ) => Math . round ( v ), set : ( v ) => Math . round ( v ), alias : \"i\" , }, }); const Number = mongoose . model ( \"Number\" , numberSchema ); const doc = new Number (); doc . integerOnly = 2.001 ; doc . integerOnly ; // 2 doc . i ; // 2 doc . i = 3.001 ; doc . integerOnly ; // 3 doc . i ; // 3 \u7d22\u5f15 Indexes \u00b6 You can also define MongoDB indexes using schema type options. index : boolean, whether to define an index on this property. unique : boolean, whether to define a unique index on this property. sparse : boolean, whether to define a sparse index on this property. JavaScript const schema2 = new Schema ({ test : { type : String , index : true , unique : true , // Unique index. If you specify `unique: true` // specifying `index: true` is optional if you do `unique: true` }, }); \u5b57\u7b26 String \u00b6 lowercase : boolean, whether to always call .toLowerCase() on the value uppercase : boolean, whether to always call .toUpperCase() on the value trim : boolean, whether to always call .trim() on the value match : RegExp, creates a validator that checks if the value matches the given regular expression enum : Array, creates a validator that checks if the value is in the given array. minLength : Number, creates a validator that checks if the value length is not less than the given number maxLength : Number, creates a validator that checks if the value length is not greater than the given number populate : Object, sets default populate options \u6570\u5b57 Number \u00b6 min : Number, creates a validator that checks if the value is greater than or equal to the given minimum. max : Number, creates a validator that checks if the value is less than or equal to the given maximum. enum : Array, creates a validator that checks if the value is strictly equal to one of the values in the given array. populate : Object, sets default populate options \u65e5\u671f Date \u00b6 min : Date max : Date \u5bf9\u8c61 Id ObjectId \u00b6 populate : Object, sets default populate options \u4f7f\u7528\u7b14\u8bb0 \u00b6 String \u00b6 To declare a path as a string, you may use either the String global constructor or the string 'String' . JavaScript const schema1 = new Schema ({ name : String }); // name will be cast to string const schema2 = new Schema ({ name : \"String\" }); // Equivalent const Person = mongoose . model ( \"Person\" , schema2 ); If you pass an element that has a toString() function, Mongoose will call it, unless the element is an array or the toString() function is strictly equal to Object.prototype.toString() . JavaScript new Person ({ name : 42 }). name ; // \"42\" as a string new Person ({ name : { toString : () => 42 } }). name ; // \"42\" as a string // \"undefined\", will get a cast error if you `save()` this document new Person ({ name : { foo : 42 } }). name ; Number \u00b6 To declare a path as a number, you may use either the Number global constructor or the string 'Number' . JavaScript const schema1 = new Schema ({ age : Number }); // age will be cast to a Number const schema2 = new Schema ({ age : \"Number\" }); // Equivalent const Car = mongoose . model ( \"Car\" , schema2 ); There are several types of values that will be successfully cast to a Number. JavaScript new Car ({ age : \"15\" }). age ; // 15 as a Number new Car ({ age : true }). age ; // 1 as a Number new Car ({ age : false }). age ; // 0 as a Number new Car ({ age : { valueOf : () => 83 } }). age ; // 83 as a Number If you pass an object with a valueOf() function that returns a Number, Mongoose will call it and assign the returned value to the path. The values null and undefined are not cast. NaN, strings that cast to NaN, arrays, and objects that don't have a valueOf() function will all result in a CastError once validated, meaning that it will not throw on initialization, only when validated. Dates \u00b6 Built-in Date methods are not hooked into the mongoose change tracking logic which in English means that if you use a Date in your document and modify it with a method like setMonth() , mongoose will be unaware of this change and doc.save() will not persist this modification. If you must modify Date types using built-in methods, tell mongoose about the change with doc.markModified('pathToYourDate') before saving. JavaScript const Assignment = mongoose . model ( \"Assignment\" , { dueDate : Date }); Assignment . findOne ( function ( err , doc ) { doc . dueDate . setMonth ( 3 ); doc . save ( callback ); // THIS DOES NOT SAVE YOUR CHANGE doc . markModified ( \"dueDate\" ); doc . save ( callback ); // works }); Buffer \u00b6 To declare a path as a Buffer, you may use either the Buffer global constructor or the string 'Buffer' . JavaScript const schema1 = new Schema ({ binData : Buffer }); // binData will be cast to a Buffer const schema2 = new Schema ({ binData : \"Buffer\" }); // Equivalent const Data = mongoose . model ( \"Data\" , schema2 ); Mongoose will successfully cast the below values to buffers. Text Only const file1 = new Data({ binData: 'test'}); // {\"type\":\"Buffer\",\"data\":[116,101,115,116]} const file2 = new Data({ binData: 72987 }); // {\"type\":\"Buffer\",\"data\":[27]} const file4 = new Data({ binData: { type: 'Buffer', data: [1, 2, 3]}}); // {\"type\":\"Buffer\",\"data\":[1,2,3]} Mixed \u00b6 An \"anything goes\" SchemaType. Mongoose will not do any casting on mixed paths. You can define a mixed path using Schema.Types.Mixed or by passing an empty object literal. The following are equivalent. JavaScript const Any = new Schema ({ any : {} }); const Any = new Schema ({ any : Object }); const Any = new Schema ({ any : Schema . Types . Mixed }); const Any = new Schema ({ any : mongoose . Mixed }); Since Mixed is a schema-less type, you can change the value to anything else you like, but Mongoose loses the ability to auto detect and save those changes. To tell Mongoose that the value of a Mixed type has changed, you need to call doc.markModified(path) , passing the path to the Mixed type you just changed. To avoid these side-effects, a Subdocument path may be used instead. JavaScript person . anything = { x : [ 3 , 4 , { y : \"changed\" }] }; person . markModified ( \"anything\" ); person . save (); // Mongoose will save changes to `anything`. ObjectIds \u00b6 An ObjectId is a special type typically used for unique identifiers. Here's how you declare a schema with a path driver that is an ObjectId: JavaScript const mongoose = require ( \"mongoose\" ); const carSchema = new mongoose . Schema ({ driver : mongoose . ObjectId }); ObjectId is a class, and ObjectIds are objects. However, they are often represented as strings. When you convert an ObjectId to a string using toString() , you get a 24-character hexadecimal string: JavaScript const Car = mongoose . model ( \"Car\" , carSchema ); const car = new Car (); car . driver = new mongoose . Types . ObjectId (); typeof car . driver ; // 'object' car . driver instanceof mongoose . Types . ObjectId ; // true car . driver . toString (); // Something like \"5e1a0651741b255ddda996c4\" Boolean \u00b6 Booleans in Mongoose are plain JavaScript booleans . By default, Mongoose casts the below values to true : true 'true' 1 '1' 'yes' Mongoose casts the below values to false : false 'false' 0 '0' 'no' Any other value causes a CastError . You can modify what values Mongoose converts to true or false using the convertToTrue and convertToFalse properties, which are JavaScript sets . JavaScript const M = mongoose . model ( \"Test\" , new Schema ({ b : Boolean })); console . log ( new M ({ b : \"nay\" }). b ); // undefined // Set { false, 'false', 0, '0', 'no' } console . log ( mongoose . Schema . Types . Boolean . convertToFalse ); mongoose . Schema . Types . Boolean . convertToFalse . add ( \"nay\" ); console . log ( new M ({ b : \"nay\" }). b ); // false Arrays \u00b6 Mongoose supports arrays of SchemaTypes and arrays of subdocuments . Arrays of SchemaTypes are also called primitive arrays , and arrays of subdocuments are also called document arrays . JavaScript const ToySchema = new Schema ({ name : String }); const ToyBoxSchema = new Schema ({ toys : [ ToySchema ], buffers : [ Buffer ], strings : [ String ], numbers : [ Number ], // ... etc }); Arrays are special because they implicitly have a default value of [] (empty array). JavaScript const ToyBox = mongoose . model ( \"ToyBox\" , ToyBoxSchema ); console . log ( new ToyBox (). toys ); // [] To overwrite this default, you need to set the default value to undefined JavaScript const ToyBoxSchema = new Schema ({ toys : { type : [ ToySchema ], default : undefined , }, }); Note: specifying an empty array is equivalent to Mixed . The following all create arrays of Mixed : JavaScript const Empty1 = new Schema ({ any : [] }); const Empty2 = new Schema ({ any : Array }); const Empty3 = new Schema ({ any : [ Schema . Types . Mixed ] }); const Empty4 = new Schema ({ any : [{}] }); Maps \u00b6 \u5728 Mongoose 5.1.0 \u4e2d\u65b0\u589e MongooseMap \u662f JavaScript Map \u7c7b \u7684\u5b50\u7c7b. \u5728\u8fd9\u4e9b\u6587\u6863\u4e2d\uff0c\u6211\u4eec\u5c06\u4ea4\u66ff\u4f7f\u7528\u672f\u8bed map \u548c MongooseMap \u3002 \u5728 Mongoose \u4e2d\uff0c\u6620\u5c04\u662f\u4f7f\u7528\u4efb\u610f\u952e\u521b\u5efa\u5d4c\u5957\u6587\u6863\u7684\u65b9\u5f0f\u3002 Note \u5728 Mongoose Maps \u4e2d\uff0c\u952e\u5fc5\u987b\u662f\u5b57\u7b26\u4e32\uff0c\u4ee5\u4fbf\u5728 MongoDB \u4e2d\u5b58\u50a8\u6587\u6863\u3002 user.schema.js const userSchema = new Schema ({ // `socialMediaHandles` is a map whose values are strings. A map's // keys are always strings. You specify the type of values using `of`. socialMediaHandles : { type : Map , of : String , }, }); const User = mongoose . model ( \"User\" , userSchema ); // Map { 'github' => 'vkarpov15', 'twitter' => '@code_barbarian' } console . log ( new User ({ socialMediaHandles : { github : \"vkarpov15\" , twitter : \"@code_barbarian\" , }, }). socialMediaHandles ); \u4e0a\u9762\u7684\u4f8b\u5b50\u5e76\u6ca1\u6709\u660e\u786e\u5730\u5c06 github or twitter \u58f0\u660e\u4e3a\u8def\u5f84\uff0c \u4f46\u662f\uff0c\u7531\u4e8e socialMediaHandles \u662f\u4e00\u4e2a\u6620\u5c04\uff0c\u4f60\u53ef\u4ee5\u5b58\u50a8\u4efb\u610f\u952e/\u503c\u5bf9\u3002 \u7136\u800c\uff0c\u7531\u4e8e socialMediaHandles \u662f\u4e00\u4e2a\u6620\u5c04\uff0c\u4f60 \u5fc5\u987b \u4f7f\u7528 .get() \u6765\u83b7\u53d6\u952e\u7684\u503c\uff0c\u800c .set() \u6765\u8bbe\u7f6e\u952e\u7684\u503c\u3002 JavaScript const user = new User ({ socialMediaHandles : {} }); // Good user . socialMediaHandles . set ( \"github\" , \"vkarpov15\" ); // Works too user . set ( \"socialMediaHandles.twitter\" , \"@code_barbarian\" ); // Bad, the `myspace` property will **not** get saved user . socialMediaHandles . myspace = \"fail\" ; // 'vkarpov15' console . log ( user . socialMediaHandles . get ( \"github\" )); // '@code_barbarian' console . log ( user . get ( \"socialMediaHandles.twitter\" )); // undefined user . socialMediaHandles . github ; // Will only save the 'github' and 'twitter' properties user . save (); \u6620\u5c04\u7c7b\u578b\u5b58\u50a8\u4e3a BSON \u5bf9\u8c61\u5728 MongoDB . BSON \u5bf9\u8c61\u4e2d\u7684\u952e\u662f\u6709\u5e8f\u7684\uff0c\u6240\u4ee5\u8fd9\u610f\u5473\u7740\u6620\u5c04\u7684 \u63d2\u5165\u987a\u5e8f \u5c5e\u6027\u5f97\u5230\u4e86\u7ef4\u62a4\u3002 Mongoose \u652f\u6301\u4e00\u4e2a\u7279\u6b8a\u7684 $* \u8bed\u6cd5\u6765 \u586b\u5145 \u6620\u5c04\u4e2d\u7684\u6240\u6709\u5143\u7d20\u3002 \u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u7684 socialMediaHandles \u5730\u56fe\u5305\u542b\u4e00\u4e2a ref : JavaScript const userSchema = new Schema ({ socialMediaHandles : { type : Map , of : new Schema ({ handle : String , oauth : { type : ObjectId , ref : \"OAuth\" }, }), }, }); const User = mongoose . model ( \"User\" , userSchema ); \u4e3a\u4e86\u586b\u5145\u6bcf\u4e2a socialMediaHandles \u6761\u76ee\u7684 oauth \u5c5e\u6027\uff0c\u4f60\u5e94\u8be5\u5728 socialMediaHandles.$*.oauth \u4e0a\u586b\u5145: JavaScript const user = await User . findOne (). populate ( \"socialMediaHandles.$*.oauth\" ); Getters \u00b6 Getters are like virtuals for paths defined in your schema. For example, let's say you wanted to store user profile pictures as relative paths and then add the hostname in your application. Below is how you would structure your userSchema : JavaScript const root = \"https://s3.amazonaws.com/mybucket\" ; const userSchema = new Schema ({ name : String , picture : { type : String , get : ( v ) => ` ${ root }${ v } ` , }, }); const User = mongoose . model ( \"User\" , userSchema ); const doc = new User ({ name : \"Val\" , picture : \"/123.png\" }); doc . picture ; // 'https://s3.amazonaws.com/mybucket/123.png' doc . toObject ({ getters : false }). picture ; // '/123.png' Generally, you only use getters on primitive paths as opposed to arrays or subdocuments. Because getters override what accessing a Mongoose path returns, declaring a getter on an object may remove Mongoose change tracking for that path. JavaScript const schema = new Schema ({ arr : [{ url : String }], }); const root = \"https://s3.amazonaws.com/mybucket\" ; // Bad, don't do this! schema . path ( \"arr\" ). get (( v ) => { return v . map (( el ) => Object . assign ( el , { url : root + el . url })); }); // Later doc . arr . push ({ key : String }); doc . arr [ 0 ]; // 'undefined' because every `doc.arr` creates a new array! Instead of declaring a getter on the array as shown above, you should declare a getter on the url string as shown below. If you need to declare a getter on a nested document or array, be very careful! JavaScript const schema = new Schema ({ arr : [{ url : String }], }); const root = \"https://s3.amazonaws.com/mybucket\" ; // Good, do this instead of declaring a getter on `arr` schema . path ( \"arr.0.url\" ). get (( v ) => ` ${ root }${ v } ` ); Schemas \u00b6 To declare a path as another schema , set type to the sub-schema's instance. To set a default value based on the sub-schema's shape, simply set a default value, and the value will be cast based on the sub-schema's definition before being set during document creation. JavaScript const subSchema = new mongoose . Schema ({ // some schema definition here }); const schema = new mongoose . Schema ({ data : { type : subSchema default : {} } }); \u521b\u5efa\u81ea\u5b9a\u4e49\u7c7b\u578b \u00b6 Mongoose can also be extended with custom SchemaTypes . Search the plugins site for compatible types like mongoose-long , mongoose-int32 , and other types . Read more about creating custom SchemaTypes here . schema.path() \u51fd\u6570 \u00b6 The schema.path() function returns the instantiated schema type for a given path. JavaScript const sampleSchema = new Schema ({ name : { type : String , required : true } }); console . log ( sampleSchema . path ( \"name\" )); // Output looks like: /** * SchemaString { * enumValues: [], * regExp: null, * path: 'name', * instance: 'String', * validators: ... */ You can use this function to inspect the schema type for a given path, including what validators it has and what the type is. \u9605\u8bfb\u66f4\u591a \u00b6 An Introduction to Mongoose SchemaTypes Mongoose Schema Types","title":"\u6a21\u5f0f\u7c7b\u578bAPI"},{"location":"schema/type/#_1","text":"SchemaTypes handle definition of path defaults , validation , getters , setters , field selection defaults for queries ,and other general characteristics for Mongoose document properties.","title":"\u6a21\u5f0f"},{"location":"schema/type/#schematype","text":"You can think of a Mongoose schema as the configuration object for a Mongoose model. A SchemaType is then a configuration object for an individual property. A SchemaType says what type a given path should have, whether it has any getters/setters, and what values are valid for that path. JavaScript const schema = new Schema ({ name : String }); schema . path ( \"name\" ) instanceof mongoose . SchemaType ; // true schema . path ( \"name\" ) instanceof mongoose . Schema . Types . String ; // true schema . path ( \"name\" ). instance ; // 'String' A SchemaType is different from a type. In other words, mongoose.ObjectId !== mongoose.Types.ObjectId . A SchemaType is just a configuration object for Mongoose. An instance of the mongoose.ObjectId SchemaType doesn't actually create MongoDB ObjectIds, it is just a configuration for a path in a schema. The following are all the valid SchemaTypes in Mongoose. Mongoose plugins can also add custom SchemaTypes like int32 . Check out Mongoose's plugins search to find plugins. String Number Date Buffer Boolean Mixed ObjectId Array Decimal128 Map Schema","title":"\u4ec0\u4e48\u662f SchemaType?"},{"location":"schema/type/#_2","text":"JavaScript const schema = new Schema ({ name : String , binary : Buffer , living : Boolean , updated : { type : Date , default : Date . now }, age : { type : Number , min : 18 , max : 65 }, mixed : Schema . Types . Mixed , _someId : Schema . Types . ObjectId , decimal : Schema . Types . Decimal128 , array : [], ofString : [ String ], ofNumber : [ Number ], ofDates : [ Date ], ofBuffer : [ Buffer ], ofBoolean : [ Boolean ], ofMixed : [ Schema . Types . Mixed ], ofObjectId : [ Schema . Types . ObjectId ], ofArrays : [[]], ofArrayOfNumbers : [[ Number ]], nested : { stuff : { type : String , lowercase : true , trim : true }, }, map : Map , mapOfString : { type : Map , of : String , }, }); // example use const Thing = mongoose . model ( \"Thing\" , schema ); const m = new Thing (); m . name = \"Statue of Liberty\" ; m . age = 125 ; m . updated = new Date (); m . binary = Buffer . alloc ( 0 ); m . living = false ; m . mixed = { any : { thing : \"i want\" } }; m . markModified ( \"mixed\" ); m . _someId = new mongoose . Types . ObjectId (); m . array . push ( 1 ); m . ofString . push ( \"strings!\" ); m . ofNumber . unshift ( 1 , 2 , 3 , 4 ); m . ofDates . addToSet ( new Date ()); m . ofBuffer . pop (); m . ofMixed = [ 1 , [], \"three\" , { four : 5 }]; m . nested . stuff = \"good\" ; m . map = new Map ([[ \"key\" , \"value\" ]]); m . save ( callback );","title":"\u793a\u4f8b"},{"location":"schema/type/#type","text":"type is a special property in Mongoose schemas. When Mongoose finds a nested property named type in your schema, Mongoose assumes that it needs to define a SchemaType with the given type. JavaScript // 3 string SchemaTypes: 'name', 'nested.firstName', 'nested.lastName' const schema = new Schema ({ name : { type : String }, nested : { firstName : { type : String }, lastName : { type : String }, }, }); As a consequence, you need a little extra work to define a property named type in your schema . For example, suppose you're building a stock portfolio app, and you want to store the asset's type (stock, bond, ETF, etc.). Naively, you might define your schema as shown below: JavaScript const holdingSchema = new Schema ({ // You might expect `asset` to be an object that has 2 properties, // but unfortunately `type` is special in Mongoose so mongoose // interprets this schema to mean that `asset` is a string asset : { type : String , ticker : String , }, }); However, when Mongoose sees type: String , it assumes that you mean asset should be a string, not an object with a property type . The correct way to define an object with a property type is shown below. JavaScript const holdingSchema = new Schema ({ asset : { // Workaround to make sure Mongoose knows `asset` is an object // and `asset.type` is a string, rather than thinking `asset` // is a string. type : { type : String }, ticker : String , }, });","title":"type \u952e"},{"location":"schema/type/#schematype_1","text":"You can declare a schema type using the type directly, or an object with a type property. JavaScript const schema1 = new Schema ({ test : String , // `test` is a path of type String }); const schema2 = new Schema ({ // The `test` object contains the \"SchemaType options\" test : { type : String }, // `test` is a path of type string }); In addition to the type property, you can specify additional properties for a path. For example, if you want to lowercase a string before saving: JavaScript const schema2 = new Schema ({ test : { type : String , lowercase : true , // Always convert `test` to lowercase }, }); You can add any property you want to your SchemaType options. Many plugins rely on custom SchemaType options. For example, the mongoose-autopopulate plugin automatically populates paths if you set autopopulate: true in your SchemaType options. Mongoose comes with support for several built-in SchemaType options, like lowercase in the above example. The lowercase option only works for strings. There are certain options which apply for all schema types, and some that apply for specific schema types.","title":"SchemaType \u9009\u9879"},{"location":"schema/type/#_3","text":"required : boolean \u6216\u51fd\u6570\uff0c\u5982\u679c\u4e3a true\uff0c\u5219\u4e3a\u8be5\u5c5e\u6027\u6dfb\u52a0 \u9700\u8981\u9a8c\u8bc1\u5668 default : \u4efb\u610f\u6216\u51fd\u6570\uff0c\u4e3a\u8def\u5f84\u8bbe\u7f6e\u9ed8\u8ba4\u503c\u3002\u5982\u679c\u8be5\u503c\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5219\u9ed8\u8ba4\u4f7f\u7528\u8be5\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002 select : boolean, \u4e3a\u67e5\u8be2\u6307\u5b9a\u9ed8\u8ba4\u7684 \u6295\u5f71 validate : \u51fd\u6570\uff0c\u4e3a\u8fd9\u4e2a\u5c5e\u6027\u6dfb\u52a0\u4e00\u4e2a \u9a8c\u8bc1\u5668\u51fd\u6570 get : \u51fd\u6570\uff0c\u4f7f\u7528 Object.defineProperty() \u4e3a\u8be5\u5c5e\u6027\u5b9a\u4e49\u4e00\u4e2a\u81ea\u5b9a\u4e49 getter. set : \u51fd\u6570\uff0c\u4f7f\u7528 Object.defineProperty() \u4e3a\u8be5\u5c5e\u6027\u5b9a\u4e49\u81ea\u5b9a\u4e49 setter. alias : \u5b57\u7b26\u4e32\uff0c\u4ec5 mongoose >= 4.10.0 \u3002\u7528\u7ed9\u5b9a\u7684\u540d\u79f0\u5b9a\u4e49\u4e00\u4e2a virtual \u6765\u83b7\u53d6/\u8bbe\u7f6e\u8fd9\u4e2a\u8def\u5f84\u3002 immutable : \u5e03\u5c14\u503c\uff0c\u5b9a\u4e49\u8def\u5f84\u4e3a\u4e0d\u53ef\u53d8\u7684\u3002Mongoose \u963b\u6b62\u4f60\u6539\u53d8\u4e0d\u53ef\u53d8\u7684\u8def\u5f84\uff0c\u9664\u975e\u7236\u6587\u6863\u6709 isNew: true \u3002 transform : \u5f53\u4f60\u8c03\u7528 Document#toJSON() \u51fd\u6570\u65f6\uff0c\u5305\u62ec\u5f53\u4f60 JSON.stringify() \u4e00\u4e2a\u6587\u6863\u65f6\uff0cMongoose \u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\u3002 JavaScript const numberSchema = new Schema ({ integerOnly : { type : Number , get : ( v ) => Math . round ( v ), set : ( v ) => Math . round ( v ), alias : \"i\" , }, }); const Number = mongoose . model ( \"Number\" , numberSchema ); const doc = new Number (); doc . integerOnly = 2.001 ; doc . integerOnly ; // 2 doc . i ; // 2 doc . i = 3.001 ; doc . integerOnly ; // 3 doc . i ; // 3","title":"\u6a21\u5f0f\u9009\u9879"},{"location":"schema/type/#indexes","text":"You can also define MongoDB indexes using schema type options. index : boolean, whether to define an index on this property. unique : boolean, whether to define a unique index on this property. sparse : boolean, whether to define a sparse index on this property. JavaScript const schema2 = new Schema ({ test : { type : String , index : true , unique : true , // Unique index. If you specify `unique: true` // specifying `index: true` is optional if you do `unique: true` }, });","title":"\u7d22\u5f15 Indexes"},{"location":"schema/type/#string","text":"lowercase : boolean, whether to always call .toLowerCase() on the value uppercase : boolean, whether to always call .toUpperCase() on the value trim : boolean, whether to always call .trim() on the value match : RegExp, creates a validator that checks if the value matches the given regular expression enum : Array, creates a validator that checks if the value is in the given array. minLength : Number, creates a validator that checks if the value length is not less than the given number maxLength : Number, creates a validator that checks if the value length is not greater than the given number populate : Object, sets default populate options","title":"\u5b57\u7b26 String"},{"location":"schema/type/#number","text":"min : Number, creates a validator that checks if the value is greater than or equal to the given minimum. max : Number, creates a validator that checks if the value is less than or equal to the given maximum. enum : Array, creates a validator that checks if the value is strictly equal to one of the values in the given array. populate : Object, sets default populate options","title":"\u6570\u5b57 Number"},{"location":"schema/type/#date","text":"min : Date max : Date","title":"\u65e5\u671f Date"},{"location":"schema/type/#id-objectid","text":"populate : Object, sets default populate options","title":"\u5bf9\u8c61 Id ObjectId"},{"location":"schema/type/#_4","text":"","title":"\u4f7f\u7528\u7b14\u8bb0"},{"location":"schema/type/#string_1","text":"To declare a path as a string, you may use either the String global constructor or the string 'String' . JavaScript const schema1 = new Schema ({ name : String }); // name will be cast to string const schema2 = new Schema ({ name : \"String\" }); // Equivalent const Person = mongoose . model ( \"Person\" , schema2 ); If you pass an element that has a toString() function, Mongoose will call it, unless the element is an array or the toString() function is strictly equal to Object.prototype.toString() . JavaScript new Person ({ name : 42 }). name ; // \"42\" as a string new Person ({ name : { toString : () => 42 } }). name ; // \"42\" as a string // \"undefined\", will get a cast error if you `save()` this document new Person ({ name : { foo : 42 } }). name ;","title":"String"},{"location":"schema/type/#number_1","text":"To declare a path as a number, you may use either the Number global constructor or the string 'Number' . JavaScript const schema1 = new Schema ({ age : Number }); // age will be cast to a Number const schema2 = new Schema ({ age : \"Number\" }); // Equivalent const Car = mongoose . model ( \"Car\" , schema2 ); There are several types of values that will be successfully cast to a Number. JavaScript new Car ({ age : \"15\" }). age ; // 15 as a Number new Car ({ age : true }). age ; // 1 as a Number new Car ({ age : false }). age ; // 0 as a Number new Car ({ age : { valueOf : () => 83 } }). age ; // 83 as a Number If you pass an object with a valueOf() function that returns a Number, Mongoose will call it and assign the returned value to the path. The values null and undefined are not cast. NaN, strings that cast to NaN, arrays, and objects that don't have a valueOf() function will all result in a CastError once validated, meaning that it will not throw on initialization, only when validated.","title":"Number"},{"location":"schema/type/#dates","text":"Built-in Date methods are not hooked into the mongoose change tracking logic which in English means that if you use a Date in your document and modify it with a method like setMonth() , mongoose will be unaware of this change and doc.save() will not persist this modification. If you must modify Date types using built-in methods, tell mongoose about the change with doc.markModified('pathToYourDate') before saving. JavaScript const Assignment = mongoose . model ( \"Assignment\" , { dueDate : Date }); Assignment . findOne ( function ( err , doc ) { doc . dueDate . setMonth ( 3 ); doc . save ( callback ); // THIS DOES NOT SAVE YOUR CHANGE doc . markModified ( \"dueDate\" ); doc . save ( callback ); // works });","title":"Dates"},{"location":"schema/type/#buffer","text":"To declare a path as a Buffer, you may use either the Buffer global constructor or the string 'Buffer' . JavaScript const schema1 = new Schema ({ binData : Buffer }); // binData will be cast to a Buffer const schema2 = new Schema ({ binData : \"Buffer\" }); // Equivalent const Data = mongoose . model ( \"Data\" , schema2 ); Mongoose will successfully cast the below values to buffers. Text Only const file1 = new Data({ binData: 'test'}); // {\"type\":\"Buffer\",\"data\":[116,101,115,116]} const file2 = new Data({ binData: 72987 }); // {\"type\":\"Buffer\",\"data\":[27]} const file4 = new Data({ binData: { type: 'Buffer', data: [1, 2, 3]}}); // {\"type\":\"Buffer\",\"data\":[1,2,3]}","title":"Buffer"},{"location":"schema/type/#mixed","text":"An \"anything goes\" SchemaType. Mongoose will not do any casting on mixed paths. You can define a mixed path using Schema.Types.Mixed or by passing an empty object literal. The following are equivalent. JavaScript const Any = new Schema ({ any : {} }); const Any = new Schema ({ any : Object }); const Any = new Schema ({ any : Schema . Types . Mixed }); const Any = new Schema ({ any : mongoose . Mixed }); Since Mixed is a schema-less type, you can change the value to anything else you like, but Mongoose loses the ability to auto detect and save those changes. To tell Mongoose that the value of a Mixed type has changed, you need to call doc.markModified(path) , passing the path to the Mixed type you just changed. To avoid these side-effects, a Subdocument path may be used instead. JavaScript person . anything = { x : [ 3 , 4 , { y : \"changed\" }] }; person . markModified ( \"anything\" ); person . save (); // Mongoose will save changes to `anything`.","title":"Mixed"},{"location":"schema/type/#objectids","text":"An ObjectId is a special type typically used for unique identifiers. Here's how you declare a schema with a path driver that is an ObjectId: JavaScript const mongoose = require ( \"mongoose\" ); const carSchema = new mongoose . Schema ({ driver : mongoose . ObjectId }); ObjectId is a class, and ObjectIds are objects. However, they are often represented as strings. When you convert an ObjectId to a string using toString() , you get a 24-character hexadecimal string: JavaScript const Car = mongoose . model ( \"Car\" , carSchema ); const car = new Car (); car . driver = new mongoose . Types . ObjectId (); typeof car . driver ; // 'object' car . driver instanceof mongoose . Types . ObjectId ; // true car . driver . toString (); // Something like \"5e1a0651741b255ddda996c4\"","title":"ObjectIds"},{"location":"schema/type/#boolean","text":"Booleans in Mongoose are plain JavaScript booleans . By default, Mongoose casts the below values to true : true 'true' 1 '1' 'yes' Mongoose casts the below values to false : false 'false' 0 '0' 'no' Any other value causes a CastError . You can modify what values Mongoose converts to true or false using the convertToTrue and convertToFalse properties, which are JavaScript sets . JavaScript const M = mongoose . model ( \"Test\" , new Schema ({ b : Boolean })); console . log ( new M ({ b : \"nay\" }). b ); // undefined // Set { false, 'false', 0, '0', 'no' } console . log ( mongoose . Schema . Types . Boolean . convertToFalse ); mongoose . Schema . Types . Boolean . convertToFalse . add ( \"nay\" ); console . log ( new M ({ b : \"nay\" }). b ); // false","title":"Boolean"},{"location":"schema/type/#arrays","text":"Mongoose supports arrays of SchemaTypes and arrays of subdocuments . Arrays of SchemaTypes are also called primitive arrays , and arrays of subdocuments are also called document arrays . JavaScript const ToySchema = new Schema ({ name : String }); const ToyBoxSchema = new Schema ({ toys : [ ToySchema ], buffers : [ Buffer ], strings : [ String ], numbers : [ Number ], // ... etc }); Arrays are special because they implicitly have a default value of [] (empty array). JavaScript const ToyBox = mongoose . model ( \"ToyBox\" , ToyBoxSchema ); console . log ( new ToyBox (). toys ); // [] To overwrite this default, you need to set the default value to undefined JavaScript const ToyBoxSchema = new Schema ({ toys : { type : [ ToySchema ], default : undefined , }, }); Note: specifying an empty array is equivalent to Mixed . The following all create arrays of Mixed : JavaScript const Empty1 = new Schema ({ any : [] }); const Empty2 = new Schema ({ any : Array }); const Empty3 = new Schema ({ any : [ Schema . Types . Mixed ] }); const Empty4 = new Schema ({ any : [{}] });","title":"Arrays"},{"location":"schema/type/#maps","text":"\u5728 Mongoose 5.1.0 \u4e2d\u65b0\u589e MongooseMap \u662f JavaScript Map \u7c7b \u7684\u5b50\u7c7b. \u5728\u8fd9\u4e9b\u6587\u6863\u4e2d\uff0c\u6211\u4eec\u5c06\u4ea4\u66ff\u4f7f\u7528\u672f\u8bed map \u548c MongooseMap \u3002 \u5728 Mongoose \u4e2d\uff0c\u6620\u5c04\u662f\u4f7f\u7528\u4efb\u610f\u952e\u521b\u5efa\u5d4c\u5957\u6587\u6863\u7684\u65b9\u5f0f\u3002 Note \u5728 Mongoose Maps \u4e2d\uff0c\u952e\u5fc5\u987b\u662f\u5b57\u7b26\u4e32\uff0c\u4ee5\u4fbf\u5728 MongoDB \u4e2d\u5b58\u50a8\u6587\u6863\u3002 user.schema.js const userSchema = new Schema ({ // `socialMediaHandles` is a map whose values are strings. A map's // keys are always strings. You specify the type of values using `of`. socialMediaHandles : { type : Map , of : String , }, }); const User = mongoose . model ( \"User\" , userSchema ); // Map { 'github' => 'vkarpov15', 'twitter' => '@code_barbarian' } console . log ( new User ({ socialMediaHandles : { github : \"vkarpov15\" , twitter : \"@code_barbarian\" , }, }). socialMediaHandles ); \u4e0a\u9762\u7684\u4f8b\u5b50\u5e76\u6ca1\u6709\u660e\u786e\u5730\u5c06 github or twitter \u58f0\u660e\u4e3a\u8def\u5f84\uff0c \u4f46\u662f\uff0c\u7531\u4e8e socialMediaHandles \u662f\u4e00\u4e2a\u6620\u5c04\uff0c\u4f60\u53ef\u4ee5\u5b58\u50a8\u4efb\u610f\u952e/\u503c\u5bf9\u3002 \u7136\u800c\uff0c\u7531\u4e8e socialMediaHandles \u662f\u4e00\u4e2a\u6620\u5c04\uff0c\u4f60 \u5fc5\u987b \u4f7f\u7528 .get() \u6765\u83b7\u53d6\u952e\u7684\u503c\uff0c\u800c .set() \u6765\u8bbe\u7f6e\u952e\u7684\u503c\u3002 JavaScript const user = new User ({ socialMediaHandles : {} }); // Good user . socialMediaHandles . set ( \"github\" , \"vkarpov15\" ); // Works too user . set ( \"socialMediaHandles.twitter\" , \"@code_barbarian\" ); // Bad, the `myspace` property will **not** get saved user . socialMediaHandles . myspace = \"fail\" ; // 'vkarpov15' console . log ( user . socialMediaHandles . get ( \"github\" )); // '@code_barbarian' console . log ( user . get ( \"socialMediaHandles.twitter\" )); // undefined user . socialMediaHandles . github ; // Will only save the 'github' and 'twitter' properties user . save (); \u6620\u5c04\u7c7b\u578b\u5b58\u50a8\u4e3a BSON \u5bf9\u8c61\u5728 MongoDB . BSON \u5bf9\u8c61\u4e2d\u7684\u952e\u662f\u6709\u5e8f\u7684\uff0c\u6240\u4ee5\u8fd9\u610f\u5473\u7740\u6620\u5c04\u7684 \u63d2\u5165\u987a\u5e8f \u5c5e\u6027\u5f97\u5230\u4e86\u7ef4\u62a4\u3002 Mongoose \u652f\u6301\u4e00\u4e2a\u7279\u6b8a\u7684 $* \u8bed\u6cd5\u6765 \u586b\u5145 \u6620\u5c04\u4e2d\u7684\u6240\u6709\u5143\u7d20\u3002 \u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u7684 socialMediaHandles \u5730\u56fe\u5305\u542b\u4e00\u4e2a ref : JavaScript const userSchema = new Schema ({ socialMediaHandles : { type : Map , of : new Schema ({ handle : String , oauth : { type : ObjectId , ref : \"OAuth\" }, }), }, }); const User = mongoose . model ( \"User\" , userSchema ); \u4e3a\u4e86\u586b\u5145\u6bcf\u4e2a socialMediaHandles \u6761\u76ee\u7684 oauth \u5c5e\u6027\uff0c\u4f60\u5e94\u8be5\u5728 socialMediaHandles.$*.oauth \u4e0a\u586b\u5145: JavaScript const user = await User . findOne (). populate ( \"socialMediaHandles.$*.oauth\" );","title":"Maps"},{"location":"schema/type/#getters","text":"Getters are like virtuals for paths defined in your schema. For example, let's say you wanted to store user profile pictures as relative paths and then add the hostname in your application. Below is how you would structure your userSchema : JavaScript const root = \"https://s3.amazonaws.com/mybucket\" ; const userSchema = new Schema ({ name : String , picture : { type : String , get : ( v ) => ` ${ root }${ v } ` , }, }); const User = mongoose . model ( \"User\" , userSchema ); const doc = new User ({ name : \"Val\" , picture : \"/123.png\" }); doc . picture ; // 'https://s3.amazonaws.com/mybucket/123.png' doc . toObject ({ getters : false }). picture ; // '/123.png' Generally, you only use getters on primitive paths as opposed to arrays or subdocuments. Because getters override what accessing a Mongoose path returns, declaring a getter on an object may remove Mongoose change tracking for that path. JavaScript const schema = new Schema ({ arr : [{ url : String }], }); const root = \"https://s3.amazonaws.com/mybucket\" ; // Bad, don't do this! schema . path ( \"arr\" ). get (( v ) => { return v . map (( el ) => Object . assign ( el , { url : root + el . url })); }); // Later doc . arr . push ({ key : String }); doc . arr [ 0 ]; // 'undefined' because every `doc.arr` creates a new array! Instead of declaring a getter on the array as shown above, you should declare a getter on the url string as shown below. If you need to declare a getter on a nested document or array, be very careful! JavaScript const schema = new Schema ({ arr : [{ url : String }], }); const root = \"https://s3.amazonaws.com/mybucket\" ; // Good, do this instead of declaring a getter on `arr` schema . path ( \"arr.0.url\" ). get (( v ) => ` ${ root }${ v } ` );","title":"Getters"},{"location":"schema/type/#schemas","text":"To declare a path as another schema , set type to the sub-schema's instance. To set a default value based on the sub-schema's shape, simply set a default value, and the value will be cast based on the sub-schema's definition before being set during document creation. JavaScript const subSchema = new mongoose . Schema ({ // some schema definition here }); const schema = new mongoose . Schema ({ data : { type : subSchema default : {} } });","title":"Schemas"},{"location":"schema/type/#_5","text":"Mongoose can also be extended with custom SchemaTypes . Search the plugins site for compatible types like mongoose-long , mongoose-int32 , and other types . Read more about creating custom SchemaTypes here .","title":"\u521b\u5efa\u81ea\u5b9a\u4e49\u7c7b\u578b"},{"location":"schema/type/#schemapath","text":"The schema.path() function returns the instantiated schema type for a given path. JavaScript const sampleSchema = new Schema ({ name : { type : String , required : true } }); console . log ( sampleSchema . path ( \"name\" )); // Output looks like: /** * SchemaString { * enumValues: [], * regExp: null, * path: 'name', * instance: 'String', * validators: ... */ You can use this function to inspect the schema type for a given path, including what validators it has and what the type is.","title":"schema.path() \u51fd\u6570"},{"location":"schema/type/#_6","text":"An Introduction to Mongoose SchemaTypes Mongoose Schema Types","title":"\u9605\u8bfb\u66f4\u591a"}]}